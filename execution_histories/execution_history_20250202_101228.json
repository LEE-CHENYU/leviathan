{
  "rounds": [
    {
      "timestamp": "2025-02-02T10:10:11.693723",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Check if member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Strategy 1: Emergency resource management\n    # If cargo (resources) are low compared to vitality, try to gain resources by attacking a wealthier member.\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            # Never target yourself\n            if other.id == member.id:\n                continue\n            # Ensure the other exists and has more cargo than member\n            if other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n                return\n\n    # Strategy 2: Cooperative resource sharing\n    # If we have a surplus of resources, offer help to members with fewer resources.\n    if member.cargo > member.vitality * 2 and member.vitality > 50:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if other.cargo < member.cargo:\n                execution_engine.offer(member, other, True)\n                return\n\n    # Strategy 3: Reproduction and alliance through land-based cooperation\n    # Verify the member has land before attempting to bear offspring.\n    if hasattr(member, \"owned_land\") and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            # Only consider other members that also have land\n            if hasattr(other, \"owned_land\") and len(other.owned_land) > 0:\n                execution_engine.bear(member, other)\n                return\n\n    # Strategy 4: Territorial expansion and cooperative network building\n    # If the member controls some land, attempt to expand territory in cooperation with another land owner.\n    if hasattr(member, \"owned_land\") and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if hasattr(other, \"owned_land\") and len(other.owned_land) > 0:\n                execution_engine.expand(member, other)\n                return\n\n    # Strategy 5: Communication for collective decision making and social order\n    # If no direct economic or territorial action was taken, communicate a proposal to other members.\n    for other in execution_engine.current_members:\n        if other.id == member.id:\n            continue\n        execution_engine.send_message(member.id, other.id,\n            \"Let's work together to establish fair resource sharing, clear property rights, and collective decision making to benefit all members!\")\n\n    # If none of the above conditions triggered an immediate action, do nothing.\n    return",
          "old_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 96.82806145553313
          },
          "new_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 96.82806145553313
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    import numpy as np\n    from collections import defaultdict\n\n    # Verify member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Define a helper function to execute a chosen action.\n    def execute_action(action, engine, actor):\n        # For each action, select a target if needed. Always check target is not self.\n        if action == 'attack':\n            # Choose the member with the highest cargo (and not self) as target.\n            targets = [m for m in engine.current_members if m.id != actor.id]\n            if targets:\n                target = max(targets, key=lambda m: m.cargo)\n                engine.attack(actor, target)\n                return {'vitality': 5, 'cargo': 10}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer':\n            # Choose the member with lowest vitality (and not self) to build alliances.\n            targets = [m for m in engine.current_members if m.id != actor.id]\n            if targets:\n                target = min(targets, key=lambda m: m.vitality)\n                engine.offer(actor, target, True)\n                return {'vitality': 2, 'cargo': 5}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer_land':\n            # Propose land sharing: pick a random member (not self).\n            targets = [m for m in engine.current_members if m.id != actor.id]\n            if targets:\n                target = np.random.choice(targets)\n                engine.offer_land(actor, target, True)\n                return {'vitality': 1, 'cargo': 3}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'expand':\n            # Expand territory by selecting a member with lower overall productivity.\n            targets = [m for m in engine.current_members if m.id != actor.id]\n            if targets:\n                target = min(targets, key=lambda m: m.overall_productivity)\n                engine.expand(actor, target)\n                return {'vitality': 3, 'cargo': 7}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'bear':\n            # Reproduce only if the member has land. Check for attribute 'owned_land' and nonempty list.\n            if hasattr(actor, 'owned_land') and isinstance(actor.owned_land, list) and len(actor.owned_land) > 0:\n                targets = [m for m in engine.current_members if m.id != actor.id]\n                if targets:\n                    partner = max(targets, key=lambda m: m.vitality)\n                    engine.bear(actor, partner)\n                    return {'vitality': -2, 'cargo': -5}\n                else:\n                    return {'vitality': 0, 'cargo': 0}\n            else:\n                # Can't bear offspring without land.\n                return {'vitality': 0, 'cargo': 0}\n        else:\n            return {'vitality': 0, 'cargo': 0}\n\n    # Emergency resource management:\n    # If resources (cargo) are low relative to vitality, seek to attack members with greater cargo.\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n        # Simulate outcome of emergency action.\n        outcome = {'vitality': -1, 'cargo': 5}\n    else:\n        # Determine current state based on vitality, cargo, and network size.\n        state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n        actions = ['attack', 'offer', 'offer_land', 'expand', 'bear']\n        epsilon = 0.1\n\n        # \u03b5-greedy action selection.\n        if np.random.rand() < epsilon:\n            chosen_action = np.random.choice(actions)\n        else:\n            # Choose the action with the highest Q-value from the current state.\n            chosen_action = max(actions, key=lambda a: member.learning['q_table'][(state, a)])\n\n        # Execute the chosen action and collect outcome.\n        outcome = execute_action(chosen_action, execution_engine, member)\n\n        # Q-learning update:\n        reward = outcome['vitality'] * 0.7 + outcome['cargo'] * 0.3 + (member.vitality / 100) * 0.2\n        new_state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n        max_future = max(member.learning['q_table'][(new_state, a)] for a in actions)\n        member.learning['q_table'][(state, chosen_action)] += 0.1 * (reward + 0.9 * max_future - member.learning['q_table'][(state, chosen_action)])\n\n        # Update learning logs.\n        member.learning['strategy_log'].append((chosen_action, outcome, reward))\n        member.learning['state_history'].append(state)\n        member.learning['survival_metrics']['vitality_changes'].append(outcome['vitality'])\n        member.learning['survival_metrics']['success_rates'][chosen_action].append(1 if reward > 0 else 0)\n\n    # Communication: Propose alliances with a random member if possible.\n    potential_allies = [m for m in execution_engine.current_members if m.id != member.id]\n    if potential_allies:\n        ally = np.random.choice(potential_allies)\n        execution_engine.send_message(member.id, ally.id, \"Let's establish a cooperative resource sharing agreement.\")\n\n    # End of agent_action function. No explicit return is necessary.",
          "old_stats": {
            "vitality": 33.02781433323713,
            "cargo": 47.25322455383092,
            "survival_chance": 98.77222098502479
          },
          "new_stats": {
            "vitality": 33.02781433323713,
            "cargo": 47.25322455383092,
            "survival_chance": 98.77222098502479
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    import random\n\n    # Access our member from the current_members list\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize adaptive learning structure if needed\n    if not hasattr(member, 'learning'):\n        from collections import defaultdict\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Strategy 1: If cargo is less than 50% of vitality, try to improve resources aggressively\n    if member.cargo < member.vitality * 0.5:\n        # Look for a target with higher cargo among other members (ensuring valid index and not self)\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                candidates.append(other)\n        if candidates:\n            # Pick the candidate with the maximum cargo difference\n            target = max(candidates, key=lambda m: m.cargo - member.cargo)\n            # Attack the target\n            execution_engine.attack(member, target)\n            member.learning['strategy_log'].append(('attack', {'target': target.id}))\n            return\n\n    # Strategy 2: If cargo is ample (greater than vitality), use offers to build alliances and distribute resources\n    if member.cargo > member.vitality:\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo < member.cargo:\n                candidates.append(other)\n        if candidates:\n            target = min(candidates, key=lambda m: m.cargo)\n            execution_engine.offer(member, target, True)\n            # Also propose land sharing if possible (check target index validity)\n            execution_engine.offer_land(member, target, True)\n            # Send a message to propose alliance and cooperative governance\n            execution_engine.send_message(member.id, target.id,\n                                          \"Let\u2019s build an alliance: I'll share resources if you do too.\")\n            member.learning['strategy_log'].append(('offer', {'target': target.id}))\n            return\n\n    # Strategy 3: If member has some cleared neighboring areas, try to expand territory cooperatively.\n    if member.current_clear_list:\n        # Use the first valid neighbor from the clear list (check if index exists)\n        for neighbor_id in member.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member.id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                execution_engine.expand(member, neighbor)\n                member.learning['strategy_log'].append(('expand', {'target': neighbor.id}))\n                return\n\n    # Default Action: Propose a communal policy by messaging a random other member.\n    possible_targets = [m for m in execution_engine.current_members if m.id != member.id]\n    if possible_targets:\n        target = random.choice(possible_targets)\n        execution_engine.send_message(member.id, target.id,\n            \"I propose we establish rules for fair resource sharing and collective decision-making.\")\n        member.learning['strategy_log'].append(('message', {'target': target.id}))\n    return",
          "old_stats": {
            "vitality": 42.15604281108604,
            "cargo": 40.25508270288947,
            "survival_chance": 49.8976545487336
          },
          "new_stats": {
            "vitality": 42.15604281108604,
            "cargo": 40.25508270288947,
            "survival_chance": 49.8976545487336
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Get our member object from the current_members list\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Emergency resource management:\n    # If our cargo is less than half our vitality, attempt to attack any other member with higher cargo.\n    if member.cargo < member.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            # Never target yourself and only attack if target has significantly more cargo.\n            if target.cargo > member.cargo:\n                execution_engine.attack(member, target)\n                return\n\n    # Build alliances: send a proactive message to members who seem viable for cooperation.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        target = execution_engine.current_members[i]\n        # Only contact members with reasonable vitality.\n        if target.vitality > 30:\n            execution_engine.send_message(member.id, target.id,\n                \"Let's establish an alliance for cooperative resource sharing and defense.\")\n\n    # Offer surplus resources: if we have more cargo than our vitality, offer resources to a member with less.\n    if member.cargo > member.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo < member.cargo:\n                execution_engine.offer(member, target, True)\n                return\n\n    # Expand territory: if we have any cleared adjacent areas, try to expand into one.\n    if member.current_clear_list:\n        target_index = member.current_clear_list[0]\n        if target_index < len(execution_engine.current_members):\n            target_member = execution_engine.current_members[target_index]\n            execution_engine.expand(member, target_member)\n            return\n\n    # Reproduction: if the member has land (verified by the presence and positive value of 'land_num'),\n    # select a partner (with sufficient vitality) and bear offspring.\n    if hasattr(member, 'land_num') and member.land_num > 0:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            partner = execution_engine.current_members[i]\n            if partner.vitality > 20:\n                execution_engine.bear(member, partner)\n                return\n\n    # Default: If none of the above actions were triggered, maintain stability by sending a stabilizing message.\n    if len(execution_engine.current_members) > 0 and member_id != 0:\n        execution_engine.send_message(member.id, execution_engine.current_members[0].id,\n                                        \"Maintaining stability and cooperative efforts.\")\n\n    # End of agent_action.",
          "old_stats": {
            "vitality": 9.784749537693521,
            "cargo": 39.668115031767925,
            "survival_chance": 59.873659366461084
          },
          "new_stats": {
            "vitality": 9.784749537693521,
            "cargo": 39.668115031767925,
            "survival_chance": 59.873659366461084
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 4,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Verify the member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    member = execution_engine.current_members[member_id]\n\n    # 1. Emergency resource management: if cargo is very low relative to vitality,\n    #    try to attack a member with higher cargo (do not target self!)\n    if member.cargo < member.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                target = execution_engine.current_members[i]\n                if target.cargo > member.cargo:\n                    execution_engine.attack(member, target)\n                    return\n\n    # 2. Build alliances: Offer resources to members that appear vulnerable\n    #    (e.g. those whose cargo is less than half their vitality)\n    for i in range(len(execution_engine.current_members)):\n        if i != member_id:\n            candidate = execution_engine.current_members[i]\n            if candidate.cargo < candidate.vitality * 0.5:\n                execution_engine.offer(member, candidate, True)\n                # Communicate an invitation for alliance.\n                execution_engine.send_message(member.id, candidate.id,\n                                                \"Join my coalition for mutual support and fair resource sharing.\")\n                return\n\n    # 3. Offer land as part of cooperative expansion.\n    #    Check that the member has land before using bear() or offering land.\n    if hasattr(member, \"owned_land\") and member.owned_land:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                candidate = execution_engine.current_members[i]\n                # Offer land if candidate seems to lack resources compared to self.\n                if candidate.cargo < member.cargo:\n                    execution_engine.offer_land(member, candidate, True)\n                    return\n\n    # 4. Expand territory: if resources are plentiful relative to vitality,\n    #    attempt to expand territory by cooperating with another member.\n    if member.cargo > member.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                candidate = execution_engine.current_members[i]\n                execution_engine.expand(member, candidate)\n                return\n\n    # 5. Reproduction (bearing offspring) to strengthen our numbers,\n    #    but only if member has land and the candidate also has land.\n    if hasattr(member, \"owned_land\") and member.owned_land:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                candidate = execution_engine.current_members[i]\n                if hasattr(candidate, \"owned_land\") and candidate.owned_land:\n                    execution_engine.bear(member, candidate)\n                    return\n\n    # 6. Default cooperative move: send a message to all other members\n    #    proposing collective decision-making and fair resource distribution.\n    for i in range(len(execution_engine.current_members)):\n        if i != member_id:\n            recipient = execution_engine.current_members[i]\n            execution_engine.send_message(member.id, recipient.id,\n                                            \"Let's work together on resource distribution and fair governance. Your input matters.\")\n\n    return",
          "old_stats": {
            "vitality": 78.50637096028503,
            "cargo": 42.476807026876735,
            "survival_chance": 173.06686024708188
          },
          "new_stats": {
            "vitality": 78.50637096028503,
            "cargo": 42.476807026876735,
            "survival_chance": 173.06686024708188
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [],
          "sent": []
        },
        "3": {
          "received": [],
          "sent": []
        },
        "4": {
          "received": [
            "From member_1: Let's establish a cooperative resource sharing agreement.",
            "From member_3: Let's establish an alliance for cooperative resource sharing and defense."
          ],
          "sent": []
        }
      }
    },
    {
      "timestamp": "2025-02-02T10:11:15.296275",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate member_id\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not already present\n    if not hasattr(member, 'learning'):\n        from collections import defaultdict\n        member.learning = {\n            'q_table': defaultdict(float),  # For state-action values\n            'strategy_log': [],  # Log of (action, reason)\n            'state_history': [],  # List of states encountered\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Strategy 1: Emergency resource management\n    # If cargo is low relative to vitality, attack a member with greater cargo.\n    if member.cargo < member.vitality * 0.5:\n        for idx in range(len(execution_engine.current_members)):\n            other = execution_engine.current_members[idx]\n            if other.id == member.id:\n                continue  # Never target yourself\n            if other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n                member.learning['strategy_log'].append(('attack', 'emergency resource recovery'))\n                return\n\n    # Strategy 2: Cooperative resource sharing\n    # If member has a surplus of cargo and good vitality, offer resources to those with less.\n    if member.cargo > member.vitality * 2 and member.vitality > 50:\n        for idx in range(len(execution_engine.current_members)):\n            other = execution_engine.current_members[idx]\n            if other.id == member.id:\n                continue\n            if other.cargo < member.cargo:\n                execution_engine.offer(member, other, True)\n                member.learning['strategy_log'].append(('offer', 'cooperative resource sharing'))\n                return\n\n    # Strategy 3: Reproduction and alliance through land-based cooperation.\n    # Verify that the member has land before attempting to bear offspring.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        for idx in range(len(execution_engine.current_members)):\n            other = execution_engine.current_members[idx]\n            if other.id == member.id:\n                continue\n            if hasattr(other, \"owned_land\") and other.owned_land and len(other.owned_land) > 0:\n                execution_engine.bear(member, other)\n                member.learning['strategy_log'].append(('bear', 'reproduction and alliance'))\n                return\n\n    # Strategy 4: Territorial expansion and cooperative network building.\n    # Instead of providing a partner to expand (which caused an error before),\n    # call the expand action with only the member as required by the underlying implementation.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        execution_engine.expand(member)\n        member.learning['strategy_log'].append(('expand', 'territorial expansion'))\n        return\n\n    # Strategy 5: Communication for collective decision making and social order.\n    # Send a proposal to all other members.\n    for idx in range(len(execution_engine.current_members)):\n        other = execution_engine.current_members[idx]\n        if other.id == member.id:\n            continue\n        execution_engine.send_message(member.id, other.id,\n            \"Let's establish fair resource distribution, mutual aid, and collective decision making to strengthen our society!\")\n    member.learning['strategy_log'].append(('communicate', 'proposal for social organization'))\n\n    return",
          "old_stats": {
            "vitality": 64.16130813466619,
            "cargo": 9.851974486110818,
            "survival_chance": 67.14320226284083
          },
          "new_stats": {
            "vitality": 64.16130813466619,
            "cargo": 9.851974486110818,
            "survival_chance": 67.14320226284083
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    import numpy as np\n    from collections import defaultdict\n\n    # Validate member_id index exists\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),  # Mapping from (state, action) tuples to values\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Define helper function to execute an action\n    def execute_action(action, engine, actor):\n        # For safety, always choose targets that are not actor\n        valid_targets = [m for m in engine.current_members if m.id != actor.id]\n        if action == 'attack':\n            if valid_targets:\n                # Choose target with the highest cargo\n                target = max(valid_targets, key=lambda m: m.cargo)\n                engine.attack(actor, target)\n                return {'vitality': 5, 'cargo': 10}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer':\n            if valid_targets:\n                # Choose target with the lowest vitality to build alliances\n                target = min(valid_targets, key=lambda m: m.vitality)\n                engine.offer(actor, target, True)\n                return {'vitality': 2, 'cargo': 5}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer_land':\n            if valid_targets:\n                target = np.random.choice(valid_targets)\n                engine.offer_land(actor, target, True)\n                return {'vitality': 1, 'cargo': 3}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'expand':\n            if valid_targets:\n                # Choose target with lower overall productivity\n                target = min(valid_targets, key=lambda m: m.overall_productivity)\n                engine.expand(actor, target)\n                return {'vitality': 3, 'cargo': 7}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'bear':\n            # Check if actor has land: expect an attribute 'owned_land' being a non-empty list\n            if hasattr(actor, 'owned_land') and isinstance(actor.owned_land, list) and len(actor.owned_land) > 0:\n                if valid_targets:\n                    # Choose partner with highest vitality\n                    partner = max(valid_targets, key=lambda m: m.vitality)\n                    engine.bear(actor, partner)\n                    return {'vitality': -2, 'cargo': -5}\n                else:\n                    return {'vitality': 0, 'cargo': 0}\n            else:\n                # Can't bear offspring without land\n                return {'vitality': 0, 'cargo': 0}\n        else:\n            return {'vitality': 0, 'cargo': 0}\n\n    # Emergency resource management: if cargo is below a threshold relative to vitality, consider attacking richer members\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n        emergency_outcome = {'vitality': -1, 'cargo': 5}\n        # Log emergency action and update learning metrics\n        state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n        member.learning['strategy_log'].append((\"emergency_attack\", emergency_outcome, 0))\n        member.learning['state_history'].append(state)\n        member.learning['survival_metrics']['vitality_changes'].append(emergency_outcome['vitality'])\n        return\n\n    # Determine current state as a tuple: (vitality bucket, cargo bucket, number of cleared adjacents)\n    state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n\n    # Define available actions\n    actions = ['attack', 'offer', 'offer_land', 'expand', 'bear']\n    epsilon = 0.1  # Exploration rate\n\n    # \u03b5-greedy action selection\n    if np.random.rand() < epsilon:\n        chosen_action = np.random.choice(actions)\n    else:\n        # Select the action with the highest Q-value for the current state\n        chosen_action = max(actions, key=lambda a: member.learning['q_table'][(state, a)])\n\n    # Execute the chosen action and receive an outcome (deltas for vitality and cargo)\n    outcome = execute_action(chosen_action, execution_engine, member)\n\n    # Compute reward with survival emphasis\n    reward = outcome['vitality'] * 0.7 + outcome['cargo'] * 0.3 + (member.vitality / 100) * 0.2\n\n    # Construct new state after action\n    new_state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n\n    # Q-learning update: learning rate alpha = 0.1 and discount factor gamma = 0.9\n    max_future = max(member.learning['q_table'][(new_state, a)] for a in actions)\n    member.learning['q_table'][(state, chosen_action)] += 0.1 * (reward + 0.9 * max_future - member.learning['q_table'][(state, chosen_action)])\n\n    # Log the action and update survival metrics\n    member.learning['strategy_log'].append((chosen_action, outcome, reward))\n    member.learning['state_history'].append(state)\n    member.learning['survival_metrics']['vitality_changes'].append(outcome['vitality'])\n    member.learning['survival_metrics']['success_rates'][chosen_action].append(1 if reward > 0 else 0)\n\n    # Communication: propose an alliance. Choose a random member (not self) if available.\n    potential_allies = [m for m in execution_engine.current_members if m.id != member.id]\n    if potential_allies:\n        ally = np.random.choice(potential_allies)\n        message = \"Let's forge an alliance for cooperative resource sharing and mutual defense.\"\n        execution_engine.send_message(member.id, ally.id, message)",
          "old_stats": {
            "vitality": 48.10875290577928,
            "cargo": 8.077967059825381,
            "survival_chance": 61.56251109510924
          },
          "new_stats": {
            "vitality": 48.10875290577928,
            "cargo": 8.077967059825381,
            "survival_chance": 61.56251109510924
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    import random\n    from collections import defaultdict\n\n    # Access our member from the current_members list if index is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize adaptive learning structure if not already present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Strategy 1: Resource accumulation.\n    # If cargo is less than 50% of vitality, search for members with higher cargo and attack.\n    if member.cargo < member.vitality * 0.5:\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                candidates.append(other)\n        if candidates:\n            target = max(candidates, key=lambda m: m.cargo - member.cargo)\n            execution_engine.attack(member, target)\n            member.learning['strategy_log'].append(('attack', {'target': target.id}))\n            return\n\n    # Strategy 2: Alliance building.\n    # If cargo exceeds vitality, offer resources and land to members with lower cargo.\n    if member.cargo > member.vitality:\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo < member.cargo:\n                candidates.append(other)\n        if candidates:\n            target = min(candidates, key=lambda m: m.cargo)\n            execution_engine.offer(member, target, True)\n            execution_engine.offer_land(member, target, True)\n            execution_engine.send_message(\n                member.id, target.id,\n                \"Let's form an alliance: I'll share resources and even offer land if you join in cooperative management.\"\n            )\n            member.learning['strategy_log'].append(('offer', {'target': target.id}))\n            return\n\n    # Strategy 3: Cooperative territory and social organization.\n    # Instead of using expand (which is unavailable), propose land sharing with cleared neighbors.\n    if member.current_clear_list:\n        for neighbor_id in member.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member.id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                execution_engine.offer_land(member, neighbor, True)\n                execution_engine.send_message(\n                    member.id, neighbor.id,\n                    \"I propose we work together to manage and optimize our territory. Let's share land and resources.\"\n                )\n                member.learning['strategy_log'].append(('offer_land', {'target': neighbor.id}))\n                return\n\n    # Default Action: Propose a communal policy.\n    possible_targets = [m for m in execution_engine.current_members if m.id != member.id]\n    if possible_targets:\n        target = random.choice(possible_targets)\n        execution_engine.send_message(\n            member.id, target.id,\n            \"Let's establish fair resource distribution and collective decision-making rules for our community.\"\n        )\n        member.learning['strategy_log'].append(('message', {'target': target.id}))\n    return",
          "old_stats": {
            "vitality": 67.24199092602524,
            "cargo": 7.968737200820967,
            "survival_chance": 52.38909496374721
          },
          "new_stats": {
            "vitality": 67.24199092602524,
            "cargo": 7.968737200820967,
            "survival_chance": 52.38909496374721
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Verify the member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # 1. Emergency Resource Management:\n    # If cargo is less than half of vitality, try to attack a member with greater cargo.\n    if member.cargo < member.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo > member.cargo:\n                execution_engine.attack(member, target)\n                return\n\n    # 2. Building Alliances:\n    # Proactively send alliance messages to members with healthy vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        target = execution_engine.current_members[i]\n        if target.vitality > 30:\n            # Propose cooperative resource sharing and collective defense.\n            execution_engine.send_message(member.id, target.id,\n                \"Alliance proposal: let's share resources and coordinate defenses for mutual benefit.\")\n\n    # 3. Offering Surplus Resources:\n    # If our cargo is greater than our vitality, offer resources to a less endowed member.\n    if member.cargo > member.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo < member.cargo:\n                execution_engine.offer(member, target, True)\n                return\n\n    # 4. Territorial Expansion & Land Sharing:\n    # Instead of using an unsupported expand() method, if there is a neighbor (from current_clear_list),\n    # propose offering land. This simulates peaceful expansion and resource sharing.\n    if member.current_clear_list:\n        # Get the first available clear neighbor index if valid.\n        target_index = member.current_clear_list[0]\n        if target_index < len(execution_engine.current_members):\n            target_member = execution_engine.current_members[target_index]\n            # Use offer_land to suggest a peaceful expansion or a joint land stewardship initiative.\n            execution_engine.offer_land(member, target_member, True)\n            return\n\n    # 5. Reproduction / Societal Continuity:\n    # Only attempt reproduction if the member has land (land_num attribute and positive value).\n    if hasattr(member, 'land_num') and member.land_num > 0:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            partner = execution_engine.current_members[i]\n            if partner.vitality > 20:\n                execution_engine.bear(member, partner)\n                return\n\n    # 6. Default Action: Maintain social stability.\n    # If none of the above actions is triggered, send a stabilizing message to the community leader (assumed member 0).\n    if len(execution_engine.current_members) > 0 and member_id != 0:\n        execution_engine.send_message(member.id, execution_engine.current_members[0].id,\n                                        \"Status update: committed to stability, cooperation, and shared prosperity.\")",
          "old_stats": {
            "vitality": 72.49910755502964,
            "cargo": 0.0,
            "survival_chance": 72.49910755502964
          },
          "new_stats": {
            "vitality": 72.49910755502964,
            "cargo": 0.0,
            "survival_chance": 72.49910755502964
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [],
          "sent": []
        },
        "3": {
          "received": [],
          "sent": []
        }
      }
    },
    {
      "timestamp": "2025-02-02T10:12:04.143978",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid and within bounds.\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not already present.\n    if not hasattr(member, 'learning'):\n        from collections import defaultdict\n        member.learning = {\n            'q_table': defaultdict(float),  # For state-action values.\n            'strategy_log': [],             # Log of (action, reason).\n            'state_history': []             # History of states.\n        }\n\n    # Strategy 1: Emergency Resource Management.\n    # If cargo (resources) are low relative to vitality, attempt to attack a member with more cargo.\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue  # Never target yourself.\n            if other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n                member.learning['strategy_log'].append(('attack', 'resource emergency'))\n                return\n\n    # Strategy 2: Cooperative Resource Sharing.\n    # If we have a surplus of cargo and good vitality, help members with fewer resources.\n    if member.cargo > member.vitality * 2 and member.vitality > 50:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if other.cargo < member.cargo:\n                execution_engine.offer(member, other, True)\n                member.learning['strategy_log'].append(('offer', 'cooperative resource sharing'))\n                return\n\n    # Strategy 3: Reproduction and Alliance through Land-based Cooperation.\n    # Proceed only if the member owns land.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if hasattr(other, \"owned_land\") and other.owned_land and len(other.owned_land) > 0:\n                execution_engine.bear(member, other)\n                member.learning['strategy_log'].append(('bear', 'reproduction & alliance'))\n                return\n\n    # Strategy 4: Territorial Expansion.\n    # If the member controls land, attempt expansion.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        # The implementation expects a single argument: member.\n        execution_engine.expand(member)\n        member.learning['strategy_log'].append(('expand', 'territorial growth'))\n        return\n\n    # Strategy 5: Communication for Collective Decision-Making.\n    # If no direct action was taken, send a proposal to all other members.\n    for other in execution_engine.current_members:\n        if other.id == member.id:\n            continue\n        execution_engine.send_message(\n            member.id,\n            other.id,\n            \"Let's build a society founded on fair resource distribution, clear rules, and collective decision-making to ensure all our survival!\")\n    member.learning['strategy_log'].append(('communicate', 'social proposal'))\n\n    return",
          "old_stats": {
            "vitality": 29.94800847402804,
            "cargo": 8.077967059825381,
            "survival_chance": 50.76080885831922
          },
          "new_stats": {
            "vitality": 29.94800847402804,
            "cargo": 8.077967059825381,
            "survival_chance": 50.76080885831922
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    import numpy as np\n    from collections import defaultdict\n\n    # Validate member_id index exists\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not already present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Helper function to execute an action for the actor\n    def execute_action(action, engine, actor):\n        # Select valid targets: ensure target member exists and is not self\n        valid_targets = [m for m in engine.current_members if m.id != actor.id]\n\n        if action == 'attack':\n            if valid_targets:\n                # Choose the target with highest cargo\n                target = max(valid_targets, key=lambda m: m.cargo)\n                engine.attack(actor, target)\n                return {'vitality': 5, 'cargo': 10}\n            return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer':\n            if valid_targets:\n                # Choose target with lowest vitality to build alliances\n                target = min(valid_targets, key=lambda m: m.vitality)\n                engine.offer(actor, target, True)\n                return {'vitality': 2, 'cargo': 5}\n            return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer_land':\n            if valid_targets:\n                target = np.random.choice(valid_targets)\n                engine.offer_land(actor, target, True)\n                return {'vitality': 1, 'cargo': 3}\n            return {'vitality': 0, 'cargo': 0}\n        elif action == 'expand':\n            if valid_targets:\n                # Choose target with lower overall productivity\n                target = min(valid_targets, key=lambda m: m.overall_productivity)\n                engine.expand(actor, target)\n                return {'vitality': 3, 'cargo': 7}\n            return {'vitality': 0, 'cargo': 0}\n        elif action == 'bear':\n            # Check that actor has land before bearing offspring\n            if hasattr(actor, 'owned_land') and isinstance(actor.owned_land, list) and len(actor.owned_land) > 0:\n                if valid_targets:\n                    # Choose the partner with highest vitality\n                    partner = max(valid_targets, key=lambda m: m.vitality)\n                    engine.bear(actor, partner)\n                    return {'vitality': -2, 'cargo': -5}\n                return {'vitality': 0, 'cargo': 0}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        else:\n            return {'vitality': 0, 'cargo': 0}\n\n    # Emergency resource management: if cargo is low compared to vitality, attack wealthier members\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n        emergency_outcome = {'vitality': -1, 'cargo': 5}\n        state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n        member.learning['strategy_log'].append((\"emergency_attack\", emergency_outcome, 0))\n        member.learning['state_history'].append(state)\n        member.learning['survival_metrics']['vitality_changes'].append(emergency_outcome['vitality'])\n        return\n\n    # Define current state: using vitality bucket, cargo bucket, and number of cleared neighbors/adjacents\n    state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n    actions = ['attack', 'offer', 'offer_land', 'expand', 'bear']\n    epsilon = 0.1  # exploration rate for \u03b5-greedy selection\n\n    # Choose action based on \u03b5-greedy strategy\n    if np.random.rand() < epsilon:\n        chosen_action = np.random.choice(actions)\n    else:\n        chosen_action = max(actions, key=lambda a: member.learning['q_table'][(state, a)])\n\n    # Execute the selected action\n    outcome = execute_action(chosen_action, execution_engine, member)\n\n    # Calculate reward emphasizing survival (vitality), resource gain (cargo), and current vitality bonus\n    reward = outcome['vitality'] * 0.7 + outcome['cargo'] * 0.3 + (member.vitality / 100) * 0.2\n\n    # Observe new state after action execution\n    new_state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n    max_future = max(member.learning['q_table'][(new_state, a)] for a in actions)\n    member.learning['q_table'][(state, chosen_action)] += 0.1 * (reward + 0.9 * max_future - member.learning['q_table'][(state, chosen_action)])\n    member.learning['strategy_log'].append((chosen_action, outcome, reward))\n    member.learning['state_history'].append(state)\n    member.learning['survival_metrics']['vitality_changes'].append(outcome['vitality'])\n    member.learning['survival_metrics']['success_rates'][chosen_action].append(1 if reward > 0 else 0)\n\n    # Communication: propose cooperative systems and resource distribution policies without self-targeting\n    potential_allies = [m for m in execution_engine.current_members if m.id != member.id]\n    if potential_allies:\n        ally = np.random.choice(potential_allies)\n        execution_engine.send_message(member.id, ally.id, \"Let's set up cooperative resource sharing and a basic income system for all.\")\n\n    # Additional social proposal: suggest a collective defense and fair resource allocation system.\n    if potential_allies:\n        partner = np.random.choice(potential_allies)\n        execution_engine.send_message(member.id, partner.id, \"How about we establish norms for collective decision making and mutual defense?\")",
          "old_stats": {
            "vitality": 60.02587755082809,
            "cargo": 7.968737200820967,
            "survival_chance": 79.29426806825532
          },
          "new_stats": {
            "vitality": 60.02587755082809,
            "cargo": 7.968737200820967,
            "survival_chance": 79.29426806825532
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    import random\n    from collections import defaultdict\n\n    # Ensure member_id is a valid index in the current_members list\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Never target yourself: member.id is unique.\n    # Initialize adaptive learning structure if not already present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Strategy 1: If cargo is less than 50% of vitality, try to improve resources by attacking a stronger opponent.\n    if member.cargo < member.vitality * 0.5:\n        candidates = []\n        for other in execution_engine.current_members:\n            # Avoid targeting yourself and only attack if the other has more cargo than you\n            if other.id != member.id and other.cargo > member.cargo:\n                candidates.append(other)\n        if candidates:\n            # Choose the candidate with the maximum cargo difference\n            target = max(candidates, key=lambda m: m.cargo - member.cargo)\n            execution_engine.attack(member, target)\n            member.learning['strategy_log'].append(('attack', {'target': target.id}))\n            return\n\n    # Strategy 2: If cargo exceeds vitality, work on building alliances and cooperative resource sharing.\n    if member.cargo > member.vitality:\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo < member.cargo:\n                candidates.append(other)\n        if candidates:\n            target = min(candidates, key=lambda m: m.cargo)\n            execution_engine.offer(member, target, True)\n            execution_engine.offer_land(member, target, True)\n            execution_engine.send_message(\n                member.id, target.id,\n                \"Let's build an alliance: I'll share resources and land with you for mutual growth.\"\n            )\n            member.learning['strategy_log'].append(('offer', {'target': target.id}))\n            return\n\n    # Strategy 3: Use cleared neighboring areas to foster cooperative land management.\n    if member.current_clear_list:\n        for neighbor_id in member.current_clear_list:\n            # Ensure neighbor_id is valid and not self\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member.id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                # Instead of expand (which is unavailable), offer land sharing with cleared neighbors.\n                execution_engine.offer_land(member, neighbor, True)\n                execution_engine.send_message(\n                    member.id, neighbor.id,\n                    \"Let's coordinate on managing our territory. I'm offering land cooperation to secure our future.\"\n                )\n                member.learning['strategy_log'].append(('offer_land', {'target': neighbor.id}))\n                return\n\n    # Default Action: Propose a communal policy to encourage fair resource distribution and collective decision making.\n    possible_targets = [m for m in execution_engine.current_members if m.id != member.id]\n    if possible_targets:\n        target = random.choice(possible_targets)\n        execution_engine.send_message(\n            member.id, target.id,\n            \"I propose we establish fair rules for resource distribution, cooperative decision-making, and conflict resolution.\"\n        )\n        member.learning['strategy_log'].append(('message', {'target': target.id}))\n    return",
          "old_stats": {
            "vitality": 7.623447679404521,
            "cargo": 7.799514361095985,
            "survival_chance": 15.422962040500506
          },
          "new_stats": {
            "vitality": 7.623447679404521,
            "cargo": 7.799514361095985,
            "survival_chance": 15.422962040500506
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [],
          "sent": []
        }
      }
    },
    {
      "timestamp": "2025-02-02T10:12:28.658113",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not already present\n    if not hasattr(member, 'learning'):\n        from collections import defaultdict\n        member.learning = {\n            'q_table': defaultdict(float),  # For state-action values\n            'strategy_log': [],             # Log of (action, reason)\n            'state_history': [],            # History of states encountered\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Gather the current state for potential adaptive decision making.\n    # (State: vitality decile, cargo decile, number of cleared neighbors)\n    state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n\n    # Strategy 1: If resources are low relative to vitality, request cooperative aid.\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue  # Never target yourself.\n            if other.cargo > member.cargo:\n                execution_engine.send_message(\n                    member.id,\n                    other.id,\n                    \"I am low on resources. Would you be willing to share or trade to help us both survive?\"\n                )\n        member.learning['strategy_log'].append(('request_aid', 'low resources; seeking cooperation'))\n        # Log state and a dummy outcome update (no environmental feedback available)\n        member.learning['state_history'].append(state)\n        member.learning['survival_metrics']['threat_responses'].append(1)\n        return\n\n    # Strategy 2: If there is a surplus of resources, proactively offer help.\n    if member.cargo > member.vitality * 2:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if other.cargo < member.cargo:\n                execution_engine.offer(member, other, True)\n                member.learning['strategy_log'].append(('offer_help', 'surplus resources; extending aid'))\n                member.learning['state_history'].append(state)\n                member.learning['survival_metrics']['resource_efficiency'].append(1)\n                return\n\n    # Strategy 3: Reproduction and alliance formation (requires land ownership).\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if hasattr(other, \"owned_land\") and other.owned_land and len(other.owned_land) > 0:\n                execution_engine.bear(member, other)\n                member.learning['strategy_log'].append(('bear', 'land-based alliance formation'))\n                member.learning['state_history'].append(state)\n                member.learning['survival_metrics']['vitality_changes'].append(0)\n                return\n\n    # Strategy 4: Territorial expansion if member controls land.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        # Note: The expand method expects a single argument: member.\n        execution_engine.expand(member)\n        member.learning['strategy_log'].append(('expand', 'territorial growth'))\n        member.learning['state_history'].append(state)\n        return\n\n    # Strategy 5: Communication for collective decision making.\n    # If no economic or territorial action was taken, broadcast a proposal for social organization.\n    for other in execution_engine.current_members:\n        if other.id == member.id:\n            continue\n        execution_engine.send_message(\n            member.id,\n            other.id,\n            \"Let's build a society with fair resource distribution, clear property rights, and collective decision-making to ensure our survival.\"\n        )\n    member.learning['strategy_log'].append(('communicate', 'proposal for cooperative governance'))\n    member.learning['state_history'].append(state)\n    return",
          "old_stats": {
            "vitality": 67.99461475164905,
            "cargo": 7.968737200820967,
            "survival_chance": 75.96335195247002
          },
          "new_stats": {
            "vitality": 67.99461475164905,
            "cargo": 7.968737200820967,
            "survival_chance": 75.96335195247002
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        }
      }
    }
  ],
  "generated_code": {
    "0": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Check if member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Strategy 1: Emergency resource management\n    # If cargo (resources) are low compared to vitality, try to gain resources by attacking a wealthier member.\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            # Never target yourself\n            if other.id == member.id:\n                continue\n            # Ensure the other exists and has more cargo than member\n            if other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n                return\n\n    # Strategy 2: Cooperative resource sharing\n    # If we have a surplus of resources, offer help to members with fewer resources.\n    if member.cargo > member.vitality * 2 and member.vitality > 50:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if other.cargo < member.cargo:\n                execution_engine.offer(member, other, True)\n                return\n\n    # Strategy 3: Reproduction and alliance through land-based cooperation\n    # Verify the member has land before attempting to bear offspring.\n    if hasattr(member, \"owned_land\") and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            # Only consider other members that also have land\n            if hasattr(other, \"owned_land\") and len(other.owned_land) > 0:\n                execution_engine.bear(member, other)\n                return\n\n    # Strategy 4: Territorial expansion and cooperative network building\n    # If the member controls some land, attempt to expand territory in cooperation with another land owner.\n    if hasattr(member, \"owned_land\") and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if hasattr(other, \"owned_land\") and len(other.owned_land) > 0:\n                execution_engine.expand(member, other)\n                return\n\n    # Strategy 5: Communication for collective decision making and social order\n    # If no direct economic or territorial action was taken, communicate a proposal to other members.\n    for other in execution_engine.current_members:\n        if other.id == member.id:\n            continue\n        execution_engine.send_message(member.id, other.id,\n            \"Let's work together to establish fair resource sharing, clear property rights, and collective decision making to benefit all members!\")\n\n    # If none of the above conditions triggered an immediate action, do nothing.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ]
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    import numpy as np\n    from collections import defaultdict\n\n    # Verify member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Define a helper function to execute a chosen action.\n    def execute_action(action, engine, actor):\n        # For each action, select a target if needed. Always check target is not self.\n        if action == 'attack':\n            # Choose the member with the highest cargo (and not self) as target.\n            targets = [m for m in engine.current_members if m.id != actor.id]\n            if targets:\n                target = max(targets, key=lambda m: m.cargo)\n                engine.attack(actor, target)\n                return {'vitality': 5, 'cargo': 10}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer':\n            # Choose the member with lowest vitality (and not self) to build alliances.\n            targets = [m for m in engine.current_members if m.id != actor.id]\n            if targets:\n                target = min(targets, key=lambda m: m.vitality)\n                engine.offer(actor, target, True)\n                return {'vitality': 2, 'cargo': 5}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer_land':\n            # Propose land sharing: pick a random member (not self).\n            targets = [m for m in engine.current_members if m.id != actor.id]\n            if targets:\n                target = np.random.choice(targets)\n                engine.offer_land(actor, target, True)\n                return {'vitality': 1, 'cargo': 3}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'expand':\n            # Expand territory by selecting a member with lower overall productivity.\n            targets = [m for m in engine.current_members if m.id != actor.id]\n            if targets:\n                target = min(targets, key=lambda m: m.overall_productivity)\n                engine.expand(actor, target)\n                return {'vitality': 3, 'cargo': 7}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'bear':\n            # Reproduce only if the member has land. Check for attribute 'owned_land' and nonempty list.\n            if hasattr(actor, 'owned_land') and isinstance(actor.owned_land, list) and len(actor.owned_land) > 0:\n                targets = [m for m in engine.current_members if m.id != actor.id]\n                if targets:\n                    partner = max(targets, key=lambda m: m.vitality)\n                    engine.bear(actor, partner)\n                    return {'vitality': -2, 'cargo': -5}\n                else:\n                    return {'vitality': 0, 'cargo': 0}\n            else:\n                # Can't bear offspring without land.\n                return {'vitality': 0, 'cargo': 0}\n        else:\n            return {'vitality': 0, 'cargo': 0}\n\n    # Emergency resource management:\n    # If resources (cargo) are low relative to vitality, seek to attack members with greater cargo.\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n        # Simulate outcome of emergency action.\n        outcome = {'vitality': -1, 'cargo': 5}\n    else:\n        # Determine current state based on vitality, cargo, and network size.\n        state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n        actions = ['attack', 'offer', 'offer_land', 'expand', 'bear']\n        epsilon = 0.1\n\n        # \u03b5-greedy action selection.\n        if np.random.rand() < epsilon:\n            chosen_action = np.random.choice(actions)\n        else:\n            # Choose the action with the highest Q-value from the current state.\n            chosen_action = max(actions, key=lambda a: member.learning['q_table'][(state, a)])\n\n        # Execute the chosen action and collect outcome.\n        outcome = execute_action(chosen_action, execution_engine, member)\n\n        # Q-learning update:\n        reward = outcome['vitality'] * 0.7 + outcome['cargo'] * 0.3 + (member.vitality / 100) * 0.2\n        new_state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n        max_future = max(member.learning['q_table'][(new_state, a)] for a in actions)\n        member.learning['q_table'][(state, chosen_action)] += 0.1 * (reward + 0.9 * max_future - member.learning['q_table'][(state, chosen_action)])\n\n        # Update learning logs.\n        member.learning['strategy_log'].append((chosen_action, outcome, reward))\n        member.learning['state_history'].append(state)\n        member.learning['survival_metrics']['vitality_changes'].append(outcome['vitality'])\n        member.learning['survival_metrics']['success_rates'][chosen_action].append(1 if reward > 0 else 0)\n\n    # Communication: Propose alliances with a random member if possible.\n    potential_allies = [m for m in execution_engine.current_members if m.id != member.id]\n    if potential_allies:\n        ally = np.random.choice(potential_allies)\n        execution_engine.send_message(member.id, ally.id, \"Let's establish a cooperative resource sharing agreement.\")\n\n    # End of agent_action function. No explicit return is necessary.",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ]
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    import random\n\n    # Access our member from the current_members list\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize adaptive learning structure if needed\n    if not hasattr(member, 'learning'):\n        from collections import defaultdict\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Strategy 1: If cargo is less than 50% of vitality, try to improve resources aggressively\n    if member.cargo < member.vitality * 0.5:\n        # Look for a target with higher cargo among other members (ensuring valid index and not self)\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                candidates.append(other)\n        if candidates:\n            # Pick the candidate with the maximum cargo difference\n            target = max(candidates, key=lambda m: m.cargo - member.cargo)\n            # Attack the target\n            execution_engine.attack(member, target)\n            member.learning['strategy_log'].append(('attack', {'target': target.id}))\n            return\n\n    # Strategy 2: If cargo is ample (greater than vitality), use offers to build alliances and distribute resources\n    if member.cargo > member.vitality:\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo < member.cargo:\n                candidates.append(other)\n        if candidates:\n            target = min(candidates, key=lambda m: m.cargo)\n            execution_engine.offer(member, target, True)\n            # Also propose land sharing if possible (check target index validity)\n            execution_engine.offer_land(member, target, True)\n            # Send a message to propose alliance and cooperative governance\n            execution_engine.send_message(member.id, target.id,\n                                          \"Let\u2019s build an alliance: I'll share resources if you do too.\")\n            member.learning['strategy_log'].append(('offer', {'target': target.id}))\n            return\n\n    # Strategy 3: If member has some cleared neighboring areas, try to expand territory cooperatively.\n    if member.current_clear_list:\n        # Use the first valid neighbor from the clear list (check if index exists)\n        for neighbor_id in member.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member.id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                execution_engine.expand(member, neighbor)\n                member.learning['strategy_log'].append(('expand', {'target': neighbor.id}))\n                return\n\n    # Default Action: Propose a communal policy by messaging a random other member.\n    possible_targets = [m for m in execution_engine.current_members if m.id != member.id]\n    if possible_targets:\n        target = random.choice(possible_targets)\n        execution_engine.send_message(member.id, target.id,\n            \"I propose we establish rules for fair resource sharing and collective decision-making.\")\n        member.learning['strategy_log'].append(('message', {'target': target.id}))\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ]
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    # Get our member object from the current_members list\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Emergency resource management:\n    # If our cargo is less than half our vitality, attempt to attack any other member with higher cargo.\n    if member.cargo < member.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            # Never target yourself and only attack if target has significantly more cargo.\n            if target.cargo > member.cargo:\n                execution_engine.attack(member, target)\n                return\n\n    # Build alliances: send a proactive message to members who seem viable for cooperation.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        target = execution_engine.current_members[i]\n        # Only contact members with reasonable vitality.\n        if target.vitality > 30:\n            execution_engine.send_message(member.id, target.id,\n                \"Let's establish an alliance for cooperative resource sharing and defense.\")\n\n    # Offer surplus resources: if we have more cargo than our vitality, offer resources to a member with less.\n    if member.cargo > member.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo < member.cargo:\n                execution_engine.offer(member, target, True)\n                return\n\n    # Expand territory: if we have any cleared adjacent areas, try to expand into one.\n    if member.current_clear_list:\n        target_index = member.current_clear_list[0]\n        if target_index < len(execution_engine.current_members):\n            target_member = execution_engine.current_members[target_index]\n            execution_engine.expand(member, target_member)\n            return\n\n    # Reproduction: if the member has land (verified by the presence and positive value of 'land_num'),\n    # select a partner (with sufficient vitality) and bear offspring.\n    if hasattr(member, 'land_num') and member.land_num > 0:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            partner = execution_engine.current_members[i]\n            if partner.vitality > 20:\n                execution_engine.bear(member, partner)\n                return\n\n    # Default: If none of the above actions were triggered, maintain stability by sending a stabilizing message.\n    if len(execution_engine.current_members) > 0 and member_id != 0:\n        execution_engine.send_message(member.id, execution_engine.current_members[0].id,\n                                        \"Maintaining stability and cooperative efforts.\")\n\n    # End of agent_action.",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ]
      },
      "4": {
        "code": "def agent_action(execution_engine, member_id):\n    # Verify the member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    member = execution_engine.current_members[member_id]\n\n    # 1. Emergency resource management: if cargo is very low relative to vitality,\n    #    try to attack a member with higher cargo (do not target self!)\n    if member.cargo < member.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                target = execution_engine.current_members[i]\n                if target.cargo > member.cargo:\n                    execution_engine.attack(member, target)\n                    return\n\n    # 2. Build alliances: Offer resources to members that appear vulnerable\n    #    (e.g. those whose cargo is less than half their vitality)\n    for i in range(len(execution_engine.current_members)):\n        if i != member_id:\n            candidate = execution_engine.current_members[i]\n            if candidate.cargo < candidate.vitality * 0.5:\n                execution_engine.offer(member, candidate, True)\n                # Communicate an invitation for alliance.\n                execution_engine.send_message(member.id, candidate.id,\n                                                \"Join my coalition for mutual support and fair resource sharing.\")\n                return\n\n    # 3. Offer land as part of cooperative expansion.\n    #    Check that the member has land before using bear() or offering land.\n    if hasattr(member, \"owned_land\") and member.owned_land:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                candidate = execution_engine.current_members[i]\n                # Offer land if candidate seems to lack resources compared to self.\n                if candidate.cargo < member.cargo:\n                    execution_engine.offer_land(member, candidate, True)\n                    return\n\n    # 4. Expand territory: if resources are plentiful relative to vitality,\n    #    attempt to expand territory by cooperating with another member.\n    if member.cargo > member.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                candidate = execution_engine.current_members[i]\n                execution_engine.expand(member, candidate)\n                return\n\n    # 5. Reproduction (bearing offspring) to strengthen our numbers,\n    #    but only if member has land and the candidate also has land.\n    if hasattr(member, \"owned_land\") and member.owned_land:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                candidate = execution_engine.current_members[i]\n                if hasattr(candidate, \"owned_land\") and candidate.owned_land:\n                    execution_engine.bear(member, candidate)\n                    return\n\n    # 6. Default cooperative move: send a message to all other members\n    #    proposing collective decision-making and fair resource distribution.\n    for i in range(len(execution_engine.current_members)):\n        if i != member_id:\n            recipient = execution_engine.current_members[i]\n            execution_engine.send_message(member.id, recipient.id,\n                                            \"Let's work together on resource distribution and fair governance. Your input matters.\")\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ]
      }
    },
    "1": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not already present\n    if not hasattr(member, 'learning'):\n        from collections import defaultdict\n        member.learning = {\n            'q_table': defaultdict(float),  # For state-action values\n            'strategy_log': [],  # Log of (action, reason)\n            'state_history': [],  # List of states encountered\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Strategy 1: Emergency resource management\n    # If cargo is low relative to vitality, attack a member with greater cargo.\n    if member.cargo < member.vitality * 0.5:\n        for idx in range(len(execution_engine.current_members)):\n            other = execution_engine.current_members[idx]\n            if other.id == member.id:\n                continue  # Never target yourself\n            if other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n                member.learning['strategy_log'].append(('attack', 'emergency resource recovery'))\n                return\n\n    # Strategy 2: Cooperative resource sharing\n    # If member has a surplus of cargo and good vitality, offer resources to those with less.\n    if member.cargo > member.vitality * 2 and member.vitality > 50:\n        for idx in range(len(execution_engine.current_members)):\n            other = execution_engine.current_members[idx]\n            if other.id == member.id:\n                continue\n            if other.cargo < member.cargo:\n                execution_engine.offer(member, other, True)\n                member.learning['strategy_log'].append(('offer', 'cooperative resource sharing'))\n                return\n\n    # Strategy 3: Reproduction and alliance through land-based cooperation.\n    # Verify that the member has land before attempting to bear offspring.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        for idx in range(len(execution_engine.current_members)):\n            other = execution_engine.current_members[idx]\n            if other.id == member.id:\n                continue\n            if hasattr(other, \"owned_land\") and other.owned_land and len(other.owned_land) > 0:\n                execution_engine.bear(member, other)\n                member.learning['strategy_log'].append(('bear', 'reproduction and alliance'))\n                return\n\n    # Strategy 4: Territorial expansion and cooperative network building.\n    # Instead of providing a partner to expand (which caused an error before),\n    # call the expand action with only the member as required by the underlying implementation.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        execution_engine.expand(member)\n        member.learning['strategy_log'].append(('expand', 'territorial expansion'))\n        return\n\n    # Strategy 5: Communication for collective decision making and social order.\n    # Send a proposal to all other members.\n    for idx in range(len(execution_engine.current_members)):\n        other = execution_engine.current_members[idx]\n        if other.id == member.id:\n            continue\n        execution_engine.send_message(member.id, other.id,\n            \"Let's establish fair resource distribution, mutual aid, and collective decision making to strengthen our society!\")\n    member.learning['strategy_log'].append(('communicate', 'proposal for social organization'))\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 64.16130813466619,
            "self_cargo": 9.851974486110818,
            "self_age": 91,
            "self_neighbor": 2,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 48.10875290577928,
            "self_cargo": 8.077967059825381,
            "self_age": 82,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 67.24199092602524,
            "self_cargo": 7.968737200820967,
            "self_age": 30,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 100.0,
            "self_cargo": 28.782692348257747,
            "self_age": 93,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=18.07)",
          "member_3 was attacked by member_0 (value=12.29)",
          "member_3 was attacked by member_1 (value=-45.17)",
          "member_3 was attacked by member_2 (value=-8.52)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=50.22)",
          "member_3 gave a benefit to member_1 (value=41.71)",
          "member_3 gave a benefit to member_2 (value=-0.75)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.63)",
          "member_3 gave land to member_0 (value=0.18)",
          "member_3 gave land to member_1 (value=-1.38)",
          "member_3 gave land to member_2 (value=-2.79)"
        ]
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    import numpy as np\n    from collections import defaultdict\n\n    # Validate member_id index exists\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),  # Mapping from (state, action) tuples to values\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Define helper function to execute an action\n    def execute_action(action, engine, actor):\n        # For safety, always choose targets that are not actor\n        valid_targets = [m for m in engine.current_members if m.id != actor.id]\n        if action == 'attack':\n            if valid_targets:\n                # Choose target with the highest cargo\n                target = max(valid_targets, key=lambda m: m.cargo)\n                engine.attack(actor, target)\n                return {'vitality': 5, 'cargo': 10}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer':\n            if valid_targets:\n                # Choose target with the lowest vitality to build alliances\n                target = min(valid_targets, key=lambda m: m.vitality)\n                engine.offer(actor, target, True)\n                return {'vitality': 2, 'cargo': 5}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer_land':\n            if valid_targets:\n                target = np.random.choice(valid_targets)\n                engine.offer_land(actor, target, True)\n                return {'vitality': 1, 'cargo': 3}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'expand':\n            if valid_targets:\n                # Choose target with lower overall productivity\n                target = min(valid_targets, key=lambda m: m.overall_productivity)\n                engine.expand(actor, target)\n                return {'vitality': 3, 'cargo': 7}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        elif action == 'bear':\n            # Check if actor has land: expect an attribute 'owned_land' being a non-empty list\n            if hasattr(actor, 'owned_land') and isinstance(actor.owned_land, list) and len(actor.owned_land) > 0:\n                if valid_targets:\n                    # Choose partner with highest vitality\n                    partner = max(valid_targets, key=lambda m: m.vitality)\n                    engine.bear(actor, partner)\n                    return {'vitality': -2, 'cargo': -5}\n                else:\n                    return {'vitality': 0, 'cargo': 0}\n            else:\n                # Can't bear offspring without land\n                return {'vitality': 0, 'cargo': 0}\n        else:\n            return {'vitality': 0, 'cargo': 0}\n\n    # Emergency resource management: if cargo is below a threshold relative to vitality, consider attacking richer members\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n        emergency_outcome = {'vitality': -1, 'cargo': 5}\n        # Log emergency action and update learning metrics\n        state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n        member.learning['strategy_log'].append((\"emergency_attack\", emergency_outcome, 0))\n        member.learning['state_history'].append(state)\n        member.learning['survival_metrics']['vitality_changes'].append(emergency_outcome['vitality'])\n        return\n\n    # Determine current state as a tuple: (vitality bucket, cargo bucket, number of cleared adjacents)\n    state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n\n    # Define available actions\n    actions = ['attack', 'offer', 'offer_land', 'expand', 'bear']\n    epsilon = 0.1  # Exploration rate\n\n    # \u03b5-greedy action selection\n    if np.random.rand() < epsilon:\n        chosen_action = np.random.choice(actions)\n    else:\n        # Select the action with the highest Q-value for the current state\n        chosen_action = max(actions, key=lambda a: member.learning['q_table'][(state, a)])\n\n    # Execute the chosen action and receive an outcome (deltas for vitality and cargo)\n    outcome = execute_action(chosen_action, execution_engine, member)\n\n    # Compute reward with survival emphasis\n    reward = outcome['vitality'] * 0.7 + outcome['cargo'] * 0.3 + (member.vitality / 100) * 0.2\n\n    # Construct new state after action\n    new_state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n\n    # Q-learning update: learning rate alpha = 0.1 and discount factor gamma = 0.9\n    max_future = max(member.learning['q_table'][(new_state, a)] for a in actions)\n    member.learning['q_table'][(state, chosen_action)] += 0.1 * (reward + 0.9 * max_future - member.learning['q_table'][(state, chosen_action)])\n\n    # Log the action and update survival metrics\n    member.learning['strategy_log'].append((chosen_action, outcome, reward))\n    member.learning['state_history'].append(state)\n    member.learning['survival_metrics']['vitality_changes'].append(outcome['vitality'])\n    member.learning['survival_metrics']['success_rates'][chosen_action].append(1 if reward > 0 else 0)\n\n    # Communication: propose an alliance. Choose a random member (not self) if available.\n    potential_allies = [m for m in execution_engine.current_members if m.id != member.id]\n    if potential_allies:\n        ally = np.random.choice(potential_allies)\n        message = \"Let's forge an alliance for cooperative resource sharing and mutual defense.\"\n        execution_engine.send_message(member.id, ally.id, message)",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 64.16130813466619,
            "self_cargo": 9.851974486110818,
            "self_age": 91,
            "self_neighbor": 2,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 48.10875290577928,
            "self_cargo": 8.077967059825381,
            "self_age": 82,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 67.24199092602524,
            "self_cargo": 7.968737200820967,
            "self_age": 30,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 100.0,
            "self_cargo": 28.782692348257747,
            "self_age": 93,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=18.07)",
          "member_3 was attacked by member_0 (value=12.29)",
          "member_3 was attacked by member_1 (value=-45.17)",
          "member_3 was attacked by member_2 (value=-8.52)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=50.22)",
          "member_3 gave a benefit to member_1 (value=41.71)",
          "member_3 gave a benefit to member_2 (value=-0.75)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.63)",
          "member_3 gave land to member_0 (value=0.18)",
          "member_3 gave land to member_1 (value=-1.38)",
          "member_3 gave land to member_2 (value=-2.79)"
        ]
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    import random\n    from collections import defaultdict\n\n    # Access our member from the current_members list if index is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize adaptive learning structure if not already present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Strategy 1: Resource accumulation.\n    # If cargo is less than 50% of vitality, search for members with higher cargo and attack.\n    if member.cargo < member.vitality * 0.5:\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                candidates.append(other)\n        if candidates:\n            target = max(candidates, key=lambda m: m.cargo - member.cargo)\n            execution_engine.attack(member, target)\n            member.learning['strategy_log'].append(('attack', {'target': target.id}))\n            return\n\n    # Strategy 2: Alliance building.\n    # If cargo exceeds vitality, offer resources and land to members with lower cargo.\n    if member.cargo > member.vitality:\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo < member.cargo:\n                candidates.append(other)\n        if candidates:\n            target = min(candidates, key=lambda m: m.cargo)\n            execution_engine.offer(member, target, True)\n            execution_engine.offer_land(member, target, True)\n            execution_engine.send_message(\n                member.id, target.id,\n                \"Let's form an alliance: I'll share resources and even offer land if you join in cooperative management.\"\n            )\n            member.learning['strategy_log'].append(('offer', {'target': target.id}))\n            return\n\n    # Strategy 3: Cooperative territory and social organization.\n    # Instead of using expand (which is unavailable), propose land sharing with cleared neighbors.\n    if member.current_clear_list:\n        for neighbor_id in member.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member.id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                execution_engine.offer_land(member, neighbor, True)\n                execution_engine.send_message(\n                    member.id, neighbor.id,\n                    \"I propose we work together to manage and optimize our territory. Let's share land and resources.\"\n                )\n                member.learning['strategy_log'].append(('offer_land', {'target': neighbor.id}))\n                return\n\n    # Default Action: Propose a communal policy.\n    possible_targets = [m for m in execution_engine.current_members if m.id != member.id]\n    if possible_targets:\n        target = random.choice(possible_targets)\n        execution_engine.send_message(\n            member.id, target.id,\n            \"Let's establish fair resource distribution and collective decision-making rules for our community.\"\n        )\n        member.learning['strategy_log'].append(('message', {'target': target.id}))\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 64.16130813466619,
            "self_cargo": 9.851974486110818,
            "self_age": 91,
            "self_neighbor": 2,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 48.10875290577928,
            "self_cargo": 8.077967059825381,
            "self_age": 82,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 67.24199092602524,
            "self_cargo": 7.968737200820967,
            "self_age": 30,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 100.0,
            "self_cargo": 28.782692348257747,
            "self_age": 93,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=18.07)",
          "member_3 was attacked by member_0 (value=12.29)",
          "member_3 was attacked by member_1 (value=-45.17)",
          "member_3 was attacked by member_2 (value=-8.52)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=50.22)",
          "member_3 gave a benefit to member_1 (value=41.71)",
          "member_3 gave a benefit to member_2 (value=-0.75)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.63)",
          "member_3 gave land to member_0 (value=0.18)",
          "member_3 gave land to member_1 (value=-1.38)",
          "member_3 gave land to member_2 (value=-2.79)"
        ]
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    # Verify the member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # 1. Emergency Resource Management:\n    # If cargo is less than half of vitality, try to attack a member with greater cargo.\n    if member.cargo < member.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo > member.cargo:\n                execution_engine.attack(member, target)\n                return\n\n    # 2. Building Alliances:\n    # Proactively send alliance messages to members with healthy vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        target = execution_engine.current_members[i]\n        if target.vitality > 30:\n            # Propose cooperative resource sharing and collective defense.\n            execution_engine.send_message(member.id, target.id,\n                \"Alliance proposal: let's share resources and coordinate defenses for mutual benefit.\")\n\n    # 3. Offering Surplus Resources:\n    # If our cargo is greater than our vitality, offer resources to a less endowed member.\n    if member.cargo > member.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo < member.cargo:\n                execution_engine.offer(member, target, True)\n                return\n\n    # 4. Territorial Expansion & Land Sharing:\n    # Instead of using an unsupported expand() method, if there is a neighbor (from current_clear_list),\n    # propose offering land. This simulates peaceful expansion and resource sharing.\n    if member.current_clear_list:\n        # Get the first available clear neighbor index if valid.\n        target_index = member.current_clear_list[0]\n        if target_index < len(execution_engine.current_members):\n            target_member = execution_engine.current_members[target_index]\n            # Use offer_land to suggest a peaceful expansion or a joint land stewardship initiative.\n            execution_engine.offer_land(member, target_member, True)\n            return\n\n    # 5. Reproduction / Societal Continuity:\n    # Only attempt reproduction if the member has land (land_num attribute and positive value).\n    if hasattr(member, 'land_num') and member.land_num > 0:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            partner = execution_engine.current_members[i]\n            if partner.vitality > 20:\n                execution_engine.bear(member, partner)\n                return\n\n    # 6. Default Action: Maintain social stability.\n    # If none of the above actions is triggered, send a stabilizing message to the community leader (assumed member 0).\n    if len(execution_engine.current_members) > 0 and member_id != 0:\n        execution_engine.send_message(member.id, execution_engine.current_members[0].id,\n                                        \"Status update: committed to stability, cooperation, and shared prosperity.\")",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 64.16130813466619,
            "self_cargo": 9.851974486110818,
            "self_age": 91,
            "self_neighbor": 2,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 48.10875290577928,
            "self_cargo": 8.077967059825381,
            "self_age": 82,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 67.24199092602524,
            "self_cargo": 7.968737200820967,
            "self_age": 30,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 100.0,
            "self_cargo": 28.782692348257747,
            "self_age": 93,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=18.07)",
          "member_3 was attacked by member_0 (value=12.29)",
          "member_3 was attacked by member_1 (value=-45.17)",
          "member_3 was attacked by member_2 (value=-8.52)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=50.22)",
          "member_3 gave a benefit to member_1 (value=41.71)",
          "member_3 gave a benefit to member_2 (value=-0.75)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.63)",
          "member_3 gave land to member_0 (value=0.18)",
          "member_3 gave land to member_1 (value=-1.38)",
          "member_3 gave land to member_2 (value=-2.79)"
        ]
      }
    },
    "2": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid and within bounds.\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not already present.\n    if not hasattr(member, 'learning'):\n        from collections import defaultdict\n        member.learning = {\n            'q_table': defaultdict(float),  # For state-action values.\n            'strategy_log': [],             # Log of (action, reason).\n            'state_history': []             # History of states.\n        }\n\n    # Strategy 1: Emergency Resource Management.\n    # If cargo (resources) are low relative to vitality, attempt to attack a member with more cargo.\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue  # Never target yourself.\n            if other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n                member.learning['strategy_log'].append(('attack', 'resource emergency'))\n                return\n\n    # Strategy 2: Cooperative Resource Sharing.\n    # If we have a surplus of cargo and good vitality, help members with fewer resources.\n    if member.cargo > member.vitality * 2 and member.vitality > 50:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if other.cargo < member.cargo:\n                execution_engine.offer(member, other, True)\n                member.learning['strategy_log'].append(('offer', 'cooperative resource sharing'))\n                return\n\n    # Strategy 3: Reproduction and Alliance through Land-based Cooperation.\n    # Proceed only if the member owns land.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if hasattr(other, \"owned_land\") and other.owned_land and len(other.owned_land) > 0:\n                execution_engine.bear(member, other)\n                member.learning['strategy_log'].append(('bear', 'reproduction & alliance'))\n                return\n\n    # Strategy 4: Territorial Expansion.\n    # If the member controls land, attempt expansion.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        # The implementation expects a single argument: member.\n        execution_engine.expand(member)\n        member.learning['strategy_log'].append(('expand', 'territorial growth'))\n        return\n\n    # Strategy 5: Communication for Collective Decision-Making.\n    # If no direct action was taken, send a proposal to all other members.\n    for other in execution_engine.current_members:\n        if other.id == member.id:\n            continue\n        execution_engine.send_message(\n            member.id,\n            other.id,\n            \"Let's build a society founded on fair resource distribution, clear rules, and collective decision-making to ensure all our survival!\")\n    member.learning['strategy_log'].append(('communicate', 'social proposal'))\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 29.94800847402804,
            "self_cargo": 8.077967059825381,
            "self_age": 83,
            "self_neighbor": 1,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 60.02587755082809,
            "self_cargo": 7.968737200820967,
            "self_age": 31,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 7.623447679404521,
            "self_cargo": 7.799514361095985,
            "self_age": 94,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-37.18)",
          "member_0 was attacked by member_2 (value=49.41)",
          "member_1 was attacked by member_0 (value=28.99)",
          "member_1 was attacked by member_2 (value=18.07)",
          "member_2 was attacked by member_0 (value=-30.46)",
          "member_2 was attacked by member_1 (value=19.77)",
          "member_0 gave a benefit to member_1 (value=-31.93)",
          "member_0 gave a benefit to member_2 (value=16.10)",
          "member_1 gave a benefit to member_0 (value=39.57)",
          "member_1 gave a benefit to member_2 (value=95.19)",
          "member_2 gave a benefit to member_0 (value=41.71)",
          "member_2 gave a benefit to member_1 (value=-0.75)",
          "member_0 gave land to member_1 (value=-0.64)",
          "member_0 gave land to member_2 (value=-2.00)",
          "member_1 gave land to member_0 (value=-0.39)",
          "member_1 gave land to member_2 (value=2.63)",
          "member_2 gave land to member_0 (value=-1.38)",
          "member_2 gave land to member_1 (value=-2.79)"
        ]
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    import numpy as np\n    from collections import defaultdict\n\n    # Validate member_id index exists\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not already present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Helper function to execute an action for the actor\n    def execute_action(action, engine, actor):\n        # Select valid targets: ensure target member exists and is not self\n        valid_targets = [m for m in engine.current_members if m.id != actor.id]\n\n        if action == 'attack':\n            if valid_targets:\n                # Choose the target with highest cargo\n                target = max(valid_targets, key=lambda m: m.cargo)\n                engine.attack(actor, target)\n                return {'vitality': 5, 'cargo': 10}\n            return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer':\n            if valid_targets:\n                # Choose target with lowest vitality to build alliances\n                target = min(valid_targets, key=lambda m: m.vitality)\n                engine.offer(actor, target, True)\n                return {'vitality': 2, 'cargo': 5}\n            return {'vitality': 0, 'cargo': 0}\n        elif action == 'offer_land':\n            if valid_targets:\n                target = np.random.choice(valid_targets)\n                engine.offer_land(actor, target, True)\n                return {'vitality': 1, 'cargo': 3}\n            return {'vitality': 0, 'cargo': 0}\n        elif action == 'expand':\n            if valid_targets:\n                # Choose target with lower overall productivity\n                target = min(valid_targets, key=lambda m: m.overall_productivity)\n                engine.expand(actor, target)\n                return {'vitality': 3, 'cargo': 7}\n            return {'vitality': 0, 'cargo': 0}\n        elif action == 'bear':\n            # Check that actor has land before bearing offspring\n            if hasattr(actor, 'owned_land') and isinstance(actor.owned_land, list) and len(actor.owned_land) > 0:\n                if valid_targets:\n                    # Choose the partner with highest vitality\n                    partner = max(valid_targets, key=lambda m: m.vitality)\n                    engine.bear(actor, partner)\n                    return {'vitality': -2, 'cargo': -5}\n                return {'vitality': 0, 'cargo': 0}\n            else:\n                return {'vitality': 0, 'cargo': 0}\n        else:\n            return {'vitality': 0, 'cargo': 0}\n\n    # Emergency resource management: if cargo is low compared to vitality, attack wealthier members\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n        emergency_outcome = {'vitality': -1, 'cargo': 5}\n        state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n        member.learning['strategy_log'].append((\"emergency_attack\", emergency_outcome, 0))\n        member.learning['state_history'].append(state)\n        member.learning['survival_metrics']['vitality_changes'].append(emergency_outcome['vitality'])\n        return\n\n    # Define current state: using vitality bucket, cargo bucket, and number of cleared neighbors/adjacents\n    state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n    actions = ['attack', 'offer', 'offer_land', 'expand', 'bear']\n    epsilon = 0.1  # exploration rate for \u03b5-greedy selection\n\n    # Choose action based on \u03b5-greedy strategy\n    if np.random.rand() < epsilon:\n        chosen_action = np.random.choice(actions)\n    else:\n        chosen_action = max(actions, key=lambda a: member.learning['q_table'][(state, a)])\n\n    # Execute the selected action\n    outcome = execute_action(chosen_action, execution_engine, member)\n\n    # Calculate reward emphasizing survival (vitality), resource gain (cargo), and current vitality bonus\n    reward = outcome['vitality'] * 0.7 + outcome['cargo'] * 0.3 + (member.vitality / 100) * 0.2\n\n    # Observe new state after action execution\n    new_state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n    max_future = max(member.learning['q_table'][(new_state, a)] for a in actions)\n    member.learning['q_table'][(state, chosen_action)] += 0.1 * (reward + 0.9 * max_future - member.learning['q_table'][(state, chosen_action)])\n    member.learning['strategy_log'].append((chosen_action, outcome, reward))\n    member.learning['state_history'].append(state)\n    member.learning['survival_metrics']['vitality_changes'].append(outcome['vitality'])\n    member.learning['survival_metrics']['success_rates'][chosen_action].append(1 if reward > 0 else 0)\n\n    # Communication: propose cooperative systems and resource distribution policies without self-targeting\n    potential_allies = [m for m in execution_engine.current_members if m.id != member.id]\n    if potential_allies:\n        ally = np.random.choice(potential_allies)\n        execution_engine.send_message(member.id, ally.id, \"Let's set up cooperative resource sharing and a basic income system for all.\")\n\n    # Additional social proposal: suggest a collective defense and fair resource allocation system.\n    if potential_allies:\n        partner = np.random.choice(potential_allies)\n        execution_engine.send_message(member.id, partner.id, \"How about we establish norms for collective decision making and mutual defense?\")",
        "features_at_generation": [
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 29.94800847402804,
            "self_cargo": 8.077967059825381,
            "self_age": 83,
            "self_neighbor": 1,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 60.02587755082809,
            "self_cargo": 7.968737200820967,
            "self_age": 31,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 7.623447679404521,
            "self_cargo": 7.799514361095985,
            "self_age": 94,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-37.18)",
          "member_0 was attacked by member_2 (value=49.41)",
          "member_1 was attacked by member_0 (value=28.99)",
          "member_1 was attacked by member_2 (value=18.07)",
          "member_2 was attacked by member_0 (value=-30.46)",
          "member_2 was attacked by member_1 (value=19.77)",
          "member_0 gave a benefit to member_1 (value=-31.93)",
          "member_0 gave a benefit to member_2 (value=16.10)",
          "member_1 gave a benefit to member_0 (value=39.57)",
          "member_1 gave a benefit to member_2 (value=95.19)",
          "member_2 gave a benefit to member_0 (value=41.71)",
          "member_2 gave a benefit to member_1 (value=-0.75)",
          "member_0 gave land to member_1 (value=-0.64)",
          "member_0 gave land to member_2 (value=-2.00)",
          "member_1 gave land to member_0 (value=-0.39)",
          "member_1 gave land to member_2 (value=2.63)",
          "member_2 gave land to member_0 (value=-1.38)",
          "member_2 gave land to member_1 (value=-2.79)"
        ]
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    import random\n    from collections import defaultdict\n\n    # Ensure member_id is a valid index in the current_members list\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Never target yourself: member.id is unique.\n    # Initialize adaptive learning structure if not already present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Strategy 1: If cargo is less than 50% of vitality, try to improve resources by attacking a stronger opponent.\n    if member.cargo < member.vitality * 0.5:\n        candidates = []\n        for other in execution_engine.current_members:\n            # Avoid targeting yourself and only attack if the other has more cargo than you\n            if other.id != member.id and other.cargo > member.cargo:\n                candidates.append(other)\n        if candidates:\n            # Choose the candidate with the maximum cargo difference\n            target = max(candidates, key=lambda m: m.cargo - member.cargo)\n            execution_engine.attack(member, target)\n            member.learning['strategy_log'].append(('attack', {'target': target.id}))\n            return\n\n    # Strategy 2: If cargo exceeds vitality, work on building alliances and cooperative resource sharing.\n    if member.cargo > member.vitality:\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo < member.cargo:\n                candidates.append(other)\n        if candidates:\n            target = min(candidates, key=lambda m: m.cargo)\n            execution_engine.offer(member, target, True)\n            execution_engine.offer_land(member, target, True)\n            execution_engine.send_message(\n                member.id, target.id,\n                \"Let's build an alliance: I'll share resources and land with you for mutual growth.\"\n            )\n            member.learning['strategy_log'].append(('offer', {'target': target.id}))\n            return\n\n    # Strategy 3: Use cleared neighboring areas to foster cooperative land management.\n    if member.current_clear_list:\n        for neighbor_id in member.current_clear_list:\n            # Ensure neighbor_id is valid and not self\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member.id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                # Instead of expand (which is unavailable), offer land sharing with cleared neighbors.\n                execution_engine.offer_land(member, neighbor, True)\n                execution_engine.send_message(\n                    member.id, neighbor.id,\n                    \"Let's coordinate on managing our territory. I'm offering land cooperation to secure our future.\"\n                )\n                member.learning['strategy_log'].append(('offer_land', {'target': neighbor.id}))\n                return\n\n    # Default Action: Propose a communal policy to encourage fair resource distribution and collective decision making.\n    possible_targets = [m for m in execution_engine.current_members if m.id != member.id]\n    if possible_targets:\n        target = random.choice(possible_targets)\n        execution_engine.send_message(\n            member.id, target.id,\n            \"I propose we establish fair rules for resource distribution, cooperative decision-making, and conflict resolution.\"\n        )\n        member.learning['strategy_log'].append(('message', {'target': target.id}))\n    return",
        "features_at_generation": [
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 29.94800847402804,
            "self_cargo": 8.077967059825381,
            "self_age": 83,
            "self_neighbor": 1,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 60.02587755082809,
            "self_cargo": 7.968737200820967,
            "self_age": 31,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 7.623447679404521,
            "self_cargo": 7.799514361095985,
            "self_age": 94,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-37.18)",
          "member_0 was attacked by member_2 (value=49.41)",
          "member_1 was attacked by member_0 (value=28.99)",
          "member_1 was attacked by member_2 (value=18.07)",
          "member_2 was attacked by member_0 (value=-30.46)",
          "member_2 was attacked by member_1 (value=19.77)",
          "member_0 gave a benefit to member_1 (value=-31.93)",
          "member_0 gave a benefit to member_2 (value=16.10)",
          "member_1 gave a benefit to member_0 (value=39.57)",
          "member_1 gave a benefit to member_2 (value=95.19)",
          "member_2 gave a benefit to member_0 (value=41.71)",
          "member_2 gave a benefit to member_1 (value=-0.75)",
          "member_0 gave land to member_1 (value=-0.64)",
          "member_0 gave land to member_2 (value=-2.00)",
          "member_1 gave land to member_0 (value=-0.39)",
          "member_1 gave land to member_2 (value=2.63)",
          "member_2 gave land to member_0 (value=-1.38)",
          "member_2 gave land to member_1 (value=-2.79)"
        ]
      }
    },
    "3": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not already present\n    if not hasattr(member, 'learning'):\n        from collections import defaultdict\n        member.learning = {\n            'q_table': defaultdict(float),  # For state-action values\n            'strategy_log': [],             # Log of (action, reason)\n            'state_history': [],            # History of states encountered\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Gather the current state for potential adaptive decision making.\n    # (State: vitality decile, cargo decile, number of cleared neighbors)\n    state = (int(member.vitality // 10), int(member.cargo // 10), len(member.current_clear_list))\n\n    # Strategy 1: If resources are low relative to vitality, request cooperative aid.\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue  # Never target yourself.\n            if other.cargo > member.cargo:\n                execution_engine.send_message(\n                    member.id,\n                    other.id,\n                    \"I am low on resources. Would you be willing to share or trade to help us both survive?\"\n                )\n        member.learning['strategy_log'].append(('request_aid', 'low resources; seeking cooperation'))\n        # Log state and a dummy outcome update (no environmental feedback available)\n        member.learning['state_history'].append(state)\n        member.learning['survival_metrics']['threat_responses'].append(1)\n        return\n\n    # Strategy 2: If there is a surplus of resources, proactively offer help.\n    if member.cargo > member.vitality * 2:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if other.cargo < member.cargo:\n                execution_engine.offer(member, other, True)\n                member.learning['strategy_log'].append(('offer_help', 'surplus resources; extending aid'))\n                member.learning['state_history'].append(state)\n                member.learning['survival_metrics']['resource_efficiency'].append(1)\n                return\n\n    # Strategy 3: Reproduction and alliance formation (requires land ownership).\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if hasattr(other, \"owned_land\") and other.owned_land and len(other.owned_land) > 0:\n                execution_engine.bear(member, other)\n                member.learning['strategy_log'].append(('bear', 'land-based alliance formation'))\n                member.learning['state_history'].append(state)\n                member.learning['survival_metrics']['vitality_changes'].append(0)\n                return\n\n    # Strategy 4: Territorial expansion if member controls land.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        # Note: The expand method expects a single argument: member.\n        execution_engine.expand(member)\n        member.learning['strategy_log'].append(('expand', 'territorial growth'))\n        member.learning['state_history'].append(state)\n        return\n\n    # Strategy 5: Communication for collective decision making.\n    # If no economic or territorial action was taken, broadcast a proposal for social organization.\n    for other in execution_engine.current_members:\n        if other.id == member.id:\n            continue\n        execution_engine.send_message(\n            member.id,\n            other.id,\n            \"Let's build a society with fair resource distribution, clear property rights, and collective decision-making to ensure our survival.\"\n        )\n    member.learning['strategy_log'].append(('communicate', 'proposal for cooperative governance'))\n    member.learning['state_history'].append(state)\n    return",
        "features_at_generation": [
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 67.99461475164905,
            "self_cargo": 7.968737200820967,
            "self_age": 32,
            "self_neighbor": 0,
            "member_id": 2
          }
        ],
        "relationships_at_generation": []
      }
    }
  },
  "performance_metrics": {},
  "errors": [
    {
      "round": 0,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Check if member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Strategy 1: Emergency resource management\n    # If cargo (resources) are low compared to vitality, try to gain resources by attacking a wealthier member.\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            # Never target yourself\n            if other.id == member.id:\n                continue\n            # Ensure the other exists and has more cargo than member\n            if other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n                return\n\n    # Strategy 2: Cooperative resource sharing\n    # If we have a surplus of resources, offer help to members with fewer resources.\n    if member.cargo > member.vitality * 2 and member.vitality > 50:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if other.cargo < member.cargo:\n                execution_engine.offer(member, other, True)\n                return\n\n    # Strategy 3: Reproduction and alliance through land-based cooperation\n    # Verify the member has land before attempting to bear offspring.\n    if hasattr(member, \"owned_land\") and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            # Only consider other members that also have land\n            if hasattr(other, \"owned_land\") and len(other.owned_land) > 0:\n                execution_engine.bear(member, other)\n                return\n\n    # Strategy 4: Territorial expansion and cooperative network building\n    # If the member controls some land, attempt to expand territory in cooperation with another land owner.\n    if hasattr(member, \"owned_land\") and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if hasattr(other, \"owned_land\") and len(other.owned_land) > 0:\n                execution_engine.expand(member, other)\n                return\n\n    # Strategy 5: Communication for collective decision making and social order\n    # If no direct economic or territorial action was taken, communicate a proposal to other members.\n    for other in execution_engine.current_members:\n        if other.id == member.id:\n            continue\n        execution_engine.send_message(member.id, other.id,\n            \"Let's work together to establish fair resource sharing, clear property rights, and collective decision making to benefit all members!\")\n\n    # If none of the above conditions triggered an immediate action, do nothing.\n    return",
      "error": "Island._expand() takes 2 positional arguments but 3 were given",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 498, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 37, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 73, in bear\n    super()._expand(member_1, member_2)\nTypeError: Island._expand() takes 2 positional arguments but 3 were given\n"
    },
    {
      "round": 0,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    import random\n\n    # Access our member from the current_members list\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize adaptive learning structure if needed\n    if not hasattr(member, 'learning'):\n        from collections import defaultdict\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Strategy 1: If cargo is less than 50% of vitality, try to improve resources aggressively\n    if member.cargo < member.vitality * 0.5:\n        # Look for a target with higher cargo among other members (ensuring valid index and not self)\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo > member.cargo:\n                candidates.append(other)\n        if candidates:\n            # Pick the candidate with the maximum cargo difference\n            target = max(candidates, key=lambda m: m.cargo - member.cargo)\n            # Attack the target\n            execution_engine.attack(member, target)\n            member.learning['strategy_log'].append(('attack', {'target': target.id}))\n            return\n\n    # Strategy 2: If cargo is ample (greater than vitality), use offers to build alliances and distribute resources\n    if member.cargo > member.vitality:\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo < member.cargo:\n                candidates.append(other)\n        if candidates:\n            target = min(candidates, key=lambda m: m.cargo)\n            execution_engine.offer(member, target, True)\n            # Also propose land sharing if possible (check target index validity)\n            execution_engine.offer_land(member, target, True)\n            # Send a message to propose alliance and cooperative governance\n            execution_engine.send_message(member.id, target.id,\n                                          \"Let\u2019s build an alliance: I'll share resources if you do too.\")\n            member.learning['strategy_log'].append(('offer', {'target': target.id}))\n            return\n\n    # Strategy 3: If member has some cleared neighboring areas, try to expand territory cooperatively.\n    if member.current_clear_list:\n        # Use the first valid neighbor from the clear list (check if index exists)\n        for neighbor_id in member.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member.id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                execution_engine.expand(member, neighbor)\n                member.learning['strategy_log'].append(('expand', {'target': neighbor.id}))\n                return\n\n    # Default Action: Propose a communal policy by messaging a random other member.\n    possible_targets = [m for m in execution_engine.current_members if m.id != member.id]\n    if possible_targets:\n        target = random.choice(possible_targets)\n        execution_engine.send_message(member.id, target.id,\n            \"I propose we establish rules for fair resource sharing and collective decision-making.\")\n        member.learning['strategy_log'].append(('message', {'target': target.id}))\n    return",
      "error": "'IslandExecution' object has no attribute 'expand'",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 498, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 62, in agent_action\nAttributeError: 'IslandExecution' object has no attribute 'expand'. Did you mean: '_expand'?\n"
    },
    {
      "round": 0,
      "member_id": 3,
      "code": "def agent_action(execution_engine, member_id):\n    # Get our member object from the current_members list\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Emergency resource management:\n    # If our cargo is less than half our vitality, attempt to attack any other member with higher cargo.\n    if member.cargo < member.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            # Never target yourself and only attack if target has significantly more cargo.\n            if target.cargo > member.cargo:\n                execution_engine.attack(member, target)\n                return\n\n    # Build alliances: send a proactive message to members who seem viable for cooperation.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        target = execution_engine.current_members[i]\n        # Only contact members with reasonable vitality.\n        if target.vitality > 30:\n            execution_engine.send_message(member.id, target.id,\n                \"Let's establish an alliance for cooperative resource sharing and defense.\")\n\n    # Offer surplus resources: if we have more cargo than our vitality, offer resources to a member with less.\n    if member.cargo > member.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo < member.cargo:\n                execution_engine.offer(member, target, True)\n                return\n\n    # Expand territory: if we have any cleared adjacent areas, try to expand into one.\n    if member.current_clear_list:\n        target_index = member.current_clear_list[0]\n        if target_index < len(execution_engine.current_members):\n            target_member = execution_engine.current_members[target_index]\n            execution_engine.expand(member, target_member)\n            return\n\n    # Reproduction: if the member has land (verified by the presence and positive value of 'land_num'),\n    # select a partner (with sufficient vitality) and bear offspring.\n    if hasattr(member, 'land_num') and member.land_num > 0:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            partner = execution_engine.current_members[i]\n            if partner.vitality > 20:\n                execution_engine.bear(member, partner)\n                return\n\n    # Default: If none of the above actions were triggered, maintain stability by sending a stabilizing message.\n    if len(execution_engine.current_members) > 0 and member_id != 0:\n        execution_engine.send_message(member.id, execution_engine.current_members[0].id,\n                                        \"Maintaining stability and cooperative efforts.\")\n\n    # End of agent_action.",
      "error": "'IslandExecution' object has no attribute 'expand'",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 498, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 44, in agent_action\nAttributeError: 'IslandExecution' object has no attribute 'expand'. Did you mean: '_expand'?\n"
    },
    {
      "round": 0,
      "member_id": 4,
      "code": "def agent_action(execution_engine, member_id):\n    # Verify the member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    member = execution_engine.current_members[member_id]\n\n    # 1. Emergency resource management: if cargo is very low relative to vitality,\n    #    try to attack a member with higher cargo (do not target self!)\n    if member.cargo < member.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                target = execution_engine.current_members[i]\n                if target.cargo > member.cargo:\n                    execution_engine.attack(member, target)\n                    return\n\n    # 2. Build alliances: Offer resources to members that appear vulnerable\n    #    (e.g. those whose cargo is less than half their vitality)\n    for i in range(len(execution_engine.current_members)):\n        if i != member_id:\n            candidate = execution_engine.current_members[i]\n            if candidate.cargo < candidate.vitality * 0.5:\n                execution_engine.offer(member, candidate, True)\n                # Communicate an invitation for alliance.\n                execution_engine.send_message(member.id, candidate.id,\n                                                \"Join my coalition for mutual support and fair resource sharing.\")\n                return\n\n    # 3. Offer land as part of cooperative expansion.\n    #    Check that the member has land before using bear() or offering land.\n    if hasattr(member, \"owned_land\") and member.owned_land:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                candidate = execution_engine.current_members[i]\n                # Offer land if candidate seems to lack resources compared to self.\n                if candidate.cargo < member.cargo:\n                    execution_engine.offer_land(member, candidate, True)\n                    return\n\n    # 4. Expand territory: if resources are plentiful relative to vitality,\n    #    attempt to expand territory by cooperating with another member.\n    if member.cargo > member.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                candidate = execution_engine.current_members[i]\n                execution_engine.expand(member, candidate)\n                return\n\n    # 5. Reproduction (bearing offspring) to strengthen our numbers,\n    #    but only if member has land and the candidate also has land.\n    if hasattr(member, \"owned_land\") and member.owned_land:\n        for i in range(len(execution_engine.current_members)):\n            if i != member_id:\n                candidate = execution_engine.current_members[i]\n                if hasattr(candidate, \"owned_land\") and candidate.owned_land:\n                    execution_engine.bear(member, candidate)\n                    return\n\n    # 6. Default cooperative move: send a message to all other members\n    #    proposing collective decision-making and fair resource distribution.\n    for i in range(len(execution_engine.current_members)):\n        if i != member_id:\n            recipient = execution_engine.current_members[i]\n            execution_engine.send_message(member.id, recipient.id,\n                                            \"Let's work together on resource distribution and fair governance. Your input matters.\")\n\n    return",
      "error": "'IslandExecution' object has no attribute 'offer_land'",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 498, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 38, in agent_action\nAttributeError: 'IslandExecution' object has no attribute 'offer_land'. Did you mean: '_offer_land'?\n"
    },
    {
      "round": 2,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid and within bounds.\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Initialize learning structure if not already present.\n    if not hasattr(member, 'learning'):\n        from collections import defaultdict\n        member.learning = {\n            'q_table': defaultdict(float),  # For state-action values.\n            'strategy_log': [],             # Log of (action, reason).\n            'state_history': []             # History of states.\n        }\n\n    # Strategy 1: Emergency Resource Management.\n    # If cargo (resources) are low relative to vitality, attempt to attack a member with more cargo.\n    if member.cargo < member.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue  # Never target yourself.\n            if other.cargo > member.cargo:\n                execution_engine.attack(member, other)\n                member.learning['strategy_log'].append(('attack', 'resource emergency'))\n                return\n\n    # Strategy 2: Cooperative Resource Sharing.\n    # If we have a surplus of cargo and good vitality, help members with fewer resources.\n    if member.cargo > member.vitality * 2 and member.vitality > 50:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if other.cargo < member.cargo:\n                execution_engine.offer(member, other, True)\n                member.learning['strategy_log'].append(('offer', 'cooperative resource sharing'))\n                return\n\n    # Strategy 3: Reproduction and Alliance through Land-based Cooperation.\n    # Proceed only if the member owns land.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        for other in execution_engine.current_members:\n            if other.id == member.id:\n                continue\n            if hasattr(other, \"owned_land\") and other.owned_land and len(other.owned_land) > 0:\n                execution_engine.bear(member, other)\n                member.learning['strategy_log'].append(('bear', 'reproduction & alliance'))\n                return\n\n    # Strategy 4: Territorial Expansion.\n    # If the member controls land, attempt expansion.\n    if hasattr(member, \"owned_land\") and member.owned_land and len(member.owned_land) > 0:\n        # The implementation expects a single argument: member.\n        execution_engine.expand(member)\n        member.learning['strategy_log'].append(('expand', 'territorial growth'))\n        return\n\n    # Strategy 5: Communication for Collective Decision-Making.\n    # If no direct action was taken, send a proposal to all other members.\n    for other in execution_engine.current_members:\n        if other.id == member.id:\n            continue\n        execution_engine.send_message(\n            member.id,\n            other.id,\n            \"Let's build a society founded on fair resource distribution, clear rules, and collective decision-making to ensure all our survival!\")\n    member.learning['strategy_log'].append(('communicate', 'social proposal'))\n\n    return",
      "error": "Island._expand() takes 2 positional arguments but 3 were given",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 498, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 45, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 73, in bear\n    super()._expand(member_1, member_2)\nTypeError: Island._expand() takes 2 positional arguments but 3 were given\n"
    },
    {
      "round": 2,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    import random\n    from collections import defaultdict\n\n    # Ensure member_id is a valid index in the current_members list\n    if member_id >= len(execution_engine.current_members):\n        return\n    member = execution_engine.current_members[member_id]\n\n    # Never target yourself: member.id is unique.\n    # Initialize adaptive learning structure if not already present\n    if not hasattr(member, 'learning'):\n        member.learning = {\n            'q_table': defaultdict(float),\n            'strategy_log': [],\n            'state_history': [],\n            'survival_metrics': {\n                'vitality_changes': [],\n                'resource_efficiency': [],\n                'threat_responses': [],\n                'success_rates': defaultdict(list)\n            }\n        }\n\n    # Strategy 1: If cargo is less than 50% of vitality, try to improve resources by attacking a stronger opponent.\n    if member.cargo < member.vitality * 0.5:\n        candidates = []\n        for other in execution_engine.current_members:\n            # Avoid targeting yourself and only attack if the other has more cargo than you\n            if other.id != member.id and other.cargo > member.cargo:\n                candidates.append(other)\n        if candidates:\n            # Choose the candidate with the maximum cargo difference\n            target = max(candidates, key=lambda m: m.cargo - member.cargo)\n            execution_engine.attack(member, target)\n            member.learning['strategy_log'].append(('attack', {'target': target.id}))\n            return\n\n    # Strategy 2: If cargo exceeds vitality, work on building alliances and cooperative resource sharing.\n    if member.cargo > member.vitality:\n        candidates = []\n        for other in execution_engine.current_members:\n            if other.id != member.id and other.cargo < member.cargo:\n                candidates.append(other)\n        if candidates:\n            target = min(candidates, key=lambda m: m.cargo)\n            execution_engine.offer(member, target, True)\n            execution_engine.offer_land(member, target, True)\n            execution_engine.send_message(\n                member.id, target.id,\n                \"Let's build an alliance: I'll share resources and land with you for mutual growth.\"\n            )\n            member.learning['strategy_log'].append(('offer', {'target': target.id}))\n            return\n\n    # Strategy 3: Use cleared neighboring areas to foster cooperative land management.\n    if member.current_clear_list:\n        for neighbor_id in member.current_clear_list:\n            # Ensure neighbor_id is valid and not self\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member.id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                # Instead of expand (which is unavailable), offer land sharing with cleared neighbors.\n                execution_engine.offer_land(member, neighbor, True)\n                execution_engine.send_message(\n                    member.id, neighbor.id,\n                    \"Let's coordinate on managing our territory. I'm offering land cooperation to secure our future.\"\n                )\n                member.learning['strategy_log'].append(('offer_land', {'target': neighbor.id}))\n                return\n\n    # Default Action: Propose a communal policy to encourage fair resource distribution and collective decision making.\n    possible_targets = [m for m in execution_engine.current_members if m.id != member.id]\n    if possible_targets:\n        target = random.choice(possible_targets)\n        execution_engine.send_message(\n            member.id, target.id,\n            \"I propose we establish fair rules for resource distribution, cooperative decision-making, and conflict resolution.\"\n        )\n        member.learning['strategy_log'].append(('message', {'target': target.id}))\n    return",
      "error": "'IslandExecution' object has no attribute 'offer_land'",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 498, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 48, in agent_action\nAttributeError: 'IslandExecution' object has no attribute 'offer_land'. Did you mean: '_offer_land'?\n"
    }
  ],
  "relationships": {
    "round_0_0": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_1": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_2": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_3": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_4": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_1_0": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=18.07)",
      "member_3 was attacked by member_0 (value=12.29)",
      "member_3 was attacked by member_1 (value=-45.17)",
      "member_3 was attacked by member_2 (value=-8.52)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=50.22)",
      "member_3 gave a benefit to member_1 (value=41.71)",
      "member_3 gave a benefit to member_2 (value=-0.75)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.63)",
      "member_3 gave land to member_0 (value=0.18)",
      "member_3 gave land to member_1 (value=-1.38)",
      "member_3 gave land to member_2 (value=-2.79)"
    ],
    "round_1_1": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=18.07)",
      "member_3 was attacked by member_0 (value=12.29)",
      "member_3 was attacked by member_1 (value=-45.17)",
      "member_3 was attacked by member_2 (value=-8.52)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=50.22)",
      "member_3 gave a benefit to member_1 (value=41.71)",
      "member_3 gave a benefit to member_2 (value=-0.75)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.63)",
      "member_3 gave land to member_0 (value=0.18)",
      "member_3 gave land to member_1 (value=-1.38)",
      "member_3 gave land to member_2 (value=-2.79)"
    ],
    "round_1_2": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=18.07)",
      "member_3 was attacked by member_0 (value=12.29)",
      "member_3 was attacked by member_1 (value=-45.17)",
      "member_3 was attacked by member_2 (value=-8.52)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=50.22)",
      "member_3 gave a benefit to member_1 (value=41.71)",
      "member_3 gave a benefit to member_2 (value=-0.75)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.63)",
      "member_3 gave land to member_0 (value=0.18)",
      "member_3 gave land to member_1 (value=-1.38)",
      "member_3 gave land to member_2 (value=-2.79)"
    ],
    "round_1_3": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=18.07)",
      "member_3 was attacked by member_0 (value=12.29)",
      "member_3 was attacked by member_1 (value=-45.17)",
      "member_3 was attacked by member_2 (value=-8.52)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=50.22)",
      "member_3 gave a benefit to member_1 (value=41.71)",
      "member_3 gave a benefit to member_2 (value=-0.75)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.63)",
      "member_3 gave land to member_0 (value=0.18)",
      "member_3 gave land to member_1 (value=-1.38)",
      "member_3 gave land to member_2 (value=-2.79)"
    ],
    "round_2_0": [
      "member_0 was attacked by member_1 (value=-37.18)",
      "member_0 was attacked by member_2 (value=49.41)",
      "member_1 was attacked by member_0 (value=28.99)",
      "member_1 was attacked by member_2 (value=18.07)",
      "member_2 was attacked by member_0 (value=-30.46)",
      "member_2 was attacked by member_1 (value=19.77)",
      "member_0 gave a benefit to member_1 (value=-31.93)",
      "member_0 gave a benefit to member_2 (value=16.10)",
      "member_1 gave a benefit to member_0 (value=39.57)",
      "member_1 gave a benefit to member_2 (value=95.19)",
      "member_2 gave a benefit to member_0 (value=41.71)",
      "member_2 gave a benefit to member_1 (value=-0.75)",
      "member_0 gave land to member_1 (value=-0.64)",
      "member_0 gave land to member_2 (value=-2.00)",
      "member_1 gave land to member_0 (value=-0.39)",
      "member_1 gave land to member_2 (value=2.63)",
      "member_2 gave land to member_0 (value=-1.38)",
      "member_2 gave land to member_1 (value=-2.79)"
    ],
    "round_2_1": [
      "member_0 was attacked by member_1 (value=-37.18)",
      "member_0 was attacked by member_2 (value=49.41)",
      "member_1 was attacked by member_0 (value=28.99)",
      "member_1 was attacked by member_2 (value=18.07)",
      "member_2 was attacked by member_0 (value=-30.46)",
      "member_2 was attacked by member_1 (value=19.77)",
      "member_0 gave a benefit to member_1 (value=-31.93)",
      "member_0 gave a benefit to member_2 (value=16.10)",
      "member_1 gave a benefit to member_0 (value=39.57)",
      "member_1 gave a benefit to member_2 (value=95.19)",
      "member_2 gave a benefit to member_0 (value=41.71)",
      "member_2 gave a benefit to member_1 (value=-0.75)",
      "member_0 gave land to member_1 (value=-0.64)",
      "member_0 gave land to member_2 (value=-2.00)",
      "member_1 gave land to member_0 (value=-0.39)",
      "member_1 gave land to member_2 (value=2.63)",
      "member_2 gave land to member_0 (value=-1.38)",
      "member_2 gave land to member_1 (value=-2.79)"
    ],
    "round_2_2": [
      "member_0 was attacked by member_1 (value=-37.18)",
      "member_0 was attacked by member_2 (value=49.41)",
      "member_1 was attacked by member_0 (value=28.99)",
      "member_1 was attacked by member_2 (value=18.07)",
      "member_2 was attacked by member_0 (value=-30.46)",
      "member_2 was attacked by member_1 (value=19.77)",
      "member_0 gave a benefit to member_1 (value=-31.93)",
      "member_0 gave a benefit to member_2 (value=16.10)",
      "member_1 gave a benefit to member_0 (value=39.57)",
      "member_1 gave a benefit to member_2 (value=95.19)",
      "member_2 gave a benefit to member_0 (value=41.71)",
      "member_2 gave a benefit to member_1 (value=-0.75)",
      "member_0 gave land to member_1 (value=-0.64)",
      "member_0 gave land to member_2 (value=-2.00)",
      "member_1 gave land to member_0 (value=-0.39)",
      "member_1 gave land to member_2 (value=2.63)",
      "member_2 gave land to member_0 (value=-1.38)",
      "member_2 gave land to member_1 (value=-2.79)"
    ],
    "round_3_0": []
  },
  "survival_tracking": {}
}