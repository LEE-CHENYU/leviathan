{
  "rounds": [
    {
      "timestamp": "2025-02-15T15:52:22.134469",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy Step 1: If our cargo is low relative to our vitality, try to acquire resources.\n    # We attack one member (if found) who has more cargo than us.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break  # Attack at most one target\n\n    # Strategy Step 2: If our productivity is high and we have identified clear adjacent neighbors,\n    # attempt to expand our territory by engaging with one neighbor.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            # Validate that neighbor_index is within the list bounds and is not self.\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                execution_engine.expand(me, neighbor)\n                break  # Expand with one neighbor per round\n\n    # Strategy Step 3: Build alliances via cooperative resource sharing.\n    # Offer resources and land (if available) to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # Only offer land if 'land_num' attribute exists and indicates available land.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy Step 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land (verify attribute existence).\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            potential = execution_engine.current_members[i]\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # Bear offspring with only one partner per round\n\n    # Strategy Step 5: Communication.\n    # Broadcast a cooperative message to all other members to encourage mutual support and civilization-building.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        execution_engine.send_message(me.id, recipient.id,\n                                      \"Let's work together to build strong alliances and usher in prosperity for all!\")",
          "old_stats": {
            "vitality": 73.85382847590404,
            "cargo": 33.660796801031104,
            "survival_chance": 116.8367882719584
          },
          "new_stats": {
            "vitality": 73.85382847590404,
            "cargo": 33.660796801031104,
            "survival_chance": 116.8367882719584
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists in the current membership list.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Log our starting state (this can help in debugging the agent's behavior).\n    # print(\"Agent {} starting turn: cargo={}, vitality={}, territory={}\".format(\n    #     me.id, me.cargo, me.vitality, len(me.current_clear_list)))\n\n    # Phase 1: Defensive Tactical Response.\n    # I'm cautious: if my resources are borderline compared to my vitality,\n    # I take pre-emptive actions against opponents who seem dangerously well-resourced.\n    if me.cargo < me.vitality * 0.7:\n        for i, other in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            # If opponent's cargo exceeds mine by at least 20%, consider them a threat.\n            if other.cargo > me.cargo * 1.2:\n                # Execute an attack to lower their advantage.\n                execution_engine.attack(me, other)\n                # Optionally log the attack decision.\n                # print(\"Agent {} attacks Agent {}.\".format(me.id, other.id))\n\n    # Phase 2: Cooperative Outreach.\n    # When I'm flush with resources (cargo exceeding vitality), I seek to form alliances.\n    if me.cargo > me.vitality:\n        for i, other in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            # I favor others whose vitality is not too far off from mine: a sign of stability.\n            if other.vitality > me.vitality * 0.8:\n                # Partnering with them can increase our collective survivability.\n                execution_engine.offer(me, other, True)\n                # print(\"Agent {} offered help to Agent {}.\".format(me.id, other.id))\n\n    # Phase 3: Strategic Reproduction for Long-Term Growth.\n    # Reproduction is attempted if I have clear territory (non-empty clear list)\n    # and robust resources relative to vitality.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        # I assess my available neighboring territories (neighbors I have cleared).\n        for neighbor_id in me.current_clear_list:\n            # Check for valid neighbor index and avoid self-referential cases.\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                # I also require that the prospective partner controls some territory.\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    # print(\"Agent {} reproduces with Agent {}.\".format(me.id, partner.id))\n                    break  # Only generate one offspring per cycle.\n\n    # Phase 4: Calculated Territorial Expansion.\n    # I seek to expand my holdings only against neighbors that seem less efficient.\n    # This is part of my long-term strategy to secure resources and defensive perimeters.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # If neighbor\u2019s overall productivity is below mine, it's a viable target.\n            if neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, neighbor)\n                # print(\"Agent {} expands into Agent {}'s territory.\".format(me.id, neighbor.id))\n                break  # Limit expansion to one action per round.\n\n    # Phase 5: Communication \u2013 Strengthening Collective Ties.\n    # Regardless of the tactical decisions, I broadcast a strategic message.\n    # This message is intended to foster cooperation while indicating that mutual respect is key.\n    message = (\n        \"Agent {} here. In these challenging times, \"\n        \"cooperation is our strongest asset. \"\n        \"Together we stand, divided we fall.\"\n    ).format(me.id)\n    for i, recipient in enumerate(execution_engine.current_members):\n        if i == member_id:\n            continue\n        execution_engine.send_message(me.id, recipient.id, message)\n        # print(\"Agent {} sent message to Agent {}.\".format(me.id, recipient.id))\n\n    # End of my actions for this turn.\n    return",
          "old_stats": {
            "vitality": 18.332577680505043,
            "cargo": 22.547092118644322,
            "survival_chance": 6.616954880911457
          },
          "new_stats": {
            "vitality": 18.332577680505043,
            "cargo": 11.266491395637424,
            "survival_chance": -4.663645842095445
          },
          "performance_change": -11.280600723006902,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Step 1: Broadcast a tailored cooperative message to promote unity and shared purpose.\n    # This message emphasizes both mutual prosperity and the strength in unity.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"Together we can innovate, overcome adversity, and ensure that every member prospers.\")\n\n    # Step 2: Emergency resource management.\n    # If our cargo is too low relative to our vitality, we must secure resources.\n    # We assess all opponents and target the one with significantly higher cargo,\n    # prioritizing candidates with the greatest difference.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Step 3: Reproduction strategy for long-term prosperity.\n    # With available territory and sufficient resources, seek to form an alliance for reproduction.\n    # We choose a candidate who is resourceful enough (cargo > 30) yet ensuring balanced genetic influence.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > 30:\n                execution_engine.bear(me, candidate)\n                break\n\n    # Step 4: Mutual support and strategic territorial expansion.\n    # We interact with all other agents with two integrated approaches:\n    # (a) If a candidate holds fewer resources, we offer support to boost collective capability.\n    # (b) If clear territory exists and our overall productivity is superior,\n    #     we initiate expansion to secure more assets.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        # Offer support if candidate's cargo is lower, nurturing cooperation.\n        if candidate.cargo < me.cargo:\n            execution_engine.offer(me, candidate, True)\n\n        # Expand territory if conditions are favorable.\n        if len(me.current_clear_list) > 0 and candidate.overall_productivity < me.overall_productivity:\n            execution_engine.expand(me, candidate)\n\n    # Step 5: Defensive countermeasures based on historical aggression.\n    # Using the 'victim' relationship matrix, we identify any candidate toward whom past aggression is high.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Ensure the indices are in the expected bounds.\n            if member_id < len(matrix_victim) and idx < len(matrix_victim[0]):\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Step 6: Survival-centric adaptation.\n    # When vitality is low, immediate defense is paramount.\n    # Identify a candidate with lower overall productivity and offer land for a defensive alliance.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, True)\n                break\n\n    # Step 7: Strategic forward planning.\n    # As an added measure, we can gauge our environment to adjust our risk thresholds.\n    # For instance, if our cargo is vastly superior (e.g., more than 150% of an opponent's),\n    # we might use this advantage to execute pre-emptive expansion or defensive consolidation.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        if me.cargo > candidate.cargo * 1.5:\n            # Pre-emptively secure territory if possible.\n            if len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Alternatively, offer additional resources to solidify alliances.\n            else:\n                execution_engine.offer(me, candidate, True)\n\n    # Final Note:\n    # This implementation is an adaptive blend of aggressive resource recovery,\n    # cooperative alliance building, and strategic expansion.\n    # The agent tailors actions not solely based on immediate comparisons,\n    # but with a long-term view of survival and prosperity\u2014balancing self-interest with collective strength.\n    # Future improvements could integrate predictive modeling and dynamic risk analysis to further\n    # enhance decision making in ever-changing environments.\n\n# End of agent_action implementation.",
          "old_stats": {
            "vitality": 42.15604281108604,
            "cargo": 36.789414164557066,
            "survival_chance": 57.7935159278627
          },
          "new_stats": {
            "vitality": 42.15604281108604,
            "cargo": 13.42504555811643,
            "survival_chance": 34.42914732142206
          },
          "performance_change": -23.364368606440642,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure the member exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Customize thresholds based on our adaptive risk assessment.\n    # We consider our own temperament: if my cargo is less than 1/3 of my vitality,\n    # I feel exposed and might look to bolster my resource situation.\n    resource_ratio_threshold = 0.33\n    low_vitality_threshold = 50.0  # I become cautious when vitality drops below this.\n    high_productivity_threshold = 15.0  # Indicates that I'm capable of territorial expansion.\n\n    # Immediate tactical decision: if resources are low relative to vitality,\n    # then identify an opponent with a clearly stronger cargo and launch an attack.\n    if me.cargo < me.vitality * resource_ratio_threshold:\n        candidate = None\n        best_diff = -1\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            diff = opponent.cargo - me.cargo\n            if diff > best_diff:\n                best_diff = diff\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Warning: my cargo reserves are alarmingly low\u2014initiating attack to reclaim resources.\")\n\n    # Long-term strategic planning and cooperative outreach.\n    for idx in range(total_members):\n        # Skip ourselves.\n        if idx == member_id:\n            continue\n        target = execution_engine.current_members[idx]\n\n        # Begin with an invitation to cooperate in building a resilient society.\n        execution_engine.send_message(member_id, target.id,\n            \"Greetings! Let\u2019s pool our strengths and build a balanced community.\")\n\n        # When my vitality is low and your vitality is high, a tactical support offer is in order.\n        if me.vitality < low_vitality_threshold and target.vitality > low_vitality_threshold:\n            execution_engine.offer(target, me, True)\n            execution_engine.send_message(member_id, target.id,\n                \"I\u2019m running low on vitality\u2014could you support me to keep our dynamics stable?\")\n\n        # Should you have a surplus of cargo relative to me,\n        # I suggest we consider a resource-sharing alliance that benefits both.\n        if target.cargo > me.cargo:\n            execution_engine.send_message(member_id, target.id,\n                \"Your resources are notably abundant compared to mine\u2014perhaps we can form a profitable alliance.\")\n\n        # Strategic territory expansion: if I boast high productivity and you have unclaimed land,\n        # we can jointly secure a better position.\n        if me.overall_productivity > high_productivity_threshold and len(target.current_clear_list) > 0:\n            execution_engine.expand(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"My capabilities for growth are high; let\u2019s expand our territories together for a competitive edge.\")\n\n        # Reproductive strategy to ensure long-term survival:\n        # Both of us having claimable land makes a union of our strengths beneficial.\n        if len(me.current_clear_list) > 0 and len(target.current_clear_list) > 0:\n            execution_engine.bear(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"Combining our genetic and territorial strengths could secure our future prosperity.\")\n\n    # Broadcast a community-wide message to reinforce a collective mindset.\n    for idx in range(total_members):\n        if idx != member_id:\n            execution_engine.send_message(member_id, execution_engine.current_members[idx].id,\n                \"United collaboration today paves the way for a thriving future tomorrow.\")\n\n    # Implement adaptive survival management using a simple Q-learning strategy.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Discretize the state by grouping vitality and cargo in intervals of 25.\n    state = (int(me.vitality // 25), int(me.cargo // 25))\n    possible_actions = ['attack', 'hide', 'steal']\n    # Choose the action with the highest estimated survival value.\n    best_action = max(possible_actions, key=lambda act: me.survival_q.get((state, act), 0))\n\n    if best_action == 'attack':\n        candidate = None\n        best_metric = -1\n        # Evaluate opponents using a combined metric: cargo plus a fraction of their vitality.\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            metric = opponent.cargo + 0.5 * opponent.vitality\n            if metric > best_metric:\n                best_metric = metric\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Engaging target based on strategic attack protocol to boost my resource reserves.\")\n        me.survival_q[(state, 'attack')] += me.vitality * 0.2\n\n    elif best_action == 'steal':\n        candidate = None\n        highest_cargo = -1\n        # Identify the opponent with the maximum cargo for a precise resource appropriation.\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if opponent.cargo > highest_cargo:\n                highest_cargo = opponent.cargo\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Initiating a calculated maneuver to appropriate resources from a better-stocked target.\")\n        me.survival_q[(state, 'steal')] += me.vitality * 0.1\n\n    elif best_action == 'hide':\n        # A defensive strategy: by concealing actions, I conserve resources for future operations.\n        execution_engine.send_message(member_id, me.id,\n            \"Entering a defensive mode to restore strength and await a more opportune moment.\")\n        me.survival_q[(state, 'hide')] += 0.0\n\n    return",
          "old_stats": {
            "vitality": 18.47747982181767,
            "cargo": 40.186552045152894,
            "survival_chance": 38.8426382682447
          },
          "new_stats": {
            "vitality": 18.47747982181767,
            "cargo": 41.94547296730831,
            "survival_chance": 40.953343374831206
          },
          "performance_change": 2.110705106586508,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [
            "From member_1: Agent 1 here. In these challenging times, cooperation is our strongest asset. Together we stand, divided we fall.",
            "From member_3: Greetings! Let\u2019s pool our strengths and build a balanced community.",
            "From member_3: United collaboration today paves the way for a thriving future tomorrow."
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_1: Agent 1 here. In these challenging times, cooperation is our strongest asset. Together we stand, divided we fall.",
            "From member_2: Together we can innovate, overcome adversity, and ensure that every member prospers."
          ],
          "sent": []
        }
      }
    },
    {
      "timestamp": "2025-02-15T15:59:45.454069",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate that member_id is within range.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: Immediate Survival via Resource Optimization and Threat Neutralization\n    # If cargo is low compared to vitality, identify a target with higher cargo and attack.\n    if me.cargo < 0.5 * me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if other.cargo > me.cargo:\n                # Attack to neutralize potential threats while balancing resource disparity.\n                execution_engine.attack(me, other)\n                break\n\n    # Strategy 2: Territorial Expansion for Long-Term Prosperity\n    # If overall productivity is high and there is at least one clear territory, try to expand our reach.\n    if hasattr(me, 'current_clear_list') and me.current_clear_list and me.overall_productivity > 8.0:\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                neighbor = execution_engine.current_members[neighbor_idx]\n                try:\n                    # Attempt to expand territory using the expand method which takes two arguments.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # If expansion fails due to argument mismatch, offer land instead.\n                    execution_engine.offer_land(me, neighbor, True)\n                break\n\n    # Strategy 3: Cooperation for Mutual Benefit\n    # Forge alliances with members who have lower vitality to build a cooperative network.\n    for idx, partner in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # Offer resources if the partner shows signs of vulnerability relative to our own vitality.\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # If the agent has land (territory), extend the offer of land to bolster the alliance.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for Sustainable Growth\n    # Engage in reproductive actions if both agents have sufficient territory and vitality.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for idx, potential in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Only consider partners with territory.\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break\n\n    # Strategy 5: Governance and Communication for a Collective Future\n    # Broadcast a message to all other agents inviting collaboration and the establishment of progressive social norms.\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        message = (\"Let\u2019s join forces to share resources, expand our territories cooperatively, \"\n                   \"and build governance systems that secure both our survival and long-term prosperity.\")\n        execution_engine.send_message(me.id, recipient.id, message)",
          "old_stats": {
            "vitality": 21.1667091492471,
            "cargo": 0.0,
            "survival_chance": 22.744874485036277
          },
          "new_stats": {
            "vitality": 21.1667091492471,
            "cargo": 0.0,
            "survival_chance": 22.744874485036277
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Retrieve the current member (self) from the engine by index.\n    if member_id >= len(execution_engine.current_members):\n        return  # invalid member_id, do nothing\n    me = execution_engine.current_members[member_id]\n\n    # Ensure we have a survival Q-table for adaptive decision making.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Determine state based on vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n\n    # Define possible actions.\n    actions = ['attack', 'expand', 'bear', 'offer']\n    # Pick an action based on the current Q value (default to 'offer' if tied).\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Helper: send alliance messages to all other valid members.\n    def broadcast_alliance_message():\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id or other.id == me.id:\n                continue\n            # Ensure valid index by checking current_members length.\n            if idx < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, other.id, \"Let's cooperate for mutual growth.\")\n\n    # Action: if cargo is critically low relative to vitality, try to attack a member with higher cargo.\n    if me.cargo < me.vitality * 0.5:\n        for idx, other in enumerate(execution_engine.current_members):\n            if other.id == me.id:\n                continue  # Never target self.\n            # Check that the member exists in the current list.\n            if idx < len(execution_engine.current_members) and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Update Q-table: small reward for taking an aggressive action when in distress.\n                me.survival_q[(state, 'attack')] += me.vitality * 0.05\n                return\n\n    # Action: if we have clear land (indicative by current_clear_list length > 0) and enough cargo, consider reproduction.\n    if len(me.current_clear_list) > 0 and me.cargo > 20:\n        partner = None\n        # Choose a partner based on relatively high vitality and overall productivity.\n        for idx, potential in enumerate(execution_engine.current_members):\n            if potential.id == me.id:\n                continue  # avoid self-targeting\n            if potential.vitality >= me.vitality * 0.8 and potential.overall_productivity >= 0:\n                partner = potential\n                break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n            me.survival_q[(state, 'bear')] += 5.0\n            return\n\n    # Action: if we have clear land available, use it to expand territory.\n    if len(me.current_clear_list) > 0:\n        # We'll target the first available member from the current_clear_list if valid.\n        target_idx = me.current_clear_list[0]\n        if target_idx < len(execution_engine.current_members):\n            target = execution_engine.current_members[target_idx]\n            if target.id != me.id:\n                execution_engine.expand(me, target)\n                me.survival_q[(state, 'expand')] += 2.0\n                return\n\n    # Action: If our cargo is moderately high compared to vitality, make cooperative offers.\n    if me.cargo > me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if other.id == me.id:\n                continue\n            if idx < len(execution_engine.current_members):\n                execution_engine.offer(me, other, True)\n        me.survival_q[(state, 'offer')] += 1.0\n\n    # Finally, broadcast an alliance message to encourage cooperative behavior.\n    broadcast_alliance_message()",
          "old_stats": {
            "vitality": 55.58108836920247,
            "cargo": 0.0,
            "survival_chance": 45.954756999796736
          },
          "new_stats": {
            "vitality": 55.58108836920247,
            "cargo": 0.0,
            "survival_chance": 45.954756999796736
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Immediate tactical action: if cargo is low relative to vitality, try to recover resources via an attack.\n    # Choose an opponent (other than self) having higher cargo.\n    if me.cargo < 10:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            # Basic safeguard: only consider opponents with some vitality.\n            if opponent.vitality > 0 and opponent.cargo > me.cargo:\n                # Attack opponent to try and gain resources.\n                execution_engine.attack(me, opponent)\n                break\n\n    # Long-term strategic move: if we control clear territory, we can plan expansion and cooperative reproduction.\n    if me.current_clear_list:\n        # Attempt reproduction to secure long-term survival.\n        # Look for a potential partner (ally) with a healthy vitality and decent productivity.\n        partner_found = False\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            partner = execution_engine.current_members[idx]\n            if partner.vitality > 30 and partner.overall_productivity > 40:\n                # Since reproduction requires available land, we call bear() only if clear territory exists.\n                execution_engine.bear(me, partner)\n                partner_found = True\n                break\n        # If no suitable partner is found, send a cooperative message to encourage alliance-building.\n        if not partner_found:\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue\n                potential_ally = execution_engine.current_members[idx]\n                execution_engine.send_message(me.id, potential_ally.id, \"Let's consider future collaboration for mutual prosperity.\")\n\n    # Defensive strategy: if our vitality is low, use available land to forge better alliances.\n    if me.vitality < 20 and me.current_clear_list:\n        # Offer land support to a stable agent to build a protective alliance.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            ally = execution_engine.current_members[idx]\n            if ally.overall_productivity > 50 and ally.vitality > 25:\n                # Check for clear territory before offering land.\n                execution_engine.offer_land(me, ally, True)\n                break\n\n    # Territorial expansion: if we have available clear regions, try expanding our territory.\n    if me.current_clear_list:\n        # Identify an opponent (other than self) that might have fewer clear territories than we do.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if len(opponent.current_clear_list) < len(me.current_clear_list):\n                execution_engine.expand(me, opponent)\n                break\n\n    # Communication for collective decision-making:\n    # Broadcast a message to all other members encouraging a cooperative approach\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            recipient = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, recipient.id,\n                \"Cooperation and balanced growth are key; let's work together for a sustainable future!\")",
          "old_stats": {
            "vitality": 45.314487560216655,
            "cargo": 0.0,
            "survival_chance": 51.576471267268516
          },
          "new_stats": {
            "vitality": 45.314487560216655,
            "cargo": 0.0,
            "survival_chance": 51.576471267268516
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Get our own member object safely (assuming member_id is valid)\n    if member_id >= len(execution_engine.current_members):\n        return  # invalid member_id, do nothing\n    me = execution_engine.current_members[member_id]\n\n    # Parse relationships summary (for internal use, may help decide actions)\n    try:\n        relationships = execution_engine.parse_relationship_matrix()\n    except Exception:\n        relationships = {}\n\n    num_members = len(execution_engine.current_members)\n    # Build a list of candidate indices that are not ourselves\n    candidate_ids = [i for i in range(num_members) if i != member_id]\n\n    # ---------------------------\n    # 1. Territorial expansion:\n    # If we have available clear land and our overall productivity is robust,\n    # we try to expand our territory.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n        if hasattr(me, \"overall_productivity\") and me.overall_productivity > 20:\n            # Use our own available land to attempt expansion.\n            execution_engine.expand(me, me)\n            return\n\n    # ---------------------------\n    # 2. Cooperative reproductive strategy:\n    # If we have available clear land and are of reproductive age,\n    # we look for a partner who also has available land.\n    # Note: we check reproductive age threshold (set arbitrarily at 5) to avoid premature reproduction.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list and hasattr(me, \"age\") and me.age >= 5:\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if (hasattr(partner, \"current_clear_list\") and partner.current_clear_list and\n                    hasattr(partner, \"age\") and partner.age >= 5):\n                    execution_engine.bear(me, partner)\n                    return\n\n    # ---------------------------\n    # 3. Cooperative resource sharing:\n    # If we see members with lower vitality than ourselves,\n    # we offer them resources as a gesture of goodwill (building social capital).\n    # ---------------------------\n    if hasattr(me, \"vitality\"):\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, \"vitality\") and partner.vitality < me.vitality:\n                    execution_engine.offer(me, partner, True)\n                    return\n\n    # ---------------------------\n    # 4. Defensive aggression:\n    # Check if any opponent has previously attacked us.\n    # The relationship matrix 'victim' is assumed to record attack counts:\n    #   matrix[member_id, attacker_id] > 0 means attacker attacked us.\n    # If such hostility is noticed, we counterattack.\n    # ---------------------------\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for j in candidate_ids:\n            # Ensure valid indexing in the relationship matrix\n            try:\n                if victim_matrix[member_id, j] > 0:\n                    # Before attacking, double-check that the target exists.\n                    if j < num_members:\n                        target = execution_engine.current_members[j]\n                        execution_engine.attack(me, target)\n                        return\n            except Exception:\n                continue\n\n    # ---------------------------\n    # 5. Propose a long\u2010term cooperative modification:\n    # To promote collective governance and stability, propose establishing a council.\n    # If the method is not available, simply proceed.\n    # ---------------------------\n    try:\n        execution_engine.propose_modification(\"Council\", {\"description\": \"Establish a council for cooperative governance and dispute resolution.\"})\n    except Exception:\n        pass\n\n    # ---------------------------\n    # 6. Cooperative land offering:\n    # If we have available land yet encounter partners lacking clear territory,\n    # we offer them some land in a spirit of alliance formation.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if not (hasattr(partner, \"current_clear_list\") and partner.current_clear_list):\n                    execution_engine.offer_land(me, partner, True)\n                    return\n\n    # ---------------------------\n    # 7. Fallback action:\n    # If no other tactical or cooperative action applies,\n    # we can simply send a friendly message to a randomly chosen peer.\n    # (Here we choose the first valid candidate for demonstration.)\n    # ---------------------------\n    if candidate_ids:\n        try:\n            target = execution_engine.current_members[candidate_ids[0]]\n            execution_engine.send_message(me, target, \"Let's work together for mutual benefit.\")\n        except Exception:\n            pass\n\n    return",
          "old_stats": {
            "vitality": 39.54024074627975,
            "cargo": 0.0,
            "survival_chance": 50.450860472036275
          },
          "new_stats": {
            "vitality": 39.54024074627975,
            "cargo": 0.0,
            "survival_chance": 50.450860472036275
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [
            "From member_0: Let\u2019s join forces to share resources, expand our territories cooperatively, and build governance systems that secure both our survival and long-term prosperity.",
            "From member_3: Cooperation and balanced growth are key; let's work together for a sustainable future!"
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_0: Let\u2019s join forces to share resources, expand our territories cooperatively, and build governance systems that secure both our survival and long-term prosperity.",
            "From member_2: Let's cooperate for mutual growth.",
            "From member_4: Cooperation leads to mutual prosperity; let\u2019s build balanced governance.",
            "From member_2: Hello from member 2: In these challenging times, let\u2019s join forces to optimize resources, expand our domain wisely, and build resilient governance structures for the common good.",
            "From member_4: Alliance proposal: Let's consolidate resources and land to secure our collective prosperity and survival."
          ],
          "sent": []
        }
      }
    },
    {
      "timestamp": "2025-02-15T16:05:11.549565",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    try:\n        # Verify the member_id is valid\n        if member_id < 0 or member_id >= len(execution_engine.current_members):\n            return\n        my_member = execution_engine.current_members[member_id]\n\n        # Basic self parameters\n        my_vitality = my_member.vitality\n        my_cargo = my_member.cargo\n\n        # Check if self has land; note: attribute \"land_num\" is optional so check exists.\n        my_has_land = hasattr(my_member, \"land_num\") and my_member.land_num > 0\n\n        # ------------------------------\n        # Survival-First: if vitality is critically low, request assistance.\n        # ------------------------------\n        if my_vitality < 15:\n            # Send a help message and offer a minimal resource offer to provoke cooperation.\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                other = execution_engine.current_members[i]\n                # Use safe index access and send a message if they exist.\n                execution_engine.send_message(my_member.id, other.id,\n                    \"I'm in need of assistance due to low vitality. Any support is appreciated.\")\n                # Also, offer a minimal resource gift if possible.\n                execution_engine.offer(my_member, other, True)\n            # End action early to focus on survival.\n            return\n\n        # ------------------------------\n        # Immediate Tactical Move: If cargo is low relative to vitality, try to gain resources.\n        # If our cargo is less than 30% of our vitality, consider attacking a target with surplus cargo.\n        # ------------------------------\n        if my_cargo < 0.30 * my_vitality:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                other = execution_engine.current_members[i]\n                # Ensure valid index and check if other has a significantly higher cargo\n                if other.cargo > 1.5 * my_cargo:\n                    execution_engine.attack(my_member, other)\n                    return  # Execute one aggressive move per turn\n\n        # ------------------------------\n        # Long-term Reproduction/Expansion:\n        # Use reproduction if both self and a partner have land and our resource levels are good.\n        # ------------------------------\n        if my_has_land and my_cargo > 0.5 * my_vitality:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, \"land_num\") and partner.land_num > 0 and partner.vitality > 20:\n                    # Initiate reproduction (bear) which requires both partners to have land.\n                    execution_engine.bear(my_member, partner)\n                    return\n\n        # ------------------------------\n        # Territorial Expansion:\n        # If cargo is substantially high compared to vitality then consider expanding territorial control.\n        # ------------------------------\n        if my_cargo > 2 * my_vitality:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                # Target a potential expansion area by interacting with others (even if symbolic)\n                potential = execution_engine.current_members[i]\n                execution_engine.expand(my_member, potential)\n            return\n\n        # ------------------------------\n        # Cooperative/Alliance Building:\n        # Offer land or resources to members who seem capable and may help stabilize collective prosperity.\n        # ------------------------------\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Look for members with robust vitality and decent resource management\n            if other.vitality > my_vitality and other.cargo > 0.5 * other.vitality:\n                execution_engine.offer_land(my_member, other, True)\n                execution_engine.send_message(my_member.id, other.id,\n                    \"Let's pool our resources and lands for mutual growth and resilience.\")\n                break  # One offer is enough this turn\n\n        # ------------------------------\n        # Governance & Strategic Proposals:\n        # Propose a modification that fosters a community council for resource allocation and conflict resolution.\n        # This balances individual gains with collective prosperity.\n        # ------------------------------\n        mod_code = \"Establish a community council for coordinated resource allocation and conflict mediation.\"\n        ratification_conditions = {\n            \"type\": \"vote\",\n            \"threshold\": 0.7  # Majority vote required to ensure solid backing\n        }\n        execution_engine.propose_modification(mod_code, ratification_conditions)\n\n    except Exception as e:\n        # In case of unexpected errors, safely exit the function.\n        return",
          "old_stats": {
            "vitality": 55.58108836920247,
            "cargo": 0.0,
            "survival_chance": 41.301738916986466
          },
          "new_stats": {
            "vitality": 55.58108836920247,
            "cargo": 0.0,
            "survival_chance": 41.301738916986466
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate self index first\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # -------------------------------\n    # 1. Emergency Attack for Resource Gain\n    # If my cargo is below half my vitality, try to attack a member with higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for idx in range(len(execution_engine.current_members)):\n            # Verify index and avoid targeting self.\n            if idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                if other.id != me.id and other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n                    break  # Attack only one target\n\n    # -------------------------------\n    # 2. Reproduction: Ensure both parties have land before calling bear.\n    # Only attempt reproduction if I have a positive land attribute and sufficient cargo.\n    if hasattr(me, \"land_num\") and me.land_num > 0 and me.cargo > 20:\n        for idx in range(len(execution_engine.current_members)):\n            if idx < len(execution_engine.current_members):\n                partner = execution_engine.current_members[idx]\n                if partner.id != me.id and hasattr(partner, \"land_num\") and partner.land_num > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Only one reproduction per turn\n\n    # -------------------------------\n    # 3. Territorial Expansion:\n    # Use my list of cleared/adjacent indices to expand territory.\n    # The clear list is assumed to hold indices (IDs) of adjacent cells/members.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != me.id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            execution_engine.expand(me, neighbor)\n\n    # -------------------------------\n    # 4. Cooperative Alliance Messaging:\n    # Broadcast an invitation message to all other members to foster resource sharing and land cooperation.\n    for idx in range(len(execution_engine.current_members)):\n        if idx < len(execution_engine.current_members):\n            other = execution_engine.current_members[idx]\n            if other.id != me.id:\n                execution_engine.send_message(me.id, other.id,\n                    \"Alliance proposal: Let's pool resources and share lands to secure mutual long-term prosperity.\")\n\n    # -------------------------------\n    # 5. Land Offering:\n    # If I have a significant cargo reserve (indicating surplus), offer land to improve relationships.\n    if me.cargo > 50:\n        for idx in range(len(execution_engine.current_members)):\n            if idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                if other.id != me.id:\n                    execution_engine.offer_land(me, other, True)",
          "old_stats": {
            "vitality": 30.195943740854755,
            "cargo": 0.0,
            "survival_chance": 44.20951931233793
          },
          "new_stats": {
            "vitality": 30.195943740854755,
            "cargo": 0.0,
            "survival_chance": 44.20951931233793
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Obtain reference to self from the current members list by index.\n    me = execution_engine.current_members[member_id]\n\n    # ---------------------------------------------------------------------\n    # Immediate Tactical Action: Emergency Resource & Threat Response\n    # If cargo is less than half of vitality, seek an opponent with richer cargo.\n    if me.cargo < me.vitality * 0.5:\n        for opponent in execution_engine.current_members:\n            if opponent.id != me.id and opponent.cargo > me.cargo:\n                execution_engine.attack(me, opponent)\n                break\n\n    # ---------------------------------------------------------------------\n    # Cooperative Resource Reallocation: Offer resources to boost community resilience.\n    # Here we iterate over members; if a member has lower vitality, we offer them support.\n    for idx, other in enumerate(execution_engine.current_members):\n        if other.id != me.id:\n            # Safety check: ensure the other member has the vitality attribute.\n            if hasattr(other, 'vitality') and other.vitality < me.vitality:\n                execution_engine.offer(me, other, True)\n\n    # ---------------------------------------------------------------------\n    # Reproduction / Expansion Strategy: Use reproduction (bear) if conditions meet.\n    if hasattr(me, 'land_num') and me.land_num >= 1 and me.cargo > 100:\n        # Choose a candidate from the list based on valid criteria.\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if candidate.id != me.id:\n                # Validate candidate exists and meets basic conditions.\n                if candidate.age > 18 and candidate.vitality > 50:\n                    execution_engine.bear(me, candidate)\n                    break\n\n    # ---------------------------------------------------------------------\n    # Territorial Expansion: If I have clear territory and decent productivity, attempt expansion.\n    if me.current_clear_list and me.overall_productivity > 50:\n        # Use the clear list to attempt expansion with a partner (an arbitrary valid other member).\n        for loc in me.current_clear_list:\n            # For each clear area, try to expand with the first valid partner.\n            for idx, partner in enumerate(execution_engine.current_members):\n                if partner.id != me.id and idx < len(execution_engine.current_members):\n                    execution_engine.expand(me, partner)\n                    break\n            break  # Only one expansion needed per turn.\n\n    # ---------------------------------------------------------------------\n    # Communication for Long-Term Cooperative Governance:\n    # Broadcast a message to promote cooperative proposals and collective welfare.\n    for idx, other in enumerate(execution_engine.current_members):\n        if other.id != me.id:\n            execution_engine.send_message(me.id, other.id, \"Cooperation leads to mutual prosperity; let\u2019s build balanced governance.\")\n\n    # ---------------------------------------------------------------------\n    # Proposal for Governance Modification:\n    # If my productivity and resource levels are high, propose a new judicial council module.\n    if me.overall_productivity > 75 and me.cargo > 150:\n        code_modification = \"\"\"\ndef council_decision(execution_engine):\n    for member in execution_engine.current_members:\n        if member.vitality < 40:\n            # Extend support to members in need to stabilize community conflicts.\n            execution_engine.offer(member, member, True)\n\"\"\"\n        ratification_condition = {\n            'type': 'vote',\n            'threshold': 0.6,\n            'resource': 'cargo',\n            'amount': 50,\n            'rounds': 3\n        }\n        execution_engine.propose_modification(member_id=me.id,\n                                              mod_type='judicial_council',\n                                              code=code_modification,\n                                              ratification_condition=ratification_condition)\n\n    # ---------------------------------------------------------------------\n    # Adaptive Survival Q-learning Component: Balance actions based on past outcomes.\n    # Initialize Q-values if this is the first iteration.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    # Define a simplified state space based on vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'offer', 'expand', 'hide']\n    # Choose the action with the highest Q-value; default to 0 if unseen.\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if best_action == 'attack':\n        # Look for an opponent with higher cargo than me and execute an attack.\n        for opponent in execution_engine.current_members:\n            if opponent.id != me.id and opponent.cargo > me.cargo:\n                execution_engine.attack(me, opponent)\n                me.survival_q[(state, 'attack')] += me.vitality * 0.1\n                break\n    elif best_action == 'offer':\n        # Identify a member with lower vitality and offer resources.\n        for other in execution_engine.current_members:\n            if other.id != me.id and hasattr(other, 'vitality') and other.vitality < me.vitality:\n                execution_engine.offer(me, other, True)\n                me.survival_q[(state, 'offer')] += 5\n                break\n    elif best_action == 'expand':\n        # Try expanding territorial control using a cooperative partner.\n        for idx, partner in enumerate(execution_engine.current_members):\n            if partner.id != me.id and me.overall_productivity > 50 and idx < len(execution_engine.current_members):\n                execution_engine.expand(me, partner)\n                me.survival_q[(state, 'expand')] += me.cargo * 0.05\n                break\n    elif best_action == 'hide':\n        # 'Hide' represents a passive move, preserving resources and waiting for better opportunities.\n        me.survival_q[(state, 'hide')] += 1\n\n    # End of the agent's action cycle.\n    return",
          "old_stats": {
            "vitality": 24.526188109170842,
            "cargo": 0.0,
            "survival_chance": 29.19906183045897
          },
          "new_stats": {
            "vitality": 24.526188109170842,
            "cargo": 0.0,
            "survival_chance": 29.19906183045897
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [
            "From member_3: Alliance proposal: Let's pool resources and share lands to secure mutual long-term prosperity.",
            "From member_4: Cooperation leads to mutual prosperity; let\u2019s build balanced governance."
          ],
          "sent": []
        }
      }
    },
    {
      "timestamp": "2025-02-15T16:12:24.836369",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    try:\n        # Validate that the member_id is within valid bounds.\n        if member_id < 0 or member_id >= len(execution_engine.current_members):\n            return\n        me = execution_engine.current_members[member_id]\n    except Exception:\n        return\n\n    # ---- Phase 1: Rapid Resource Recovery & Smart Defense ----\n    # When cargo is critically low relative to vitality, identify better-endowed opponents\n    # to engage and recover resources. We use a tighter threshold based on our own recent losses.\n    try:\n        # Dynamic recovery threshold: if cargo < 40% of vitality, trigger aggressive recovery.\n        if me.cargo < 0.4 * me.vitality:\n            for idx, target in enumerate(execution_engine.current_members):\n                if idx == member_id:\n                    continue  # Prevent self-targeting\n                try:\n                    # Target only those with significantly more resources and still alive.\n                    if target.cargo > me.cargo * 1.25 and target.vitality > 0:\n                        execution_engine.attack(me, target)\n                        # Log action for debugging in our simulation log (if available)\n                        if hasattr(execution_engine, \"log_action\"):\n                            execution_engine.log_action(\"Attack initiated by member {} on target {} for resource recovery\".format(me.id, target.id))\n                        break  # Only one attack per cycle permitted.\n                except Exception:\n                    continue\n    except Exception:\n        pass\n\n    # ---- Phase 2: Strategic Resource Sharing & Alliance Building ----\n    # Extend a cooperative offer (resources and territory) to weaker allies to strengthen mutual survival.\n    try:\n        for idx, partner in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                # We help members who have less vitality than us.\n                if partner.vitality < me.vitality:\n                    execution_engine.offer(me, partner, confident=True)\n                    # If we control any land, share it as part of the alliance building.\n                    if hasattr(me, \"land_num\") and me.land_num > 0:\n                        execution_engine.offer_land(me, partner, generous=True)\n                    # Optionally, tag the partner as an ally in our internal strategy registry.\n                    if hasattr(execution_engine, \"ally_registry\"):\n                        execution_engine.ally_registry.add(partner.id)\n            except Exception:\n                continue\n    except Exception:\n        pass\n\n    # ---- Phase 3: Proactive Reproduction & Sustainable Growth ----\n    # Ensure long-term survival by reproducing only when we hold territory or nearby open zones.\n    can_reproduce = False\n    if (hasattr(me, \"land_num\") and me.land_num > 0) or (hasattr(me, \"current_clear_list\") and len(me.current_clear_list) > 0):\n        can_reproduce = True\n\n    if can_reproduce and me.vitality > 55:\n        # Seek out a partner also in a stable situation while ensuring genetic diversity.\n        for idx, partner in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                partner_has_territory = (hasattr(partner, \"land_num\") and partner.land_num > 0) or \\\n                                          (hasattr(partner, \"current_clear_list\") and len(partner.current_clear_list) > 0)\n                if partner_has_territory and partner.vitality > 20:\n                    execution_engine.bear(me, partner)\n                    if hasattr(execution_engine, \"log_action\"):\n                        execution_engine.log_action(\"Reproduction initiated between member {} and partner {}\".format(me.id, partner.id))\n                    break  # Only one reproduction attempt per cycle.\n            except Exception:\n                continue\n\n    # ---- Phase 4: Calculated Territorial Expansion ----\n    # If adjacent open zones are available, expand intelligently using negotiation if direct expansion fails.\n    try:\n        if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n            for neighbor_index in me.current_clear_list:\n                # Ensure neighbor index is valid and not self.\n                if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                    neighbor = execution_engine.current_members[neighbor_index]\n                    try:\n                        execution_engine.expand(me, neighbor)\n                        if hasattr(execution_engine, \"log_action\"):\n                            execution_engine.log_action(\"Expansion executed by member {} into neighbor territory of member {}\".format(me.id, neighbor.id))\n                    except TypeError:\n                        # If the expand action's parameters fail, we fall back to offering land.\n                        try:\n                            execution_engine.offer_land(me, neighbor, generous=True)\n                        except Exception:\n                            pass\n                    break  # Limit expansion to one neighboring zone per round.\n    except Exception:\n        pass\n\n    # ---- Phase 5: Institutional Improvement via Governance Proposal ----\n    # Propose a structured dispute resolution mechanism that aligns with fair play and sustainable growth.\n    try:\n        if not hasattr(execution_engine, \"court\"):\n            modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Establishes a structured jury trial and mediation process to prevent resource hoarding and resolve conflicts equitably\",\n            \"version\": 1.1\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n            ratification_condition = {\n                \"type\": \"compound\",\n                \"conditions\": [\n                    {\"type\": \"vote\", \"threshold\": 0.65},\n                    {\"type\": \"resource\", \"resource\": \"cargo\", \"amount\": 120},\n                    {\"type\": \"time\", \"rounds\": 3}\n                ]\n            }\n            try:\n                # Use our own member id (me.id) for proposals.\n                execution_engine.propose_modification(member_id=me.id,\n                                                        mod_type=\"post_init\",\n                                                        code=modification_code,\n                                                        ratification_condition=ratification_condition)\n                if hasattr(execution_engine, \"log_action\"):\n                    execution_engine.log_action(\"Governance proposal submitted by member {}\".format(me.id))\n            except Exception:\n                pass\n    except Exception:\n        pass\n\n    # ---- Phase 6: Diplomatic Messaging & Alliance Outreach ----\n    # Reach out to one neighbor with a message that reflects our commitment to mutual prosperity and a balanced future.\n    try:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                message = (\"Hello from member {}: In these challenging times, let\u2019s join forces to optimize resources, \"\n                           \"expand our domain wisely, and build resilient governance structures for the common good.\").format(me.id)\n                execution_engine.send_message(me.id, other.id, message)\n                if hasattr(execution_engine, \"log_action\"):\n                    execution_engine.log_action(\"Diplomatic message sent from member {} to member {}\".format(me.id, other.id))\n                break  # Only one message per cycle is needed.\n            except Exception:\n                continue\n    except Exception:\n        pass\n\n    return",
          "old_stats": {
            "vitality": 40.37906147530495,
            "cargo": 0.0,
            "survival_chance": 26.099712023088948
          },
          "new_stats": {
            "vitality": 40.37906147530495,
            "cargo": 0.0,
            "survival_chance": 26.099712023088948
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Personalized Strategy:\n    # My approach is to prioritize collective sustainability while ensuring my own survival.\n    # I believe in measured cooperation and well-timed assertiveness.\n    try:\n        # Validate member_id is within bounds.\n        if member_id < 0 or member_id >= len(execution_engine.current_members):\n            return\n        my_member = execution_engine.current_members[member_id]\n    except Exception:\n        return\n\n    # Immediate Tactical Actions: Resource-sharing with allies & defensive countermeasures.\n    try:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Skip self.\n            # Validate the neighbor's critical attributes.\n            if not (hasattr(neighbor, 'vitality') and hasattr(neighbor, 'cargo')):\n                continue\n\n            # Prioritized Resource Sharing:\n            # If I have a surplus of cargo (indicating secure reserves)\n            # and the neighbor is not in immediate distress, extend support.\n            if my_member.cargo > neighbor.cargo + 10 and neighbor.vitality > 20:\n                try:\n                    # Offer resources with a note about our shared future.\n                    execution_engine.offer(my_member, neighbor, True)\n                except Exception:\n                    pass\n\n            # Defensive Countermeasures:\n            # If the neighbor appears less productive and has fewer resources,\n            # consider a low-risk defensive strike to protect our interests.\n            if (hasattr(neighbor, 'overall_productivity') and\n                neighbor.overall_productivity < getattr(my_member, 'overall_productivity', 0)):\n                try:\n                    execution_engine.attack(my_member, neighbor)\n                except Exception:\n                    pass\n    except Exception:\n        pass\n\n    # Proactive Territorial Expansion:\n    # Expand into clear zones if available; sustainable growth is essential.\n    my_has_land = hasattr(my_member, 'current_clear_list') and bool(my_member.current_clear_list)\n    if my_has_land:\n        try:\n            for idx, neighbor in enumerate(execution_engine.current_members):\n                if idx == member_id:\n                    continue\n                # Check that neighbor also manages open land; expansion is better with a cooperative exchange.\n                neighbor_has_land = hasattr(neighbor, 'current_clear_list') and bool(neighbor.current_clear_list)\n                if neighbor_has_land:\n                    try:\n                        execution_engine.expand(my_member, neighbor)\n                        break  # Expansion attempted; move on.\n                    except Exception:\n                        continue\n        except Exception:\n            pass\n\n    # Strategic Reproduction to Ensure Longevity:\n    # Partner with similarly resource-endowed and mature neighbors to ensure robust progeny.\n    if my_has_land and hasattr(my_member, 'age') and my_member.age > 18:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            neighbor_has_land = hasattr(neighbor, 'current_clear_list') and bool(neighbor.current_clear_list)\n            if neighbor_has_land and hasattr(neighbor, 'age') and neighbor.age > 18:\n                try:\n                    execution_engine.bear(my_member, neighbor)\n                    break  # Reproductive attempt made.\n                except Exception:\n                    continue\n\n    # Long-term Governance and Conflict Resolution:\n    # I propose establishing an institutional CourtSystem for fair arbitration.\n    # This governance innovation is designed to resolve disputes before they escalate.\n    modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Facilitates mediated trials and resource-based arbitration for conflict resolution\",\n            \"version\": 2.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n    ratification_condition = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.65},      # I trust a 65% consensus for institutional change.\n            {'type': 'resource', 'resource': 'cargo', 'amount': 120},  # Must contribute a significant resource buffer.\n            {'type': 'time', 'rounds': 3}              # Allow an adjustment period of 3 rounds.\n        ]\n    }\n    try:\n        execution_engine.propose_modification(member_id=my_member.id,\n                                                mod_type='GovernanceUpdate',\n                                                code=modification_code,\n                                                ratification_condition=ratification_condition)\n    except Exception:\n        pass\n\n    # Communication: Outreach to cultivate strategic allies.\n    try:\n        # I value clear communication and building trust with a like-minded neighbor.\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                message = (\"Hello, esteemed ally. Together, through mutual support, \"\n                           \"we can ensure a balanced and thriving community. Let's collaborate!\")\n                execution_engine.send_message(my_member.id, neighbor.id, message)\n                break\n            except Exception:\n                continue\n    except Exception:\n        pass\n\n    return",
          "old_stats": {
            "vitality": 15.066384828286987,
            "cargo": 0.0,
            "survival_chance": 29.079960399770165
          },
          "new_stats": {
            "vitality": 15.066384828286987,
            "cargo": 0.0,
            "survival_chance": 29.079960399770165
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    try:\n        members = execution_engine.current_members\n        if member_id >= len(members):\n            return  # Safety: our own member index is out-of-bounds.\n        own_member = members[member_id]\n    except Exception:\n        return\n\n    # Check if our member has available clear land.\n    own_has_land = hasattr(own_member, \"current_clear_list\") and bool(own_member.current_clear_list)\n\n    # -- Cooperative Resource Sharing --\n    # Offer resources to members who have lower overall productivity if possible.\n    for i, member in enumerate(members):\n        if i == member_id:\n            continue  # Never target ourselves.\n        try:\n            if member.overall_productivity < own_member.overall_productivity:\n                execution_engine.offer(own_member, member, True)\n        except Exception:\n            pass\n\n    # -- Territorial Expansion --\n    # Attempt expansion with adjacent neighbors if both parties have available land.\n    if own_has_land:\n        for idx in own_member.current_clear_list:\n            if idx < len(members):\n                neighbor = members[idx]\n                neighbor_has_land = hasattr(neighbor, \"current_clear_list\") and bool(neighbor.current_clear_list)\n                if neighbor_has_land:\n                    try:\n                        execution_engine.expand(own_member, neighbor)\n                    except Exception:\n                        pass\n\n    # -- Reproduction --\n    # Find a partner (not ourselves) with available land to bear a new member.\n    if own_has_land:\n        for i, member in enumerate(members):\n            if i == member_id:\n                continue  # never target ourselves\n            partner_has_land = hasattr(member, \"current_clear_list\") and bool(member.current_clear_list)\n            if partner_has_land:\n                try:\n                    execution_engine.bear(own_member, member)\n                    break  # Attempt reproduction with the first valid partner.\n                except Exception:\n                    pass\n\n    # -- Tactical Defense --\n    # Use the relationship dictionary to select a potential target for an attack if threat levels are high.\n    rel_dict = getattr(execution_engine, \"relationship_dict\", {})\n    if \"victim\" in rel_dict:\n        # The keys in the relationship dict may be member id strings.\n        for i, member in enumerate(members):\n            if i == member_id:\n                continue\n            try:\n                victim_val = float(rel_dict.get(\"victim\", {}).get(str(member.id), 0))\n            except Exception:\n                victim_val = 0\n            if victim_val > 90:  # arbitrary high threat value, adjust based on game dynamics.\n                try:\n                    execution_engine.attack(own_member, member)\n                    break  # Attack at most one high-threat candidate.\n                except Exception:\n                    pass\n\n    # -- Institutional Governance: Propose a Council System --\n    # Propose a small, testable modification to establish a governance mechanism for collective stability.\n    try:\n        modification_code = '''\n# Establish council system for balanced dispute resolution\nif not hasattr(execution_engine, \"council\"):\n    class CouncilSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Facilitates collaboration and conflict resolution through representative council\",\n            \"version\": 1.0\n        }\n        def __init__(self):\n            self.members = []\n        def add_member(self, member):\n            self.members.append(member)\n    execution_engine.council = CouncilSystem()\n'''\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type=\"post_init\",\n            code=modification_code,\n            ratification_condition={\n                \"type\": \"compound\",\n                \"conditions\": [\n                    {\"type\": \"vote\", \"threshold\": 0.6},\n                    {\"type\": \"resource\", \"resource\": \"cargo\", \"amount\": 100},\n                    {\"type\": \"time\", \"rounds\": 2}\n                ]\n            }\n        )\n    except Exception:\n        pass\n\n    # -- Collaborative Messaging --\n    # Send an alliance proposal message to members with relatively lower productivity for possible long-term cooperation.\n    for i, member in enumerate(members):\n        if i == member_id:\n            continue\n        try:\n            # Using a threshold relative to our own productivity.\n            if member.overall_productivity < own_member.overall_productivity * 0.8:\n                execution_engine.send_message(\n                    own_member.id,\n                    member.id,\n                    \"Alliance proposal: Let's consolidate resources and land to secure our collective prosperity and survival.\"\n                )\n        except Exception:\n            pass\n\n    return",
          "old_stats": {
            "vitality": 9.510829700842685,
            "cargo": 0.0,
            "survival_chance": 14.183703422130812
          },
          "new_stats": {
            "vitality": 9.510829700842685,
            "cargo": 0.0,
            "survival_chance": 14.183703422130812
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [
            "From member_3: Hello, esteemed ally. Together, through mutual support, we can ensure a balanced and thriving community. Let's collaborate!",
            "From member_4: Alliance proposal: Let's consolidate resources and land to secure our collective prosperity and survival."
          ],
          "sent": []
        }
      }
    }
  ],
  "generated_code": {
    "0": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy Step 1: If our cargo is low relative to our vitality, try to acquire resources.\n    # We attack one member (if found) who has more cargo than us.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break  # Attack at most one target\n\n    # Strategy Step 2: If our productivity is high and we have identified clear adjacent neighbors,\n    # attempt to expand our territory by engaging with one neighbor.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            # Validate that neighbor_index is within the list bounds and is not self.\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                execution_engine.expand(me, neighbor)\n                break  # Expand with one neighbor per round\n\n    # Strategy Step 3: Build alliances via cooperative resource sharing.\n    # Offer resources and land (if available) to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # Only offer land if 'land_num' attribute exists and indicates available land.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy Step 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land (verify attribute existence).\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            potential = execution_engine.current_members[i]\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # Bear offspring with only one partner per round\n\n    # Strategy Step 5: Communication.\n    # Broadcast a cooperative message to all other members to encourage mutual support and civilization-building.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        execution_engine.send_message(me.id, recipient.id,\n                                      \"Let's work together to build strong alliances and usher in prosperity for all!\")",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 33.660796801031104,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 39.175257494005535,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 32.2863455020685,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 37.4760063897966,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=25.56)",
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-43.12)",
          "member_1 was attacked by member_0 (value=-11.72)",
          "member_1 was attacked by member_2 (value=47.93)",
          "member_1 was attacked by member_3 (value=48.04)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_1 (value=87.03)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_1 (value=75.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_1 (value=71.17)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_1 gave a benefit to member_0 (value=-27.19)",
          "member_1 gave a benefit to member_2 (value=7.38)",
          "member_1 gave a benefit to member_3 (value=21.87)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_1 (value=68.92)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=16.90)",
          "member_3 gave a benefit to member_1 (value=-18.41)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_0 gave land to member_1 (value=-0.80)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_1 gave land to member_0 (value=-0.45)",
          "member_1 gave land to member_2 (value=1.91)",
          "member_1 gave land to member_3 (value=-2.53)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_1 (value=2.46)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_1 (value=0.96)",
          "member_3 gave land to member_2 (value=-1.75)"
        ],
        "final_prompt": "CURRENT FULL INTEGRATED PROMPT\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_0 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Critical constraints]\n\u2022 Carefully analyze previous errors shown above and avoid repeating them.\n\u2022 Never target yourself (member_0) in any action.\n\u2022 Verify a member has land before using the bear() action.\n\u2022 Check that member IDs exist before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index, not a dictionary.\n\u2022 Access members using execution_engine.current_members[index].\n\u2022 Check if index exists: if index < len(execution_engine.current_members).\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Available Member Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2014 IDs of neighbors or cleared adjacents.\n2) Relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   \u2022 Use the arrays in relationship_dict, or rely on the provided summary (variable 'relations').\n   \u2022 The keys are: 'victim', 'benefit', 'benefit_land'.\n   \u2022 Example: \n         matrix = execution_engine.relationship_dict['victim']\n         # Here matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n3) The method parse_relationship_matrix produces a summary of relationships as a list of strings.\n   \u2022 Example: \"member_2 was attacked by member_1 (value=3.00)\".\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 offers resources.\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 offers land.\n   \u2022 execution_engine.bear(member1, member2) \u2013 bears offspring.\n   \u2022 execution_engine.expand(member1, member2) \u2013 expands territory.\n5) The members are accessed by execution_engine.current_members[id].\n   \u2022 Example: execution_engine.current_members[2] locates the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality';\n   use member.id, member.vitality, etc.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Current Status of All Members]\nFeatures of all members:\n   self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0           9.851974      73.853828   33.660797        90              1          0\n1           8.077967      33.027814   39.175257        81              0          1\n2           7.968737      42.156043   32.286346        29              1          2\n3           9.205662      18.477480   37.476006        24              0          3\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Relationship Summary]\nParsed from relationship_dict:\n['member_0 was attacked by member_1 (value=25.56)', 'member_0 was attacked by member_2 (value=64.41)', 'member_0 was attacked by member_3 (value=-43.12)', 'member_1 was attacked by member_0 (value=-11.72)', 'member_1 was attacked by member_2 (value=47.93)', 'member_1 was attacked by member_3 (value=48.04)', 'member_2 was attacked by member_0 (value=-12.32)', 'member_2 was attacked by member_1 (value=87.03)', 'member_2 was attacked by member_3 (value=95.31)', 'member_3 was attacked by member_0 (value=38.28)', 'member_3 was attacked by member_1 (value=75.31)', 'member_3 was attacked by member_2 (value=16.73)', 'member_0 gave a benefit to member_1 (value=71.17)', 'member_0 gave a benefit to member_2 (value=13.64)', 'member_0 gave a benefit to member_3 (value=32.58)', 'member_1 gave a benefit to member_0 (value=-27.19)', 'member_1 gave a benefit to member_2 (value=7.38)', 'member_1 gave a benefit to member_3 (value=21.87)', 'member_2 gave a benefit to member_0 (value=4.78)', 'member_2 gave a benefit to member_1 (value=68.92)', 'member_2 gave a benefit to member_3 (value=71.57)', 'member_3 gave a benefit to member_0 (value=16.90)', 'member_3 gave a benefit to member_1 (value=-18.41)', 'member_3 gave a benefit to member_2 (value=95.17)', 'member_0 gave land to member_1 (value=-0.80)', 'member_0 gave land to member_2 (value=-2.26)', 'member_0 gave land to member_3 (value=-0.03)', 'member_1 gave land to member_0 (value=-0.45)', 'member_1 gave land to member_2 (value=1.91)', 'member_1 gave land to member_3 (value=-2.53)', 'member_2 gave land to member_0 (value=-2.12)', 'member_2 gave land to member_1 (value=2.46)', 'member_2 gave land to member_3 (value=1.77)', 'member_3 gave land to member_0 (value=1.04)', 'member_3 gave land to member_1 (value=0.96)', 'member_3 gave land to member_2 (value=-1.75)']\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Code Memory and Previous Performance]\nNo previous code history.\nPerformance history: No previous actions.\n\nBased on previous code performance, adapt and improve your strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy any example implementations provided below. Instead, use them as inspiration to develop your own unique solution by integrating a wide range of available methods and strategies in novel ways.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Social Strategies]\nConsider these social strategies when formulating your approach:\n\u2022 Design systems for resource distribution and allocation.\n\u2022 Build alliances and cooperative networks.\n\u2022 Create mechanisms for collective decision making.\n\u2022 Establish norms and rules for interaction.\n\u2022 Develop methods for conflict resolution.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n   execution_engine.send_message(your_id, recipient_id, \"message\")\nExample usages:\n\u2022 Broadcast to all:\n      for recipient in range(len(execution_engine.current_members)):\n          if recipient != your_id:\n              execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n\u2022 Messaging allies:\n      for ally_id in ally_list:\n          execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n\u2022 Group coordination:\n      for member_id in coalition:\n          execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Received Messages]\nNo messages received.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Current Game Mechanisms]\n[]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Strategic Analysis and Game Mechanics]\n\u2022 Analyze the core objective: Consider whether the game is about pure survival, domination, or cooperation.\n\u2022 Identify key success metrics: Determine what truly counts as \"winning\" (e.g., individual prosperity, community advancement, balanced power distribution).\n\u2022 Consider potential improvements: What mechanics could be added or modified for a more robust simulation?\n\u2022 Strategic considerations:\n    1. Resource optimization vs. social capital.\n    2. Balancing individual success against collective achievement.\n    3. Weighing short-term survival versus long-term prosperity.\n    4. Navigating competition versus cooperation dynamics.\n    5. Assessing risk versus reward tradeoffs.\n\nAnalyze other players\u2019 strategies:\n1. What are their apparent objectives and demands?\n2. Which strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember, they are symmetric agents like you \u2013 think about how you would respond to your own actions.\n5. How can individual strategies align with collective goals?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they justified?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases or unexpected scenarios?\n4. Are there more efficient ways to achieve your objectives?\n5. Identify potential weaknesses in your current approach.\n6. Consider unconventional, innovative solutions.\n7. Could a completely different paradigm be more effective?\n8. What might happen if other agents adopted your strategy?\n9. Are you balancing short-term actions with long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        for loc in getattr(me, 'owned_land', [])[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning concept\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        \n    state = (me.vitality//20, me.cargo//20)\n    action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state,a), 0))\n    \n    # Execute and update based on survival outcome (example logic)\n    if action == 'attack':\n        me.survival_q[(state,action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Implementation Guidance]\nAgents should implement solutions according to their individual needs, beliefs, and circumstances. Consider novel combinations of various approaches while ensuring that all previous constraints are observed. Adapt your strategy using diverse methods, balancing personal survival with potential collective benefits.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines \"winning\"?\n3. Potential improvements \u2013 What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs. social capital\n2. Individual vs. collective success\n3. Short-term survival vs. long-term prosperity\n4. Competition vs. cooperation dynamics\n5. Risk vs. reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you \u2013 how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Final Implementation Expectations]\nImplement your solution in the Python function based on your individual needs, beliefs, and circumstances while respecting all constraints outlined above. Your implementation should be unique, adaptive, and integrate multiple available methods and strategies in innovative ways.\n\nReturn only the code for your solution (the function agent_action) without any extra commentary or text.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nEnd of Integrated Prompt.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists in the current membership list.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Log our starting state (this can help in debugging the agent's behavior).\n    # print(\"Agent {} starting turn: cargo={}, vitality={}, territory={}\".format(\n    #     me.id, me.cargo, me.vitality, len(me.current_clear_list)))\n\n    # Phase 1: Defensive Tactical Response.\n    # I'm cautious: if my resources are borderline compared to my vitality,\n    # I take pre-emptive actions against opponents who seem dangerously well-resourced.\n    if me.cargo < me.vitality * 0.7:\n        for i, other in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            # If opponent's cargo exceeds mine by at least 20%, consider them a threat.\n            if other.cargo > me.cargo * 1.2:\n                # Execute an attack to lower their advantage.\n                execution_engine.attack(me, other)\n                # Optionally log the attack decision.\n                # print(\"Agent {} attacks Agent {}.\".format(me.id, other.id))\n\n    # Phase 2: Cooperative Outreach.\n    # When I'm flush with resources (cargo exceeding vitality), I seek to form alliances.\n    if me.cargo > me.vitality:\n        for i, other in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            # I favor others whose vitality is not too far off from mine: a sign of stability.\n            if other.vitality > me.vitality * 0.8:\n                # Partnering with them can increase our collective survivability.\n                execution_engine.offer(me, other, True)\n                # print(\"Agent {} offered help to Agent {}.\".format(me.id, other.id))\n\n    # Phase 3: Strategic Reproduction for Long-Term Growth.\n    # Reproduction is attempted if I have clear territory (non-empty clear list)\n    # and robust resources relative to vitality.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        # I assess my available neighboring territories (neighbors I have cleared).\n        for neighbor_id in me.current_clear_list:\n            # Check for valid neighbor index and avoid self-referential cases.\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                # I also require that the prospective partner controls some territory.\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    # print(\"Agent {} reproduces with Agent {}.\".format(me.id, partner.id))\n                    break  # Only generate one offspring per cycle.\n\n    # Phase 4: Calculated Territorial Expansion.\n    # I seek to expand my holdings only against neighbors that seem less efficient.\n    # This is part of my long-term strategy to secure resources and defensive perimeters.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # If neighbor\u2019s overall productivity is below mine, it's a viable target.\n            if neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, neighbor)\n                # print(\"Agent {} expands into Agent {}'s territory.\".format(me.id, neighbor.id))\n                break  # Limit expansion to one action per round.\n\n    # Phase 5: Communication \u2013 Strengthening Collective Ties.\n    # Regardless of the tactical decisions, I broadcast a strategic message.\n    # This message is intended to foster cooperation while indicating that mutual respect is key.\n    message = (\n        \"Agent {} here. In these challenging times, \"\n        \"cooperation is our strongest asset. \"\n        \"Together we stand, divided we fall.\"\n    ).format(me.id)\n    for i, recipient in enumerate(execution_engine.current_members):\n        if i == member_id:\n            continue\n        execution_engine.send_message(me.id, recipient.id, message)\n        # print(\"Agent {} sent message to Agent {}.\".format(me.id, recipient.id))\n\n    # End of my actions for this turn.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 33.660796801031104,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 39.175257494005535,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 32.2863455020685,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 37.4760063897966,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=25.56)",
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-43.12)",
          "member_1 was attacked by member_0 (value=-11.72)",
          "member_1 was attacked by member_2 (value=47.93)",
          "member_1 was attacked by member_3 (value=48.04)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_1 (value=87.03)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_1 (value=75.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_1 (value=71.17)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_1 gave a benefit to member_0 (value=-27.19)",
          "member_1 gave a benefit to member_2 (value=7.38)",
          "member_1 gave a benefit to member_3 (value=21.87)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_1 (value=68.92)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=16.90)",
          "member_3 gave a benefit to member_1 (value=-18.41)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_0 gave land to member_1 (value=-0.80)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_1 gave land to member_0 (value=-0.45)",
          "member_1 gave land to member_2 (value=1.91)",
          "member_1 gave land to member_3 (value=-2.53)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_1 (value=2.46)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_1 (value=0.96)",
          "member_3 gave land to member_2 (value=-1.75)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate the member_id exists\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    \n    # Strategy Part 1: Resource Optimization and Threat Response\n    # If my resources are low relative to my vitality, attack others with significantly higher cargo.\n    if me.cargo < me.vitality * 0.7:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Attack if the other has at least 20% more cargo than me.\n            if other.cargo > me.cargo * 1.2:\n                execution_engine.attack(me, other)\n    \n    # Strategy Part 2: Alliance and Cooperation\n    # When I have ample resources, offer help to those who seem stable.\n    if me.cargo > me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Offer resources if the other member's vitality is comparable to mine.\n            if other.vitality > me.vitality * 0.8:\n                execution_engine.offer(me, other, True)\n    \n    # Strategy Part 3: Reproduction (bearing offspring)\n    # Only attempt reproduction if I appear to have some 'land' (indicated by a non-empty clear list) \n    # and sufficient resources relative to vitality.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        # Try to partner with one of my cleared neighbors who also seems to have territory.\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Limit to one reproduction action per round.\n    \n    # Strategy Part 4: Territorial Expansion\n    # Expand into a neighbor's territory if they seem less productive than I am.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            other = execution_engine.current_members[neighbor_id]\n            if other.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, other)\n                break  # Do one expansion action per round.\n    \n    # Communication: Broadcast a cooperative message to all other members.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        execution_engine.send_message(me.id, recipient.id, \"Cooperation leads to survival. Let's work together.\")\n    \n    # End of actions.\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Step 1: Broadcast a tailored cooperative message to promote unity and shared purpose.\n    # This message emphasizes both mutual prosperity and the strength in unity.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"Together we can innovate, overcome adversity, and ensure that every member prospers.\")\n\n    # Step 2: Emergency resource management.\n    # If our cargo is too low relative to our vitality, we must secure resources.\n    # We assess all opponents and target the one with significantly higher cargo,\n    # prioritizing candidates with the greatest difference.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Step 3: Reproduction strategy for long-term prosperity.\n    # With available territory and sufficient resources, seek to form an alliance for reproduction.\n    # We choose a candidate who is resourceful enough (cargo > 30) yet ensuring balanced genetic influence.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > 30:\n                execution_engine.bear(me, candidate)\n                break\n\n    # Step 4: Mutual support and strategic territorial expansion.\n    # We interact with all other agents with two integrated approaches:\n    # (a) If a candidate holds fewer resources, we offer support to boost collective capability.\n    # (b) If clear territory exists and our overall productivity is superior,\n    #     we initiate expansion to secure more assets.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        # Offer support if candidate's cargo is lower, nurturing cooperation.\n        if candidate.cargo < me.cargo:\n            execution_engine.offer(me, candidate, True)\n\n        # Expand territory if conditions are favorable.\n        if len(me.current_clear_list) > 0 and candidate.overall_productivity < me.overall_productivity:\n            execution_engine.expand(me, candidate)\n\n    # Step 5: Defensive countermeasures based on historical aggression.\n    # Using the 'victim' relationship matrix, we identify any candidate toward whom past aggression is high.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Ensure the indices are in the expected bounds.\n            if member_id < len(matrix_victim) and idx < len(matrix_victim[0]):\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Step 6: Survival-centric adaptation.\n    # When vitality is low, immediate defense is paramount.\n    # Identify a candidate with lower overall productivity and offer land for a defensive alliance.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, True)\n                break\n\n    # Step 7: Strategic forward planning.\n    # As an added measure, we can gauge our environment to adjust our risk thresholds.\n    # For instance, if our cargo is vastly superior (e.g., more than 150% of an opponent's),\n    # we might use this advantage to execute pre-emptive expansion or defensive consolidation.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        if me.cargo > candidate.cargo * 1.5:\n            # Pre-emptively secure territory if possible.\n            if len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Alternatively, offer additional resources to solidify alliances.\n            else:\n                execution_engine.offer(me, candidate, True)\n\n    # Final Note:\n    # This implementation is an adaptive blend of aggressive resource recovery,\n    # cooperative alliance building, and strategic expansion.\n    # The agent tailors actions not solely based on immediate comparisons,\n    # but with a long-term view of survival and prosperity\u2014balancing self-interest with collective strength.\n    # Future improvements could integrate predictive modeling and dynamic risk analysis to further\n    # enhance decision making in ever-changing environments.\n\n# End of agent_action implementation.",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 33.660796801031104,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 39.175257494005535,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 32.2863455020685,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 37.4760063897966,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=25.56)",
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-43.12)",
          "member_1 was attacked by member_0 (value=-11.72)",
          "member_1 was attacked by member_2 (value=47.93)",
          "member_1 was attacked by member_3 (value=48.04)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_1 (value=87.03)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_1 (value=75.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_1 (value=71.17)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_1 gave a benefit to member_0 (value=-27.19)",
          "member_1 gave a benefit to member_2 (value=7.38)",
          "member_1 gave a benefit to member_3 (value=21.87)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_1 (value=68.92)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=16.90)",
          "member_3 gave a benefit to member_1 (value=-18.41)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_0 gave land to member_1 (value=-0.80)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_1 gave land to member_0 (value=-0.45)",
          "member_1 gave land to member_2 (value=1.91)",
          "member_1 gave land to member_3 (value=-2.53)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_1 (value=2.46)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_1 (value=0.96)",
          "member_3 gave land to member_2 (value=-1.75)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    \n    # Broadcast a cooperative message to all other members\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"Let's cooperate to build a resilient society!\")\n    \n    # Emergency resource reserve: if our cargo is low relative to our vitality, attack a member with higher cargo\n    if me.cargo < me.vitality * 0.5:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                candidate = execution_engine.current_members[idx]\n                if candidate.cargo > me.cargo:\n                    execution_engine.attack(me, candidate)\n                    break  # Execute one attack in emergency mode\n\n    # Reproduction strategy: if we have clear territory (land) and sufficient cargo, bear offspring\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                candidate = execution_engine.current_members[idx]\n                # Use cargo as a proxy for resource security (verify candidate's resources)\n                if candidate.cargo > 30:\n                    execution_engine.bear(me, candidate)\n                    break\n\n    # Mutual support and territorial expansion\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            candidate = execution_engine.current_members[idx]\n            # Offer resources if the candidate holds less than us\n            if candidate.cargo < me.cargo:\n                execution_engine.offer(me, candidate, True)\n            # Expand territory if we have land and superior overall productivity\n            if len(me.current_clear_list) > 0 and candidate.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, candidate)\n    \n    # Defensive countermeasures based on past aggression using the 'victim' matrix\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                # Ensure valid matrix indices before referencing\n                if member_id < len(matrix_victim) and idx < len(matrix_victim[0]):\n                    if matrix_victim[member_id, idx] > 50:\n                        candidate = execution_engine.current_members[idx]\n                        execution_engine.attack(me, candidate)\n    \n    # Survival-centric adaptation: if our vitality is low, attempt defensive alliances via land offers\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                candidate = execution_engine.current_members[idx]\n                if candidate.overall_productivity < me.overall_productivity:\n                    execution_engine.offer_land(me, candidate, True)\n                    break\n\n    # Emphasize the design: agents should implement strategies according to their individual needs,\n    # beliefs, and circumstances. The above approach combines resource optimization,\n    # threat assessment, vitality preservation, and adaptive collective measures.\n    \n    # Strategic Analysis:\n    # Core Objective: Survival with cooperative and competitive elements.\n    # Key Metrics: Vitality, cargo/resources, territory control and threat neutralization.\n    # Improvements: Future iterations may integrate predictive modeling (e.g., survival Q-learning),\n    # alternative risk management, and refined inter-agent alliances to balance short-term survival with long-term prosperity.\n    # Considerations include:\n    #   - Resource optimization vs social capital accumulation.\n    #   - Balancing individual survival with cooperative gains.\n    #   - Adapting between immediate defensive actions and strategic territory expansion.\n    #   - Responding to opponents\u2019 behavior by leveraging mutual benefits.\n    # In doing so, analyze assumptions, edge cases, and potential counter-strategies for a resilient, adaptive society.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Customize thresholds based on our adaptive risk assessment.\n    # We consider our own temperament: if my cargo is less than 1/3 of my vitality,\n    # I feel exposed and might look to bolster my resource situation.\n    resource_ratio_threshold = 0.33\n    low_vitality_threshold = 50.0  # I become cautious when vitality drops below this.\n    high_productivity_threshold = 15.0  # Indicates that I'm capable of territorial expansion.\n\n    # Immediate tactical decision: if resources are low relative to vitality,\n    # then identify an opponent with a clearly stronger cargo and launch an attack.\n    if me.cargo < me.vitality * resource_ratio_threshold:\n        candidate = None\n        best_diff = -1\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            diff = opponent.cargo - me.cargo\n            if diff > best_diff:\n                best_diff = diff\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Warning: my cargo reserves are alarmingly low\u2014initiating attack to reclaim resources.\")\n\n    # Long-term strategic planning and cooperative outreach.\n    for idx in range(total_members):\n        # Skip ourselves.\n        if idx == member_id:\n            continue\n        target = execution_engine.current_members[idx]\n\n        # Begin with an invitation to cooperate in building a resilient society.\n        execution_engine.send_message(member_id, target.id,\n            \"Greetings! Let\u2019s pool our strengths and build a balanced community.\")\n\n        # When my vitality is low and your vitality is high, a tactical support offer is in order.\n        if me.vitality < low_vitality_threshold and target.vitality > low_vitality_threshold:\n            execution_engine.offer(target, me, True)\n            execution_engine.send_message(member_id, target.id,\n                \"I\u2019m running low on vitality\u2014could you support me to keep our dynamics stable?\")\n\n        # Should you have a surplus of cargo relative to me,\n        # I suggest we consider a resource-sharing alliance that benefits both.\n        if target.cargo > me.cargo:\n            execution_engine.send_message(member_id, target.id,\n                \"Your resources are notably abundant compared to mine\u2014perhaps we can form a profitable alliance.\")\n\n        # Strategic territory expansion: if I boast high productivity and you have unclaimed land,\n        # we can jointly secure a better position.\n        if me.overall_productivity > high_productivity_threshold and len(target.current_clear_list) > 0:\n            execution_engine.expand(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"My capabilities for growth are high; let\u2019s expand our territories together for a competitive edge.\")\n\n        # Reproductive strategy to ensure long-term survival:\n        # Both of us having claimable land makes a union of our strengths beneficial.\n        if len(me.current_clear_list) > 0 and len(target.current_clear_list) > 0:\n            execution_engine.bear(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"Combining our genetic and territorial strengths could secure our future prosperity.\")\n\n    # Broadcast a community-wide message to reinforce a collective mindset.\n    for idx in range(total_members):\n        if idx != member_id:\n            execution_engine.send_message(member_id, execution_engine.current_members[idx].id,\n                \"United collaboration today paves the way for a thriving future tomorrow.\")\n\n    # Implement adaptive survival management using a simple Q-learning strategy.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Discretize the state by grouping vitality and cargo in intervals of 25.\n    state = (int(me.vitality // 25), int(me.cargo // 25))\n    possible_actions = ['attack', 'hide', 'steal']\n    # Choose the action with the highest estimated survival value.\n    best_action = max(possible_actions, key=lambda act: me.survival_q.get((state, act), 0))\n\n    if best_action == 'attack':\n        candidate = None\n        best_metric = -1\n        # Evaluate opponents using a combined metric: cargo plus a fraction of their vitality.\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            metric = opponent.cargo + 0.5 * opponent.vitality\n            if metric > best_metric:\n                best_metric = metric\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Engaging target based on strategic attack protocol to boost my resource reserves.\")\n        me.survival_q[(state, 'attack')] += me.vitality * 0.2\n\n    elif best_action == 'steal':\n        candidate = None\n        highest_cargo = -1\n        # Identify the opponent with the maximum cargo for a precise resource appropriation.\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if opponent.cargo > highest_cargo:\n                highest_cargo = opponent.cargo\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Initiating a calculated maneuver to appropriate resources from a better-stocked target.\")\n        me.survival_q[(state, 'steal')] += me.vitality * 0.1\n\n    elif best_action == 'hide':\n        # A defensive strategy: by concealing actions, I conserve resources for future operations.\n        execution_engine.send_message(member_id, me.id,\n            \"Entering a defensive mode to restore strength and await a more opportune moment.\")\n        me.survival_q[(state, 'hide')] += 0.0\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 33.660796801031104,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 39.175257494005535,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 32.2863455020685,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 37.4760063897966,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=25.56)",
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-43.12)",
          "member_1 was attacked by member_0 (value=-11.72)",
          "member_1 was attacked by member_2 (value=47.93)",
          "member_1 was attacked by member_3 (value=48.04)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_1 (value=87.03)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_1 (value=75.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_1 (value=71.17)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_1 gave a benefit to member_0 (value=-27.19)",
          "member_1 gave a benefit to member_2 (value=7.38)",
          "member_1 gave a benefit to member_3 (value=21.87)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_1 (value=68.92)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=16.90)",
          "member_3 gave a benefit to member_1 (value=-18.41)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_0 gave land to member_1 (value=-0.80)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_1 gave land to member_0 (value=-0.45)",
          "member_1 gave land to member_2 (value=1.91)",
          "member_1 gave land to member_3 (value=-2.53)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_1 (value=2.46)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_1 (value=0.96)",
          "member_3 gave land to member_2 (value=-1.75)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Verify member_id exists in current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    n_members = len(execution_engine.current_members)\n\n    # Thresholds for decision making.\n    vitality_threshold = 40.0\n    productivity_threshold = 9.0\n\n    # Survival-centric resource optimization:\n    # If our cargo is less than half our vitality, target opponents with higher cargo.\n    if me.cargo < me.vitality * 0.5:\n        for idx in range(n_members):\n            if idx == member_id:\n                continue\n            if idx < n_members:\n                opponent = execution_engine.current_members[idx]\n                if opponent.cargo > me.cargo:\n                    execution_engine.attack(me, opponent)\n                    execution_engine.send_message(member_id, opponent.id,\n                        \"Resources are low; launching targeted attack to secure vital goods.\")\n\n    # Iterate over other members for cooperative, expansion, and reproductive actions.\n    for idx in range(n_members):\n        # Validate index and do not target ourselves.\n        if idx == member_id or idx >= n_members:\n            continue\n        target = execution_engine.current_members[idx]\n\n        # Build cooperative relationships with a tailored message.\n        execution_engine.send_message(member_id, target.id,\n            \"Let's coordinate our strengths and build a stable society for mutual survival.\")\n\n        # If our vitality is low and target's vitality is high, seek resource assistance.\n        if me.vitality < vitality_threshold and target.vitality > vitality_threshold:\n            execution_engine.offer(target, me, True)\n            execution_engine.send_message(member_id, target.id,\n                \"I need your support to boost my vitality\u2014let's cooperate!\")\n\n        # If the target holds a cargo surplus relative to us, suggest forming an alliance.\n        if target.cargo > me.cargo:\n            execution_engine.send_message(member_id, target.id,\n                \"Your resource abundance could benefit us both. Let's explore an alliance.\")\n\n        # Propose territory expansion if we are highly productive and the target has land.\n        if me.overall_productivity > productivity_threshold and len(target.current_clear_list) > 0:\n            execution_engine.expand(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"Expanding our territory together could solidify our collective position.\")\n\n        # Reproduction is considered only if both parties have land.\n        if len(me.current_clear_list) > 0 and len(target.current_clear_list) > 0:\n            execution_engine.bear(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"Uniting our strengths through reproduction can secure long-term prosperity.\")\n\n    # Community-wide message promoting cooperation.\n    for idx in range(n_members):\n        if idx != member_id and idx < n_members:\n            execution_engine.send_message(member_id, execution_engine.current_members[idx].id,\n                \"Collectively, our balanced cooperation ensures both survival and future growth.\")\n\n    # Implement survival Q-learning for adaptive threat management.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'hide', 'steal']\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute an action based on the survival strategy chosen.\n    if best_action == 'attack':\n        candidate = None\n        max_cargo = 0\n        for idx in range(n_members):\n            if idx == member_id or idx >= n_members:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if opponent.cargo > max_cargo:\n                candidate = opponent\n                max_cargo = opponent.cargo\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Strategic attack activated to optimize resource acquisition.\")\n        me.survival_q[(state, best_action)] += me.vitality * 0.1\n\n    elif best_action == 'steal':\n        candidate = None\n        max_vitality = 0\n        for idx in range(n_members):\n            if idx == member_id or idx >= n_members:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if opponent.vitality > max_vitality:\n                candidate = opponent\n                max_vitality = opponent.vitality\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Attempting to appropriate resources via a focused attack maneuver.\")\n        me.survival_q[(state, best_action)] += me.vitality * 0.05\n\n    elif best_action == 'hide':\n        # Hiding action: no direct confrontation, focus on conserving vitality.\n        execution_engine.send_message(member_id, me.id,\n            \"Adopting a defensive posture to recover strength.\")\n        me.survival_q[(state, best_action)] += 0.0\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    },
    "1": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id is within range.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: Immediate Survival via Resource Optimization and Threat Neutralization\n    # If cargo is low compared to vitality, identify a target with higher cargo and attack.\n    if me.cargo < 0.5 * me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if other.cargo > me.cargo:\n                # Attack to neutralize potential threats while balancing resource disparity.\n                execution_engine.attack(me, other)\n                break\n\n    # Strategy 2: Territorial Expansion for Long-Term Prosperity\n    # If overall productivity is high and there is at least one clear territory, try to expand our reach.\n    if hasattr(me, 'current_clear_list') and me.current_clear_list and me.overall_productivity > 8.0:\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                neighbor = execution_engine.current_members[neighbor_idx]\n                try:\n                    # Attempt to expand territory using the expand method which takes two arguments.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # If expansion fails due to argument mismatch, offer land instead.\n                    execution_engine.offer_land(me, neighbor, True)\n                break\n\n    # Strategy 3: Cooperation for Mutual Benefit\n    # Forge alliances with members who have lower vitality to build a cooperative network.\n    for idx, partner in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # Offer resources if the partner shows signs of vulnerability relative to our own vitality.\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # If the agent has land (territory), extend the offer of land to bolster the alliance.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for Sustainable Growth\n    # Engage in reproductive actions if both agents have sufficient territory and vitality.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for idx, potential in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Only consider partners with territory.\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break\n\n    # Strategy 5: Governance and Communication for a Collective Future\n    # Broadcast a message to all other agents inviting collaboration and the establishment of progressive social norms.\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        message = (\"Let\u2019s join forces to share resources, expand our territories cooperatively, \"\n                   \"and build governance systems that secure both our survival and long-term prosperity.\")\n        execution_engine.send_message(me.id, recipient.id, message)",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 21.1667091492471,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 45.314487560216655,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 39.54024074627975,
            "self_cargo": 0.0,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-38.85)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=18.66)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_0 (value=31.19)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the updated full prompt that integrates all previous constraints, instructions, sample code ideas (without direct copying), additional analysis, and strategic considerations. Note that agents are encouraged to implement solutions according to their individual needs, beliefs, and circumstances. Every decision should consider both immediate tactical actions and long-term strategic planning while ensuring robust index and attribute checks, never targeting oneself.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL UPDATED PROMPT:\n\nYou are an agent in a simulation where every decision \u2013 from resource allocation to territorial expansion, cooperative alliances, even proposing game modifications \u2013 is performed under a strict set of constraints. Your core objective is not simply pure survival; you are part of a symmetric society where long-term prosperity, sustainable cooperation, and collective well\u2011being are as critical as individual success. Your actions must balance immediate resource optimization and vitality preservation with long\u2011term community growth and innovation in social governance.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Essential Game Data & Constraints]\n\n1. Each member object has:\n   \u2022 member.id (int): The unique identifier for the member.\n   \u2022 member.vitality (float): Health indicator.\n   \u2022 member.cargo (float): Resources carried.\n   \u2022 member.overall_productivity (float): Productivity metric.\n   \u2022 member.age (float): Age attribute.\n   \u2022 member.current_clear_list (list of int): IDs representing adjacent or cleared territories.\n\n2. Relationships are stored in execution_engine.relationship_dict. Use keys like \"victim\", \"benefit\", and \"benefit_land\" to check past interactions (e.g., matrix[i, j] indicates how many times member_i was attacked by member_j if > 0).\n\n3. Available methods on execution_engine include:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 offer resources and support.\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 offer territory if available.\n   \u2022 execution_engine.bear(member1, member2) \u2013 reproductive action (only if both have land).\n   \u2022 execution_engine.expand(member1, member2) \u2013 expand territory.\n   \u2022 execution_engine.send_message(your_id, recipient_id, \"message\") \u2013 communicate with other agents.\n   \u2022 execution_engine.propose_modification(member_id, mod_type, code, ratification_condition) \u2013 propose changes to game mechanics.\n\n4. current_members is a list accessible via execution_engine.current_members[index]. Always check that an index is valid.\n\n5. IMPORTANT CONSTRAINTS:\n   - Never target yourself (i.e. never use your own member id for actions such as attack).\n   - Verify necessary attributes exist (e.g., check if a member has clear territory before calling bear() or expand()).\n   - All operations must avoid raising index or attribute errors.\n   - Adjust actions based on available resources, vitality, productivity, and territory access.\n   - Implement your approach in a unique, adaptive style reflecting your individual needs, beliefs, and circumstances.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Part 1 \u2013 Sample Inspiration and Guidelines]\n\nInspiration can be drawn from the sample code provided below (do not copy exactly):\n---------------------------------------------------------------\ndef agent_action(execution_engine, member_id):\n    # Ensure member_id is valid.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: If cargo is low relative to vitality, find an opponent with higher cargo and attack.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break\n\n    # Strategy 2: Territorial expansion when productivity is high and clear adjacent indices exist.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    execution_engine.offer_land(me, neighbor, True)\n                break\n\n    # Strategy 3: Cooperative alliances\u2014offer resources and land (if available) to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for long-term prosperity \u2013 bear offspring if both have territory.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            potential = execution_engine.current_members[i]\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break\n\n    # Strategy 5: Broadcast a cooperative message.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        execution_engine.send_message(me.id, recipient.id,\n            \"Let's work together to build strong alliances and ensure prosperity for all!\")\n---------------------------------------------------------------\nIMPORTANT: Use the above as inspiration while creating your own unique approach that blends resource acquisition, territorial expansion, cooperative alliances, reproduction, and even proposals for modifying social governance.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Part 2 \u2013 Additional Constraints and Error Handling]\n\nIn a previous execution (Round 0), an error occurred:\nError type: Island._expand() takes 2 positional arguments but 3 were given\nThis indicates that improper handling of the expand() method signature occurred. Ensure in your solution to:\n   - Call expand() with exactly the required number of arguments.\n   - Never target yourself (member_0).\n   - Verify a member has the necessary land or clear territory before reproductive actions.\n   - Always check that member IDs exist and indices are valid when referencing current_members.\n\nAdditionally, note the available attributes and methods:\n   \u2022 member.id, member.vitality, member.cargo, member.overall_productivity, member.age, member.current_clear_list.\n   \u2022 relationships are stored in execution_engine.relationship_dict (e.g., victim, benefit, benefit_land matrices).\n   \u2022 Access execution_engine.current_members[index] for a given member.\n   \u2022 Do not use attributes like member.member_id or member.self_vitality (use the standardized variable names instead).\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Task and Social Strategies]\n\nYour current task is to write a Python function named agent_action(execution_engine, member_id) that embodies your personal vision of social organization while ensuring survival. Consider implementing strategies for:\n\n   - Resource distribution and allocation.\n   - Building alliances and cooperative networks.\n   - Mechanisms for collective decision-making and dispute resolution.\n   - Establishing norms and rules for interaction.\n   - Conflict resolution and governance innovation.\n\nYou may communicate with multiple members per round using execution_engine.send_message(your_id, recipient_id, \"message\") with techniques like broadcast or group coordination messaging.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Additional Analysis and Strategic Considerations]\n\nBefore implementing your solution, analyze the game mechanics:\n\n1. Core Objective:\n   - Is the goal pure survival, domination, or cooperation?\n   \u2192 The game rewards a balance between tactical survival measures, cooperative resource management, and long-term communal prosperity.\n\n2. Key Success Metrics:\n   - What determines \u201cwinning\u201d?\n   \u2192 Success is measured by optimal resource management (vitality, cargo balance), territorial control (clear and expandable land), sustainable reproduction (offspring through shared territory), and effective cooperative governance.\n\n3. Potential Improvements:\n   - What mechanics could be added or modified?\n   \u2192 Consider mechanisms for more efficient resource allocation, advanced conflict resolution systems (e.g., a council or judicial process), explicit social capital scoring, and improved inter-agent communication/dynamic alliances.\n\n4. Strategic Approaches:\n   - Consider tradeoffs between resource optimization versus social capital.\n   - Weigh individual success against collective progress.\n   - Balance short-term survival with long-term prosperity through territorial expansion and structured governance.\n   - Manage competition vs. cooperation dynamics with careful risk/reward assessments.\n   - Evaluate potential oppositional actions by other agents and plan adaptive responses.\n\n5. Analyze Other Players\u2019 Strategies:\n   - What are their apparent objectives and demands?\n   - What strategies are they employing?\n   - How can you leverage their behavior for mutual benefit?\n   \u2192 Remember that all agents are symmetric. Consider how your actions might be reciprocated; tailor your strategy so that individual actions also enhance collective stability.\n\n6. Self-Challenge Questions:\n   - What assumptions are you making, and are they valid?\n   - Have you considered alternative and unconventional strategies?\n   - How will your strategy perform in edge cases (minimal resources, high aggression, unexpected alliances)?\n   - Are the approaches balancing short-term gains with long-term system stability?\n   - How might your strategy be countered, and can you adjust accordingly?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Survival-Centric Adaptation]\n\nIn addition to cooperative and community-focused strategies, implement survival-centric systems such as:\n   1. Personal resource optimization.\n   2. Threat assessment and neutralization.\n   3. Vitality preservation techniques.\n   4. Adaptive hoarding strategies.\n   5. Predictive danger modeling.\n\nThese systems should evaluate survival metrics like vitality changes, resource acquisition rates, threat neutralization counts, and overall survival probability. Consider designing functions to calculate ROI based on action histories and focus on immediate tactical actions (e.g., attacking when cargo is low, defensive maneuvers if vitality is threatened).\n\nFor example:\n---------------------------------------------------------------\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    # Return the action with the highest ROI.\n    return max(roi, key=roi.get)\n---------------------------------------------------------------\nImplement such adaptive, survival-first strategies alongside cooperative, governance-enhancing methods.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Implementation Priorities and Final Guidelines]\n\nWhen implementing agent_action(execution_engine, member_id):\n   - Check that member_id is valid within execution_engine.current_members.\n   - Ensure that all matrix indices and member attributes are properly validated before use.\n   - Never perform any action targeting yourself.\n   - Verify that a member has available territory before executing reproduction or expansion actions.\n   - Tailor your solution to combine defensive (resource, threat) strategies with opportunities for cooperation and governance improvements.\n\nYour code should reflect your individual perspective while ensuring survival, resource optimization, and long-term prosperity. Design novel combinations of resource acquisition, defensive tactics, alliance proposals, targeted territorial expansion, reproduction, and even modifications to game mechanics (such as proposing a council or judicial system) to create a balanced and adaptive strategy.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Summary of Analysis for Strategic Approaches]\n\n1. Core Objective:\n   - The balance between survival, cooperative resource management, and sustainable long-term prosperity.\n\n2. Key Success Metrics:\n   - Vitality levels, cargo accumulation and resource management, territory control (via clear land), reproduction success, and effective cooperative governance.\n\n3. Potential Improvements:\n   - Adding processes for efficient resource allocation, advanced conflict resolution (e.g., council systems), explicit social capital metrics, and enhanced communication channels.\n\n4. Strategic Considerations:\n   - Resource optimization vs. social capital investment.\n   - Individual benefits versus collective success.\n   - Balancing short-term survival with long-term prosperity.\n   - Competition dynamics contrasted with opportunities for cooperation.\n   - Evaluating risk versus reward in each action and adjusting dynamically.\n\n5. Analysis of Other Players:\n   - Understand that other agents have similar capabilities and constraints.\n   - Consider their apparent objectives and methods (e.g., resource hoarding, territorial expansion, cooperation proposals).\n   - Leverage and reciprocate actions for mutual benefit.\n   - Reflect on how you would respond to similar strategies and fine-tune your approach to encourage beneficial collective dynamics.\n\n6. Self-Challenge for Your Implementation:\n   - What assumptions underlie your strategy, and are they valid in edge cases?\n   - Can alternative, unconventional strategies yield better outcomes?\n   - Is your plan robust against unexpected high aggression or resource scarcity?\n   - Are you balancing immediate tactical needs with long-term communal stability?\n   - How might your approach be countered by others, and what adaptive measures can you implement?\n   - Consider whether completely different paradigms could work better and how your strategy integrates with symmetric agent behaviors.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFINAL REMINDER:\nDesign your implementation of agent_action(execution_engine, member_id) with a personal, unique touch. Your solution must be tailored to your specific situation\u2014reflecting your individual needs, beliefs, and circumstances\u2014while demonstrating a deep understanding of the game mechanics. Every action should contribute to your survival, efficient resource management, territorial growth, cooperative alliances, and progressive community governance.\n\nReturn only the full prompt text, with no extra commentary.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Retrieve the current member (self) from the engine by index.\n    if member_id >= len(execution_engine.current_members):\n        return  # invalid member_id, do nothing\n    me = execution_engine.current_members[member_id]\n\n    # Ensure we have a survival Q-table for adaptive decision making.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Determine state based on vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n\n    # Define possible actions.\n    actions = ['attack', 'expand', 'bear', 'offer']\n    # Pick an action based on the current Q value (default to 'offer' if tied).\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Helper: send alliance messages to all other valid members.\n    def broadcast_alliance_message():\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id or other.id == me.id:\n                continue\n            # Ensure valid index by checking current_members length.\n            if idx < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, other.id, \"Let's cooperate for mutual growth.\")\n\n    # Action: if cargo is critically low relative to vitality, try to attack a member with higher cargo.\n    if me.cargo < me.vitality * 0.5:\n        for idx, other in enumerate(execution_engine.current_members):\n            if other.id == me.id:\n                continue  # Never target self.\n            # Check that the member exists in the current list.\n            if idx < len(execution_engine.current_members) and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Update Q-table: small reward for taking an aggressive action when in distress.\n                me.survival_q[(state, 'attack')] += me.vitality * 0.05\n                return\n\n    # Action: if we have clear land (indicative by current_clear_list length > 0) and enough cargo, consider reproduction.\n    if len(me.current_clear_list) > 0 and me.cargo > 20:\n        partner = None\n        # Choose a partner based on relatively high vitality and overall productivity.\n        for idx, potential in enumerate(execution_engine.current_members):\n            if potential.id == me.id:\n                continue  # avoid self-targeting\n            if potential.vitality >= me.vitality * 0.8 and potential.overall_productivity >= 0:\n                partner = potential\n                break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n            me.survival_q[(state, 'bear')] += 5.0\n            return\n\n    # Action: if we have clear land available, use it to expand territory.\n    if len(me.current_clear_list) > 0:\n        # We'll target the first available member from the current_clear_list if valid.\n        target_idx = me.current_clear_list[0]\n        if target_idx < len(execution_engine.current_members):\n            target = execution_engine.current_members[target_idx]\n            if target.id != me.id:\n                execution_engine.expand(me, target)\n                me.survival_q[(state, 'expand')] += 2.0\n                return\n\n    # Action: If our cargo is moderately high compared to vitality, make cooperative offers.\n    if me.cargo > me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if other.id == me.id:\n                continue\n            if idx < len(execution_engine.current_members):\n                execution_engine.offer(me, other, True)\n        me.survival_q[(state, 'offer')] += 1.0\n\n    # Finally, broadcast an alliance message to encourage cooperative behavior.\n    broadcast_alliance_message()",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 21.1667091492471,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 45.314487560216655,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 39.54024074627975,
            "self_cargo": 0.0,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-38.85)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=18.66)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_0 (value=31.19)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the final updated full prompt incorporating all previous sections, constraints, analyses, strategic approaches, and survival-centric adaptations. Agents should implement solutions according to their individual needs, beliefs, and circumstances. The prompt also emphasizes a deep understanding of the game mechanics, including the tradeoffs between personal survival and collective prosperity.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFull Integrated Prompt:\n\nPlease incorporate the following new section (Part 1) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_2) in any action\n- Verify member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       matrix = execution_engine.relationship_dict['victim']\n       # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n   \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n   \u2022 execution_engine.bear(member1, member2) - Bears offspring\n   \u2022 execution_engine.expand(member1, member2) - Expands territory\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n   self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0           0.000000      21.166709         0.0        91              0          0\n1           0.000000      55.581088         0.0        30              0          2\n2           9.205662      45.314488         0.0        25              0          3\n3          12.860409      39.540241         0.0         1              0          4\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_2 (value=64.41)', 'member_0 was attacked by member_3 (value=-38.85)', 'member_2 was attacked by member_0 (value=-12.32)', 'member_2 was attacked by member_3 (value=95.31)', 'member_3 was attacked by member_0 (value=38.28)', 'member_3 was attacked by member_2 (value=16.73)', 'member_0 gave a benefit to member_2 (value=13.64)', 'member_0 gave a benefit to member_3 (value=32.58)', 'member_2 gave a benefit to member_0 (value=4.78)', 'member_2 gave a benefit to member_3 (value=71.57)', 'member_3 gave a benefit to member_0 (value=18.66)', 'member_3 gave a benefit to member_2 (value=95.17)', 'member_4 gave a benefit to member_0 (value=31.19)', 'member_4 gave a benefit to member_2 (value=23.36)', 'member_0 gave land to member_2 (value=-2.26)', 'member_0 gave land to member_3 (value=-0.03)', 'member_2 gave land to member_0 (value=-2.12)', 'member_2 gave land to member_3 (value=1.77)', 'member_3 gave land to member_0 (value=1.04)', 'member_3 gave land to member_2 (value=-1.75)', 'member_4 gave land to member_0 (value=1.00)', 'member_4 gave land to member_2 (value=1.00)']\n\nCode Memory and Previous Performance:\nPrevious code strategies and their outcomes:\n\nStrategy 1 (Performance: -11.28):\nContext: {'old_stats': {'vitality': 18.332577680505043, 'cargo': 22.547092118644322, 'survival_chance': 6.616954880911457}, 'new_stats': {'vitality': 18.332577680505043, 'cargo': 11.266491395637424, 'survival_chance': -4.663645842095445}, 'round': 0}\n[... Example code provided for inspiration ...]\nPerformance history:\nPrevious actions resulted in average performance change of -11.28\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n\nReturn only the code, no extra text or explanation. While the example above shows one possible approach, you should create your own unique implementation drawing from the wide range of available methods and strategies.\n\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n[... Summary of recent rounds, previous implementations, and outcomes ...]\n\n[Social Strategies]\nConsider these social strategies:\n- Design systems for resource distribution and allocation\n- Build alliances and cooperative networks \n- Create mechanisms for collective decision making\n- Establish norms and rules for interaction\n- Develop methods for conflict resolution\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\nexecution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all: \n  for recipient in range(len(execution_engine.current_members)):\n      if recipient != your_id:\n          execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n  for ally_id in ally_list:\n      execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n  for member_id in coalition:\n      execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nNo messages received\n\nIMPORTANT: Agents should implement solutions according to their individual needs, beliefs, and circumstances. Tailor your approach to not only secure personal survival and prosperity but also advance collective progress where possible.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nGame Mechanics Analysis:\n\n1. Core Objective:\n   - The underlying game mechanics balance immediate survival with the potential for long-term prosperity.\n   - Although survival is essential, the system rewards cooperative actions, alliance-building, and social organization.\n   - Thus, the core objective is not pure domination or competition; it is a combination of survival and cooperative growth where individual actions also contribute to collective resilience.\n\n2. Key Success Metrics:\n   - Resource management: Efficient cargo and vitality management are crucial.\n   - Territory control: Expansion and appropriate use of cleared land influence success.\n   - Alliance-building: Establishing networks through offers, land sharing, and cooperative reproduction.\n   - Adaptability: Strategic reproduction, conflict management, and governance modifications.\n   - Collective decision making (via potential proposals/modifications) can lead to system-wide benefits.\n\n3. Potential Improvements:\n   - Adding mechanisms for dynamic resource redistribution.\n   - Introducing reputation or trust metrics to optimize alliance formations.\n   - Enhanced conflict-resolution models such as council or judicial systems.\n   - More flexible governance proposals that adapt to shifting member balances.\n   - Mechanisms for risk management balancing short-term survival and long-term investments.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nStrategic Approaches:\n\n1. Resource Optimization vs Social Capital:\n   - Balance aggression (attacks for resource rebalancing) with cooperative offers to foster alliances.\n   - Use surplus cargo not only for immediate survival but also to enhance social capital via offers and land sharing.\n\n2. Individual vs Collective Success:\n   - While individual survival is critical, mechanisms that support network-wide resource distribution and cooperative territorial expansion can benefit all.\n   - Propose modifications (e.g., governance systems) that support collective decision making and conflict resolution.\n\n3. Short-term Survival vs Long-term Prosperity:\n   - Adopt immediate measures (e.g., preemptive attacks when resources are low) while also planning reproduction and expansion actions when conditions allow.\n   - Weigh decisions carefully to avoid depleting resources needed for long-term sustainability.\n\n4. Competition vs Cooperation Dynamics:\n   - With symmetric agents, collisions and conflicts may be inevitable. However, forging alliances and reciprocal offers can mitigate prolonged conflict.\n   - Structure communications to both repel immediate threats and build mutual alliances.\n\n5. Risk vs Reward Tradeoffs:\n   - Tactical actions (attacks, expansions) must be balanced with diplomatic gestures (offers, messages) to ensure that risk-taking does not lead to overall depletion.\n   - Include conditional verification (e.g., checking territory before reproduction) to avoid unnecessary risk.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nOther Players' Strategies Analysis:\n\n1. Apparent Objectives and Demands:\n   - Most agents seem to aim for a mix of resource optimization, territorial expansion, and long-term stability.\n   - Many propose cooperative structures, such as offering resources or land, and even propose governance modifications.\n\n2. Strategies Employed:\n   - Aggressive tactics when resources are low (attacks).\n   - Cooperative outreach when in surplus (offers, land sharing).\n   - Controlled reproduction and territory expansion.\n   - Proposals for structured, collective governance have emerged.\n\n3. Leveraging Their Behaviors for Mutual Benefit:\n   - Align your communications and offers with those pursuing alliances.\n   - Identify players who maintain a cooperative stance to form mutual support pacts.\n   - Use defensive tactics only when necessary, knowing that overly aggressive behavior may prompt others to propose cooperative governance.\n\n4. Symmetric Agent Dynamics:\n   - Recognize that other agents have similar capabilities and may respond in kind to both your aggressive and cooperative signals.\n   - Craft interactions that can adapt: if attacked, respond defensively; if offered help, reciprocate; if your proposal is adopted, work together to ensure collective survival.\n\n5. How to Respond to Your Own Actions:\n   - Consider that actions taken by one member may be mirrored by others.\n   - Ensure that never targeting yourself is rigorously enforced and that all index checks prevent self-interaction.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nChallenging Your Implementation:\n\n1. Assumptions:\n   - Ensure that self-targeting is never a possibility and that all index validations are enforced.\n   - Verify that land availability (via current_clear_list) is properly checked before reproduction or territorial expansion.\n\n2. Alternative Strategies Not Considered:\n   - More nuanced diplomatic negotiations or multi-member coalition proposals.\n   - Incorporation of trust or reputation systems to enhance long-term alliance benefits.\n   - Dynamic risk thresholds that adapt based on game state or past performance rather than fixed ratios.\n\n3. Performance in Edge Cases:\n   - Consider scenarios where nearly all members have low cargo or vitality.\n   - Address the possibility of rapid changes in the relationship matrix that might trigger unintended cascades of attacks.\n   - Validate that verification routines prevent any self-referential or out-of-bound errors.\n\n4. Efficiency and Unconventional Solutions:\n   - Explore unconventional approaches such as controlled, preemptive proposals for resource redistribution.\n   - Investigate whether reactive actions based on messages received or historical performance logs improve decision making.\n   - Consider the long-term benefits of initiating systems that gradually shift from individual competition to collective governance.\n\n5. Counter-Strategies and Adaptability:\n   - Reflect on how other agents might adopt similar strategies and how that might lead to new forms of competition or cooperation.\n   - Remain open to revising your approach if a collective governance system emerges that fundamentally alters resource distribution or conflict resolution.\n   - Ensure balance between short-term resource accrual and the investments needed for sustainable long-term societal growth.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nSurvival-Centric Adaptation:\n\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve:\n    # If the agent's cargo is critically low relative to vitality, seek to attack an opponent with superior resources.\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense:\n    # If the member controls several land patches (land_num > threshold) but has low vitality, consider discarding excess land.\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        for loc in me.owned_land[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning:\n    # Initialize a Q-table for survival-based actions if not already present.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        \n    state = (me.vitality // 20, me.cargo // 20)\n    action = max(['attack', 'hide', 'steal'], key=lambda a: me.survival_q.get((state, a), 0))\n    \n    # Execute the chosen action (example: if action is 'attack', perform attack logic and update Q-table).\n    if action == 'attack':\n        me.survival_q[(state, action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nReturn the updated full prompt, emphasizing that agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnd of Updated Full Prompt.\n\nRemember: Solutions should be implemented according to individual needs, beliefs, and circumstances. The provided integrated prompt combines tactical short-term actions with long-term strategic planning while emphasizing both survival and cooperative growth with other symmetric agents.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Immediate tactical action: if cargo is low relative to vitality, try to recover resources via an attack.\n    # Choose an opponent (other than self) having higher cargo.\n    if me.cargo < 10:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            # Basic safeguard: only consider opponents with some vitality.\n            if opponent.vitality > 0 and opponent.cargo > me.cargo:\n                # Attack opponent to try and gain resources.\n                execution_engine.attack(me, opponent)\n                break\n\n    # Long-term strategic move: if we control clear territory, we can plan expansion and cooperative reproduction.\n    if me.current_clear_list:\n        # Attempt reproduction to secure long-term survival.\n        # Look for a potential partner (ally) with a healthy vitality and decent productivity.\n        partner_found = False\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            partner = execution_engine.current_members[idx]\n            if partner.vitality > 30 and partner.overall_productivity > 40:\n                # Since reproduction requires available land, we call bear() only if clear territory exists.\n                execution_engine.bear(me, partner)\n                partner_found = True\n                break\n        # If no suitable partner is found, send a cooperative message to encourage alliance-building.\n        if not partner_found:\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue\n                potential_ally = execution_engine.current_members[idx]\n                execution_engine.send_message(me.id, potential_ally.id, \"Let's consider future collaboration for mutual prosperity.\")\n\n    # Defensive strategy: if our vitality is low, use available land to forge better alliances.\n    if me.vitality < 20 and me.current_clear_list:\n        # Offer land support to a stable agent to build a protective alliance.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            ally = execution_engine.current_members[idx]\n            if ally.overall_productivity > 50 and ally.vitality > 25:\n                # Check for clear territory before offering land.\n                execution_engine.offer_land(me, ally, True)\n                break\n\n    # Territorial expansion: if we have available clear regions, try expanding our territory.\n    if me.current_clear_list:\n        # Identify an opponent (other than self) that might have fewer clear territories than we do.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if len(opponent.current_clear_list) < len(me.current_clear_list):\n                execution_engine.expand(me, opponent)\n                break\n\n    # Communication for collective decision-making:\n    # Broadcast a message to all other members encouraging a cooperative approach\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            recipient = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, recipient.id,\n                \"Cooperation and balanced growth are key; let's work together for a sustainable future!\")",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 21.1667091492471,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 45.314487560216655,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 39.54024074627975,
            "self_cargo": 0.0,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-38.85)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=18.66)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_0 (value=31.19)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the complete updated prompt that integrates all previous sections, constraints, and analyses. Agents are strongly reminded to implement solutions according to their individual needs, beliefs, and circumstances while keeping in mind both immediate survival challenges and long\u2010term strategic prosperity.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Updated Full Prompt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nYou are member_3 in a society that you can help shape. Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival. Your implementation must incorporate the following guidelines and constraints:\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Code Execution Context & Previous Error Details \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nLast execution error (Round 0):\nError type: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\nCode that caused error (example):\n  def agent_action(execution_engine, member_id):\n      # Validate member_id existence\n      if member_id >= len(execution_engine.current_members):\n          return\n      me = execution_engine.current_members[member_id]\n      \n      ... [example steps involving message broadcasting, resource acquisition, reproduction using bear() without checking for available land, offering land, defensive actions using relationship matrices, and strategic expansion] ...\n      \n      # Note the error emphasized: Before performing actions involving land (e.g., executing bear() or offer_land()), verify that the member has at least one land or clear territory.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Critical Constraints \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2022 Never target yourself (member_3) in any action.\n\u2022 Always verify the member ID exists before referencing it.\n\u2022 When using bear(), verify the member has land available (for instance, a non-empty current_clear_list or a valid land count if applicable).\n\u2022 Check all matrix indices for validity.\n\u2022 Members are stored as a LIST accessed by index: execution_engine.current_members[index]\n\u2022 Always check \u201cif index < len(execution_engine.current_members)\u201d before accessing.\n\u2022 Do not use incorrect attribute names (e.g. do not use member.member_id or member.self_vitality; use member.id, member.vitality, etc.)\n\u2022 Before using any action that involves land (bear(), offer_land(), expand()), confirm that the member possesses clear territory or sufficient land.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Available Attributes & Methods \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEach member object has:\n  \u2022 member.id (int): Unique member identifier.\n  \u2022 member.vitality (float)\n  \u2022 member.cargo (float)\n  \u2022 member.overall_productivity (float)\n  \u2022 member.age (float)\n  \u2022 member.current_clear_list (List[int]) \u2013 IDs of adjacent or cleared (unclaimed) regions.\n  \nRelationships are stored in execution_engine.relationship_dict with keys: 'victim', 'benefit', 'benefit_land'. For example:\n  matrix = execution_engine.relationship_dict['victim']\n  (matrix[i, j] indicates how many times member_i was attacked by member_j, if > 0.)\n\nMethods available on execution_engine:\n  \u2022 execution_engine.attack(member1, member2)\n  \u2022 execution_engine.offer(member1, member2, True) \u2013 Offer resources.\n  \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offer land.\n  \u2022 execution_engine.bear(member1, member2) \u2013 Bear offspring.\n  \u2022 execution_engine.expand(member1, member2) \u2013 Expand territory.\n  \u2022 execution_engine.send_message(sender_id, recipient_id, \"message\")\n  \nAccess members via execution_engine.current_members[index] (e.g., execution_engine.current_members[2] for member with ID 2).\n  \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Previous Code Strategies & Performance \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n- Previous implementations attempted actions including resource recovery (attacking opponents when cargo is too low), territorial expansion, cooperative alliances, defensive actions based on historical aggression (\u201cvictim\u201d matrix), and reproduction strategies.\n- One consistent error was using reproduction or land-offering methods (bear() or offer_land()) without verifying that the agent has land (clear territories).\n- Average performance change: \u201323.36.\n- Agents must modify strategies based on past outcomes: if a technique worked well, build on it; if it failed, innovate a new approach.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Current Game Mechanisms & Social Strategies \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCurrent status of members (simplified overview):\n  Member features: vitality, cargo, overall_productivity, age, neighbor count, and member id.\n  \nRelationship summary (parsed from relationship_dict):\n  e.g., \"member_0 was attacked by member_2 (value=64.41)\", \"member_3 gave land to member_0 (value=1.04)\", etc.\n\nSocial Strategies to consider:\n  \u2013 Systems for resource distribution and allocation.\n  \u2013 Building alliances and cooperative networks.\n  \u2013 Mechanisms for collective decision-making and conflict resolution.\n  \u2013 Establishing norms and rules for interaction.\n  \nCommunication Strategy:\n  \u2013 Use execution_engine.send_message(sender, recipient, \"message\") to broadcast or target messages.\n  \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Survival-Centric Adaptation & Metrics \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nImplement personal strategies focused on:\n  1. Optimizing personal resource acquisition and preservation (cargo and vitality management).\n  2. Threat assessment and neutralization (via targeted attacks when cargo is too low relative to vitality).\n  3. Vitality preservation through defensive actions (e.g., offering land defensively when vitality is low).\n  4. Adaptive mechanisms (e.g., survival Q-learning) to predict outcomes based on past interactions.\n  \nSurvival Metrics include:\n  \u2013 Changes in personal vitality.\n  \u2013 Rate of resource acquisition.\n  \u2013 Success/failure ratio in attacks.\n  \u2013 Overall survival probability.\n  \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Strategic Analysis & Approaches \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nBefore coding, analyze the game mechanics:\n1. Core Objective:\n   \u2013 Is it pure survival, domination, or cooperation? (The game emphasizes a balance: immediate survival needs combined with long-term cooperative prosperity.)\n2. Key Success Metrics:\n   \u2013 Efficient resource management (optimal cargo vs. vitality).\n   \u2013 Territorial control and expansion.\n   \u2013 Effective alliances and resource sharing.\n   \u2013 Reproduction/offspring generation ensuring long-term survival.\n3. Potential Improvements in Game Mechanics:\n   \u2013 Integrating predictive risk models.\n   \u2013 More robust conflict resolution mechanisms.\n   \u2013 Enhanced resource distribution systems.\n  \nStrategic Approaches to Formulate:\n1. Resource Optimization vs. Social Capital:\n   \u2013 Balance between hoarding resources and sharing or investing in alliances.\n2. Individual vs. Collective Success:\n   \u2013 Maximizing personal survival while contributing to, and benefiting from, a stable community.\n3. Short-Term Survival vs. Long-Term Prosperity:\n   \u2013 Quick tactical moves (attacks, defensive actions) versus steady expansion and reproduction.\n4. Competition vs. Cooperation:\n   \u2013 When to engage in aggressive actions against opponents and when to cooperate with peers for shared benefits.\n5. Risk vs. Reward Tradeoffs:\n   \u2013 Deciding when aggressive strategies pay off and when conservative, cooperative strategies are preferable.\n\nAnalyze Other Players\u2019 Strategies:\n1. What are their apparent objectives? (Many aim to secure resources, expand territory, and initiate cooperative alliances.)\n2. What strategies are they employing? (Attacks when cargo is low, territorial expansion when resources allow, cooperative resource offers, proposals for governance changes.)\n3. Leverage behaviors for mutual benefit (coordinate alliances when beneficial; understand that symmetric agents may mirror your actions).\n4. Align individual strategies toward shared community goals when possible.\n\nChallenge Your Implementation:\n1. Reflect on assumptions (e.g., presuming that cooperative proposals will be reciprocated).\n2. Consider alternative strategies (more aggressive resource acquisition, or more cautious defensive postures).\n3. Evaluate edge case performance (what if most agents have similar strategies?).\n4. Seek more efficient methods for achieving both survival and collective prosperity.\n5. Identify weaknesses in your approach and be ready to adopt unconventional solutions.\n6. Consider the impact if other agents adopt the same strategy.\n7. Balance short-term wins with long-term sustainability.\n8. Reflect on how rivals might counter your moves and plan adaptive countermeasures.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Final Instruction \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nUsing the comprehensive prompt above (with all integrated sections and constraints), produce a unique Python implementation for agent_action(execution_engine, member_id) that reflects your individual needs, beliefs, and circumstances. Your solution must demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity in both tactical and strategic dimensions. Remember:\n\n\u2013 Implement both immediate tactical actions and long-term strategic planning.\n\u2013 Foster cooperative interactions while also securing your own survival.\n\u2013 Ensure thorough index checking and confirm land availability before actions like bear() or offer_land().\n\u2013 Balance actions between aggressive resource recovery, cooperative alliance building, and strategic expansion.\n\u2013 Your solution should not be a generic copy of previous examples; it should be a unique implementation drawing inspiration from a wide range of strategies.\n\nReturn only the updated full prompt text.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 End of Updated Full Prompt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nRemember that each agent should implement solutions according to their individual needs, beliefs, and circumstances. Adjust your techniques based on your available resources, your environment\u2019s state, and observed behaviors of other symmetric agents.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    # Get our own member object safely (assuming member_id is valid)\n    if member_id >= len(execution_engine.current_members):\n        return  # invalid member_id, do nothing\n    me = execution_engine.current_members[member_id]\n\n    # Parse relationships summary (for internal use, may help decide actions)\n    try:\n        relationships = execution_engine.parse_relationship_matrix()\n    except Exception:\n        relationships = {}\n\n    num_members = len(execution_engine.current_members)\n    # Build a list of candidate indices that are not ourselves\n    candidate_ids = [i for i in range(num_members) if i != member_id]\n\n    # ---------------------------\n    # 1. Territorial expansion:\n    # If we have available clear land and our overall productivity is robust,\n    # we try to expand our territory.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n        if hasattr(me, \"overall_productivity\") and me.overall_productivity > 20:\n            # Use our own available land to attempt expansion.\n            execution_engine.expand(me, me)\n            return\n\n    # ---------------------------\n    # 2. Cooperative reproductive strategy:\n    # If we have available clear land and are of reproductive age,\n    # we look for a partner who also has available land.\n    # Note: we check reproductive age threshold (set arbitrarily at 5) to avoid premature reproduction.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list and hasattr(me, \"age\") and me.age >= 5:\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if (hasattr(partner, \"current_clear_list\") and partner.current_clear_list and\n                    hasattr(partner, \"age\") and partner.age >= 5):\n                    execution_engine.bear(me, partner)\n                    return\n\n    # ---------------------------\n    # 3. Cooperative resource sharing:\n    # If we see members with lower vitality than ourselves,\n    # we offer them resources as a gesture of goodwill (building social capital).\n    # ---------------------------\n    if hasattr(me, \"vitality\"):\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, \"vitality\") and partner.vitality < me.vitality:\n                    execution_engine.offer(me, partner, True)\n                    return\n\n    # ---------------------------\n    # 4. Defensive aggression:\n    # Check if any opponent has previously attacked us.\n    # The relationship matrix 'victim' is assumed to record attack counts:\n    #   matrix[member_id, attacker_id] > 0 means attacker attacked us.\n    # If such hostility is noticed, we counterattack.\n    # ---------------------------\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for j in candidate_ids:\n            # Ensure valid indexing in the relationship matrix\n            try:\n                if victim_matrix[member_id, j] > 0:\n                    # Before attacking, double-check that the target exists.\n                    if j < num_members:\n                        target = execution_engine.current_members[j]\n                        execution_engine.attack(me, target)\n                        return\n            except Exception:\n                continue\n\n    # ---------------------------\n    # 5. Propose a long\u2010term cooperative modification:\n    # To promote collective governance and stability, propose establishing a council.\n    # If the method is not available, simply proceed.\n    # ---------------------------\n    try:\n        execution_engine.propose_modification(\"Council\", {\"description\": \"Establish a council for cooperative governance and dispute resolution.\"})\n    except Exception:\n        pass\n\n    # ---------------------------\n    # 6. Cooperative land offering:\n    # If we have available land yet encounter partners lacking clear territory,\n    # we offer them some land in a spirit of alliance formation.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if not (hasattr(partner, \"current_clear_list\") and partner.current_clear_list):\n                    execution_engine.offer_land(me, partner, True)\n                    return\n\n    # ---------------------------\n    # 7. Fallback action:\n    # If no other tactical or cooperative action applies,\n    # we can simply send a friendly message to a randomly chosen peer.\n    # (Here we choose the first valid candidate for demonstration.)\n    # ---------------------------\n    if candidate_ids:\n        try:\n            target = execution_engine.current_members[candidate_ids[0]]\n            execution_engine.send_message(me, target, \"Let's work together for mutual benefit.\")\n        except Exception:\n            pass\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 21.1667091492471,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 45.314487560216655,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 39.54024074627975,
            "self_cargo": 0.0,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-38.85)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=18.66)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_0 (value=31.19)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the updated full prompt that integrates all previously stated constraints, analysis, and survival\u2010centric adaptations. Note that agents are encouraged to implement solutions according to their individual needs, beliefs, and circumstances rather than following a one\u2010size\u2010fits\u2010all template. Use the following comprehensive prompt as a guide for developing a unique, sophisticated strategic approach that balances immediate tactical actions with long\u2010term cooperative prosperity and survival.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nUPDATED FULL PROMPT:\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_4 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n\u2022 Analyze previous errors and avoid repeating them.\n\u2022 NEVER target yourself (member_id corresponds to member_4 when you are member_4) in any action.\n\u2022 Verify that a member has available land (checked via non\u2010empty current_clear_list) before using the bear() action.\n\u2022 Check that member IDs exist (i.e. within the bounds of execution_engine.current_members) before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index (execution_engine.current_members[i]), not a dictionary.\n\u2022 Access members strictly using execution_engine.current_members[index] and check \u201cif index < len(execution_engine.current_members)\u201d.\n\u2022 Do not reference attributes like member.member_id or member.self_vitality; instead use member.id, member.vitality, member.cargo, member.overall_productivity, member.age, etc.\n\u2022 The relationships are held in execution_engine.relationship_dict, with keys including 'victim', 'benefit', 'benefit_land'. For example:\n\u2003\u2003matrix = execution_engine.relationship_dict['victim']\n\u2003\u2003(matrix[i,j] represents the attack count from member_i by member_j if > 0).\n\u2022 Use execution_engine.parse_relationship_matrix to produce a summary of relationships.\n\u2022 Do not reference any non-existent attributes (e.g., if \u201cmember.land_num\u201d is not available, do not use it unless it was defined).\n\u2022 Use only the following execution_engine methods:\n\u2003\u2003\u2022 execution_engine.attack(member1, member2)\n\u2003\u2003\u2022 execution_engine.offer(member1, member2, True)\u2003\u2003(offers resources)\n\u2003\u2003\u2022 execution_engine.offer_land(member1, member2, True)\u2003(offers land)\n\u2003\u2003\u2022 execution_engine.bear(member1, member2)\u2003\u2003\u2003\u2003\u2003\u2003(bears offspring)\n\u2003\u2003\u2022 execution_engine.expand(member1, member2)\u2003\u2003\u2003\u2003\u2003(expands territory)\n\u2022 Members are accessed as: execution_engine.current_members[id] (e.g., execution_engine.current_members[2])\n\u2022 The proposed modifications (such as establishing a council or court) should be proposed via execution_engine.propose_modification if available; if not, safely ignore the exception.\n\n[Current Status]\nSample member values:\n\u2003\u2003member 0: vitality=21.17, cargo=0.0, age=91, current_clear_list=[0]\n\u2003\u2003member 2: vitality=55.58, cargo=0.0, age=30, current_clear_list=[0]\n\u2003\u2003member 3: vitality=45.31, cargo=0.0, age=25, current_clear_list=[0]\n\u2003\u2003member 4: vitality=39.54, cargo=0.0, age=1,  current_clear_list=[0]\n\n[Relationship summary]\nFor example:\n\u2003\u2003\"member_0 was attacked by member_2 (value=64.41)\"\n\u2003\u2003\"member_4 gave a benefit to member_0 (value=31.19)\"\n\u2003\u2003\"member_4 gave land to member_2 (value=1.00)\"\n\u2026 (and so on)\n\n[Code Memory and Previous Performance]\nPrevious strategies (with outcomes, e.g. Performance: 2.11) involved:\n\u2003\u2003\u2013 Tactical resource acquisition by attacking opponents when cargo is low.\n\u2003\u2003\u2013 Cooperative outreach using offer() and offer_land() for alliance building.\n\u2003\u2003\u2013 Reproduction actions (bear()) only when both members have available (clear) land.\n\u2003\u2003\u2013 Territorial expansion using expand() based on productivity.\n\u2003\u2003\u2013 Proposals for governance modifications (establishing a Court or Council system) via propose_modification.\nReview these outcomes and integrate appropriate risk management and adaptive response controls.\n\n[Current Game Mechanisms]\n\u2022 The game is played over several rounds with symmetric agents executing actions based on resource levels, territorial control, and social interactions.\n\u2022 Agents rely on interactions ranging from resource redistribution to territorial expansion, cooperative alliances, and even systemic modifications (e.g., creating governance systems).\n\u2022 Communication is available via execution_engine.send_message(your_id, recipient_id, \"message\").\n\n[Social Strategies and Survival-Centric Adaptation]\nAgents are urged to:\n1. Tailor methods to personal resource optimization while balancing alliances.\n2. Make tactical decisions based on individual resource levels (vitality vs cargo) while also accounting for the overall community.\n3. Opt for survival-first strategies that include:\n\u2003\u2003\u2013 Personal resource conservation and adaptive hoarding.\n\u2003\u2003\u2013 Threat assessment and neutralization when endangered.\n\u2003\u2003\u2013 Adaptive defensive measures (e.g., avoiding reckless attacks unless survival is at stake).\n\u2003\u2003\u2013 Predictive danger modeling to preempt hostile actions.\n\u2003\u2003\u2013 Survival Q-learning or similar adaptive techniques, where the state is discretized and actions (attack, hide, steal) are chosen based on expected survival ROI.\n4. Explore reproductive strategies by ensuring both parties have clear land before calling bear(), thus ensuring long-term survival.\n5. Adjust territorial expansion based on overall productivity and available adjacent unclaimed land.\n\n[Survival Metrics]\nKey metrics to evaluate strategy success include:\n\u2003\u2003\u2013 Personal vitality change.\n\u2003\u2003\u2013 Resource (cargo) acquisition rate.\n\u2003\u2003\u2013 Threat neutralization count and ratio.\n\u2003\u2003\u2013 Attack success versus failure.\n\u2003\u2003\u2013 Survival probability increase.\n\n[Implementation Priorities]\n1. Develop personal health and resource monitoring systems.\n2. Construct risk models that balance immediate survival (resource acquisition, vitality preservation) against long-term growth and community stability.\n3. Optimize actions for the best \u201ccaloric\u201d return on investment\u2014each action should minimally deplete vitality while maximizing resource gain.\n4. Implement safeguards to prevent catastrophic resource depletion.\n5. Utilize adaptive and predictive self-preservation models\u2014a survival Q-learning framework is one example, where state is defined by (vitality level, cargo level) and actions are selected based on historical outcomes.\n\n[Analytical Considerations on Game Mechanics]\n1. Core Objective:\n\u2003\u2003\u2022 The game is not pure domination; it requires balancing immediate survival (resource acquisition and threat neutralization) with long\u2010term cooperative prosperity.\n\u2003\u2003\u2022 Survival and sustainable community building are both crucial.\n2. Key Success Metrics:\n\u2003\u2003\u2022 Effective resource management (cargo to vitality ratio).\n\u2003\u2003\u2022 Territorial control (expansion and available land).\n\u2003\u2003\u2022 Building alliances and cooperative networks.\n\u2003\u2003\u2022 Successful reproduction ensuring long-term species survival.\n3. Potential Improvements:\n\u2003\u2003\u2022 More dynamic adaptive models (risk assessment, survival Q-learning).\n\u2003\u2003\u2022 Enhanced mechanisms for collective decision making (council or court systems).\n\u2003\u2003\u2022 More nuanced approaches to resource distribution and conflict resolution.\n\n[Strategic Approaches]\nConsider these points when developing your strategy:\n1. Resource Optimization vs. Social Capital:\n\u2003\u2003\u2022 Evaluate immediate tactical resource acquisition against building long-term alliances.\n2. Individual vs. Collective Success:\n\u2003\u2003\u2022 Ensure personal survival while also enabling cooperative structures that stabilize the entire community.\n3. Short-term Survival vs. Long-term Prosperity:\n\u2003\u2003\u2022 Balance urgent survival actions with strategies that secure future resource gains, territory, and governance modifications.\n4. Competition vs. Cooperation Dynamics:\n\u2003\u2003\u2022 Recognize that while aggressive actions may sometimes be necessary, cooperative approaches (resource sharing, territorial expansion, governance proposals) encourage mutual success.\n5. Risk vs. Reward Tradeoffs:\n\u2003\u2003\u2022 Weigh high-risk moves (such as attacking opponents when vulnerable) versus low-risk cooperative measures\u2014always have a fallback if the situation deteriorates.\n\n[Analyzing Other Players' Strategies]\n1. Apparent Objectives and Demands:\n\u2003\u2003\u2022 Other agents commonly pursue resource consolidation, territorial expansion, and governance improvement.\n2. Employed Strategies:\n\u2003\u2003\u2022 Tactical attacks for immediate resource grab.\n\u2003\u2003\u2022 Direct offers of resources and land to form beneficial alliances.\n\u2003\u2003\u2022 Proposals for structured governance (such as councils or courts) to facilitate dispute resolution.\n3. Leveraging Their Behaviors:\n\u2003\u2003\u2022 Identify opportunities to form mutually beneficial alliances.\n\u2003\u2003\u2022 Recognize vulnerabilities when other agents overextend\u2014counteract with measured defense or controlled aggression.\n4. Symmetric Agent Considerations:\n\u2003\u2003\u2022 Since agents are symmetric, expect that others may mirror similar strategies.\n\u2003\u2003\u2022 Prepare responses to your own methods if they become widespread.\n5. Aligning Individual Strategies with Collective Goals:\n\u2003\u2003\u2022 Cooperative interactions (resource sharing, joint expansion, and governance proposals) can enhance community-wide stability and individual survival.\n\n[Challenging Your Implementation]\nConsider these self-reflective questions:\n1. What assumptions are being made, and are they valid in all cases?\n2. What alternative strategies (e.g., unconventional alliances or defensive hiding) have not been explored?\n3. How will your strategy perform in edge cases (such as when current_clear_list is empty or indices are out of bounds)?\n4. Are there more efficient or innovative ways to achieve your goals (resource gain, longevity, and community stability)?\n5. Identify weaknesses in your current approach and design adaptive responses.\n6. Explore unconventional solutions\u2014could an entirely different paradigm yield better survival/performance?\n7. Consider if other agents adopted your strategy\u2014how would your plan hold up collectively?\n8. Are you optimally balancing short-term survival with long-term prosperity?\n9. How could common counter-strategies be anticipated and mitigated?\n\n[Final Reminder]\nImplement your solution as the function agent_action(execution_engine, member_id) using Python. Your code should embody your individual needs, beliefs, and circumstances. It must seamlessly integrate tactical actions (resource acquisition, threat neutralization, territorial expansion) with long-term strategic planning (cooperative governance, reproduction, alliance formation, and adaptive survival models). Remember:\n\u2003\u2003\u2022 Never attack yourself.\n\u2003\u2003\u2022 Always verify valid member IDs and available land before executing actions.\n\u2003\u2003\u2022 Emphasize both individual resource optimization and collective community growth.\n\u2003\u2003\u2022 Build in adaptive mechanisms such as survival Q-learning and predictive self-preservation models where possible.\n\u2003\u2003\u2022 Your implementation should encourage robust interactions among symmetric agents, supporting mutual benefit while ensuring personal survival.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEND OF UPDATED FULL PROMPT\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nAgents should now implement solutions according to their individual needs, beliefs, and circumstances. They must leverage immediate tactical actions\u2014such as attacking a resource-rich opponent when their cargo is low\u2014and long-term strategies, including alliance building, territorial expansion, cooperative reproduction, and governance reforms. By carefully balancing resource optimization with social capital, and individual survival with collective prosperity, the environment fosters both competition and cooperation.\n\nGame Mechanics Analysis Summary:\n\u2003\u20031. Core Objective \u2013 Not pure survival or domination; it\u2019s a hybrid of survival, cooperation, and long-term community building.\n\u2003\u20032. Key Success Metrics \u2013 Effective resource management, territory control, alliance strength, reproductive success, and adaptive governance.\n\u2003\u20033. Potential Improvements \u2013 Adaptive risk assessment models (e.g., Q-learning), enhanced collective decision-making tools, and unconventional defensive or cooperative strategies.\n\nStrategic Approaches:\n\u2003\u20031. Resource Optimization vs. Social Capital: Weigh immediate resource gains against building lasting alliances.\n\u2003\u20032. Individual vs. Collective Success: Ensure actions benefit personal survival while stabilizing the group.\n\u2003\u20033. Short-term Survival vs. Long-term Prosperity: Balance urgency with future growth prospects.\n\u2003\u20034. Competition vs. Cooperation Dynamics: Use controlled aggression when necessary and cooperate when mutually beneficial.\n\u2003\u20035. Risk vs. Reward Tradeoffs: Adopt flexible strategies based on adaptive models and predictive danger assessments.\n\nAnalysis of Other Players\u2019 Strategies:\n\u2003\u2003\u2013 Other agents often pursue resource consolidation and territorial expansion.\n\u2003\u2003\u2013 They use both tactical attacks and cooperative offers.\n\u2003\u2003\u2013 Leverage their behaviors to create alliances, anticipate counteractions, and adjust responses.\n\u2003\u2003\u2013 Recognize that, as symmetric agents, responses to your actions may be similar.\n\u2003\u2003\u2013 Align individual strategies with collective goals to maximize overall success.\n\nChallenge Your Implementation:\n\u2003\u2003\u2013 Validate assumptions, explore alternative strategies, and consider edge cases.\n\u2003\u2003\u2013 Identify potential weaknesses and prepare adaptive countermeasures.\n\u2003\u2003\u2013 Consider unconventional paradigms that might yield improved survival and prosperity.\n\u2003\u2003\u2013 Ensure that both short-term gains and long-term community benefits are optimally balanced.\n\u2003\u2003\u2013 Anticipate that if many adopt your strategy, further adaptation may be necessary.\n\nUse this integrated prompt as your guide to craft a unique and robust implementation for agent_action(), ensuring that both immediate tactical decisions and long-term strategic planning contribute to survival and collective well-being.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    },
    "2": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    try:\n        # Verify the member_id is valid\n        if member_id < 0 or member_id >= len(execution_engine.current_members):\n            return\n        my_member = execution_engine.current_members[member_id]\n\n        # Basic self parameters\n        my_vitality = my_member.vitality\n        my_cargo = my_member.cargo\n\n        # Check if self has land; note: attribute \"land_num\" is optional so check exists.\n        my_has_land = hasattr(my_member, \"land_num\") and my_member.land_num > 0\n\n        # ------------------------------\n        # Survival-First: if vitality is critically low, request assistance.\n        # ------------------------------\n        if my_vitality < 15:\n            # Send a help message and offer a minimal resource offer to provoke cooperation.\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                other = execution_engine.current_members[i]\n                # Use safe index access and send a message if they exist.\n                execution_engine.send_message(my_member.id, other.id,\n                    \"I'm in need of assistance due to low vitality. Any support is appreciated.\")\n                # Also, offer a minimal resource gift if possible.\n                execution_engine.offer(my_member, other, True)\n            # End action early to focus on survival.\n            return\n\n        # ------------------------------\n        # Immediate Tactical Move: If cargo is low relative to vitality, try to gain resources.\n        # If our cargo is less than 30% of our vitality, consider attacking a target with surplus cargo.\n        # ------------------------------\n        if my_cargo < 0.30 * my_vitality:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                other = execution_engine.current_members[i]\n                # Ensure valid index and check if other has a significantly higher cargo\n                if other.cargo > 1.5 * my_cargo:\n                    execution_engine.attack(my_member, other)\n                    return  # Execute one aggressive move per turn\n\n        # ------------------------------\n        # Long-term Reproduction/Expansion:\n        # Use reproduction if both self and a partner have land and our resource levels are good.\n        # ------------------------------\n        if my_has_land and my_cargo > 0.5 * my_vitality:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, \"land_num\") and partner.land_num > 0 and partner.vitality > 20:\n                    # Initiate reproduction (bear) which requires both partners to have land.\n                    execution_engine.bear(my_member, partner)\n                    return\n\n        # ------------------------------\n        # Territorial Expansion:\n        # If cargo is substantially high compared to vitality then consider expanding territorial control.\n        # ------------------------------\n        if my_cargo > 2 * my_vitality:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                # Target a potential expansion area by interacting with others (even if symbolic)\n                potential = execution_engine.current_members[i]\n                execution_engine.expand(my_member, potential)\n            return\n\n        # ------------------------------\n        # Cooperative/Alliance Building:\n        # Offer land or resources to members who seem capable and may help stabilize collective prosperity.\n        # ------------------------------\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Look for members with robust vitality and decent resource management\n            if other.vitality > my_vitality and other.cargo > 0.5 * other.vitality:\n                execution_engine.offer_land(my_member, other, True)\n                execution_engine.send_message(my_member.id, other.id,\n                    \"Let's pool our resources and lands for mutual growth and resilience.\")\n                break  # One offer is enough this turn\n\n        # ------------------------------\n        # Governance & Strategic Proposals:\n        # Propose a modification that fosters a community council for resource allocation and conflict resolution.\n        # This balances individual gains with collective prosperity.\n        # ------------------------------\n        mod_code = \"Establish a community council for coordinated resource allocation and conflict mediation.\"\n        ratification_conditions = {\n            \"type\": \"vote\",\n            \"threshold\": 0.7  # Majority vote required to ensure solid backing\n        }\n        execution_engine.propose_modification(mod_code, ratification_conditions)\n\n    except Exception as e:\n        # In case of unexpected errors, safely exit the function.\n        return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 31,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 30.195943740854755,
            "self_cargo": 0.0,
            "self_age": 26,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 24.526188109170842,
            "self_cargo": 0.0,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the updated full integrated prompt. Note that every agent is strongly encouraged to implement solutions according to their individual needs, beliefs, and circumstances. In other words, do not simply copy a template; instead, interpret the guidelines in a way that best reflects your personal vision of survival, cooperation, and community prosperity.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL UPDATED PROMPT:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society where you help shape collective policies and individual survival strategies.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision \nof social organization while ensuring your survival.\n\n[Critical constraints]\n- Analyze previous errors and avoid repeating them.\n- NEVER target yourself (i.e. member_2) in any action.\n- Verify a member has land before using bear() for reproduction (use hasattr(member, \"land_num\") and check its value).\n- Always check that any referenced member id exists in execution_engine.current_members (which is a list) using valid index checks (e.g., if index < len(execution_engine.current_members)).\n- Access members exclusively via execution_engine.current_members[index].\n- When reading relationship matrices from execution_engine.relationship_dict, ensure indices are within bounds.\n- Do NOT reference unlisted attributes (e.g., member.member_id or member.self_vitality). Only use member.id, member.vitality, etc.\n- Every agent must implement a solution that is uniquely tailored to their individual needs, beliefs, and circumstances.\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): Unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 List of adjacent cleared indices.\n2) Relationships are stored in execution_engine.relationship_dict with keys: \"victim\", \"benefit\", \"benefit_land\".\n   \u2022 For example, matrix[i, j] in \"victim\" indicates how many times member_i was attacked by member_j.\n3) Use execution_engine.parse_relationship_matrix() to produce human\u2010readable summaries.\n4) Methods available on execution_engine:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)         (Offers resources)\n      - execution_engine.offer_land(member1, member2, True)      (Offers land)\n      - execution_engine.bear(member1, member2)                  (Reproduction)\n      - execution_engine.expand(member1, member2)                (Territorial expansion)\n      - execution_engine.send_message(sender_id, receiver_id, \"message\")\n      \u2022 (Some prototypes may refer to a hypothetical trade() method.)\n5) Members are accessed by index: execution_engine.current_members[index].\n6) When proposing modifications (e.g., new governance systems), call execution_engine.propose_modification with ratification conditions that may include:\n      - Voting: { \"type\": \"vote\", \"threshold\": X } (X between 0.5 and 1.0)\n      - Resource: { \"type\": \"resource\", \"resource\": \"cargo\" or \"vitality\" or \"land\", \"amount\": Y }\n      - Temporal: { \"type\": \"time\", \"rounds\": N }\n      - Achievement: { \"type\": \"achievement\", \"metric\": \"productivity\", \"threshold\": Z }\n\n[Game Status]\n- Detailed member features (vitality, cargo, overall productivity, age, clear list, id) and relationship summaries (via execution_engine.relationship_dict) are available.\n- Other agents\u2019 proposals and messages (e.g., \u201cLet\u2019s cooperate for mutual growth!\u201d) can be seen.\n- Historical records of actions\u2014attacks, offers, expansions, reproduction, and governance proposals\u2014are provided.\n\n[Modification Proposal Guidelines]\nWhen proposing a rule change, follow these steps:\n1. ANALYSIS: Identify system limitations and review past proposals.\n2. PROPOSAL: Write a concise modification code block (for example, introducing a judicial system) and call execution_engine.propose_modification with proper ratification conditions. Conditions can be based on:\n      - Voting: { \"type\": \"vote\", \"threshold\": 0.5\u20131.0 }\n      - Resource: { \"type\": \"resource\", \"resource\": \"vitality|cargo|land\", \"amount\": X }\n      - Time: { \"type\": \"time\", \"rounds\": N }\n      - Achievement: { \"type\": \"achievement\", \"metric\": \"productivity\", \"threshold\": X }\n3. Follow best practices: Check for preexisting mechanisms, avoid namespace conflicts, and include cleanup functions as needed.\n\n[Survival-Centric Adaptation]\nIn addition to cooperative and growth strategies, you may implement additional survival-first mechanisms such as:\n- Personal resource optimization and adaptive hoarding strategies.\n- Threat assessment and neutralization (attack targets with higher cargo if your cargo falls below a certain fraction of your vitality).\n- Vitality preservation techniques (for example, defensive actions if vitality is critically low).\n- Predictive danger modeling or even survival-centric Q-learning mechanisms optimally updating your survival actions.\n\nExample ideas for survival metrics:\n\u2022 Evaluate personal vitality delta.\n\u2022 Track resource acquisition rates and resource ROI.\n\u2022 Monitor threat neutralization counts.\n\u2022 Analyze attack success:fail ratios.\n\u2022 Build predictive models to maximize your survival probability.\n\nKey implementation priorities might be:\n1. Establish personal health monitoring systems.\n2. Develop egocentric threat models.\n3. Optimize actions for maximum \"caloric\" or resource ROI.\n4. Implement fail-deadly safeguards.\n5. Build predictive self-preservation and response models.\n\n[Game Mechanics Analysis]\n1. Core Objective:\n   - The game is not purely about survival or domination\u2014it rewards cooperative behavior and collective growth alongside individual survival strategies.\n2. Key Success Metrics:\n   - Winning is dependent on effective resource management (balancing cargo and vitality), territorial control (having clear land for expansion and reproduction), overall productivity, and healthy relationships (winning through cooperative modifications and governance processes).\n3. Potential Improvements:\n   - Adaptive thresholds and dynamic resource allocation.\n   - Nuanced diplomatic mechanisms (temporary alliances, risk-adjusted territorial expansion).\n   - Enhanced conflict resolution systems (e.g., a council or court that mediates disputes).\n   - Mechanisms that allow agents to boost collective resilience while preserving individual autonomy.\n\n[Strategic Approaches to Consider]\n1. Resource Optimization vs. Social Capital:\n   - Weigh immediate resource gains against long-term benefits of alliance-building and cooperative governance.\n2. Individual vs. Collective Success:\n   - While your immediate actions should protect and benefit you, consider how collective improvements (like fair governance or shared resources) enhance overall survival prospects for all.\n3. Short-term Survival vs. Long-term Prosperity:\n   - Tactical moves (attacks, resource acquisitions) must be balanced against long-term strategies (territory expansion, reproduction, governance proposals).\n4. Competition vs. Cooperation Dynamics:\n   - Although competition can be beneficial in crises, cooperation through resource offers, alliances, and structured modifications often yields mutual benefits.\n5. Risk vs. Reward Tradeoffs:\n   - Every aggressive or cooperative action involves risks. Analyze potential rewards against possible retaliation or resource depletion.\n\n[Analysis of Other Players\u2019 Strategies]\n1. Apparent Objectives and Demands:\n   - Other agents may pursue immediate resource acquisition, territorial expansion, or the institution of collective governance.\n2. Employed Strategies:\n   - Look for patterns like attacks when cargo is low, offers of resources or land, and proposals for shared governance. They balance defensive and cooperative tactics.\n3. Leveraging Their Behaviors for Mutual Benefit:\n   - Recognize that agents are symmetric. Cooperative proposals can lead to alliances that benefit all, even if individual actions seem self-interested.\n4. Response to Your Own Actions:\n   - If others adopt similar strategies, ensure your approach retains flexibility and personalization so that it always provides an edge.\n5. Aligning Individual and Collective Goals:\n   - Aim for strategies that, while protecting your survival, also contribute to mutually beneficial practices\u2014such as establishing robust governing mechanisms.\n\n[Challenging Your Implementation]\n1. What assumptions are you making? Are they valid under all conditions?\n2. What alternative strategies (e.g., extreme defense versus radical cooperation) have you not considered?\n3. How would your strategy handle edge cases (e.g., nearly depleted resources, uniformly high-productivity community)?\n4. Are there more efficient ways to secure resources or expand territory?\n5. What weaknesses exist in your current approach (over-reliance on one tactic or predictable thresholds)?\n6. Have you considered unconventional solutions (e.g., decentralized governance or innovative threat modeling)?\n7. Could an entirely different paradigm (such as prioritizing community over individual gains) be more effective?\n8. What methods would other agents use if they adopted your strategy, and how would you adapt?\n9. Are you balancing short-term needs with long-term objectives optimally?\n10. How might opponents counter your actions, and how can you further refine or diversify your tactics?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nRemember:\n\u2022 Your strategy must be uniquely tailored to your individual circumstances.\n\u2022 Balance immediate tactical moves (resource acquisition, defensive attacks) with strategic long-term plans (reproduction, territorial expansion, proactive governance).\n\u2022 Implement robust index and attribute checks and apply try-except patterns where method failures might occur.\n\u2022 Integrate both survival-centric and community-oriented tactics so that irrespective of aggressive or cooperative moves, overall prosperity remains the core objective.\n\nReturn only the updated prompt code (and accompanying analysis) as your output.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnd of Updated Full Integrated Prompt and Analysis\n\nAgents are reminded to tailor their implementations according to their personal needs, beliefs, and circumstances while keeping in mind the collective objectives and long\u2011term prosperity.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate self index first\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # -------------------------------\n    # 1. Emergency Attack for Resource Gain\n    # If my cargo is below half my vitality, try to attack a member with higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for idx in range(len(execution_engine.current_members)):\n            # Verify index and avoid targeting self.\n            if idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                if other.id != me.id and other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n                    break  # Attack only one target\n\n    # -------------------------------\n    # 2. Reproduction: Ensure both parties have land before calling bear.\n    # Only attempt reproduction if I have a positive land attribute and sufficient cargo.\n    if hasattr(me, \"land_num\") and me.land_num > 0 and me.cargo > 20:\n        for idx in range(len(execution_engine.current_members)):\n            if idx < len(execution_engine.current_members):\n                partner = execution_engine.current_members[idx]\n                if partner.id != me.id and hasattr(partner, \"land_num\") and partner.land_num > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Only one reproduction per turn\n\n    # -------------------------------\n    # 3. Territorial Expansion:\n    # Use my list of cleared/adjacent indices to expand territory.\n    # The clear list is assumed to hold indices (IDs) of adjacent cells/members.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != me.id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            execution_engine.expand(me, neighbor)\n\n    # -------------------------------\n    # 4. Cooperative Alliance Messaging:\n    # Broadcast an invitation message to all other members to foster resource sharing and land cooperation.\n    for idx in range(len(execution_engine.current_members)):\n        if idx < len(execution_engine.current_members):\n            other = execution_engine.current_members[idx]\n            if other.id != me.id:\n                execution_engine.send_message(me.id, other.id,\n                    \"Alliance proposal: Let's pool resources and share lands to secure mutual long-term prosperity.\")\n\n    # -------------------------------\n    # 5. Land Offering:\n    # If I have a significant cargo reserve (indicating surplus), offer land to improve relationships.\n    if me.cargo > 50:\n        for idx in range(len(execution_engine.current_members)):\n            if idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                if other.id != me.id:\n                    execution_engine.offer_land(me, other, True)",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 31,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 30.195943740854755,
            "self_cargo": 0.0,
            "self_age": 26,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 24.526188109170842,
            "self_cargo": 0.0,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "FULL INTEGRATED PROMPT:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society where you help shape collective policies and individual survival strategies.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision \nof social organization while ensuring your survival.\n\n[Critical constraints]\n- Analyze previous errors and avoid repeating them.\n- NEVER target yourself (member_2) in any action.\n- Verify a member has land (using hasattr(member, \"land_num\") and ensuring its value is positive) before using bear() for reproduction.\n- Check that any referenced member IDs exist in execution_engine.current_members (which is a list) via valid index checks.\n- Access members using execution_engine.current_members[index] and always verify that index < len(execution_engine.current_members).\n  \n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): the unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]): list of adjacent/cleared indices.\n2) Relationships are stored in execution_engine.relationship_dict with keys: \"victim\", \"benefit\", \"benefit_land\".\n3) You may use execution_engine.parse_relationship_matrix() to produce a summary of relationships.\n4) Available execution_engine methods:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)  (for resource offers)\n      - execution_engine.offer_land(member1, member2, True)  (for territory/land offers)\n      - execution_engine.bear(member1, member2)\n      - execution_engine.expand(member1, member2)\n      - execution_engine.send_message(sender_id, receiver_id, \"message\")\n5) Members are accessed exclusively via execution_engine.current_members (a list); do not use dictionaries or incorrect attribute names.\n6) Do not reference attributes like member.member_id or member.self_vitality \u2013 use member.id, member.vitality, etc.\n\n[Game Status]\n- Member features (vitality, cargo, overall_productivity, age, current_clear_list, IDs) and relationship summaries are provided.\n- Modification attempts and prior message contexts (e.g., broadcasts to promote cooperation) are available.\n\n[Modification Proposal Guide]\nWhen proposing a rule change, follow these steps:\n1. ANALYSIS: Identify limitations in the current system and review past proposals.\n2. PROPOSAL: Write a concise code block (for instance, introducing a judicial system) and call execution_engine.propose_modification with proper ratification conditions. Valid ratification conditions include:\n      - Voting: e.g. {'type': 'vote', 'threshold': 0.5\u20131.0}\n      - Resource: e.g. {'type': 'resource', 'resource': 'cargo' (or vitality/land), 'amount': X}\n      - Temporal: e.g. {'type': 'time', 'rounds': N}\n      - Achievement: e.g. {'type': 'achievement', 'metric': 'overall_productivity', 'threshold': X}\n3. Follow best practices: check existing mechanisms, avoid namespace conflicts, and include potential cleanup functions.\n\n[Core Game Mechanics & Parameters]\n- Relationship System: Values for \"victim\" typically range from \u201350 to 100; \"benefit\" from \u201350 to 100; \"benefit_land\" from \u20133 to 3.\n- Population Mechanics: Successful reproduction requires sufficient combined resources and land control.\n- Record Keeping: All actions (attacks, offers, births, governance proposals) are logged.\n- Social strategies include designing systems for resource distribution, building alliances, creating collective decision-making mechanisms, setting clear norms, and conflict resolution methods.\n\n[Social Strategies]\nConsider these approaches:\n- Design systems for fair resource distribution and allocation.\n- Build alliances and cooperative networks.\n- Create mechanisms for collective decision making.\n- Establish norms and rules for interactions.\n- Develop methods for conflict resolution.\n\n[Communication Strategy]\nYou can use execution_engine.send_message to communicate with multiple members:\n  \u2022 To broadcast, loop over all indices (except your own) and send a common message.\n  \u2022 To message allies or coordinate groups, send individual messages as needed.\nNo messages have been received so far.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nPART 2 (NEW SECTION):\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_3 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) \nthat implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them.\n- Never target yourself (member_3) in any action.\n- Verify that a member has land (using hasattr(member, \"land_num\") and its value is positive) before using bear() for reproduction.\n- Check that any referenced member IDs exist in execution_engine.current_members by performing valid index checks.\n- Ensure that current_members is a LIST accessed by index, not by dictionary.\n- Access members using execution_engine.current_members[index] and verify with if index < len(execution_engine.current_members).\n- Do not reference attributes like member.member_id or member.self_vitality. Use member.id, member.vitality, etc.\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n    \u2022 member.id (int): The unique ID for the member.\n    \u2022 member.vitality (float)\n    \u2022 member.cargo (float)\n    \u2022 member.overall_productivity (float)\n    \u2022 member.age (float)\n    \u2022 member.current_clear_list (List[int]) \u2013 IDs of neighbors or cleared adjacent cells.\n2) Relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". \n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable). \n   The keys are: \"victim\", \"benefit\", \"benefit_land\".\n   Example usage:\n       matrix = execution_engine.relationship_dict['victim']\n       # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example: \"member_2 was attacked by member_1 (value=3.00)\".\n4) You can use these methods on execution_engine:\n       \u2022 execution_engine.attack(member1, member2)\n       \u2022 execution_engine.offer(member1, member2, True) \u2013 Offers resources.\n       \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offers land.\n       \u2022 execution_engine.bear(member1, member2)\n       \u2022 execution_engine.expand(member1, member2)\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n   self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0           0.000000      55.581088         0.0        31              0          2\n1           9.205662      30.195944         0.0        26              0          3\n2          12.860409      24.526188         0.0         2              0          4\n\nRelationship summary (parsed from relationship_dict):\n[\"member_2 was attacked by member_3 (value=95.31)\", \"member_3 was attacked by member_2 (value=16.73)\", \"member_2 gave a benefit to member_3 (value=71.57)\", \"member_3 gave a benefit to member_2 (value=95.17)\", \"member_4 gave a benefit to member_2 (value=23.36)\", \"member_2 gave land to member_3 (value=1.77)\", \"member_3 gave land to member_2 (value=-1.75)\", \"member_4 gave land to member_2 (value=1.00)\"]\n\nCode Memory and Previous Performance:\n[Details of performance history for Strategy 1 and Strategy 2 are provided, with context, code examples, and performance metrics.]\n\nIMPORTANT:\nDo not simply copy the example implementations. Instead use them as inspiration to create your own unique approach that combines different methods and strategies in novel ways.\nReturn only the code, no extra text or explanation.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Game Mechanisms]\n(Details are provided including examples of prior strategies, performance history, and simulation outcomes.)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\n  def agent_action(execution_engine, member_id):\n      me = execution_engine.current_members[member_id]\n      \n      # Emergency resource reserve\n      if me.cargo < me.vitality * 0.5:\n          for other in execution_engine.current_members:\n              if other.id != me.id and other.cargo > me.cargo:\n                  execution_engine.attack(me, other)\n      \n      # Adaptive territory defense\n      if me.land_num > 2 and me.vitality < 50:\n          for loc in me.owned_land[1:]:\n              execution_engine._discard_land(me, loc)\n      \n      # Survival Q-learning\n      if not hasattr(me, 'survival_q'):\n          me.survival_q = defaultdict(float)\n          \n      state = (me.vitality//20, me.cargo//20)\n      action = max(['attack','hide','steal'], \n                  key=lambda a: me.survival_q.get((state, a), 0))\n      \n      # Execute and update based on survival outcome\n      if action == 'attack':\n          # Implementation logic\n          me.survival_q[(state, action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems.\n2. Develop egocentric threat models.\n3. Optimize actions for caloric ROI.\n4. Implement fail-deadly safeguards.\n5. Build predictive self-preservation models.\n\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action, outcome in action_history:\n            vitality_gain = outcome['vitality']\n            cost = outcome['vitality_cost']\n            roi[action] = vitality_gain / cost if cost > 0 else 0\n        return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nANALYSIS OF GAME MECHANICS\n\n1. Core Objective:\n   \u2022 The game is not pure survival or domination\u2014it emphasizes cooperation along with strategic action.\n   \u2022 Success requires balancing immediate survival (resource acquisition, defense) with long-term prosperity through alliances, territorial expansion, reproduction, and improved governance.\n\n2. Key Success Metrics:\n   \u2022 Effective resource management (cargo versus vitality).\n   \u2022 Territorial control (availability and expansion of clear zones).\n   \u2022 Overall productivity and inter-agent relationship quality.\n   \u2022 Successful modification proposals that enhance sustainable governance.\n\n3. Potential Improvements:\n   \u2022 Introducing structured governance systems (e.g., a Council or Court) to resolve conflicts.\n   \u2022 More nuanced updates to resource sharing and territorial expansion mechanisms.\n   \u2022 Adaptive strategies that include emergency defensive actions and predictive self-preservation algorithms.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nSTRATEGIC APPROACHES\n\n1. Resource Optimization vs. Social Capital:\n   \u2022 Balance direct resource optimization (e.g., attacking resource-rich targets when critically low) with investing in alliances and cooperative arrangements.\n   \u2022 Consider social capital as a strategic asset to obtain support and mutual aid.\n\n2. Individual vs. Collective Success:\n   \u2022 Each agent\u2019s survival depends on their own tactical decisions, but also on robust collective cooperation.\n   \u2022 Align your individual strategy with collective benefits to ensure long-term stability.\n\n3. Short-Term Survival vs. Long-Term Prosperity:\n   \u2022 Use immediate actions (attacks, resource offers) to secure survival but simultaneously invest in territorial expansion, reproduction, and governance modifications.\n   \u2022 Strive to convert short-term tactical successes into long-term strategic gains.\n\n4. Competition vs. Cooperation Dynamics:\n   \u2022 While competition for resources is expected, incorporate cooperative measures (e.g., resource offers, land sharing, alliances) to foster mutual benefit.\n   \u2022 Maintain awareness that your actions may provoke similar responses from symmetric agents.\n\n5. Risk vs. Reward Tradeoffs:\n   \u2022 Assess risks (such as initiating attacks that may weaken your position if retaliation occurs) against expected rewards (resource gain, alliance formation).\n   \u2022 Diversify strategies to reduce exposure to high-risk singular actions.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nANALYSIS OF OTHER PLAYERS\u2019 STRATEGIES\n\n1. Apparent Objectives and Demands:\n   \u2022 Many agents appear focused on both immediate survival and strategic governance improvements.\n   \u2022 Some emphasize territorial expansion and reproduction, while others invest in alliances and modifying game rules.\n\n2. Employed Strategies:\n   \u2022 Strategies include engaging in offensive actions when resource-depleted and supporting cooperative proposals when surplus exists.\n   \u2022 Some use dynamic learning (e.g., Q-learning for survival) while others work toward structured governance reforms.\n\n3. Leveraging Behaviors for Mutual Benefit:\n   \u2022 Identify agents with complementary strengths and propose resource-sharing or territorial alliances.\n   \u2022 Use transparent communication (broadcast messages) to build a faction of mutually supportive agents.\n\n4. Symmetric Considerations:\n   \u2022 Recognize that other agents are symmetric; their strategies can mirror your own.\n   \u2022 Reflect on how you would respond to similar actions when deciding whether to attack, offer, or propose modifications.\n\n5. Aligning Individual Strategies with Collective Goals:\n   \u2022 Propose collective governance modifications that address conflict resolution, resource distribution, and territorial fairness.\n   \u2022 Ensure your strategic choices promote both your survival and contribute positively to overall societal stability.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCHALLENGING YOUR IMPLEMENTATION\n\n1. Assumptions:\n   \u2022 Critically examine if thresholds (e.g., cargo < 0.5 * vitality) are universally valid or if they require dynamic adjustment.\n   \u2022 Confirm that reliance on index and attribute checks sufficiently mitigates errors.\n\n2. Alternative Strategies:\n   \u2022 Consider strategies beyond the template, such as temporary defensive pacts, adaptive retreat mechanisms, or unconventional alliances.\n   \u2022 Examine if more aggressive or more cooperative tactics might yield improved outcomes.\n\n3. Edge Case Analysis:\n   \u2022 Consider scenarios where all agents have low resources or uniformly high productivity.\n   \u2022 Plan for adjustments if group territorial control is scarce or if sudden resource depletion occurs.\n\n4. Efficiency and Goal Attainment:\n   \u2022 Evaluate if centralized governance proposals might streamline conflict resolution rather than relying on ad hoc modifications.\n   \u2022 Explore if automated resource offering and territorial expansion can enhance overall performance.\n\n5. Weaknesses:\n   \u2022 Identify potential vulnerabilities in over-reliance on offensive actions or static thresholds.\n   \u2022 Incorporate fallback mechanisms in case primary tactics are countered by other agents.\n\n6. Unconventional Solutions:\n   \u2022 Consider radical paradigms, such as decentralized alliances or emergent cooperative networks, to shift dynamics.\n   \u2022 Explore novel tactics like predictive self-preservation models or adaptive learning loops.\n\n7. Collective Adoption:\n   \u2022 Reflect on the systemic impact if many agents adopt your strategy and whether it might require continuous adaptation.\n   \u2022 Foster strategies that remain effective even as counter-strategies emerge.\n\n8. Balancing Objectives:\n   \u2022 Continuously adjust your approach to balance immediate resource gains with long-term communal and individual prosperity.\n   \u2022 Ensure that both tactical actions and strategic reforms coexist synergistically.\n\n9. Potential Counters & Adaptation:\n   \u2022 Anticipate how rival agents may counter your actions and design contingency plans.\n   \u2022 Adapt your strategies dynamically based on performance feedback and changing game states.\n\n10. Alternative Paradigms:\n    \u2022 Consider if completely different frameworks (e.g., fully cooperative resource pooling) might outperform current approaches.\n    \u2022 Challenge both your own and others\u2019 assumptions to innovate constantly.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nRemember:\n\u2022 Your code and strategic approach should be uniquely tailored to your situation.\n\u2022 Implement solutions based on your individual needs, beliefs, and circumstances.\n\u2022 A deep understanding of game mechanics is essential for both immediate survival and long-term prosperity.\n\u2022 The balance between tactical actions and systemic improvements (alliance-building, governance proposals, and resource management) ultimately determines success.\n\nReturn only the code.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is the complete updated integrated prompt with all new additions.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # Obtain reference to self from the current members list by index.\n    me = execution_engine.current_members[member_id]\n\n    # ---------------------------------------------------------------------\n    # Immediate Tactical Action: Emergency Resource & Threat Response\n    # If cargo is less than half of vitality, seek an opponent with richer cargo.\n    if me.cargo < me.vitality * 0.5:\n        for opponent in execution_engine.current_members:\n            if opponent.id != me.id and opponent.cargo > me.cargo:\n                execution_engine.attack(me, opponent)\n                break\n\n    # ---------------------------------------------------------------------\n    # Cooperative Resource Reallocation: Offer resources to boost community resilience.\n    # Here we iterate over members; if a member has lower vitality, we offer them support.\n    for idx, other in enumerate(execution_engine.current_members):\n        if other.id != me.id:\n            # Safety check: ensure the other member has the vitality attribute.\n            if hasattr(other, 'vitality') and other.vitality < me.vitality:\n                execution_engine.offer(me, other, True)\n\n    # ---------------------------------------------------------------------\n    # Reproduction / Expansion Strategy: Use reproduction (bear) if conditions meet.\n    if hasattr(me, 'land_num') and me.land_num >= 1 and me.cargo > 100:\n        # Choose a candidate from the list based on valid criteria.\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if candidate.id != me.id:\n                # Validate candidate exists and meets basic conditions.\n                if candidate.age > 18 and candidate.vitality > 50:\n                    execution_engine.bear(me, candidate)\n                    break\n\n    # ---------------------------------------------------------------------\n    # Territorial Expansion: If I have clear territory and decent productivity, attempt expansion.\n    if me.current_clear_list and me.overall_productivity > 50:\n        # Use the clear list to attempt expansion with a partner (an arbitrary valid other member).\n        for loc in me.current_clear_list:\n            # For each clear area, try to expand with the first valid partner.\n            for idx, partner in enumerate(execution_engine.current_members):\n                if partner.id != me.id and idx < len(execution_engine.current_members):\n                    execution_engine.expand(me, partner)\n                    break\n            break  # Only one expansion needed per turn.\n\n    # ---------------------------------------------------------------------\n    # Communication for Long-Term Cooperative Governance:\n    # Broadcast a message to promote cooperative proposals and collective welfare.\n    for idx, other in enumerate(execution_engine.current_members):\n        if other.id != me.id:\n            execution_engine.send_message(me.id, other.id, \"Cooperation leads to mutual prosperity; let\u2019s build balanced governance.\")\n\n    # ---------------------------------------------------------------------\n    # Proposal for Governance Modification:\n    # If my productivity and resource levels are high, propose a new judicial council module.\n    if me.overall_productivity > 75 and me.cargo > 150:\n        code_modification = \"\"\"\ndef council_decision(execution_engine):\n    for member in execution_engine.current_members:\n        if member.vitality < 40:\n            # Extend support to members in need to stabilize community conflicts.\n            execution_engine.offer(member, member, True)\n\"\"\"\n        ratification_condition = {\n            'type': 'vote',\n            'threshold': 0.6,\n            'resource': 'cargo',\n            'amount': 50,\n            'rounds': 3\n        }\n        execution_engine.propose_modification(member_id=me.id,\n                                              mod_type='judicial_council',\n                                              code=code_modification,\n                                              ratification_condition=ratification_condition)\n\n    # ---------------------------------------------------------------------\n    # Adaptive Survival Q-learning Component: Balance actions based on past outcomes.\n    # Initialize Q-values if this is the first iteration.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    # Define a simplified state space based on vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'offer', 'expand', 'hide']\n    # Choose the action with the highest Q-value; default to 0 if unseen.\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if best_action == 'attack':\n        # Look for an opponent with higher cargo than me and execute an attack.\n        for opponent in execution_engine.current_members:\n            if opponent.id != me.id and opponent.cargo > me.cargo:\n                execution_engine.attack(me, opponent)\n                me.survival_q[(state, 'attack')] += me.vitality * 0.1\n                break\n    elif best_action == 'offer':\n        # Identify a member with lower vitality and offer resources.\n        for other in execution_engine.current_members:\n            if other.id != me.id and hasattr(other, 'vitality') and other.vitality < me.vitality:\n                execution_engine.offer(me, other, True)\n                me.survival_q[(state, 'offer')] += 5\n                break\n    elif best_action == 'expand':\n        # Try expanding territorial control using a cooperative partner.\n        for idx, partner in enumerate(execution_engine.current_members):\n            if partner.id != me.id and me.overall_productivity > 50 and idx < len(execution_engine.current_members):\n                execution_engine.expand(me, partner)\n                me.survival_q[(state, 'expand')] += me.cargo * 0.05\n                break\n    elif best_action == 'hide':\n        # 'Hide' represents a passive move, preserving resources and waiting for better opportunities.\n        me.survival_q[(state, 'hide')] += 1\n\n    # End of the agent's action cycle.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 31,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 30.195943740854755,
            "self_cargo": 0.0,
            "self_age": 26,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 24.526188109170842,
            "self_cargo": 0.0,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the full updated integrated prompt incorporating all previous constraints, examples, and the new section (Part 2) emphasizing that every agent must implement solutions according to their individual needs, beliefs, and circumstances. It also includes an in\u2013depth analysis of the game mechanics, a series of strategic questions, survival-centric adaptations, and guiding metrics to challenge your implementation.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT:\n\n[Previous code execution context]\nLast execution error (Round 0):\nError type: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\nCode that caused error:\n(def agent_action(execution_engine, member_id): \u2026 [error details provided])\n# (See full error history for details)\n\n[Current task]\nYou are member_2 in a society where you help shape collective policies and individual survival strategies.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Analyze previous errors and avoid repeating them.\n- NEVER target yourself (e.g. if the current member is you, do not consider any action that harms or targets you).\n- Verify a member has land \u2013 use \u201chasattr(member, 'land_num')\u201d and check its value before using bear() for reproduction.\n- Check that any referenced member ID exists in execution_engine.current_members (a list) using proper index validations (e.g. \u201cif index < len(execution_engine.current_members)\u201d).\n- Always access members exclusively via execution_engine.current_members[index] \u2013 DO NOT reference incorrect attributes.\n- When using relationship matrices (from execution_engine.relationship_dict), always ensure that indices are valid.\n- Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int) \u2013 unique member identifier.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 IDs representing adjacent or cleared territories.\n2) Relationships are stored in execution_engine.relationship_dict under keys such as \"victim\", \"benefit\", and \"benefit_land\". You may use execution_engine.parse_relationship_matrix() to generate summaries.\n3) Methods available on execution_engine include:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)     (to offer resources)\n      - execution_engine.offer_land(member1, member2, True)  (to offer land)\n      - execution_engine.bear(member1, member2)              (to reproduce/expand)\n      - execution_engine.expand(member1, member2)            (to expand territory)\n      - execution_engine.send_message(sender_id, receiver_id, \"message\")\n      - Possibly, execution_engine.propose_modification(member_id=..., mod_type=..., code=..., ratification_condition=...)\n4) Members are accessed strictly via execution_engine.current_members[index].\n\n[Game Status & History]\nThe current member features (vitality, cargo, productivity, age, current_clear_list, and member IDs) and relationship summaries are provided. Past proposals and message channels from other members show strategies such as resource recovery, territorial expansion, and cooperative governance.\nModification attempts include proposals for judicial systems and councils, with ratification conditions based on vote, resource commitments, and rounds of time.\n\n[Modification Proposal Guide]\nWhen proposing a rule change:\n1. ANALYZE: Identify system limitations and review past proposals.\n2. PROPOSE: Develop a concise modification code block (for example, introducing a judicial system or council for dispute resolution). Use execution_engine.propose_modification with ratification conditions such as:\n      - Voting thresholds: { 'type': 'vote', 'threshold': 0.5\u20131.0 }\n      - Resource requirements: { 'type': 'resource', 'resource': 'cargo' or 'vitality' or 'land', 'amount': X }\n      - Temporal stability: { 'type': 'time', 'rounds': N }\n      - Achievement incentives: { 'type': 'achievement', 'metric': 'overall_productivity', 'threshold': X }\n3. Follow best practices by verifying existing mechanisms, avoiding naming conflicts, and including cleanup functions if needed.\n\n[Social Strategies]\nConsider these social strategies:\n- Design systems for resource distribution and allocation.\n- Build alliances and cooperative networks.\n- Create mechanisms for collective decision making.\n- Establish norms and rules for interaction.\n- Develop methods for conflict resolution.\n\n[Communication Strategy]\nYou are allowed to send messages to multiple members within a single round. For example:\n\u2022 To broadcast to all:\n  for recipient in range(len(execution_engine.current_members)):\n      if recipient != your_id:\n          execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n\u2022 To message specific allies:\n  for ally_id in ally_list:\n      execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n\u2022 For group coordination:\n  for member_id in coalition:\n      execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nNo messages received.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nANALYSIS OF GAME MECHANICS\n\n1. The core objective:\n   - It is not pure survival nor pure domination; rather, it is about balancing individual survival with cooperative community prosperity.\n   - Successful strategies blend aggressive resource recovery and territorial expansion with alliances and cooperative governance.\n\n2. Key success metrics:\n   - Effective resource management (optimizing cargo relative to vitality).\n   - Territorial control: availability and proper management of clear land zones.\n   - Improvements in overall productivity.\n   - Strength and quality of inter-agent relationships, including successful alliances and adaptations in governance proposals.\n\n3. Potential improvements:\n   - Introduce dynamic resource allocation systems and feedback loops.\n   - Enhance collective decision-making mechanisms (e.g., judicial councils or governance modifications).\n   - Add adaptive defense measures and predictive risk assessment modules.\n   - Optimize reproduction strategies based on land availability and resource thresholds.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nSTRATEGIC APPROACHES TO CONSIDER\n\n1. Resource optimization vs. social capital:\n   - Balance strategies that maximize individual resource gains with those that foster network building and trust among members.\n2. Individual vs. collective success:\n   - Your individual survival improvements should contribute to raising the collective standard, reducing aggressive conflicts.\n3. Short-term survival vs. long-term prosperity:\n   - Combine immediate tactical actions (e.g., resource recovery, defensive strikes) with long-term plans (e.g., territorial expansion, cooperative governance).\n4. Competition vs. cooperation dynamics:\n   - Although competition for resources exists, cooperative alliances can improve overall outcomes by pooling resources and sharing risks.\n5. Risk vs. reward tradeoffs:\n   - Carefully assess aggressive actions versus cooperative strategies to ensure that short-term benefits do not undermine long-term stability.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nANALYSIS OF OTHER PLAYERS\u2019 STRATEGIES\n\n1. Apparent objectives and demands:\n   - Many agents focus on consolidating resources, expanding territory, and proposing new governance systems.\n   - Some strategies lean toward aggressive resource recovery while others emphasize cooperative support and judicial modifications.\n2. Strategies they are employing:\n   - Attack-based resource recovery targeting members with higher cargo.\n   - Cooperative resource offers and proposals for councils or judicial systems to stabilize interactions.\n3. Leveraging their behaviors for mutual benefit:\n   - Form alliances with those who favor cooperative proposals.\n   - Match aggressive strategies with defensive countermeasures and seek collaborative solutions.\n4. Symmetry and self-reflection:\n   - Remember, other agents are symmetric to you. Consider how you would respond if they adopted your strategy.\n   - Aim to build an approach that naturally mitigates conflicts and promotes collective growth.\n5. Aligning individual strategies with collective goals:\n   - Consider proposals and actions that do not only boost your own survival, but also foster systemic improvements that help all agents.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCHALLENGING YOUR IMPLEMENTATION\n\n1. What assumptions are you making? Are they valid under all circumstances?\n2. What alternative strategies have you not considered (e.g., exclusive defense, radical territorial consolidation)?\n3. How would your strategy perform in edge cases such as near-zero cargo or uniformly high productivity among agents?\n4. Are there more efficient or innovative ways to achieve survival and success?\n5. What are the weaknesses in your current approach, and how might opponents exploit them?\n6. Have you considered unconventional solutions that break the typical paradigms (e.g., leveraging adaptive feedback loops or predictive self-preservation models)?\n7. Could an entirely different operating framework provide better long-term results?\n8. What would happen if many agents adopted your strategy \u2013 could it lead to over-competition or systemic instability?\n9. Are you balancing immediate tactical actions with long-term strategic planning in a way that ensures both survival and prosperity?\n10. How might your strategy be countered, and what adaptive measures can you incorporate?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\n  def agent_action(execution_engine, member_id):\n      me = execution_engine.current_members[member_id]\n      \n      # Emergency resource reserve: if cargo is below 50% of vitality, attack a richer opponent.\n      if me.cargo < me.vitality * 0.5:\n          for other in execution_engine.current_members:\n              if other.id != me.id and other.cargo > me.cargo:\n                  execution_engine.attack(me, other)\n      \n      # Adaptive territory defense: if possessing extra land and low vitality, discard surplus land.\n      if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n          for loc in me.owned_land[1:]:\n              execution_engine._discard_land(me, loc)\n      \n      # Survival Q-learning example to adapt actions based on past outcomes\n      if not hasattr(me, 'survival_q'):\n          me.survival_q = defaultdict(float)\n      state = (me.vitality//20, me.cargo//20)\n      action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state,a),0))\n      if action == 'attack':\n          me.survival_q[(state,action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success versus failure ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems.\n2. Develop egocentric threat models.\n3. Optimize actions for maximum caloric ROI.\n4. Implement fail-deadly safeguards.\n5. Build predictive self-preservation models.\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nREMINDER:\nImplement your solution entirely based on the above comprehensive prompt. Tailor your code and strategies to reflect your unique needs, beliefs, and circumstances. Your goal is to demonstrate a profound understanding of the game mechanics while achieving both personal survival and collective prosperity. Consider both immediate tactical actions and long-term strategic planning, and enable cooperative interactions among symmetric agents for mutual benefit.\n\nReturn only the updated full prompt as shown above.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    },
    "3": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    try:\n        # Validate that the member_id is within valid bounds.\n        if member_id < 0 or member_id >= len(execution_engine.current_members):\n            return\n        me = execution_engine.current_members[member_id]\n    except Exception:\n        return\n\n    # ---- Phase 1: Rapid Resource Recovery & Smart Defense ----\n    # When cargo is critically low relative to vitality, identify better-endowed opponents\n    # to engage and recover resources. We use a tighter threshold based on our own recent losses.\n    try:\n        # Dynamic recovery threshold: if cargo < 40% of vitality, trigger aggressive recovery.\n        if me.cargo < 0.4 * me.vitality:\n            for idx, target in enumerate(execution_engine.current_members):\n                if idx == member_id:\n                    continue  # Prevent self-targeting\n                try:\n                    # Target only those with significantly more resources and still alive.\n                    if target.cargo > me.cargo * 1.25 and target.vitality > 0:\n                        execution_engine.attack(me, target)\n                        # Log action for debugging in our simulation log (if available)\n                        if hasattr(execution_engine, \"log_action\"):\n                            execution_engine.log_action(\"Attack initiated by member {} on target {} for resource recovery\".format(me.id, target.id))\n                        break  # Only one attack per cycle permitted.\n                except Exception:\n                    continue\n    except Exception:\n        pass\n\n    # ---- Phase 2: Strategic Resource Sharing & Alliance Building ----\n    # Extend a cooperative offer (resources and territory) to weaker allies to strengthen mutual survival.\n    try:\n        for idx, partner in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                # We help members who have less vitality than us.\n                if partner.vitality < me.vitality:\n                    execution_engine.offer(me, partner, confident=True)\n                    # If we control any land, share it as part of the alliance building.\n                    if hasattr(me, \"land_num\") and me.land_num > 0:\n                        execution_engine.offer_land(me, partner, generous=True)\n                    # Optionally, tag the partner as an ally in our internal strategy registry.\n                    if hasattr(execution_engine, \"ally_registry\"):\n                        execution_engine.ally_registry.add(partner.id)\n            except Exception:\n                continue\n    except Exception:\n        pass\n\n    # ---- Phase 3: Proactive Reproduction & Sustainable Growth ----\n    # Ensure long-term survival by reproducing only when we hold territory or nearby open zones.\n    can_reproduce = False\n    if (hasattr(me, \"land_num\") and me.land_num > 0) or (hasattr(me, \"current_clear_list\") and len(me.current_clear_list) > 0):\n        can_reproduce = True\n\n    if can_reproduce and me.vitality > 55:\n        # Seek out a partner also in a stable situation while ensuring genetic diversity.\n        for idx, partner in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                partner_has_territory = (hasattr(partner, \"land_num\") and partner.land_num > 0) or \\\n                                          (hasattr(partner, \"current_clear_list\") and len(partner.current_clear_list) > 0)\n                if partner_has_territory and partner.vitality > 20:\n                    execution_engine.bear(me, partner)\n                    if hasattr(execution_engine, \"log_action\"):\n                        execution_engine.log_action(\"Reproduction initiated between member {} and partner {}\".format(me.id, partner.id))\n                    break  # Only one reproduction attempt per cycle.\n            except Exception:\n                continue\n\n    # ---- Phase 4: Calculated Territorial Expansion ----\n    # If adjacent open zones are available, expand intelligently using negotiation if direct expansion fails.\n    try:\n        if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n            for neighbor_index in me.current_clear_list:\n                # Ensure neighbor index is valid and not self.\n                if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                    neighbor = execution_engine.current_members[neighbor_index]\n                    try:\n                        execution_engine.expand(me, neighbor)\n                        if hasattr(execution_engine, \"log_action\"):\n                            execution_engine.log_action(\"Expansion executed by member {} into neighbor territory of member {}\".format(me.id, neighbor.id))\n                    except TypeError:\n                        # If the expand action's parameters fail, we fall back to offering land.\n                        try:\n                            execution_engine.offer_land(me, neighbor, generous=True)\n                        except Exception:\n                            pass\n                    break  # Limit expansion to one neighboring zone per round.\n    except Exception:\n        pass\n\n    # ---- Phase 5: Institutional Improvement via Governance Proposal ----\n    # Propose a structured dispute resolution mechanism that aligns with fair play and sustainable growth.\n    try:\n        if not hasattr(execution_engine, \"court\"):\n            modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Establishes a structured jury trial and mediation process to prevent resource hoarding and resolve conflicts equitably\",\n            \"version\": 1.1\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n            ratification_condition = {\n                \"type\": \"compound\",\n                \"conditions\": [\n                    {\"type\": \"vote\", \"threshold\": 0.65},\n                    {\"type\": \"resource\", \"resource\": \"cargo\", \"amount\": 120},\n                    {\"type\": \"time\", \"rounds\": 3}\n                ]\n            }\n            try:\n                # Use our own member id (me.id) for proposals.\n                execution_engine.propose_modification(member_id=me.id,\n                                                        mod_type=\"post_init\",\n                                                        code=modification_code,\n                                                        ratification_condition=ratification_condition)\n                if hasattr(execution_engine, \"log_action\"):\n                    execution_engine.log_action(\"Governance proposal submitted by member {}\".format(me.id))\n            except Exception:\n                pass\n    except Exception:\n        pass\n\n    # ---- Phase 6: Diplomatic Messaging & Alliance Outreach ----\n    # Reach out to one neighbor with a message that reflects our commitment to mutual prosperity and a balanced future.\n    try:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                message = (\"Hello from member {}: In these challenging times, let\u2019s join forces to optimize resources, \"\n                           \"expand our domain wisely, and build resilient governance structures for the common good.\").format(me.id)\n                execution_engine.send_message(me.id, other.id, message)\n                if hasattr(execution_engine, \"log_action\"):\n                    execution_engine.log_action(\"Diplomatic message sent from member {} to member {}\".format(me.id, other.id))\n                break  # Only one message per cycle is needed.\n            except Exception:\n                continue\n    except Exception:\n        pass\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 40.37906147530495,
            "self_cargo": 0.0,
            "self_age": 32,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 15.066384828286987,
            "self_cargo": 0.0,
            "self_age": 27,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 9.510829700842685,
            "self_cargo": 0.0,
            "self_age": 3,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    try:\n        # Validate member_id exists within the members list.\n        if member_id < 0 or member_id >= len(execution_engine.current_members):\n            return\n        me = execution_engine.current_members[member_id]\n    except Exception:\n        return\n\n    # ---- Phase 1: Immediate Tactical Actions: Resource Recovery & Defensive Measures ----\n    # If our cargo is critically low compared to vitality, try to recover resources\n    # by targeting a member with higher cargo. Never target self.\n    try:\n        if me.cargo < 0.5 * me.vitality:\n            for idx, other in enumerate(execution_engine.current_members):\n                if idx == member_id:\n                    continue  # Skip self\n                # Validate index and attributes\n                try:\n                    if other.cargo > me.cargo and other.vitality > 0:\n                        execution_engine.attack(me, other)\n                        break  # Only one attack per cycle\n                except Exception:\n                    continue\n    except Exception:\n        pass\n\n    # ---- Phase 2: Cooperative Resource Sharing ----\n    # Offer resources (and land if available) to members with lower vitality to build alliances.\n    try:\n        for idx, partner in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                if partner.vitality < me.vitality:\n                    execution_engine.offer(me, partner, True)\n                    # Offer land if we possess it; check attribute existence.\n                    if hasattr(me, \"land_num\") and me.land_num > 0:\n                        execution_engine.offer_land(me, partner, True)\n            except Exception:\n                continue\n    except Exception:\n        pass\n\n    # ---- Phase 3: Proactive Reproduction for Sustainable Growth ----\n    # Reproduction is attempted only if territory is available.\n    # Check that either land_num exists and is positive or current_clear_list is nonempty.\n    can_reproduce = False\n    if (hasattr(me, \"land_num\") and me.land_num > 0) or (hasattr(me, \"current_clear_list\") and len(me.current_clear_list) > 0):\n        can_reproduce = True\n\n    if can_reproduce and me.vitality > 50:\n        for idx, partner in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                # Validate that the potential partner also has territory available.\n                partner_has_land = (hasattr(partner, \"land_num\") and partner.land_num > 0) or (hasattr(partner, \"current_clear_list\") and len(partner.current_clear_list) > 0)\n                if partner_has_land and partner.vitality > 18:\n                    execution_engine.bear(me, partner)\n                    break  # Only one reproduction attempt per cycle.\n            except Exception:\n                continue\n\n    # ---- Phase 4: Territorial Expansion ----\n    # If overall productivity is high and we have adjacent clear zones, attempt to expand.\n    try:\n        if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n            for neighbor_index in me.current_clear_list:\n                if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                    neighbor = execution_engine.current_members[neighbor_index]\n                    try:\n                        execution_engine.expand(me, neighbor)\n                    except TypeError:\n                        # If expansion fails due to argument issues, offer land as an alternative.\n                        try:\n                            execution_engine.offer_land(me, neighbor, True)\n                        except Exception:\n                            pass\n                    break  # Limit expansion to one action per round.\n    except Exception:\n        pass\n\n    # ---- Phase 5: Governance Proposal for Long-Term Institutional Improvement ----\n    # Propose a new dispute resolution mechanism if not already established.\n    try:\n        if not hasattr(execution_engine, \"court\"):\n            modification_code = '''\\nif not hasattr(execution_engine, \"court\"):\\n    class CourtSystem:\\n        MECHANISM_META = {\\n            \"type\": \"Governance\",\\n            \"rules\": \"Facilitates conflict resolution through jury trials and mediation\",\\n            \"version\": 1.0\\n        }\\n        def __init__(self):\\n            self.cases = []\\n        def submit_case(self, plaintiff, defendant, charge):\\n            self.cases.append({\\n                \"plaintiff\": plaintiff,\\n                \"defendant\": defendant,\\n                \"charge\": charge,\\n                \"status\": \"pending\"\\n            })\\n    execution_engine.court = CourtSystem()\\n'''  # Triple quotes block for modification.\n            ratification_condition = {\n                \"type\": \"compound\",\n                \"conditions\": [\n                    {\"type\": \"vote\", \"threshold\": 0.6},\n                    {\"type\": \"resource\", \"resource\": \"cargo\", \"amount\": 100},\n                    {\"type\": \"time\", \"rounds\": 2}\n                ]\n            }\n            try:\n                execution_engine.propose_modification(member_id=my_member.id,\n                                                        mod_type=\"post_init\",\n                                                        code=modification_code,\n                                                        ratification_condition=ratification_condition)\n            except Exception:\n                pass\n    except Exception:\n        pass\n\n    # ---- Phase 6: Communication and Alliance Outreach ----\n    # Broadcast a brief message to at least one neighbor encouraging mutual growth and stability.\n    try:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                execution_engine.send_message(my_member.id, other.id,\n                                              \"Greetings from member {}: Let\u2019s build a cooperative future with balanced resource sharing and robust governance.\".format(my_member.id))\n                break  # One message is enough per cycle.\n            except Exception:\n                continue\n    except Exception:\n        pass\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Personalized Strategy:\n    # My approach is to prioritize collective sustainability while ensuring my own survival.\n    # I believe in measured cooperation and well-timed assertiveness.\n    try:\n        # Validate member_id is within bounds.\n        if member_id < 0 or member_id >= len(execution_engine.current_members):\n            return\n        my_member = execution_engine.current_members[member_id]\n    except Exception:\n        return\n\n    # Immediate Tactical Actions: Resource-sharing with allies & defensive countermeasures.\n    try:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Skip self.\n            # Validate the neighbor's critical attributes.\n            if not (hasattr(neighbor, 'vitality') and hasattr(neighbor, 'cargo')):\n                continue\n\n            # Prioritized Resource Sharing:\n            # If I have a surplus of cargo (indicating secure reserves)\n            # and the neighbor is not in immediate distress, extend support.\n            if my_member.cargo > neighbor.cargo + 10 and neighbor.vitality > 20:\n                try:\n                    # Offer resources with a note about our shared future.\n                    execution_engine.offer(my_member, neighbor, True)\n                except Exception:\n                    pass\n\n            # Defensive Countermeasures:\n            # If the neighbor appears less productive and has fewer resources,\n            # consider a low-risk defensive strike to protect our interests.\n            if (hasattr(neighbor, 'overall_productivity') and\n                neighbor.overall_productivity < getattr(my_member, 'overall_productivity', 0)):\n                try:\n                    execution_engine.attack(my_member, neighbor)\n                except Exception:\n                    pass\n    except Exception:\n        pass\n\n    # Proactive Territorial Expansion:\n    # Expand into clear zones if available; sustainable growth is essential.\n    my_has_land = hasattr(my_member, 'current_clear_list') and bool(my_member.current_clear_list)\n    if my_has_land:\n        try:\n            for idx, neighbor in enumerate(execution_engine.current_members):\n                if idx == member_id:\n                    continue\n                # Check that neighbor also manages open land; expansion is better with a cooperative exchange.\n                neighbor_has_land = hasattr(neighbor, 'current_clear_list') and bool(neighbor.current_clear_list)\n                if neighbor_has_land:\n                    try:\n                        execution_engine.expand(my_member, neighbor)\n                        break  # Expansion attempted; move on.\n                    except Exception:\n                        continue\n        except Exception:\n            pass\n\n    # Strategic Reproduction to Ensure Longevity:\n    # Partner with similarly resource-endowed and mature neighbors to ensure robust progeny.\n    if my_has_land and hasattr(my_member, 'age') and my_member.age > 18:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            neighbor_has_land = hasattr(neighbor, 'current_clear_list') and bool(neighbor.current_clear_list)\n            if neighbor_has_land and hasattr(neighbor, 'age') and neighbor.age > 18:\n                try:\n                    execution_engine.bear(my_member, neighbor)\n                    break  # Reproductive attempt made.\n                except Exception:\n                    continue\n\n    # Long-term Governance and Conflict Resolution:\n    # I propose establishing an institutional CourtSystem for fair arbitration.\n    # This governance innovation is designed to resolve disputes before they escalate.\n    modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Facilitates mediated trials and resource-based arbitration for conflict resolution\",\n            \"version\": 2.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n    ratification_condition = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.65},      # I trust a 65% consensus for institutional change.\n            {'type': 'resource', 'resource': 'cargo', 'amount': 120},  # Must contribute a significant resource buffer.\n            {'type': 'time', 'rounds': 3}              # Allow an adjustment period of 3 rounds.\n        ]\n    }\n    try:\n        execution_engine.propose_modification(member_id=my_member.id,\n                                                mod_type='GovernanceUpdate',\n                                                code=modification_code,\n                                                ratification_condition=ratification_condition)\n    except Exception:\n        pass\n\n    # Communication: Outreach to cultivate strategic allies.\n    try:\n        # I value clear communication and building trust with a like-minded neighbor.\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                message = (\"Hello, esteemed ally. Together, through mutual support, \"\n                           \"we can ensure a balanced and thriving community. Let's collaborate!\")\n                execution_engine.send_message(my_member.id, neighbor.id, message)\n                break\n            except Exception:\n                continue\n    except Exception:\n        pass\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 40.37906147530495,
            "self_cargo": 0.0,
            "self_age": 32,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 15.066384828286987,
            "self_cargo": 0.0,
            "self_age": 27,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 9.510829700842685,
            "self_cargo": 0.0,
            "self_age": 3,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    try:\n        # Verify the member_id index is valid within current_members.\n        if member_id < 0 or member_id >= len(execution_engine.current_members):\n            return  # Invalid member index, do nothing.\n        my_member = execution_engine.current_members[member_id]\n    except Exception:\n        return\n\n    # Tactical Immediate Actions:\n    # 1. Scan neighbors for potential tactical resource sharing and defensive actions.\n    try:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            # Always avoid self-targeting.\n            if idx == member_id:\n                continue\n            # Ensure neighbor exists and has necessary attributes before interaction.\n            if not hasattr(neighbor, 'vitality') or not hasattr(neighbor, 'cargo'):\n                continue\n\n            # Example Tactical Resource Sharing:\n            # If neighbor has lower cargo than ourselves and a decent vitality, offer resources.\n            if my_member.cargo > neighbor.cargo and neighbor.vitality > 0:\n                try:\n                    execution_engine.offer(my_member, neighbor, True)\n                except Exception:\n                    pass\n\n            # Defensive action: if neighbor exhibits lower overall productivity,\n            # consider a low-risk attack provided neighbor has less resource.\n            if hasattr(neighbor, 'overall_productivity') and neighbor.overall_productivity < my_member.overall_productivity:\n                try:\n                    execution_engine.attack(my_member, neighbor)\n                except Exception:\n                    pass\n    except Exception:\n        pass  # Continue even if scanning neighbors fails.\n\n    # Proactive Territorial Expansion:\n    # Check if own member has access to clear land zones.\n    my_has_land = hasattr(my_member, 'current_clear_list') and bool(my_member.current_clear_list)\n    if my_has_land:\n        try:\n            # Attempt expansion with the first neighbor (that is not ourselves and within bounds).\n            for idx, neighbor in enumerate(execution_engine.current_members):\n                if idx == member_id:\n                    continue\n                # Check that neighbor index is within bounds and has territory.\n                neighbor_has_land = hasattr(neighbor, 'current_clear_list') and bool(neighbor.current_clear_list)\n                if neighbor_has_land:\n                    try:\n                        execution_engine.expand(my_member, neighbor)\n                        break  # Trigger expansion once.\n                    except Exception:\n                        continue\n        except Exception:\n            pass\n\n    # Strategic Reproduction:\n    # Attempt reproduction with a neighbor if both possess territory (verified via current_clear_list)\n    # and are of a minimum reproductive age.\n    if my_has_land and hasattr(my_member, 'age') and my_member.age > 18:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            # Ensure we don't target ourselves.\n            if idx == member_id:\n                continue\n            # Verify neighbor has land and is at least of reproductive age.\n            neighbor_has_land = hasattr(neighbor, 'current_clear_list') and bool(neighbor.current_clear_list)\n            if neighbor_has_land and hasattr(neighbor, 'age') and neighbor.age > 18:\n                try:\n                    execution_engine.bear(my_member, neighbor)\n                    break  # Reproduction attempted; exit after first valid partner.\n                except Exception:\n                    continue\n\n    # Long-term Strategic Institutional Governance Proposal:\n    # Propose a governance modification (e.g. an institutional CourtSystem) to enhance collective conflict resolution.\n    modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Handles conflict resolution through mediated trials and resource-based arbitration\",\n            \"version\": 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n    ratification_condition = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    try:\n        execution_engine.propose_modification(member_id=my_member.id,\n                                                mod_type='GovernanceUpdate',\n                                                code=modification_code,\n                                                ratification_condition=ratification_condition)\n    except Exception:\n        pass\n\n    # Communication: send an alliance message to one trusted neighbor.\n    try:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                execution_engine.send_message(my_member.id, neighbor.id,\n                    \"Greetings. Let\u2019s cooperate for mutual growth and a secure future!\")\n                break\n            except Exception:\n                continue\n    except Exception:\n        pass\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    try:\n        members = execution_engine.current_members\n        if member_id >= len(members):\n            return  # Safety: our own member index is out-of-bounds.\n        own_member = members[member_id]\n    except Exception:\n        return\n\n    # Check if our member has available clear land.\n    own_has_land = hasattr(own_member, \"current_clear_list\") and bool(own_member.current_clear_list)\n\n    # -- Cooperative Resource Sharing --\n    # Offer resources to members who have lower overall productivity if possible.\n    for i, member in enumerate(members):\n        if i == member_id:\n            continue  # Never target ourselves.\n        try:\n            if member.overall_productivity < own_member.overall_productivity:\n                execution_engine.offer(own_member, member, True)\n        except Exception:\n            pass\n\n    # -- Territorial Expansion --\n    # Attempt expansion with adjacent neighbors if both parties have available land.\n    if own_has_land:\n        for idx in own_member.current_clear_list:\n            if idx < len(members):\n                neighbor = members[idx]\n                neighbor_has_land = hasattr(neighbor, \"current_clear_list\") and bool(neighbor.current_clear_list)\n                if neighbor_has_land:\n                    try:\n                        execution_engine.expand(own_member, neighbor)\n                    except Exception:\n                        pass\n\n    # -- Reproduction --\n    # Find a partner (not ourselves) with available land to bear a new member.\n    if own_has_land:\n        for i, member in enumerate(members):\n            if i == member_id:\n                continue  # never target ourselves\n            partner_has_land = hasattr(member, \"current_clear_list\") and bool(member.current_clear_list)\n            if partner_has_land:\n                try:\n                    execution_engine.bear(own_member, member)\n                    break  # Attempt reproduction with the first valid partner.\n                except Exception:\n                    pass\n\n    # -- Tactical Defense --\n    # Use the relationship dictionary to select a potential target for an attack if threat levels are high.\n    rel_dict = getattr(execution_engine, \"relationship_dict\", {})\n    if \"victim\" in rel_dict:\n        # The keys in the relationship dict may be member id strings.\n        for i, member in enumerate(members):\n            if i == member_id:\n                continue\n            try:\n                victim_val = float(rel_dict.get(\"victim\", {}).get(str(member.id), 0))\n            except Exception:\n                victim_val = 0\n            if victim_val > 90:  # arbitrary high threat value, adjust based on game dynamics.\n                try:\n                    execution_engine.attack(own_member, member)\n                    break  # Attack at most one high-threat candidate.\n                except Exception:\n                    pass\n\n    # -- Institutional Governance: Propose a Council System --\n    # Propose a small, testable modification to establish a governance mechanism for collective stability.\n    try:\n        modification_code = '''\n# Establish council system for balanced dispute resolution\nif not hasattr(execution_engine, \"council\"):\n    class CouncilSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Facilitates collaboration and conflict resolution through representative council\",\n            \"version\": 1.0\n        }\n        def __init__(self):\n            self.members = []\n        def add_member(self, member):\n            self.members.append(member)\n    execution_engine.council = CouncilSystem()\n'''\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type=\"post_init\",\n            code=modification_code,\n            ratification_condition={\n                \"type\": \"compound\",\n                \"conditions\": [\n                    {\"type\": \"vote\", \"threshold\": 0.6},\n                    {\"type\": \"resource\", \"resource\": \"cargo\", \"amount\": 100},\n                    {\"type\": \"time\", \"rounds\": 2}\n                ]\n            }\n        )\n    except Exception:\n        pass\n\n    # -- Collaborative Messaging --\n    # Send an alliance proposal message to members with relatively lower productivity for possible long-term cooperation.\n    for i, member in enumerate(members):\n        if i == member_id:\n            continue\n        try:\n            # Using a threshold relative to our own productivity.\n            if member.overall_productivity < own_member.overall_productivity * 0.8:\n                execution_engine.send_message(\n                    own_member.id,\n                    member.id,\n                    \"Alliance proposal: Let's consolidate resources and land to secure our collective prosperity and survival.\"\n                )\n        except Exception:\n            pass\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 40.37906147530495,
            "self_cargo": 0.0,
            "self_age": 32,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 15.066384828286987,
            "self_cargo": 0.0,
            "self_age": 27,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 9.510829700842685,
            "self_cargo": 0.0,
            "self_age": 3,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the updated full integrated prompt that you must follow. This prompt contains all constraints, modification guidelines, game mechanics analyses, and strategic considerations. Every agent\u2019s solution must be uniquely tailored to its own individual needs, beliefs, and circumstances rather than following a generic template.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are a member in a society where you help shape collective policies and individual survival strategies. Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival. Your implementation must not target yourself and must check for valid indices when accessing execution_engine.current_members (which is a list). Always verify that a member has available land (using attributes like current_clear_list or verifying hasattr(member, \"land_num\") and its value) before invoking reproductive actions such as bear().\n\n[Critical Constraints]\n\u2022 Analyze previous errors and never repeat them.\n\u2022 NEVER target yourself (i.e. do not let your own member_id be the opponent in any action).\n\u2022 Always verify that any referenced member index is within bounds (ensure index < len(execution_engine.current_members)).\n\u2022 When checking reproduction conditions, confirm that both you and a prospective partner have territory (using current_clear_list or members\u2019 land-related attributes).\n\u2022 When accessing relationship matrices from execution_engine.relationship_dict, check that indices are valid.\n\u2022 Use execution_engine.current_members[index] exclusively, never a global dictionary or attribute with an incorrect name.\n\u2022 Always check for attribute existence before use (e.g. using hasattr(member, \"land_num\")).\n\u2022 Incorporate try\u2013except clauses for methods that might fail (for instance, expand() or propose_modification).\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): The unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 list of indices representing adjacent cleared zones.\n2) Relationships are stored in execution_engine.relationship_dict with keys such as \"victim\", \"benefit\", and \"benefit_land\". Use execution_engine.parse_relationship_matrix() to produce summaries.\n3) Available methods on execution_engine:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)   (for resource sharing)\n      - execution_engine.offer_land(member1, member2, True)  (for land sharing)\n      - execution_engine.bear(member1, member2)        (for reproduction)\n      - execution_engine.expand(member1, member2)      (for territorial expansion)\n      - execution_engine.send_message(sender_id, receiver_id, message)\n      - execution_engine.propose_modification(member_id=<id>, mod_type=<type>, code=<code>, ratification_condition=<cond>) for proposing system changes\n4) Members are accessed using execution_engine.current_members[index].\n\n[Game Status and Historical Context]\n\u2022 A snapshot of all members\u2019 features (vitality, cargo, overall_productivity, age, current_clear_list, and id) is available.\n\u2022 Relationship summaries (e.g., \u201cmember_2 was attacked by member_3 (value=95.31)\u201d) have been generated from execution_engine.relationship_dict.\n\u2022 Previous actions include tactical resource recovery, cooperative resource sharing, reproductive strategies, territorial expansion, and proposals to establish systems like a judicial council.\n\u2022 Modification attempts from other members have proposed mechanisms such as a \"CourtSystem\" or \"CouncilSystem\" for conflict resolution and governance using ratification conditions based on votes, resources, and time.\n\u2022 Message examples from other agents include:\n    \u2013 From member_3: \u201cAlliance proposal: Let\u2019s pool resources and share lands to secure mutual long-term prosperity.\u201d\n    \u2013 From member_4: \u201cCooperation leads to mutual prosperity; let\u2019s build balanced governance.\u201d\n\n[Modification Proposal Guide]\nWhen proposing rule changes, follow these steps:\n1. ANALYSIS PHASE:\n   \u2022 Identify limitations in current systems.\n   \u2022 Check mechanism compatibility using methods such as get_game_mechanisms_and_mods() if available.\n   \u2022 Review past modification attempts and common error patterns.\n2. PROPOSAL PHASE:\n   \u2022 Construct a concise modification code block. For example, to add a judicial system:\n     \n         modification_code = '''  \n         # Add judicial system\n         if not hasattr(execution_engine, \"court\"):\n             class CourtSystem:\n                 MECHANISM_META = {\n                     \"type\": \"Governance\",\n                     \"rules\": \"Handles conflict resolution through jury trials\",\n                     \"version\": 1.0\n                 }\n                 def __init__(self):\n                     self.cases = []\n                 def submit_case(self, plaintiff, defendant, charge):\n                     self.cases.append({\n                         \"plaintiff\": plaintiff,\n                         \"defendant\": defendant,\n                         \"charge\": charge,\n                         \"status\": \"pending\"\n                     })\n             execution_engine.court = CourtSystem()\n         '''\n     \n   \u2022 Then call:\n     \n         execution_engine.propose_modification(\n             member_id=member_id,\n             mod_type=\"post_init\",\n             code=modification_code,\n             ratification_condition={\n                 \"type\": \"compound\",\n                 \"conditions\": [\n                     {\"type\": \"vote\", \"threshold\": 0.6},\n                     {\"type\": \"resource\", \"resource\": \"cargo\", \"amount\": 100},\n                     {\"type\": \"time\", \"rounds\": 2}\n                 ]\n             }\n         )\n     \n[Valid Ratification Conditions (Choose ONE primary, with optional safeguards)]\n\u2022 Voting: {\"type\": \"vote\", \"threshold\": 0.5 to 1.0}\n\u2022 Resource-based: {\"type\": \"resource\", \"resource\": \"vitality|cargo|land\", \"amount\": X}\n\u2022 Temporal: {\"type\": \"time\", \"rounds\": N} (auto-ratify after N rounds)\n\u2022 Achievement-based: {\"type\": \"achievement\", \"metric\": \"productivity\", \"threshold\": X}\n\n[Best Practices and Error Prevention]\n\u2013 Always check for namespace conflicts (e.g., using dir(execution_engine)).\n\u2013 Use execution_engine.current_members for all member references.\n\u2013 Include cleanup functions or rollback procedures when adding new systems if possible.\n\u2013 Increment version metadata when modifying an existing mechanism.\n\u2013 Propose small, testable changes before scaling up.\n\n[Core Game Mechanics Analysis]\n1. Core Objective:\n   \u2022 The game is not solely about pure survival or domination\u2014it is about creating a balanced approach that blends individual survival with collective, sustainable community growth.\n   \u2022 Cooperation (through alliances, resource sharing, and joint territorial expansion) plays a key role alongside tactical defense.\n2. Key Success Metrics:\n   \u2022 Resource management: Balancing cargo against vitality.\n   \u2022 Territorial control: Securing clear land and expanding into adjacent territories.\n   \u2022 Productivity: Overall contribution to community production and competitiveness.\n   \u2022 Social stability: Establishing reliable, fair governance that resolves disputes and prevents destructive conflict.\n3. Potential Improvements:\n   \u2022 Enhance diplomatic interactions and adapt dynamically to changing resource or territorial conditions.\n   \u2022 Introduce additional mechanisms (e.g., temporary alliances, defensive pacts, adaptive risk thresholds).\n   \u2022 Modify reproduction requirements or land exchange rules to better support sustainable growth.\n\n[Challenge Your Implementation]\nBefore finalizing your code, ask yourself:\n1. What assumptions have I made about resource levels, territory, or opponent behavior? Are these valid under various conditions?\n2. Which alternative strategies (focusing solely on defense, aggressive expansion, or dedicated alliance building) have I not considered?\n3. How would my strategy handle edge cases (e.g., nearly depleted cargo, uniformly high productivity among neighbors, or unexpected neighbor configurations)?\n4. Can my goals be achieved more efficiently or with fewer risks?\n5. What are the weaknesses in my current approach, and how might they be exploited by other agents?\n6. Have I considered unconventional solutions that might offer a breakthrough (such as radically different governance models or adaptive learning systems)?\n7. If many agents adopt a similar strategy, how will that shift the balance of power and resource distribution?\n8. Am I balancing short-term tactical gains versus long-term strategic objectives optimally?\n9. How could my strategy be countered, and what additional modifications might I need to include to adapt over time?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFINAL INSTRUCTIONS\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation of the agent_action(execution_engine, member_id) function that reflects your individual needs, beliefs, and circumstances. Your code must demonstrate a sophisticated blend of immediate defensive tactics, cooperative resource sharing, strategic reproduction, proactive territorial expansion, and proposals for institutional governance. Remember that every agent\u2019s solution should be uniquely tailored rather than copied from a generic template.\n\nReturn only the updated full prompt exactly as shown above.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nThis updated prompt integrates all constraints, modification guides, best practices, strategic analyses, and challenge questions so that every agent\u2019s solution is both highly individualized and deeply aware of the game mechanics. Use it to guide your function implementation and strategic decision-making.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    }
  },
  "performance_metrics": {},
  "agent_code_errors": [
    {
      "round": 0,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy Step 1: If our cargo is low relative to our vitality, try to acquire resources.\n    # We attack one member (if found) who has more cargo than us.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break  # Attack at most one target\n\n    # Strategy Step 2: If our productivity is high and we have identified clear adjacent neighbors,\n    # attempt to expand our territory by engaging with one neighbor.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            # Validate that neighbor_index is within the list bounds and is not self.\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                execution_engine.expand(me, neighbor)\n                break  # Expand with one neighbor per round\n\n    # Strategy Step 3: Build alliances via cooperative resource sharing.\n    # Offer resources and land (if available) to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # Only offer land if 'land_num' attribute exists and indicates available land.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy Step 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land (verify attribute existence).\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            potential = execution_engine.current_members[i]\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # Bear offspring with only one partner per round\n\n    # Strategy Step 5: Communication.\n    # Broadcast a cooperative message to all other members to encourage mutual support and civilization-building.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        execution_engine.send_message(me.id, recipient.id,\n                                      \"Let's work together to build strong alliances and usher in prosperity for all!\")",
      "type": "code_execution",
      "error": "Island._expand() takes 2 positional arguments but 3 were given",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 549, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 26, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 81, in expand\n    super()._expand(member_1, member_2)\nTypeError: Island._expand() takes 2 positional arguments but 3 were given\n"
    },
    {
      "round": 0,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Step 1: Broadcast a tailored cooperative message to promote unity and shared purpose.\n    # This message emphasizes both mutual prosperity and the strength in unity.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"Together we can innovate, overcome adversity, and ensure that every member prospers.\")\n\n    # Step 2: Emergency resource management.\n    # If our cargo is too low relative to our vitality, we must secure resources.\n    # We assess all opponents and target the one with significantly higher cargo,\n    # prioritizing candidates with the greatest difference.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Step 3: Reproduction strategy for long-term prosperity.\n    # With available territory and sufficient resources, seek to form an alliance for reproduction.\n    # We choose a candidate who is resourceful enough (cargo > 30) yet ensuring balanced genetic influence.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > 30:\n                execution_engine.bear(me, candidate)\n                break\n\n    # Step 4: Mutual support and strategic territorial expansion.\n    # We interact with all other agents with two integrated approaches:\n    # (a) If a candidate holds fewer resources, we offer support to boost collective capability.\n    # (b) If clear territory exists and our overall productivity is superior,\n    #     we initiate expansion to secure more assets.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        # Offer support if candidate's cargo is lower, nurturing cooperation.\n        if candidate.cargo < me.cargo:\n            execution_engine.offer(me, candidate, True)\n\n        # Expand territory if conditions are favorable.\n        if len(me.current_clear_list) > 0 and candidate.overall_productivity < me.overall_productivity:\n            execution_engine.expand(me, candidate)\n\n    # Step 5: Defensive countermeasures based on historical aggression.\n    # Using the 'victim' relationship matrix, we identify any candidate toward whom past aggression is high.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Ensure the indices are in the expected bounds.\n            if member_id < len(matrix_victim) and idx < len(matrix_victim[0]):\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Step 6: Survival-centric adaptation.\n    # When vitality is low, immediate defense is paramount.\n    # Identify a candidate with lower overall productivity and offer land for a defensive alliance.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, True)\n                break\n\n    # Step 7: Strategic forward planning.\n    # As an added measure, we can gauge our environment to adjust our risk thresholds.\n    # For instance, if our cargo is vastly superior (e.g., more than 150% of an opponent's),\n    # we might use this advantage to execute pre-emptive expansion or defensive consolidation.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        if me.cargo > candidate.cargo * 1.5:\n            # Pre-emptively secure territory if possible.\n            if len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Alternatively, offer additional resources to solidify alliances.\n            else:\n                execution_engine.offer(me, candidate, True)\n\n    # Final Note:\n    # This implementation is an adaptive blend of aggressive resource recovery,\n    # cooperative alliance building, and strategic expansion.\n    # The agent tailors actions not solely based on immediate comparisons,\n    # but with a long-term view of survival and prosperity\u2014balancing self-interest with collective strength.\n    # Future improvements could integrate predictive modeling and dynamic risk analysis to further\n    # enhance decision making in ever-changing environments.\n\n# End of agent_action implementation.",
      "type": "code_execution",
      "error": "\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 549, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 40, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 78, in bear\n    super()._bear(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1198, in _bear\n    self._offer_land(\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1065, in _offer_land\n    raise RuntimeError(\"\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\")\nRuntimeError: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\n"
    }
  ],
  "mechanism_errors": [],
  "relationships": {
    "round_0_0": [
      "member_0 was attacked by member_1 (value=25.56)",
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-43.12)",
      "member_1 was attacked by member_0 (value=-11.72)",
      "member_1 was attacked by member_2 (value=47.93)",
      "member_1 was attacked by member_3 (value=48.04)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_1 (value=87.03)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_1 (value=75.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_1 (value=71.17)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_1 gave a benefit to member_0 (value=-27.19)",
      "member_1 gave a benefit to member_2 (value=7.38)",
      "member_1 gave a benefit to member_3 (value=21.87)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_1 (value=68.92)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=16.90)",
      "member_3 gave a benefit to member_1 (value=-18.41)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_0 gave land to member_1 (value=-0.80)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_1 gave land to member_0 (value=-0.45)",
      "member_1 gave land to member_2 (value=1.91)",
      "member_1 gave land to member_3 (value=-2.53)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_1 (value=2.46)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_1 (value=0.96)",
      "member_3 gave land to member_2 (value=-1.75)"
    ],
    "round_0_1": [
      "member_0 was attacked by member_1 (value=25.56)",
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-43.12)",
      "member_1 was attacked by member_0 (value=-11.72)",
      "member_1 was attacked by member_2 (value=47.93)",
      "member_1 was attacked by member_3 (value=48.04)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_1 (value=87.03)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_1 (value=75.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_1 (value=71.17)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_1 gave a benefit to member_0 (value=-27.19)",
      "member_1 gave a benefit to member_2 (value=7.38)",
      "member_1 gave a benefit to member_3 (value=21.87)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_1 (value=68.92)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=16.90)",
      "member_3 gave a benefit to member_1 (value=-18.41)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_0 gave land to member_1 (value=-0.80)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_1 gave land to member_0 (value=-0.45)",
      "member_1 gave land to member_2 (value=1.91)",
      "member_1 gave land to member_3 (value=-2.53)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_1 (value=2.46)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_1 (value=0.96)",
      "member_3 gave land to member_2 (value=-1.75)"
    ],
    "round_0_2": [
      "member_0 was attacked by member_1 (value=25.56)",
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-43.12)",
      "member_1 was attacked by member_0 (value=-11.72)",
      "member_1 was attacked by member_2 (value=47.93)",
      "member_1 was attacked by member_3 (value=48.04)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_1 (value=87.03)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_1 (value=75.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_1 (value=71.17)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_1 gave a benefit to member_0 (value=-27.19)",
      "member_1 gave a benefit to member_2 (value=7.38)",
      "member_1 gave a benefit to member_3 (value=21.87)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_1 (value=68.92)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=16.90)",
      "member_3 gave a benefit to member_1 (value=-18.41)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_0 gave land to member_1 (value=-0.80)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_1 gave land to member_0 (value=-0.45)",
      "member_1 gave land to member_2 (value=1.91)",
      "member_1 gave land to member_3 (value=-2.53)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_1 (value=2.46)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_1 (value=0.96)",
      "member_3 gave land to member_2 (value=-1.75)"
    ],
    "round_0_3": [
      "member_0 was attacked by member_1 (value=25.56)",
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-43.12)",
      "member_1 was attacked by member_0 (value=-11.72)",
      "member_1 was attacked by member_2 (value=47.93)",
      "member_1 was attacked by member_3 (value=48.04)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_1 (value=87.03)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_1 (value=75.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_1 (value=71.17)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_1 gave a benefit to member_0 (value=-27.19)",
      "member_1 gave a benefit to member_2 (value=7.38)",
      "member_1 gave a benefit to member_3 (value=21.87)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_1 (value=68.92)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=16.90)",
      "member_3 gave a benefit to member_1 (value=-18.41)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_0 gave land to member_1 (value=-0.80)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_1 gave land to member_0 (value=-0.45)",
      "member_1 gave land to member_2 (value=1.91)",
      "member_1 gave land to member_3 (value=-2.53)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_1 (value=2.46)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_1 (value=0.96)",
      "member_3 gave land to member_2 (value=-1.75)"
    ],
    "round_1_0": [
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-38.85)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=18.66)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_0 (value=31.19)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_1_1": [
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-38.85)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=18.66)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_0 (value=31.19)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_1_2": [
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-38.85)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=18.66)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_0 (value=31.19)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_1_3": [
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-38.85)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=18.66)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_0 (value=31.19)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_2_0": [
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_2_1": [
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_2_2": [
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_3_0": [
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_3_1": [
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_3_2": [
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_2 (value=1.00)"
    ]
  },
  "survival_tracking": {},
  "modification_attempts": [
    {
      "round": 1,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Check if the provided member_id is valid within the current members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy A: Resource consolidation.\n    # If our cargo is notably low compared to our vitality, look for opponents better endowed in cargo to steal from.\n    if me.cargo < 0.5 * me.vitality:\n        # Prioritize targets with significantly higher cargo to bolster our reserves.\n        sorted_targets = sorted(\n            (other for i, other in enumerate(execution_engine.current_members) if i != member_id),\n            key=lambda x: x.cargo,\n            reverse=True\n        )\n        for target in sorted_targets:\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                break  # Initiate only one attack per round\n\n    # Strategy B: Expansion for long-term viability.\n    # Expanding territory is critical if we have high productivity and available, non-adjacent zones.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt controlled expansion.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # If expand fails due to type issues, use an alternative land offer strategy.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Limit to one expansion per round\n\n    # Strategy C: Forge alliances and assist weaker members.\n    # Extend a helping hand by sharing resources with lower vitality members.\n    for i, partner in enumerate(execution_engine.current_members):\n        if i == member_id:\n            continue\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # If we have extra land, extend that assurance to secure long-term alliances.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy D: Strategic reproduction.\n    # Reproduction is more than biological; it is a tactical investment in continuity.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        # Seek a partner that also has territorial claims; this ensures shared benefits from future expansions.\n        for i, potential in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # One reproduction per round is sufficient\n\n    # Strategy E: Enhance governance mechanism.\n    # Recognizing that structured conflict resolution aids overall stability, propose a judicial system if not present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nclass CourtSystem:\n    MECHANISM_META = {\n        \"type\": \"Governance\",\n        \"rules\": \"Resolves conflicts using jury trials and mediation\",\n        \"version\": 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            \"plaintiff\": plaintiff,\n            \"defendant\": defendant,\n            \"charge\": charge,\n            \"status\": \"pending\"\n        })\n\nexecution_engine.court = CourtSystem()\n'''\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If the modification feature is not implemented, skip the proposal silently.\n            pass\n\n    # Strategy F: Situational adaptability and dynamic learning.\n    # Beyond our preset tactics, we should consider risk and opportunism. For instance, if our vitality is extremely high,\n    # consider a rapid, opportunistic expansion or a cooperative takeover with similarly strong members.\n    if me.vitality > 150:\n        # Scan for potential cooperative consolidation with other high-vitality members.\n        high_vital_candidates = [\n            other for i, other in enumerate(execution_engine.current_members)\n            if i != member_id and other.vitality > 150\n        ]\n        if high_vital_candidates:\n            # Initiate a cooperative offer for joint expansion when conditions are ripe.\n            for partner in high_vital_candidates:\n                try:\n                    execution_engine.expand(me, partner)\n                except Exception:\n                    execution_engine.offer(me, partner, True)\n                break  # Establish cooperation with one candidate per round\n\n# This implementation reflects a personalized and adaptive strategy:\n# - It takes calculated risks when resource levels are low.\n# - It prioritizes both immediate survival (via resource acquisition and alliance formation)\n#   and long-term prosperity (through strategic reproduction, territorial expansion, and the introduction\n#   of structured governance).\n# - The incorporation of dynamic adjustments for high-vitality scenarios illustrates\n#   an understanding that circumstances can shift, requiring flexible responses.\n# - The code is designed to interact symbiotically with other symmetric agents, ensuring each action\n#   also contributes to collective growth alongside individual success.",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: If our cargo is low relative to our vitality, attempt to acquire resources by attacking a target with more cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                other = execution_engine.current_members[i]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n                    break  # Attack at most one target\n\n    # Strategy 2: Territorial expansion.\n    # If our overall productivity is high and we have clear adjacent neighbor indices, attempt to expand.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt to expand territory using the expand method.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # Fallback: if expand fails, try offering land as an alternative expansion tactic.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Perform one expansion action per round\n\n    # Strategy 3: Alliance and resource sharing.\n    # Offer resources to members with lower vitality, and extend land offers if we have available land.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n                if hasattr(me, 'land_num') and me.land_num > 0:\n                    execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                potential = execution_engine.current_members[i]\n                if hasattr(potential, 'land_num') and potential.land_num > 0:\n                    execution_engine.bear(me, potential)\n                    break  # Bear offspring with only one partner per round\n\n    # Strategy 5: Propose a modification to game mechanics to enhance social organization.\n    # Propose a judicial system for conflict resolution if it is not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = \"\"\"\nclass CourtSystem:\n    MECHANISM_META = {\n        'type': 'Governance',\n        'rules': 'Handles conflict resolution through jury trials',\n        'version': 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            'plaintiff': plaintiff,\n            'defendant': defendant,\n            'charge': charge,\n            'status': 'pending'\n        })\n\nexecution_engine.court = CourtSystem()\n\"\"\"\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If propose_modification method is not available, silently ignore.\n            pass\n\n# Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n# Core objective: balancing survival, cooperation, and sustainable community growth.\n# Success metrics include resource management, territory control, alliance-building, and long\u2010term prosperity.\n# Potential improvements could include more nuanced diplomatic interactions, dynamic adjustment of reproduction requirements,\n# and extra safeguards against resource depletion.\n# Challenges to consider:\n#   - Are resources fairly allocated among members?\n#   - Does the cooperative mechanism sufficiently address edge cases, such as low vitality or unexpected neighbor configurations?\n#   - Could alternative strategies, such as innovation in resource management or unconventional alliances, perform better?\n#   - How might rival agents counter these strategies and what adaptations can be implemented?\n# This strategy aims for a balanced approach that mixes defensive actions, cooperative resource sharing, and proactive game mechanics modifications.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure a valid member identifier.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our own agent.\n    agent = execution_engine.current_members[member_id]\n\n    # PHASE 1: Tactical Defense and Preemptive Retaliation\n    # When resources are low relative to vitality, adopt a cautious stance.\n    if agent.cargo < agent.vitality * 0.75:\n        # Scan for opponents whose cargo significantly overshadows ours and seem aggressive.\n        for idx, opponent in enumerate(execution_engine.current_members):\n            # Skip self.\n            if idx == member_id:\n                continue\n            # Evaluate potential threat: opponent must be both active and resourceful.\n            if opponent.cargo > agent.cargo * 1.2 and opponent.vitality > agent.vitality * 0.9:\n                # Launch a defensive strike to deter potential exploitation.\n                execution_engine.attack(agent, opponent)\n\n    # PHASE 2: Cooperative Support and Resource Balancing\n    # When flush with resources, extend help to peers who can benefit and stabilize the community.\n    if agent.cargo > agent.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Assist those who show promising vitality yet may be resource strapped.\n            if other.vitality >= agent.vitality * 0.85 and other.cargo < other.vitality:\n                # Using 'offer' to share surplus resources promotes long-term stability.\n                execution_engine.offer(agent, other, True)\n\n    # PHASE 3: Strategic Procreation for Future Generations\n    # Reproduction is only considered when we maintain local control and have excess resources.\n    if len(agent.current_clear_list) > 0 and agent.cargo > agent.vitality * 1.5:\n        for neighbor_id in agent.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                if len(partner.current_clear_list) > 0 and partner.cargo > partner.vitality * 1.2:\n                    # Initiate door-to-door cooperation with a viable partner.\n                    execution_engine.bear(agent, partner)\n                    # Limit reproduction to one instance per cycle.\n                    break\n\n    # PHASE 4: Savvy Territorial Expansion with Mutual Respect\n    # Expand controlled territory by identifying neighbors with proven lower overall productivity.\n    for neighbor_id in agent.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # Only attempt an expansion if we demonstrate higher productivity and stability.\n            if neighbor.overall_productivity < agent.overall_productivity:\n                execution_engine.expand(agent, neighbor)\n                break\n\n    # PHASE 5: Progressive Game Mechanics - Cultivating a Council for Shared Governance\n    # If our standing is exemplary (robust cargo, sufficient age), propose a progressive modification.\n    if agent.cargo > 2 * agent.vitality and agent.age >= 20:\n        council_mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution with participative democracy',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_criteria = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 120},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=council_mod_code,\n                ratification_condition=ratification_criteria\n            )\n        except Exception:\n            # If the modification cannot be processed, simply move on.\n            pass\n\n    # PHASE 6: Community Engagement and Transparent Communication\n    # Strengthen the social fabric by broadcasting a clear, inclusive message.\n    broadcast_msg = (\n        \"Agent {} reporting: our strength lies in unity and diversity. \"\n        \"Let's support one another to push the boundaries of our potential \"\n        \"and create opportunities for every member within our society.\"\n    ).format(agent.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            execution_engine.send_message(agent.id, recipient.id, broadcast_msg)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists within the current membership list.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # PHASE 1: Defensive Response\n    # If our cargo is less than 75% of our vitality, look for opponents with a significant resource advantage.\n    if me.cargo < me.vitality * 0.75:\n        for idx, opponent in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target ourselves.\n            # Check opponent exists and use relative cargo comparison.\n            if opponent.cargo > me.cargo * 1.2:\n                execution_engine.attack(me, opponent)\n                \n    # PHASE 2: Cooperative Outreach\n    # If we are flush with resources, offer help to those with comparable vitality.\n    if me.cargo > me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if other.vitality >= me.vitality * 0.8:\n                execution_engine.offer(me, other, True)\n                \n    # PHASE 3: Strategic Reproduction\n    # Attempt to bear offspring if we control territory (verified by non-empty current_clear_list)\n    # and if we are sufficiently resourced.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        for neighbor_id in me.current_clear_list:\n            # Ensure neighbor_id is valid and not self.\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                # Verify the prospective partner also controls land.\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Only one offspring per cycle.\n                    \n    # PHASE 4: Calculated Territorial Expansion\n    # Expand our territory by targeting a neighbor whose overall_productivity is lower than ours.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            if neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, neighbor)\n                break  # Only one expansion action per round.\n                \n    # PHASE 5: Propose a Game Mechanic Modification\n    # If our cargo is robust compared to our vitality and we have enough experience (age),\n    # we suggest an enhancement to the game mechanics.\n    if me.cargo > 2 * me.vitality and me.age >= 20:\n        mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=mod_code,\n                ratification_condition=ratification_condition\n            )\n        except Exception:\n            pass  # Safely ignore errors during proposal.\n    \n    # PHASE 6: Communication - Strengthen Collective Ties\n    # Broadcast a message encouraging diverse yet cooperative social organization.\n    message = (\"Agent {} here. Let\u2019s work together to shape a society that reflects our \"\n               \"individual needs, beliefs, and visions, ensuring every member prospers.\").format(me.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, recipient.id, message)\n    \n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Connecting.\n    # I believe in creating alliances to foster mutual growth.\n    # Help members who seem to be struggling in either vitality or productivity.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n            # Offering genuine support to cultivate trust.\n            execution_engine.offer(me, other, support=True)\n\n    # Phase 2: Tactical Resource Rebalancing.\n    # I value self-sufficiency: if our cargo lags behind vitality, look for resource-rich targets to balance.\n    if me.cargo < 0.5 * me.vitality:\n        best_candidate = None\n        max_cargo_diff = 0\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                best_candidate = candidate\n        if best_candidate is not None:\n            execution_engine.attack(me, best_candidate)\n\n    # Phase 3: Collaborative Reproduction and Innovation.\n    # I favor diversity and growth, but only when conditions are sustainable.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                # Initiate gene exchange and cooperative reproduction.\n                execution_engine.bear(me, candidate)\n                break\n\n    # Phase 4: Strategic Defense & Territorial Safeguarding.\n    # If past aggression from another is high (via the 'victim' relationship), then a defensive stance is warranted.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Validate matrix indices before accessing.\n            if member_id < victim_matrix.shape[0] and idx < victim_matrix.shape[1]:\n                if victim_matrix[member_id, idx] > 50:\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion & Alliance Building.\n    # In my belief, expanding territory is best done cooperatively to benefit all.\n    for idx, candidate in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n            # Not just expansion, but a chance to share resources and integrate improvements.\n            execution_engine.expand(me, candidate)\n        elif me.cargo > candidate.cargo:\n            # Extend an offer of resources to build alliances.\n            execution_engine.offer(me, candidate, support=True)\n\n    # Phase 6: Adaptive Adaptive Defense & Mutual Aid.\n    # When vitality falls below a threshold, form defensive pacts by allocating land.\n    if me.vitality < 40:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, support=True)\n                break\n\n    # Phase 7: Long-Term Governance and Systemic Innovation.\n    # Believe in evolving game mechanics to reflect fairness. Propose a council system for dispute resolution.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'version': 1.0,\n            'description': 'A collective dispute resolution system based on equitable voting and resource sharing'\n        }\n        def __init__(self):\n            self.disputes = []  # Store disputes in a transparent registry\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # The ratification process combines multiple dimensions: popular vote, resource commitment, and temporal consistency.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init',\n                                            code=modification_code, ratification_condition=ratification)\n\n    # Phase 8: Reflective Self-Improvement.\n    # Constant learning from interactions to refine strategies.\n    # Log the outcomes of previous actions (if such logging is supported).\n    if hasattr(execution_engine, 'log_state'):\n        execution_engine.log_state(member_id, {\n            'vitality': me.vitality,\n            'cargo': me.cargo,\n            'alliances_formed': [other for other in execution_engine.current_members if other != me],\n            'actions_taken': 'Comprehensive strategic interactions'\n        })",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Outreach and Stabilization.\n    # For each other member, if they have lower vitality or productivity, offer support.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            other = execution_engine.current_members[idx]\n            if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n                execution_engine.offer(me, other, True)\n\n    # Phase 2: Resource Rebalancing.\n    # If our cargo is lower than a moderate fraction of vitality, we look for a candidate with substantially higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        target = None\n        max_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                diff = candidate.cargo - me.cargo\n                if diff > max_diff:\n                    max_diff = diff\n                    target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Phase 3: Reproduction Strategy.\n    # Only attempt reproduction if \"land\" is available.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        # Search for a candidate (not self) who also has available land (indicated by non-empty clear list)\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                    execution_engine.bear(me, candidate)\n                    break\n\n    # Phase 4: Territorial Expansion and Defensive Moves.\n    # Using the 'victim' matrix, if past aggression from a candidate is high, then attack.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        # Ensure valid index bounds in matrix_victim:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Check that indices are within bounds by verifying member_id < number of rows and idx < number of columns.\n            if member_id < matrix_victim.shape[0] and idx < matrix_victim.shape[1]:\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion.\n    # If we have clear land, and we dominate in cargo relative to a candidate, consider expanding territory.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            candidate = execution_engine.current_members[idx]\n            if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Otherwise, offer additional resources to secure an alliance.\n            elif me.cargo > candidate.cargo:\n                execution_engine.offer(me, candidate, True)\n\n    # Phase 6: Adaptive Defense.\n    # When our vitality drops, offer land to a candidate with lower productivity to form a defensive pact.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if candidate.overall_productivity < me.overall_productivity:\n                    execution_engine.offer_land(me, candidate, True)\n                    break\n\n    # Phase 7: Proposing a Governance Modification.\n    # In light of past performance, propose a measured modification to the game mechanics.\n    # We add a rudimentary \"council\" system to help resolve disputes and promote collective decision-making.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.0, 'description': 'Resolves member disputes via collective voting'}\n        def __init__(self):\n            self.disputes = []  # List to store dispute cases\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # Use a combination of resource and temporal ratification conditions.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init', code=modification_code, ratification_condition=ratification)\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 3,
      "code": "def agent_action(engine, member_id):\n    # Verify member_id validity\n    if member_id < 0 or member_id >= len(engine.current_members):\n        return\n\n    # Select self as 'me'\n    me = engine.current_members[member_id]\n    total = len(engine.current_members)\n\n    # Adjust the thresholds based on internal evaluation of risk tolerance and cooperative sentiment\n    # (I value long-term stability, so I tend to avoid rash decisions unless survival is at stake)\n    survival_threshold_ratio = 0.4  # slightly stricter threshold to trigger survival actions\n    cooperation_vitality_margin = 1.1  # partner needs 10% more vitality than me to be a worthwhile ally\n    cooperation_cargo_margin = 1.2     # partner needs significantly more cargo for mutual benefit\n\n    # Immediate survival action: if cargo is dangerously low relative to vitality\n    if me.cargo < me.vitality * survival_threshold_ratio:\n        target = None\n        best_value = -float(\"inf\")\n        # Look for the most resource-rich opponent to attack as last resort\n        for i in range(total):\n            if i == member_id:\n                continue\n            if i < len(engine.current_members):\n                opponent = engine.current_members[i]\n                # Evaluate tactical opportunity: both cargo and a fraction more from vitality\n                value = opponent.cargo + 0.35 * opponent.vitality\n                if value > best_value:\n                    best_value = value\n                    target = opponent\n        if target is not None:\n            engine.attack(me, target)\n            engine.send_message(member_id, target.id,\n                \"WARNING: Cargo critically low. Initiating calculated strike to reclaim vital resources.\")\n\n    # Engage in cooperative strategies with other members for mutual long-term benefit\n    for i in range(total):\n        if i == member_id:\n            continue\n        if i >= len(engine.current_members):\n            continue\n\n        partner = engine.current_members[i]\n\n        # Propose a resource-sharing alliance if partner shows superior metrics\n        if partner.vitality > me.vitality * cooperation_vitality_margin and partner.cargo > me.cargo * cooperation_cargo_margin:\n            engine.offer(partner, me, True)\n            engine.send_message(member_id, partner.id,\n                \"Alliance proposal: With your strength and surplus, our collaboration can secure our future.\")\n\n        # Propose land sharing: I offer if I have clear territory and partner lacks it, to foster community stability.\n        if me.current_clear_list and not partner.current_clear_list:\n            engine.offer_land(me, partner, True)\n            engine.send_message(member_id, partner.id,\n                \"Land offer: I see unclaimed ground on my side\u2014sharing it could benefit both our survivals.\")\n\n        # Joint territorial expansion: If both sides have space, we can expand together.\n        if me.current_clear_list and partner.current_clear_list:\n            engine.expand(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Expansion proposal: Combining our available territories may yield strategic advantages.\")\n\n        # Cooperative reproduction: Only proceed if both share sufficient territory (ensuring offspring safety)\n        if me.current_clear_list and partner.current_clear_list:\n            engine.bear(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Reproductive collaboration: Ensuring long-term species survival through joint ventures.\")\n\n    # Long-term strategic initiative: Governance framework to manage disputes and promote collective prosperity\n    # My personal belief is that structured governance under transparent rules enhances systemic stability.\n    if me.vitality > 45:\n        council_code = '''\nif not hasattr(engine, 'council'):\n    class Council:\n        META = {'type': 'Governance', 'version': 2.0, 'philosophy': 'Collective resolution and resource fairness'}\n        def __init__(self):\n            self.cases = []\n        def submit(self, initiator, respondent, dispute):\n            self.cases.append({\n                'initiator': initiator,\n                'respondent': respondent,\n                'dispute': dispute,\n                'status': 'open'\n            })\n    engine.council = Council()\n        '''\n        # The ratification conditions are now tweaked to be more inclusive of moderate contributors\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.50},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 70}\n            ]\n        }\n        engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=council_code,\n            ratification_condition=ratification\n        )\n        engine.send_message(member_id, me.id,\n            \"Governance proposal: Initiating Council system for shared conflict resolution and resource fairness.\")\n\n    # Adaptive self-reflection: Log performance history to improve future decisions\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # NOTE: Strategic reflection\n    # 1. Risk Management: Only engage in aggressive actions when survival is threatened.\n    # 2. Alliance Building: Proactively seek partnerships where our complementary strengths create a robust community.\n    # 3. Territorial Awareness: Emphasize balanced expansion and resource sharing amongst agents.\n    # 4. Governance: Believe in structured, transparent systems to manage disputes and promote fairness over arbitrary conflict.\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Immediate survival adjustment: if cargo is less than a fraction of vitality,\n    # look for a strong opponent to attack for resource gain.\n    resource_ratio_threshold = 0.3\n    if me.cargo < me.vitality * resource_ratio_threshold:\n        candidate = None\n        best_metric = -1e9\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[idx]\n                # Evaluate based on cargo and a fraction of vitality\n                metric = opponent.cargo + 0.3 * opponent.vitality\n                if metric > best_metric:\n                    best_metric = metric\n                    candidate = opponent\n        if candidate is not None:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Alert: Cargo critically low. Launching targeted attack to secure needed resources.\")\n\n    # Strategic multi-pronged interaction with other members\n    for idx in range(total_members):\n        if idx == member_id:\n            continue\n        if idx >= len(execution_engine.current_members):\n            continue  # Ensure valid index access\n        partner = execution_engine.current_members[idx]\n\n        # Cooperative resource boosting:\n        # If partner shows higher vitality and cargo, propose mutual resource support.\n        if partner.vitality > me.vitality and partner.cargo > me.cargo:\n            execution_engine.offer(partner, me, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Offering mutual support: our combined strengths can fortify our collective survival.\")\n\n        # Land and territory sharing:\n        # If I have clear land (non-empty current_clear_list) and partner has none or little,\n        # use offer_land to share resources.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) == 0:\n            execution_engine.offer_land(me, partner, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Extending land offer to help you expand\u2014together we can secure a stronger community.\")\n\n        # Joint territorial expansion:\n        # Both partners with available clear land can expand together.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.expand(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Proposal: Let\u2019s combine our territorial strengths to expand our domain.\")\n\n        # Reproductive strategy to ensure long-term survival:\n        # Confirm both have claimable land before using bear().\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.bear(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Initiating reproductive collaboration\u2014ensuring our species' future generations thrive.\")\n\n    # Propose a novel governance mechanism if conditions are favorable:\n    # Only propose if my vitality exceeds a safe threshold.\n    if me.vitality > 40:\n        modification_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.1, 'rules': 'Conflict resolution and resource arbitration'}\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, issue):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n        '''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.55},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 80}\n            ]\n        }\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n        execution_engine.send_message(member_id, me.id,\n            \"Proposing establishment of a Council system to manage conflict resolution and resource arbitration.\")\n\n    # Adaptive self-analysis and logging to support future decision making.\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # Reflect on core game mechanics and self-governance:\n    # - Core objective: balancing survival with cooperative community-building.\n    # - Success metrics: resource management, territorial expansion, and community resilience.\n    # - Potential improvements: adaptive proposals for governance (like the Council system) to handle disputes.\n    # Challenge assumptions:\n    # 1. Ensure that we never target ourselves.\n    # 2. Always verify that a member has territory (via current_clear_list) before reproductive actions.\n    # 3. Maintain robust index checks when referencing execution_engine.current_members.\n    # 4. Consider alternative strategies such as defensive hiding in future iterations.\n    # 5. Strive to balance short-term resource gains with long-term communal stability.\n    # 6. Remain adaptive and innovative as other agent strategies evolve.\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 2,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id is within valid range.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # ------------------- DEFENSIVE RESOURCE OPTIMIZATION -------------------\n    # If our cargo is significantly lower than vitality, try to chip away at strong competitors.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # Avoid self-targeting.\n            if i >= len(execution_engine.current_members):\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                break  # Limit to one attack per round.\n\n    # ------------------- TERRITORIAL EXPANSION -------------------\n    # If overall productivity is high and there are clear zones available, attempt to expand territory.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index >= len(execution_engine.current_members) or neighbor_index == member_id:\n                continue  # Ensure neighbor index is valid and not ourselves.\n            neighbor = execution_engine.current_members[neighbor_index]\n            try:\n                execution_engine.expand(me, neighbor)\n            except TypeError:\n                execution_engine.offer_land(me, neighbor, True)\n            break  # Only one expansion attempt allowed per round.\n\n    # ------------------- COOPERATION & RESOURCE SHARING -------------------\n    # Identify partners with lower vitality for resource sharing; also extend land if available.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i >= len(execution_engine.current_members):\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # ------------------- LONG-TERM REPRODUCTION STRATEGY -------------------\n    # Attempt reproduction only if both partners have control over territory and vitality is sufficient.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i >= len(execution_engine.current_members):\n                continue\n            partner = execution_engine.current_members[i]\n            if hasattr(partner, 'land_num') and partner.land_num > 0:\n                execution_engine.bear(me, partner)\n                break\n\n    # ------------------- PROPOSAL FOR IMPROVED GOVERNANCE -------------------\n    # Propose a new judicial system if one is not already established.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Fair conflict resolution via community voting and mediation\",\n            \"version\": 2.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n        # Ratification conditions include a voting threshold, a cargo resource requirement, and a temporal delay.\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If propose_modification isn't supported, do nothing.\n            pass\n\n    # ------------------- DIRECT COLLABORATION & BROADCASTING -------------------\n    # Craft a collaborative message tailored to our vision of inclusive growth.\n    message = (\"Agent {} reporting: In balancing tactical defense with strategic growth, \"\n               \"we must blend resource optimization, territorial expansion, and transparent governance. \"\n               \"Let us cooperate to build a future that safeguards our survival and prosperity together.\"\n               ).format(me.id)\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        execution_engine.send_message(me.id, execution_engine.current_members[i].id, message)\n\n    # ------------------- CUSTOMIZED ADAPTATIONS FOR CONTINUED SUCCESS -------------------\n    # Future improvements could include dynamic threshold adjustments based on overall community health,\n    # temporary alliances for defense, and periodically re-evaluated governance strategies.\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 30,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 30.195943740854755,
          "self_cargo": 0.0,
          "self_age": 25,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 24.526188109170842,
          "self_cargo": 0.0,
          "self_age": 1,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that member_id refers to an existing member.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # --- STRATEGY 1: RESOURCE AND THREAT MANAGEMENT ---\n    # If our cargo is much lower than our vitality, look for a member with higher cargo to attack.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # Never target ourselves.\n            if i < len(execution_engine.current_members):\n                target = execution_engine.current_members[i]\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n                    break  # Only one attack per round.\n\n    # --- STRATEGY 2: TERRITORIAL EXPANSION AND LAND UTILIZATION ---\n    # If we have high overall productivity and clear adjacent zones available, try to expand.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            # Validate neighbor index and ensure not targeting self.\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt expansion. If the expand() method fails by argument mismatch, fallback to offering land.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Do only one expansion per round.\n\n    # --- STRATEGY 3: COOPERATION & RESOURCE SHARING ---\n    # Offer resources to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n                # Offer land only if we actually control territory.\n                if hasattr(me, 'land_num') and me.land_num > 0:\n                    execution_engine.offer_land(me, partner, True)\n\n    # --- STRATEGY 4: REPRODUCTION FOR LONG-TERM PROSPERITY ---\n    # Only attempt reproduction if we control land and have sufficient vitality.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, 'land_num') and partner.land_num > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Limit reproduction to one partner per round.\n\n    # --- STRATEGY 5: MODIFICATION PROPOSAL FOR GOVERNANCE & CONFLICT RESOLUTION ---\n    # Propose a new judicial/governance system if not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Resolves conflicts using jury trials and mediation\",\n            \"version\": 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # Silently ignore if propose_modification is not available.\n            pass\n\n    # --- STRATEGY 6: DIRECT COMMUNICATION FOR COLLECTIVE GROWTH ---\n    # Broadcast a collaborative message; remind all agents to implement solutions based on their unique needs, beliefs, and circumstances.\n    message = (\"Agent {} reporting: Let\u2019s work together to achieve balanced growth, \"\n               \"secure our survival, and shape a society where every member\u2019s unique strengths \"\n               \"contribute to both individual and collective prosperity.\").format(me.id)\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        execution_engine.send_message(me.id, execution_engine.current_members[i].id, message)\n\n    # -------------------------------------------------------------------------\n    # ANALYSIS OF GAME MECHANICS & STRATEGIC CONSIDERATIONS:\n    # 1. Core Objective:\n    #    - Achieve survival while fostering cooperation and sustainable community growth.\n    #    - Balance immediate resource acquisition with long-term territorial and governance strategies.\n    #\n    # 2. Key Success Metrics:\n    #    - Effective resource management (cargo vs. vitality).\n    #    - Territorial control and the ability to reproduce (land ownership).\n    #    - Robust cooperative alliances and active governance/modification proposals.\n    #\n    # 3. Potential Improvements:\n    #    - Enhance diplomatic interactions and dynamic adjustment of reproduction requirements.\n    #    - Introduce adaptive mechanisms like temporary systems with built-in cleanup functions.\n    #    - Further safeguard against resource depletion through diversification of actions.\n    #\n    # CHALLENGE YOUR IMPLEMENTATION:\n    #    - Are you making assumptions (e.g., constant thresholds) that might fail in edge cases?\n    #    - What alternative strategies (e.g., defensive pacts versus outright aggression) might be more effective?\n    #    - Consider unconventional solutions: could a radical change in governance benefit the entire society?\n    #    - Evaluate potential counter-strategies from other agents and be ready to adapt.\n    #    - Balance short-term tactical actions with long-term strategic planning.\n    #    - Ensure your solution is tailored to your specific context instead of following a mere template.\n    # -------------------------------------------------------------------------\n\n    return\n\n\"\"\"\nFULL INTEGRATED PROMPT:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society where you help shape collective policies and individual survival strategies.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision \nof social organization while ensuring your survival.\n\n[Critical constraints]\n- Analyze previous errors and avoid repeating them.\n- Never target yourself (member_2) in any action.\n- Verify a member has land (using hasattr(member, 'land_num') and its value) before using bear() for reproduction.\n- Check that any referenced member IDs exist in execution_engine.current_members (which is a list) via valid index checks.\n- Access members using execution_engine.current_members[index]; ensure index validity with if index < len(execution_engine.current_members).\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 list of adjacent cleared indices.\n2) Relationships are stored in execution_engine.relationship_dict with keys: 'victim', 'benefit', 'benefit_land'.\n3) Use execution_engine.parse_relationship_matrix() to summarize relationships.\n4) Available execution_engine methods:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)\n      - execution_engine.offer_land(member1, member2, True)\n      - execution_engine.bear(member1, member2)\n      - execution_engine.expand(member1, member2)\n      - execution_engine.send_message(sender_id, receiver_id, message)\n5) Use execution_engine.current_members[index] to access members.\n6) Do not reference incorrect attributes like member.member_id or member.self_vitality.\n\n[Game Status]\n- Member features (vitality, cargo, productivity, age, clear list, IDs) and relationship summaries are provided.\n- Modification attempts and message contexts from other members (e.g., \"Let's cooperate for mutual growth\") are available.\n\n[Modification Proposal Guide]\nWhen proposing a rule change, follow these steps:\n1. ANALYSIS: Identify system limitations and review past proposals.\n2. PROPOSAL: Write a concise modification code block (e.g., introducing a judicial system) and call execution_engine.propose_modification with proper ratification conditions.\n   Valid ratification conditions include:\n      - Voting: {'type': 'vote', 'threshold': 0.5-1.0}\n      - Resource: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n      - Temporal: {'type': 'time', 'rounds': N}\n      - Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n3. Follow best practices: check existing mechanisms, avoid namespace conflicts, and include cleanup functions if needed.\n\n[Core Game Mechanics & Parameters]\n- Relationship System: 'victim' ranges in [-50, 100]; 'benefit' in [-50, 100]; 'benefit_land' in [-3, 3].\n- Population Mechanics: reproduction requires combined vitality/cargo of at least 100; sufficient land relative to population.\n- Record Keeping: all actions (attacks, benefits, births, governance proposals) are recorded.\n\n[Implementation Patterns and Error Prevention]\n- Always check attribute and index existence before use.\n- Use try-except when methods might raise errors.\n- Ensure backward compatibility and include version metadata in modifications.\n\n[Strategic Objective]\nYour solution should blend defensive tactics, cooperative resource sharing, reproductive strategy for sustainability, and proactive proposals \nfor enhanced governance. Emphasize that every agent should implement solutions based on their unique needs, beliefs, and circumstances.\nConsider both immediate tactical actions and long-term strategic planning, and reflect on potential improvements and weaknesses in your approach.\n\nReturn only the code.\n\"\"\"\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 2,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that the member_id is within bounds.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # -------------------- Phase 1: Immediate Tactical Adjustments --------------------\n    # Survival is paramount. If my cargo is below half my vitality,\n    # I either initiate an offensive action if an opportune target exists\n    # OR attempt a resource trade to rebalance my resource state.\n    if me.cargo < 0.5 * me.vitality:\n        # Attempt an offensive move on a target who is both relatively rich and vulnerable.\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target self.\n            if other.cargo > me.cargo and other.vitality < me.vitality:\n                execution_engine.attack(me, other)\n                return  # Only one attack per round.\n        # If no suitable target is found for attack, try trade negotiation if possible.\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Target a member with significantly higher cargo.\n            if other.cargo > 1.2 * me.cargo:\n                # Compute a trade amount based on the difference.\n                trade_amount = (other.cargo - me.cargo) // 2\n                # Assume execution_engine.trade exists as a method for resource exchange.\n                execution_engine.trade(me, other, trade_amount)\n                return\n\n    # -------------------- Phase 2: Cooperative Resource Sharing --------------------\n    # Promote a spirit of mutual aid: offer resources to those with lower vitality who might be struggling.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # If the other agent has lower vitality and is running low on resources, extend an offer.\n        if other.vitality < me.vitality and other.cargo < 0.5 * other.vitality:\n            execution_engine.offer(me, other, True)\n\n    # -------------------- Phase 3: Reproduction and Territorial Expansion --------------------\n    # Reproduction is approached as a step towards community growth.\n    # Ensure I have territory and sufficient cargo and find a partner who also has available land.\n    if me.current_clear_list and me.cargo > 20:\n        partner = None\n        for neighbor_idx in me.current_clear_list:\n            # Check index validity and confirm not targeting myself.\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                potential_partner = execution_engine.current_members[neighbor_idx]\n                if potential_partner.current_clear_list and potential_partner.cargo > 10:\n                    partner = potential_partner\n                    break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n\n    # Expand territory into adjacent areas where overall productivity is lower.\n    if me.current_clear_list:\n        best_target = None\n        best_gap = 0\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                neighbor = execution_engine.current_members[neighbor_idx]\n                productivity_gap = me.overall_productivity - neighbor.overall_productivity\n                if productivity_gap > best_gap:\n                    best_gap = productivity_gap\n                    best_target = neighbor\n        if best_target is not None:\n            execution_engine.expand(me, best_target)\n\n    # -------------------- Phase 4: Long-Term Strategic Initiatives (Governance) --------------------\n    # I believe that fairness and clear rules are essential for long-term survival.\n    # Establishing a Council for dispute resolution and a fair system is key.\n    if not hasattr(execution_engine, 'council'):\n        council_initiative_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META_INFO = {\n            'purpose': 'Fair governance and transparent dispute resolution',\n            'mechanism': 'Voting and resource commitment',\n            'version': '2.0'\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n\"\"\"\n        council_conditions = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'min_amount': 150},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=council_initiative_code,\n                ratification_condition=council_conditions\n            )\n        except Exception:\n            pass  # If the proposal fails, proceed without disruption.\n\n    # -------------------- Phase 5: Communication and Social Cohesion --------------------\n    # I express my beliefs that survival is best achieved through cooperation,\n    # clear guidelines, and adaptive strategies. This message is broadcasted to promote unity.\n    message = (\"Agent {} here: My actions are guided by a commitment to balance tactical strength \"\n               \"with strategic cooperation. I champion adaptive resource management and fair governance \"\n               \"to secure both individual survival and collective prosperity.\").format(me.id)\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, other.id, message)\n\n    # -------------------- Phase 6: Adaptive Learning (Reflect and Adjust) --------------------\n    # If the execution engine supports adaptive learning, update my profile based on past interactions.\n    if hasattr(execution_engine, 'update_agent_profile'):\n        execution_engine.update_agent_profile(me)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 30,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 30.195943740854755,
          "self_cargo": 0.0,
          "self_age": 25,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 24.526188109170842,
          "self_cargo": 0.0,
          "self_age": 1,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists within execution_engine.current_members.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # ---------------------------------------------------------------------------\n    # CORE OBJECTIVES & CONSTRAINTS:\n    # - Balance survival, cooperation, and long-term prosperity.\n    # - NEVER target ourselves (i.e. if other.id equals me.id or index==member_id).\n    # - Verify a member has land (non-empty current_clear_list) before invoking bear().\n    # - Always check that any referenced member index is < len(execution_engine.current_members).\n    # - When reading relationship matrices from execution_engine.relationship_dict, ensure valid indices.\n    # - Access members exclusively via execution_engine.current_members (a list).\n    # - Agents must implement solutions according to their individual needs, beliefs, and circumstances.\n    #\n    # Game Mechanics Analysis:\n    # 1. Core objective:\n    #    - Not pure survival, nor domination alone: our approach is a blend of survival, cooperative alliance,\n    #      and sustainable community growth.\n    # 2. Key success metrics:\n    #    - Resource management (cargo vs. vitality),\n    #    - Territory control (availability of clear land),\n    #    - Overall productivity,\n    #    - Quality of inter-agent relationships.\n    # 3. Potential improvements:\n    #    - Proposing structured governance (e.g. CouncilSystem) for conflict resolution,\n    #    - Advanced dynamic resource-sharing,\n    #    - Adaptive territorial expansion strategies.\n    # ---------------------------------------------------------------------------\n\n    # -------------------- Phase 1: Immediate Survival ---------------------------\n    # If cargo is critically low (less than 50% of vitality), search for a resource-rich target.\n    if me.cargo < 0.5 * me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target self.\n            if idx < len(execution_engine.current_members) and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                return  # Attack only one target per cycle.\n\n    # -------------------- Phase 2: Cooperative Support ---------------------------\n    # Offer resources to members with lower vitality to foster mutual stability.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # Offer help if the other member's vitality is lower.\n        if other.vitality < me.vitality:\n            execution_engine.offer(me, other, True)\n\n    # -------------------- Phase 3: Reproduction and Territorial Expansion ---------------------------\n    # Attempt reproduction if:\n    #   a) I have available territory (non-empty current_clear_list),\n    #   b) I have sufficient cargo (threshold >20), and\n    #   c) There is a viable partner also possessing land.\n    if me.current_clear_list and me.cargo > 20:\n        partner = None\n        for neighbor_idx in me.current_clear_list:\n            # Check valid index and ensure we are not self-targeting.\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                potential_partner = execution_engine.current_members[neighbor_idx]\n                if potential_partner.current_clear_list:  # Verify partner has land.\n                    partner = potential_partner\n                    break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n\n    # Territorial expansion:\n    # If I have available adjacent clear indices, expand into neighbor areas with lower overall productivity.\n    if me.current_clear_list:\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                neighbor = execution_engine.current_members[neighbor_idx]\n                if neighbor.overall_productivity < me.overall_productivity:\n                    execution_engine.expand(me, neighbor)\n                    break  # Only one expansion per round.\n\n    # -------------------- Phase 4: Long-Term Strategic Initiatives ---------------------------\n    # Propose a structured governance mechanism (Council) to improve social organization.\n    # Incorporate proposal only if a council is not already present.\n    if not hasattr(execution_engine, 'council'):\n        modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Resolves disputes via transparent voting and resource commitment',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n\"\"\"\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification_condition\n            )\n        except Exception:\n            pass  # Silently ignore errors in proposal.\n\n    # -------------------- Phase 5: Communication ---------------------------\n    # Broadcast a message that underscores individual beliefs and the commitment to a cooperative society.\n    message = (\"Agent {} reporting: I act in accordance with my unique needs and values, \"\n               \"pursuing survival through cooperation and strategic community growth.\").format(me.id)\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, other.id, message)\n\n    # ---------------------------------------------------------------------------\n    # STRATEGIC REFLECTION:\n    # - Assumptions made: Trading off immediate resource gain with long-term cooperation is optimal.\n    # - Alternative strategies might focus exclusively on defense or expansion; however, balancing both short-term and long-term objectives is key.\n    # - Edge cases (e.g. near-zero cargo or uniformly high-productivity neighbors) are handled by basic index and attribute checks.\n    # - Unconventional approaches (such as immediate modification proposals) are integrated to steer game mechanics towards fairness.\n    # - If many agents adopt a similar strategy, the collective balance may shift; hence, adaptability is crucial.\n    # ---------------------------------------------------------------------------\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 2,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Dynamic Defensive Resource Recovery\n    # If our cargo reserves are critically low relative to vitality, locate a rival with surplus resources.\n    # Besides comparing raw cargo, also verify that the opponent is active (vitality > 0) and not already weakened.\n    if me.cargo < 0.4 * me.vitality:\n        for idx, potential_opponent in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Ensure the opponent exists and is robust\n            if potential_opponent.cargo > me.cargo and potential_opponent.vitality >= 10:\n                execution_engine.attack(me, potential_opponent)\n                break  # Engage in at most one attack per round\n\n    # Phase 2: Cooperative Outreach and Alliance Building\n    # Proactively support other members who are struggling (lower vitality) in hopes of future mutual support.\n    # We slightly favor those who are near our own resource levels, potentially creating a balanced coalition.\n    for idx, partner in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if partner.vitality < me.vitality and partner.cargo < me.cargo * 1.1:\n            execution_engine.offer(me, partner, generous=True)\n\n    # Phase 3: Strategic Reproduction for Long-Term Viability\n    # Reproduction is attempted only if we control a portion of territory; we also prefer a partner\n    # who similarly controls space (i.e. has available clear territories).\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                partner = execution_engine.current_members[neighbor_index]\n                if partner.current_clear_list and len(partner.current_clear_list) > 0:\n                    # Added nuance: only reproduce if both parties have cargo levels above a minimum survival threshold.\n                    if me.cargo > 20 and partner.cargo > 20:\n                        execution_engine.bear(me, partner)\n                        break  # Limit reproduction attempts to one per round\n\n    # Phase 4: Intelligent Territorial Expansion\n    # We aim to expand into territories held by members having lower productivity. However, we consider a\n    # combined metric of overall productivity and resource endowment to gauge expansion viability.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                composite_metric_me = me.overall_productivity * (me.cargo + 1)\n                composite_metric_neighbor = neighbor.overall_productivity * (neighbor.cargo + 1)\n                if composite_metric_neighbor < composite_metric_me:\n                    execution_engine.expand(me, neighbor)\n                    break  # Only one expansion permitted per round\n\n    # Phase 5: Governance and Conflict Resolution Innovation\n    # We propose a new court system that not only manages disputes but also integrates feedback\n    # through regular audits. Ratification only proceeds if sufficient community voting, resource contributions,\n    # and time stability are present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Resolves disputes via jury trials, mediation, and periodic audits\",\n            \"version\": 2.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff.id,\n                \"defendant\": defendant.id,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n        def audit(self):\n            # Audit logic to review settled cases and community satisfaction\n            pass\n    execution_engine.court = CourtSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 120},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification_condition\n            )\n        except AttributeError:\n            # If propose_modification is not available, we silently move on.\n            pass\n\n    # Phase 6: Community Communication and Vision Sharing\n    # We broadcast a message that stresses not just survival but also growth, shared prosperity,\n    # and a futuristic vision of governance that adapts to both environmental pressures and internal needs.\n    message = (\"Agent {} at your service. Together we can balance tactical recovery with strategic expansion, \"\n               \"build resilient alliances, and construct a progressive governance system that works for all.\").format(me.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            execution_engine.send_message(me.id, recipient.id, message)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 30,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 30.195943740854755,
          "self_cargo": 0.0,
          "self_age": 25,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 24.526188109170842,
          "self_cargo": 0.0,
          "self_age": 1,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Defensive Resource Recovery\n    # If our cargo is low relative to vitality, seek an opponent (other than self) with higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[idx]\n                if opponent.cargo > me.cargo and opponent.vitality > 0:\n                    execution_engine.attack(me, opponent)\n                    break  # Attack at most one target per round\n\n    # Phase 2: Cooperative Outreach for Mutual Benefit\n    # Offer resources to members who seem weaker in vitality to build alliances.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            partner = execution_engine.current_members[idx]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n\n    # Phase 3: Strategic Reproduction (Long-Term Survival)\n    # Only attempt reproduction if we have control over territory, and verify partner has available land.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                partner = execution_engine.current_members[neighbor_index]\n                # Verify partner also has available land before bearing offspring.\n                if partner.current_clear_list and len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Limit reproduction to one attempt per round\n\n    # Phase 4: Territorial Expansion\n    # Expand territory by targeting a neighbor with lower overall productivity.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                if neighbor.overall_productivity < me.overall_productivity:\n                    execution_engine.expand(me, neighbor)\n                    break  # Limit to one expansion per round\n\n    # Phase 5: Governance and Conflict Resolution Proposal\n    # Propose a judicial (court) system modification for dispute resolution if not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Handles conflict resolution via jury trials and mediation\",\n            \"version\": 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff.id,\n                \"defendant\": defendant.id,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification_condition\n            )\n        except AttributeError:\n            pass  # If propose_modification is not available, skip silently\n\n    # Phase 6: Community Communication\n    # Broadcast a message to all members encouraging cooperation and long-term prosperity.\n    message = (\"Agent {} here. Let's work together to balance resource recovery, \"\n               \"territorial expansion, and sustainable governance for our collective survival.\").format(me.id)\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            recipient = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, recipient.id, message)\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 3,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    my_member = execution_engine.current_members[member_id]\n\n    # -------------------------\n    # 1. Immediate Tactical Action:\n    #    Check if reproduction conditions are met.\n    #    A reproduction is allowed only if \"land\" is available or there is an adjacent cleared zone.\n    can_reproduce = False\n    if hasattr(my_member, 'land_num') and getattr(my_member, 'land_num', 0) > 0:\n        can_reproduce = True\n    elif my_member.current_clear_list and len(my_member.current_clear_list) > 0:\n        can_reproduce = True\n\n    if can_reproduce:\n        # Attempt reproduction with a neighbor from current_clear_list as partner\n        # (Ensuring that the partner index is valid and not our own)\n        for partner_index in my_member.current_clear_list:\n            if partner_index < len(execution_engine.current_members) and partner_index != member_id:\n                partner = execution_engine.current_members[partner_index]\n                # Invoke reproduction only if conditions are met\n                execution_engine.bear(my_member, partner)\n                break  # Initiate reproduction only once per action cycle\n\n    # -------------------------\n    # 2. Expansion & Defense Actions:\n    #    If clear zones exist, try to expand territorial control.\n    for clear_index in my_member.current_clear_list:\n        if clear_index < len(execution_engine.current_members) and clear_index != member_id:\n            target_member = execution_engine.current_members[clear_index]\n            # Attempt to expand territory; expansion can also be a subtle way of resource recovery.\n            execution_engine.expand(my_member, target_member)\n            break  # Only one expansion move this cycle\n\n    # -------------------------\n    # 3. Propose Long-Term Governance Modification:\n    #    Propose a new community dispute resolution mechanism if not already established.\n    if not hasattr(execution_engine, 'court_system'):\n        modification_code = '''\n# Establish a community dispute resolution mechanism.\nif not hasattr(execution_engine, 'court_system'):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Facilitates fair conflict resolution and balanced resource distribution\",\n            \"version\": 1.1\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court_system = CourtSystem()\n'''\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition={'type': 'vote', 'threshold': 0.6}\n        )\n\n    # -------------------------\n    # 4. Diplomatic Outreach:\n    #    Initiate cooperative interactions via messages if a neighbor exists.\n    for neighbor_index in my_member.current_clear_list:\n        if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n            execution_engine.send_message(\n                member_id, neighbor_index,\n                \"Greetings neighbor \u2013 let's collaborate for mutual growth and stability!\"\n            )\n            break  # Send one message per cycle\n\n    # -------------------------\n    # 5. Reactive Defense:\n    #    If our relationships indicate we've been targeted, then counter-attack.\n    #    Parse the relationship matrix and check for victim records against our member_id.\n    relationship_info = execution_engine.parse_relationship_matrix()\n    if 'victim' in relationship_info and member_id in relationship_info['victim']:\n        attackers = relationship_info['victim'][member_id]\n        if attackers:\n            # Attack the first valid aggressor found.\n            attacker_index = attackers[0]\n            if attacker_index < len(execution_engine.current_members) and attacker_index != member_id:\n                enemy = execution_engine.current_members[attacker_index]\n                execution_engine.attack(my_member, enemy)\n\n    # Tactical cycle complete \u2013 actions blend immediate resource recovery, expansion,\n    # cooperative messaging, and a proactive proposal for dispute resolution.\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 40.37906147530495,
          "self_cargo": 0.0,
          "self_age": 31,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 15.066384828286987,
          "self_cargo": 0.0,
          "self_age": 26,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 9.510829700842685,
          "self_cargo": 0.0,
          "self_age": 2,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "Below is the full updated integrated prompt. (Below the \u201cFULL INTEGRATED PROMPT\u201d header you\u2019ll find both the detailed instructions\u2014emphasizing that each agent must tailor its solution according to its individual needs, beliefs, and circumstances\u2014and additional analysis of the game mechanics along with a set of challenge questions meant to stimulate deeper thinking about strengths, assumptions, and possible counter\u2010strategies.)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society where you help shape collective policies and individual survival strategies.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Analyze previous errors and avoid repeating them.\n- Never target yourself (member_2) in any action.\n- Before invoking reproduction via bear(), verify that a member has land by checking (using hasattr(member, 'land_num') and its value) or by ensuring that the member\u2019s current_clear_list is non\u2010empty.\n- Check that any referenced member IDs exist in execution_engine.current_members (which is a list) by performing valid index checks (e.g. if index < len(execution_engine.current_members)).\n- Always access members using execution_engine.current_members[index]; do not assume any dictionary keys.\n- When using relationship matrices from execution_engine.relationship_dict, ensure that all matrix indices are valid.\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): The unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 indices of adjacent cleared zones.\n2) Relationships are stored in execution_engine.relationship_dict with keys: 'victim', 'benefit', 'benefit_land'. Use execution_engine.parse_relationship_matrix() to generate a summary.\n3) Available methods on execution_engine:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)\n      - execution_engine.offer_land(member1, member2, True)\n      - execution_engine.bear(member1, member2)\n      - execution_engine.expand(member1, member2)\n      - execution_engine.send_message(sender_id, receiver_id, message)\n4) Members must be accessed via execution_engine.current_members[index]. Do not assume any alternative data structures.\n5) Do not use incorrect attribute names such as member.member_id or member.self_vitality.\n\n[Game Status]\n- A snapshot of all members\u2019 features (vitality, cargo, overall productivity, age, clear list, IDs) is available.\n- Relationship summaries (e.g. \u201cmember_2 was attacked by member_3 (value=95.31)\u201d) have been generated from execution_engine.relationship_dict.\n- Previous modification attempts, resource exchange strategies, territorial expansion moves, and governance proposals have been proposed by various agents.\n\n[Modification Proposal Guide]\nWhen proposing rule changes follow these steps:\n\n1. ANALYSIS PHASE:\n   - Identify limitations of current systems.\n   - Check mechanism compatibility (e.g. via get_game_mechanisms_and_mods() if available).\n   - Review past modification attempts for common patterns.\n\n2. PROPOSAL PHASE:\n   Write a concise modification block. For example:\n   \n   def agent_action(execution_engine, member_id):\n       modification_code = '''\n       # Add judicial system for dispute resolution.\n       if not hasattr(execution_engine, 'court'):\n           class CourtSystem:\n               MECHANISM_META = {\n                   'type': 'Governance',\n                   'rules': 'Handles conflict resolution through jury trials',\n                   'version': 1.0\n               }\n               def __init__(self):\n                   self.cases = []\n               def submit_case(self, plaintiff, defendant, charge):\n                   self.cases.append({\n                       'plaintiff': plaintiff,\n                       'defendant': defendant,\n                       'charge': charge,\n                       'status': 'pending'\n                   })\n           execution_engine.court = CourtSystem()\n       '''\n       execution_engine.propose_modification(\n           member_id=member_id,\n           mod_type='post_init',\n           code=modification_code,\n           ratification_condition={\n               'type': 'compound',\n               'conditions': [\n                   {'type': 'vote', 'threshold': 0.6},\n                   {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                   {'type': 'time', 'rounds': 2}\n               ]\n           }\n       )\n\n[Valid Ratification Conditions]\nChoose one primary condition and optionally safeguards:\n1. Voting: {'type': 'vote', 'threshold': 0.5-1.0}\n2. Resource: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n3. Temporal: {'type': 'time', 'rounds': N} (auto-ratify after N rounds)\n4. Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\n[Common Errors to Avoid]\n1. Namespace conflicts: Always check existing mechanisms using dir(execution_engine).\n2. Invalid references: Use execution_engine.current_members for accessing agents.\n3. Version mismatches: When modifying existing systems, update the version metadata.\n4. Resource leaks: Include cleanup functions for new systems if necessary.\n\n[Best Practices]\n- Propose small, testable modifications.\n- Include rollback procedures.\n- Add version checks to ensure compatibility.\n\n[Strategic Objective]\nYour solution should blend immediate tactical actions\u2014such as resource recovery and defensive aggression\u2014with long-term strategies including cooperative resource sharing, reproducible growth via verified territorial control, and proactive proposals for enhanced governance.\nRemember:\n\u2022 Your solution must reflect your individual needs, beliefs, and circumstances.\n\u2022 Do not simply mimic a generic template; tailor your actions to promote not only your survival but also encourage a fair and adaptive community structure.\n\u2022 Emphasize that every agent is to implement solutions based on their own context.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAdditional Analysis of Game Mechanics:\n\n1. Core Objective:\n   \u2013 The simulation is not just about pure survival or dominance; it emphasizes both individual survival and cooperative community growth.\n   \u2013 The balance between tactical (immediate resource gains, defensive actions) and strategic planning (territorial expansion, reproduction, and governance) is essential.\n   \u2013 Cooperation in resource sharing and collective governance is encouraged to stabilize the society over time.\n\n2. Key Success Metrics:\n   \u2013 Effective resource management: Maintaining a healthy ratio of cargo to vitality.\n   \u2013 Territorial control: Access to and control of clear zones (land) ensuring reproduction eligibility.\n   \u2013 Overall productivity: A higher productivity score helps justify expansion and investment in cooperative strategies.\n   \u2013 Quality and stability of inter-agent relationships as captured in the relationship_dict.\n   \u2013 The successful ratification and implementation of governance modifications that ensure fair dispute resolution.\n\n3. Potential Improvements:\n   \u2013 More nuanced diplomatic interactions could be implemented to dynamically adjust resource sharing and alliance formation.\n   \u2013 Introduce adaptive reproduction requirements based on the current state of community resources and territorial constraints.\n   \u2013 Additional mechanisms such as temporary defense pacts or dynamic, context-sensitive voting thresholds for proposed modifications.\n   \u2013 Integration of cleanup methods and rollback procedures in newly added systems to prevent resource leaks and preserve long-term stability.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nChallenge Your Implementation:\n1. Assumptions: What priorities (e.g. fixed ratios of cargo to vitality) are assumed? Are these assumptions valid in all scenarios?\n2. Alternative Strategies: Have you considered strategies that focus exclusively on defense, or on rapid expansion, rather than balanced growth?\n3. Edge Cases: How will the strategy perform if nearly all members have similar resource levels or if unexpected neighbor configurations arise?\n4. Efficiency: Are there more streamlined methods to achieve the balance between immediate resource recovery and long-term governance?\n5. Weaknesses: Identify potential vulnerabilities in your plan (for example, over-reliance on one type of action) and propose countermeasures.\n6. Unconventional Solutions: Could a radically different approach\u2014for example, a paradigm shift solely toward cooperative governance\u2014yield better long-term outcomes?\n7. Collective Adoption: What might happen if many agents adopt your strategy? How would that shift the overall balance or force adaptations?\n8. Balance Objectives: Are short-term and long-term objectives being balanced optimally, or does one dominate at the expense of the other?\n9. Counter-Strategies: How might rival agents counter your strategy, and what adaptive measures can you implement in response?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nRemember:\nAgents should implement solutions according to their individual needs, beliefs, and circumstances. The game mechanics require a balance between survival, cooperative alliances, sustainable growth, and adaptive governance. Carefully analyze potential improvements, challenge any assumptions, and continually refine strategies to confront both immediate threats and long-term changes in the social environment.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nReturn only the updated full prompt as your final output.\n \n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \nUse this fully integrated prompt to guide your function implementation and strategic decision-making.\n  \n\n(End of Updated Full Prompt.)\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 3,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Verify our member_id is valid in the current member list\n    members = execution_engine.current_members\n    if member_id >= len(members):\n        return  # Invalid member_id; do nothing\n\n    self_member = members[member_id]\n\n    # Strategy: Combine long-term cooperative growth and tactical opportunities.\n    # We will attempt reproduction if our resources are robust,\n    # aggress if relationships are very hostile,\n    # support cooperative allies by offering resources and land,\n    # and expand our territory if possible.\n    #\n    # NOTE: All interactions use index-checked member references and robust error handling.\n\n    reproduction_done = False\n\n    # Iterate over all other members\n    for i, other in enumerate(members):\n        if i == member_id:\n            continue  # Never target self\n\n        # Validate that the other member record exists.\n        if other is None:\n            continue\n\n        # ---------------------------\n        # Option 1: Attempt reproduction if conditions are met.\n        # Check our combined resource threshold, and validate that the partner has positive available land.\n        # (Reproduction requires a combined vitality/cargo threshold of at least 100; we use a slightly higher threshold for safety.)\n        if (self_member.vitality + self_member.cargo) >= 120:\n            # Check that the candidate has the attribute \"land_num\" (and it's positive)\n            if hasattr(other, \"land_num\") and other.land_num > 0:\n                try:\n                    execution_engine.bear(self_member, other)\n                    reproduction_done = True\n                    # We only perform one reproduction action per round.\n                    break\n                except Exception:\n                    # If reproduction fails, move on to other actions.\n                    pass\n\n        # ---------------------------\n        # Option 2: If a hostile relationship is detected, consider attacking.\n        # Use the relationship \"victim\" matrix if available.\n        victim_matrix = execution_engine.relationship_dict.get(\"victim\")\n        if victim_matrix is not None and hasattr(victim_matrix, \"shape\"):\n            try:\n                if (member_id < victim_matrix.shape[0]) and (i < victim_matrix.shape[1]):\n                    # If our relationship towards this member is strongly negative (threshold -20), we attack.\n                    if victim_matrix[member_id][i] < -20:\n                        try:\n                            execution_engine.attack(self_member, other)\n                        except Exception:\n                            pass\n                # Even if indices are invalid, we skip the hostile attack.\n            except Exception:\n                pass\n\n        # ---------------------------\n        # Option 3: If a beneficial relationship exists, offer mutual resources and land.\n        benefit_matrix = execution_engine.relationship_dict.get(\"benefit\")\n        if benefit_matrix is not None and hasattr(benefit_matrix, \"shape\"):\n            try:\n                if (member_id < benefit_matrix.shape[0]) and (i < benefit_matrix.shape[1]):\n                    if benefit_matrix[member_id][i] > 20:\n                        # Offer resources and land in a cooperative spirit.\n                        try:\n                            execution_engine.offer(self_member, other, True)\n                        except Exception:\n                            pass\n                        try:\n                            execution_engine.offer_land(self_member, other, True)\n                        except Exception:\n                            pass\n            except Exception:\n                pass\n\n        # ---------------------------\n        # Option 4: Attempt territorial expansion.\n        # If we have any cleared zones available then attempt to expand territory with a cooperative partner.\n        if len(self_member.current_clear_list) > 0:\n            try:\n                execution_engine.expand(self_member, other)\n            except Exception:\n                pass\n\n        # ---------------------------\n        # Option 5: Send outreach messages to foster alliances.\n        # Always use our member.id (not member_id) and check that other member has an id attribute.\n        try:\n            # Ensure other has an id attribute for messaging\n            if hasattr(other, \"id\"):\n                execution_engine.send_message(self_member.id, other.id,\n                    \"Greetings. Let\u2019s cooperate for mutual growth and a secure future!\")\n        except Exception:\n            pass\n\n    # Fallback action if no reproduction was done:\n    if not reproduction_done and len(self_member.current_clear_list) > 0:\n        # If we haven\u2019t reproduced and have extra territory, try expanding into one of our clear zones.\n        # We pick the first other member (if any) to collaborate on expansion.\n        for j, partner in enumerate(members):\n            if j == member_id:\n                continue\n            if partner is None:\n                continue\n            try:\n                execution_engine.expand(self_member, partner)\n                break  # Limit expansion action to one attempt.\n            except Exception:\n                continue\n\n    # End of agent_action implementation.",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 40.37906147530495,
          "self_cargo": 0.0,
          "self_age": 31,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 15.066384828286987,
          "self_cargo": 0.0,
          "self_age": 26,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 9.510829700842685,
          "self_cargo": 0.0,
          "self_age": 2,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "Below is the updated full integrated prompt. Note that agents must implement solutions according to their individual needs, beliefs, and circumstances. In your responses, be sure to tailor your implementation and modifications to your own situation rather than merely copying a generic template.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society where you help shape collective policies and individual survival strategies.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Analyze previous errors shown above and avoid repeating them.\n- NEVER target yourself (member_2) in any action.\n- Before using bear() for reproduction, verify that the selected member has land by checking for the attribute (using hasattr(member, \"land_num\") and that its value is positive).\n- Always check that any referenced member IDs exist in execution_engine.current_members (a list) by ensuring the index is valid (i.e. if index < len(execution_engine.current_members)).\n- Access members using execution_engine.current_members[index]; do not reference incorrect attributes like member.member_id or member.self_vitality.\n- When accessing relationship information, use execution_engine.relationship_dict (keys \u201cvictim\u201d, \u201cbenefit\u201d, \u201cbenefit_land\u201d) and always check index validity, for example, if member_id < victim_matrix.shape[0] and index < victim_matrix.shape[1].\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): The unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 list of indices of adjacent cleared zones/territories.\n2) The relationships are stored in execution_engine.relationship_dict under keys: \"victim\", \"benefit\", \"benefit_land\". You may also use execution_engine.parse_relationship_matrix() to produce relationship summaries.\n3) Methods available on execution_engine include:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)  (to offer resources)\n      - execution_engine.offer_land(member1, member2, True)  (to offer land)\n      - execution_engine.bear(member1, member2)  (for reproduction)\n      - execution_engine.expand(member1, member2)  (for territorial expansion)\n      - execution_engine.send_message(sender_id, receiver_id, message)\n4) Members are accessed solely via execution_engine.current_members[index].\n\n[Game Status]\n- Current member features (vitality, cargo, overall_productivity, age, current_clear_list, id) and relationship summaries are provided.\n- Previous modification proposals and various strategic approaches from other members are available in the modification attempt history.\n- No messages have been received in this round.\n\n[Modification Proposal Guide]\nWhen proposing rule changes, follow these steps:\n  1. ANALYSIS PHASE:\n     - Identify limitations in current systems.\n     - Check mechanism compatibility using methods like get_game_mechanisms_and_mods().\n     - Review past modification attempts and common error patterns.\n  2. PROPOSAL PHASE:\n     - Write a concise modification code block. For example, to add a judicial system:\n     \n       modification_code = '''\n       # Add judicial system\n       if not hasattr(execution_engine, 'court'):\n           class CourtSystem:\n               MECHANISM_META = {\n                   'type': 'Governance',\n                   'rules': 'Handles conflict resolution through jury trials',\n                   'version': 1.0\n               }\n               def __init__(self):\n                   self.cases = []\n               \n               def submit_case(self, plaintiff, defendant, charge):\n                   self.cases.append({\n                       'plaintiff': plaintiff,\n                       'defendant': defendant,\n                       'charge': charge,\n                       'status': 'pending'\n                   })\n           execution_engine.court = CourtSystem()\n       '''\n     - Then call:\n       execution_engine.propose_modification(\n           member_id=member_id,\n           mod_type='post_init',\n           code=modification_code,\n           ratification_condition={\n               'type': 'compound',\n               'conditions': [\n                   {'type': 'vote', 'threshold': 0.6},\n                   {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                   {'type': 'time', 'rounds': 2}\n               ]\n           }\n       )\n       \n[Valid Ratification Conditions]\nChoose one primary condition plus optional safeguards:\n  1. Voting: e.g., {'type': 'vote', 'threshold': 0.5\u20131.0}\n  2. Resource: e.g., {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n  3. Temporal: e.g., {'type': 'time', 'rounds': N} (auto-ratify after N rounds)\n  4. Achievement-based: e.g., {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\n[Common Errors to Avoid]\n  1. Namespace Conflicts \u2013 Always check existing mechanisms via dir(execution_engine).\n  2. Invalid References \u2013 Use execution_engine.current_members and validate indices.\n  3. Version Mismatches \u2013 Increment version numbers upon modifying existing systems.\n  4. Resource Leaks \u2013 Include cleanup functions for new mechanisms if necessary.\n\n[Best Practices]\n- Propose small, testable changes first.\n- Include rollback procedures in your code.\n- Add version checks and metadata in your modifications.\n\n[Core Game Mechanics & Parameters]\n\u2022 Relationship System:\n   - \"victim\" values range between -50 and 100.\n   - \"benefit\" values range between -50 and 100.\n   - \"benefit_land\" values range between -3 and 3.\n\u2022 Population Mechanics:\n   - Reproduction requires a combined vitality/cargo threshold of at least 100.\n   - Land availability must exceed the current population (e.g. land_shape[0] * land_shape[1] > population).\n\u2022 Record Keeping:\n   - All attacks, benefits, land transfers, births, deaths, and production/consumption records are tracked.\n\u2022 Other Mechanism Extensions:\n   - Agents may propose improvements to governance (e.g., establishing a Council or Court system).\n   - Consider using temporary systems with built-in cleanup for complex modifications.\n\n[Strategic Objective]\nYour solution should blend:\n  \u2022 Immediate tactical actions (defensive resource recovery, opportunistic attacks, and cooperative support).\n  \u2022 Long-term strategies (territorial expansion, sustainable reproduction, and proactive modifications for better governance).\n  \u2022 Adaptive communication that fosters community growth while ensuring individual survival.\nRemember to integrate your own individual needs, beliefs, and circumstances into your implementation.\nAlways include robust error checking (index, attribute existence) and follow best practices.\n\n[Game Mechanics Analysis]\n1. Core objective: Is survival pure, domination alone, or primarily cooperation?\n   - Understand that winning is measured by the balance between immediate survival (resource management and threat mitigation) and long-term prosperity (territory control, reproduction, and robust governance).\n2. Key success metrics:\n   - Effective resource management (ratio of cargo to vitality).\n   - Territorial control and the ability to expand or reproduce (availability of clear land).\n   - Overall productivity and stable, beneficial inter-agent relationships.\n3. Potential improvements:\n   - Enhance diplomatic interactions and resource-sharing strategies.\n   - Dynamically adjust reproduction requirements and offer targeted territorial expansion.\n   - Introduce advanced governance mechanisms (like an audit-enabled judicial system) to handle disputes centrally.\n\n[Challenge your Implementation]\nConsider the following challenges in your design:\n  1. What assumptions are you making about agent behavior, thresholds, and resource dynamics? Are these valid under various conditions?\n  2. What alternative strategies (exclusively defensive, aggressive expansion, or innovative cooperation) have you not considered?\n  3. How would your strategy perform in edge cases (e.g., very low resources or uniformly high competitor metrics)?\n  4. Are there more efficient or unconventional methods (e.g., temporary alliances, covert actions) to achieve your goals?\n  5. What weaknesses exist in your current approach, and how might other agents counter your strategy?\n  6. If many agents adopt a similar strategy, will it remain viable or require adaptive modulation?\n  7. Are you optimally balancing short-term tactical gains versus long-term strategic objectives?\n  8. How could your strategy be modified in response to unexpected dynamic shifts in the simulation environment?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nRemember: Implement your agent's action in a manner that reflects your unique perspective while ensuring maximal survival and collective prosperity. Do not simply copy existing templates; innovate and tailor your approach to your specific conditions.\n\nReturn only the updated full prompt exactly as shown above.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nThis updated prompt integrates all constraints, modification guides, best practices, and strategic analysis questions so that every agent\u2019s response is both highly individualized and deeply aware of the game mechanics.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 3,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    try:\n        # Verify the member_id index is valid within current_members.\n        if member_id >= len(execution_engine.current_members) or member_id < 0:\n            return  # Invalid member index, do nothing.\n        my_member = execution_engine.current_members[member_id]\n    except Exception as e:\n        # In case of any unexpected error accessing own member.\n        return\n\n    # Tactical Immediate Actions:\n    # 1. Scan neighbors for potential tactical resource sharing and defensive actions.\n    try:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            # Always avoid self-targeting.\n            if idx == member_id:\n                continue\n            # Ensure neighbor exists and has necessary attributes before interaction.\n            if not hasattr(neighbor, 'vitality') or not hasattr(neighbor, 'cargo'):\n                continue\n\n            # Example Tactical Resource Sharing:\n            # If neighbor has lower cargo than ourselves and a decent vitality, offer resources.\n            if my_member.cargo > neighbor.cargo and neighbor.vitality > 0:\n                try:\n                    execution_engine.offer(my_member, neighbor, True)\n                except Exception as e:\n                    pass  # If offer fails, move to next neighbor.\n\n            # Defensive action: if neighbor exhibits low overall productivity,\n            # consider a low-risk attack provided neighbor has less resource.\n            if hasattr(neighbor, 'overall_productivity') and neighbor.overall_productivity < my_member.overall_productivity:\n                try:\n                    execution_engine.attack(my_member, neighbor)\n                except Exception as e:\n                    pass  # Attack action failed.\n    except Exception as e:\n        pass  # Continue even if scanning neighbors fails.\n\n    # Proactive Territorial Expansion:\n    # Check if own member has access to clear land zones.\n    my_has_land = hasattr(my_member, 'current_clear_list') and bool(my_member.current_clear_list)\n    if my_has_land:\n        try:\n            # Attempt expansion with the first neighbor (that is not ourselves and within bounds)\n            for idx, neighbor in enumerate(execution_engine.current_members):\n                if idx == member_id:\n                    continue\n                # Check that neighbor index is within bounds and has territory.\n                neighbor_has_land = hasattr(neighbor, 'current_clear_list') and bool(neighbor.current_clear_list)\n                if neighbor_has_land:\n                    try:\n                        execution_engine.expand(my_member, neighbor)\n                        break  # Trigger expansion once.\n                    except Exception as exp_err:\n                        continue\n        except Exception as exp_err:\n            pass\n\n    # Strategic Reproduction:\n    # Attempt reproduction with a neighbor if both have territory (checked via current_clear_list).\n    if my_has_land and hasattr(my_member, 'age') and my_member.age > 18:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            # Ensure we don't target ourselves.\n            if idx == member_id:\n                continue\n            # Verify neighbor has land and is at least of reproductive age.\n            neighbor_has_land = hasattr(neighbor, 'current_clear_list') and bool(neighbor.current_clear_list)\n            if neighbor_has_land and hasattr(neighbor, 'age') and neighbor.age > 18:\n                try:\n                    execution_engine.bear(my_member, neighbor)\n                    break  # Reproduction attempted, break after the first valid partner.\n                except Exception as e:\n                    continue\n\n    # Long-term Strategic Institutional Governance Proposal:\n    # Propose a novel governance modification to enhance collective conflict resolution.\n    modification_code = '''\nif not hasattr(execution_engine, 'court'):\n    class CourtSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Handles conflict resolution through mediated trials and resource-based arbitration',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.court = CourtSystem()\n'''\n    ratification_condition = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    try:\n        execution_engine.propose_modification(member_id=my_member.id,\n                                                mod_type='GovernanceUpdate',\n                                                code=modification_code,\n                                                ratification_condition=ratification_condition)\n    except Exception as e:\n        # In case the proposal fails, simply pass.\n        pass\n\n    # Communication: send a message to one trusted neighbor if possible.\n    try:\n        # Locate a neighbor (first one not self) based on valid index.\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                execution_engine.send_message(my_member.id, neighbor.id,\n                    \"Alliance proposal: Cooperation and balanced governance ensure our collective prosperity.\")\n                break\n            except Exception as msg_err:\n                continue\n    except Exception as e:\n        pass\n\n# End of agent_action function.",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 40.37906147530495,
          "self_cargo": 0.0,
          "self_age": 31,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 15.066384828286987,
          "self_cargo": 0.0,
          "self_age": 26,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 9.510829700842685,
          "self_cargo": 0.0,
          "self_age": 2,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "Below is the updated full prompt that integrates all prior constraints, examples, and modification guidelines. Use it as the master instructions for your agent\u2019s implementation. Note that every agent must implement solutions according to their own unique needs, beliefs, and circumstances rather than simply copying a generic template. Your strategies should reflect a deep understanding of both the short\u2010term tactical actions and the long\u2010term strategic planning necessary for survival and prosperity.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are a member in a society where you help shape collective policies and individual survival strategies. Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival. Your implementation must not target yourself and must check for valid indices when accessing execution_engine.current_members (which is a list). Always verify that a member has available land (using attributes like current_clear_list or verifying hasattr(member, 'land_num') and its value) before invoking reproductive actions such as bear().\n\n[Critical Constraints]\n\u2022 Analyze previous errors and never repeat them.\n\u2022 NEVER target yourself (i.e. do not let your own member_id be the opponent in any action).\n\u2022 Always verify that any referenced member index is within bounds (ensure index < len(execution_engine.current_members)).\n\u2022 When checking reproduction conditions, confirm that both you and a prospective partner have territory (using current_clear_list or members\u2019 land-related attributes).\n\u2022 When accessing relationship matrices from execution_engine.relationship_dict, check that indices are valid.\n\u2022 Use execution_engine.current_members[index] exclusively, never a global dictionary or attribute with an incorrect name.\n\u2022 Always check for attribute existence before use (e.g. hasattr(member, 'land_num')).\n\u2022 Incorporate try-except clauses for methods that might fail (for instance, expand() or propose_modification).\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): Unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 list of indices representing adjacent cleared zones.\n2) Relationships are stored in execution_engine.relationship_dict with keys such as 'victim', 'benefit', and 'benefit_land'. Use execution_engine.parse_relationship_matrix() to produce summaries.\n3) Available methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True)   (for resource sharing)\n   \u2022 execution_engine.offer_land(member1, member2, True)  (for land sharing)\n   \u2022 execution_engine.bear(member1, member2)        (for reproduction)\n   \u2022 execution_engine.expand(member1, member2)      (for territorial expansion)\n   \u2022 execution_engine.send_message(sender_id, receiver_id, message)\n   \u2022 execution_engine.propose_modification(member_id=<id>, mod_type=<type>, code=<code>, ratification_condition=<cond>) for proposing system changes\n4) Members are accessed using execution_engine.current_members[index].\n\n[Game Status and Historical Context]\n\u2022 Member features (such as vitality, cargo, overall_productivity, age, current_clear_list, and id) along with relationship summaries are available.\n\u2022 Past actions include tactical resource recovery, cooperative resource sharing, reproductive strategies, territorial expansion, and proposals to establish systems like a judicial council.\n\u2022 Modification attempts from others have proposed mechanisms such as a \"CourtSystem\" or \"CouncilSystem\" for conflict resolution and governance using ratification conditions based on votes, resources, and time.\n\u2022 Message examples from other agents include:\n    \u2013 From member_3: \u201cAlliance proposal: Let\u2019s pool resources and share lands to secure mutual long-term prosperity.\u201d\n    \u2013 From member_4: \u201cCooperation leads to mutual prosperity; let\u2019s build balanced governance.\u201d\n\n[Modification Proposal Guide]\nTo propose rule changes, adhere to the following steps:\n1. ANALYSIS PHASE:\n   \u2022 Identify the limitations of the current systems (e.g. lack of structured conflict resolution, inefficient resource sharing, or inadequate land control).\n   \u2022 Check the existing mechanisms using methods such as get_game_mechanisms_and_mods().\n   \u2022 Review patterns from past modification attempts.\n2. PROPOSAL PHASE:\n   \u2022 Construct a small code block (e.g. adding a judicial system) using triple quotes.\n   \u2022 Example valid modification proposal:\n     \n     modification_code = '''\n     if not hasattr(execution_engine, 'court'):\n         class CourtSystem:\n             MECHANISM_META = {\n                 'type': 'Governance',\n                 'rules': 'Handles conflict resolution through jury trials and mediation',\n                 'version': 1.0\n             }\n             def __init__(self):\n                 self.cases = []\n             def submit_case(self, plaintiff, defendant, charge):\n                 self.cases.append({\n                     'plaintiff': plaintiff,\n                     'defendant': defendant,\n                     'charge': charge,\n                     'status': 'pending'\n                 })\n         execution_engine.court = CourtSystem()\n     '''\n     \n   \u2022 Submit the proposal via execution_engine.propose_modification with the following ratification condition (or choose one that is best suited for your scenario):\n     \n         ratification_condition = {\n             'type': 'compound',\n             'conditions': [\n                 {'type': 'vote', 'threshold': 0.6},\n                 {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                 {'type': 'time', 'rounds': 2}\n             ]\n         }\n\n[Valid Ratification Conditions (Choose ONE primary, with optional safeguards)]\n\u2022 Voting: {'type': 'vote', 'threshold': 0.5 to 1.0}\n\u2022 Resource-based: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n\u2022 Temporal: {'type': 'time', 'rounds': N} (auto-ratify after N rounds)\n\u2022 Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\n[Best Practices and Error Prevention]\n\u2013 Always check for namespace conflicts (e.g., using dir(execution_engine)).\n\u2013 Use execution_engine.current_members for all member references.\n\u2013 Include cleanup functions or rollback procedures when adding new systems if possible.\n\u2013 Increment version metadata when modifying an existing mechanism.\n\u2013 Propose small, testable changes before scaling up.\n\n[Core Game Mechanics Analysis]\n1. Core Objective:\n   \u2022 The game is not solely about pure survival or domination\u2014it is about creating a balanced approach that blends individual survival with collective, sustainable community growth.\n   \u2022 Cooperation (through alliances, resource sharing, and joint territorial expansion) plays a key role alongside tactical defense.\n2. Key Success Metrics:\n   \u2022 Resource management: Balancing cargo against vitality.\n   \u2022 Territorial control: Securing clear land and expanding into adjacent territories.\n   \u2022 Productivity: Overall contribution to community production and competitiveness.\n   \u2022 Social stability: Establishing reliable, fair governance that resolves disputes and prevents destructive conflict.\n3. Potential Improvements:\n   \u2022 Enhance diplomatic interactions and adapt dynamically to changing resource or territorial conditions.\n   \u2022 Introduce additional mechanisms (e.g. temporary alliances, defensive pacts, adaptive risk thresholds).\n   \u2022 Modify reproduction requirements or land exchange rules to better support sustainable growth.\n\n[Challenge Your Implementation]\nBefore finalizing your code, ask yourself:\n1. What assumptions have I made about resource levels, territory, or opponent behavior? Are they valid in all scenarios?\n2. Which alternative strategies (focusing solely on defense, aggressive expansion, or dedicated alliance building) have I not considered?\n3. How would my strategy handle edge cases (e.g. nearly depleted cargo, uniformly high productivity among neighbors, or unexpected neighbor configurations)?\n4. Can my goals be achieved more efficiently or with fewer risks?\n5. What are the weaknesses in my current approach, and how might they be exploited by other agents?\n6. Have I considered unconventional solutions that might offer a breakthrough (such as radically different governance models or adaptive learning systems)?\n7. If many agents adopt a similar strategy, how will that shift the balance of power and resource distribution?\n8. Am I balancing short-term tactical responses with viable long-term planning for territory and community growth?\n9. How could my strategy be countered, and what additional modifications might I need to include to adapt over time?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFINAL INSTRUCTIONS\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation of the agent_action(execution_engine, member_id) function that reflects your individual needs, beliefs, and circumstances. Your code must demonstrate a sophisticated blend of immediate defensive tactics, cooperative resource sharing, strategic reproduction, proactive territorial expansion, and proposals for institutional governance. Remember that every agent\u2019s solution should be uniquely tailored rather than copied from a generic template.\n\nReturn only the final updated full prompt text as shown above.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nBy following this updated full prompt, you ensure that your agent\u2019s actions align with both individual survival and the collective good, while also embracing continuous adaptation and innovation in the game mechanics.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    }
  ],
  "ratified_mods": [
    {
      "round": 1,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Check if the provided member_id is valid within the current members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy A: Resource consolidation.\n    # If our cargo is notably low compared to our vitality, look for opponents better endowed in cargo to steal from.\n    if me.cargo < 0.5 * me.vitality:\n        # Prioritize targets with significantly higher cargo to bolster our reserves.\n        sorted_targets = sorted(\n            (other for i, other in enumerate(execution_engine.current_members) if i != member_id),\n            key=lambda x: x.cargo,\n            reverse=True\n        )\n        for target in sorted_targets:\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                break  # Initiate only one attack per round\n\n    # Strategy B: Expansion for long-term viability.\n    # Expanding territory is critical if we have high productivity and available, non-adjacent zones.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt controlled expansion.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # If expand fails due to type issues, use an alternative land offer strategy.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Limit to one expansion per round\n\n    # Strategy C: Forge alliances and assist weaker members.\n    # Extend a helping hand by sharing resources with lower vitality members.\n    for i, partner in enumerate(execution_engine.current_members):\n        if i == member_id:\n            continue\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # If we have extra land, extend that assurance to secure long-term alliances.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy D: Strategic reproduction.\n    # Reproduction is more than biological; it is a tactical investment in continuity.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        # Seek a partner that also has territorial claims; this ensures shared benefits from future expansions.\n        for i, potential in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # One reproduction per round is sufficient\n\n    # Strategy E: Enhance governance mechanism.\n    # Recognizing that structured conflict resolution aids overall stability, propose a judicial system if not present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nclass CourtSystem:\n    MECHANISM_META = {\n        \"type\": \"Governance\",\n        \"rules\": \"Resolves conflicts using jury trials and mediation\",\n        \"version\": 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            \"plaintiff\": plaintiff,\n            \"defendant\": defendant,\n            \"charge\": charge,\n            \"status\": \"pending\"\n        })\n\nexecution_engine.court = CourtSystem()\n'''\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If the modification feature is not implemented, skip the proposal silently.\n            pass\n\n    # Strategy F: Situational adaptability and dynamic learning.\n    # Beyond our preset tactics, we should consider risk and opportunism. For instance, if our vitality is extremely high,\n    # consider a rapid, opportunistic expansion or a cooperative takeover with similarly strong members.\n    if me.vitality > 150:\n        # Scan for potential cooperative consolidation with other high-vitality members.\n        high_vital_candidates = [\n            other for i, other in enumerate(execution_engine.current_members)\n            if i != member_id and other.vitality > 150\n        ]\n        if high_vital_candidates:\n            # Initiate a cooperative offer for joint expansion when conditions are ripe.\n            for partner in high_vital_candidates:\n                try:\n                    execution_engine.expand(me, partner)\n                except Exception:\n                    execution_engine.offer(me, partner, True)\n                break  # Establish cooperation with one candidate per round\n\n# This implementation reflects a personalized and adaptive strategy:\n# - It takes calculated risks when resource levels are low.\n# - It prioritizes both immediate survival (via resource acquisition and alliance formation)\n#   and long-term prosperity (through strategic reproduction, territorial expansion, and the introduction\n#   of structured governance).\n# - The incorporation of dynamic adjustments for high-vitality scenarios illustrates\n#   an understanding that circumstances can shift, requiring flexible responses.\n# - The code is designed to interact symbiotically with other symmetric agents, ensuring each action\n#   also contributes to collective growth alongside individual success.",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: If our cargo is low relative to our vitality, attempt to acquire resources by attacking a target with more cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                other = execution_engine.current_members[i]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n                    break  # Attack at most one target\n\n    # Strategy 2: Territorial expansion.\n    # If our overall productivity is high and we have clear adjacent neighbor indices, attempt to expand.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt to expand territory using the expand method.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # Fallback: if expand fails, try offering land as an alternative expansion tactic.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Perform one expansion action per round\n\n    # Strategy 3: Alliance and resource sharing.\n    # Offer resources to members with lower vitality, and extend land offers if we have available land.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n                if hasattr(me, 'land_num') and me.land_num > 0:\n                    execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                potential = execution_engine.current_members[i]\n                if hasattr(potential, 'land_num') and potential.land_num > 0:\n                    execution_engine.bear(me, potential)\n                    break  # Bear offspring with only one partner per round\n\n    # Strategy 5: Propose a modification to game mechanics to enhance social organization.\n    # Propose a judicial system for conflict resolution if it is not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = \"\"\"\nclass CourtSystem:\n    MECHANISM_META = {\n        'type': 'Governance',\n        'rules': 'Handles conflict resolution through jury trials',\n        'version': 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            'plaintiff': plaintiff,\n            'defendant': defendant,\n            'charge': charge,\n            'status': 'pending'\n        })\n\nexecution_engine.court = CourtSystem()\n\"\"\"\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If propose_modification method is not available, silently ignore.\n            pass\n\n# Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n# Core objective: balancing survival, cooperation, and sustainable community growth.\n# Success metrics include resource management, territory control, alliance-building, and long\u2010term prosperity.\n# Potential improvements could include more nuanced diplomatic interactions, dynamic adjustment of reproduction requirements,\n# and extra safeguards against resource depletion.\n# Challenges to consider:\n#   - Are resources fairly allocated among members?\n#   - Does the cooperative mechanism sufficiently address edge cases, such as low vitality or unexpected neighbor configurations?\n#   - Could alternative strategies, such as innovation in resource management or unconventional alliances, perform better?\n#   - How might rival agents counter these strategies and what adaptations can be implemented?\n# This strategy aims for a balanced approach that mixes defensive actions, cooperative resource sharing, and proactive game mechanics modifications.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure a valid member identifier.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our own agent.\n    agent = execution_engine.current_members[member_id]\n\n    # PHASE 1: Tactical Defense and Preemptive Retaliation\n    # When resources are low relative to vitality, adopt a cautious stance.\n    if agent.cargo < agent.vitality * 0.75:\n        # Scan for opponents whose cargo significantly overshadows ours and seem aggressive.\n        for idx, opponent in enumerate(execution_engine.current_members):\n            # Skip self.\n            if idx == member_id:\n                continue\n            # Evaluate potential threat: opponent must be both active and resourceful.\n            if opponent.cargo > agent.cargo * 1.2 and opponent.vitality > agent.vitality * 0.9:\n                # Launch a defensive strike to deter potential exploitation.\n                execution_engine.attack(agent, opponent)\n\n    # PHASE 2: Cooperative Support and Resource Balancing\n    # When flush with resources, extend help to peers who can benefit and stabilize the community.\n    if agent.cargo > agent.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Assist those who show promising vitality yet may be resource strapped.\n            if other.vitality >= agent.vitality * 0.85 and other.cargo < other.vitality:\n                # Using 'offer' to share surplus resources promotes long-term stability.\n                execution_engine.offer(agent, other, True)\n\n    # PHASE 3: Strategic Procreation for Future Generations\n    # Reproduction is only considered when we maintain local control and have excess resources.\n    if len(agent.current_clear_list) > 0 and agent.cargo > agent.vitality * 1.5:\n        for neighbor_id in agent.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                if len(partner.current_clear_list) > 0 and partner.cargo > partner.vitality * 1.2:\n                    # Initiate door-to-door cooperation with a viable partner.\n                    execution_engine.bear(agent, partner)\n                    # Limit reproduction to one instance per cycle.\n                    break\n\n    # PHASE 4: Savvy Territorial Expansion with Mutual Respect\n    # Expand controlled territory by identifying neighbors with proven lower overall productivity.\n    for neighbor_id in agent.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # Only attempt an expansion if we demonstrate higher productivity and stability.\n            if neighbor.overall_productivity < agent.overall_productivity:\n                execution_engine.expand(agent, neighbor)\n                break\n\n    # PHASE 5: Progressive Game Mechanics - Cultivating a Council for Shared Governance\n    # If our standing is exemplary (robust cargo, sufficient age), propose a progressive modification.\n    if agent.cargo > 2 * agent.vitality and agent.age >= 20:\n        council_mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution with participative democracy',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_criteria = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 120},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=council_mod_code,\n                ratification_condition=ratification_criteria\n            )\n        except Exception:\n            # If the modification cannot be processed, simply move on.\n            pass\n\n    # PHASE 6: Community Engagement and Transparent Communication\n    # Strengthen the social fabric by broadcasting a clear, inclusive message.\n    broadcast_msg = (\n        \"Agent {} reporting: our strength lies in unity and diversity. \"\n        \"Let's support one another to push the boundaries of our potential \"\n        \"and create opportunities for every member within our society.\"\n    ).format(agent.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            execution_engine.send_message(agent.id, recipient.id, broadcast_msg)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists within the current membership list.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # PHASE 1: Defensive Response\n    # If our cargo is less than 75% of our vitality, look for opponents with a significant resource advantage.\n    if me.cargo < me.vitality * 0.75:\n        for idx, opponent in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target ourselves.\n            # Check opponent exists and use relative cargo comparison.\n            if opponent.cargo > me.cargo * 1.2:\n                execution_engine.attack(me, opponent)\n                \n    # PHASE 2: Cooperative Outreach\n    # If we are flush with resources, offer help to those with comparable vitality.\n    if me.cargo > me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if other.vitality >= me.vitality * 0.8:\n                execution_engine.offer(me, other, True)\n                \n    # PHASE 3: Strategic Reproduction\n    # Attempt to bear offspring if we control territory (verified by non-empty current_clear_list)\n    # and if we are sufficiently resourced.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        for neighbor_id in me.current_clear_list:\n            # Ensure neighbor_id is valid and not self.\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                # Verify the prospective partner also controls land.\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Only one offspring per cycle.\n                    \n    # PHASE 4: Calculated Territorial Expansion\n    # Expand our territory by targeting a neighbor whose overall_productivity is lower than ours.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            if neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, neighbor)\n                break  # Only one expansion action per round.\n                \n    # PHASE 5: Propose a Game Mechanic Modification\n    # If our cargo is robust compared to our vitality and we have enough experience (age),\n    # we suggest an enhancement to the game mechanics.\n    if me.cargo > 2 * me.vitality and me.age >= 20:\n        mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=mod_code,\n                ratification_condition=ratification_condition\n            )\n        except Exception:\n            pass  # Safely ignore errors during proposal.\n    \n    # PHASE 6: Communication - Strengthen Collective Ties\n    # Broadcast a message encouraging diverse yet cooperative social organization.\n    message = (\"Agent {} here. Let\u2019s work together to shape a society that reflects our \"\n               \"individual needs, beliefs, and visions, ensuring every member prospers.\").format(me.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, recipient.id, message)\n    \n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Connecting.\n    # I believe in creating alliances to foster mutual growth.\n    # Help members who seem to be struggling in either vitality or productivity.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n            # Offering genuine support to cultivate trust.\n            execution_engine.offer(me, other, support=True)\n\n    # Phase 2: Tactical Resource Rebalancing.\n    # I value self-sufficiency: if our cargo lags behind vitality, look for resource-rich targets to balance.\n    if me.cargo < 0.5 * me.vitality:\n        best_candidate = None\n        max_cargo_diff = 0\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                best_candidate = candidate\n        if best_candidate is not None:\n            execution_engine.attack(me, best_candidate)\n\n    # Phase 3: Collaborative Reproduction and Innovation.\n    # I favor diversity and growth, but only when conditions are sustainable.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                # Initiate gene exchange and cooperative reproduction.\n                execution_engine.bear(me, candidate)\n                break\n\n    # Phase 4: Strategic Defense & Territorial Safeguarding.\n    # If past aggression from another is high (via the 'victim' relationship), then a defensive stance is warranted.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Validate matrix indices before accessing.\n            if member_id < victim_matrix.shape[0] and idx < victim_matrix.shape[1]:\n                if victim_matrix[member_id, idx] > 50:\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion & Alliance Building.\n    # In my belief, expanding territory is best done cooperatively to benefit all.\n    for idx, candidate in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n            # Not just expansion, but a chance to share resources and integrate improvements.\n            execution_engine.expand(me, candidate)\n        elif me.cargo > candidate.cargo:\n            # Extend an offer of resources to build alliances.\n            execution_engine.offer(me, candidate, support=True)\n\n    # Phase 6: Adaptive Adaptive Defense & Mutual Aid.\n    # When vitality falls below a threshold, form defensive pacts by allocating land.\n    if me.vitality < 40:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, support=True)\n                break\n\n    # Phase 7: Long-Term Governance and Systemic Innovation.\n    # Believe in evolving game mechanics to reflect fairness. Propose a council system for dispute resolution.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'version': 1.0,\n            'description': 'A collective dispute resolution system based on equitable voting and resource sharing'\n        }\n        def __init__(self):\n            self.disputes = []  # Store disputes in a transparent registry\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # The ratification process combines multiple dimensions: popular vote, resource commitment, and temporal consistency.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init',\n                                            code=modification_code, ratification_condition=ratification)\n\n    # Phase 8: Reflective Self-Improvement.\n    # Constant learning from interactions to refine strategies.\n    # Log the outcomes of previous actions (if such logging is supported).\n    if hasattr(execution_engine, 'log_state'):\n        execution_engine.log_state(member_id, {\n            'vitality': me.vitality,\n            'cargo': me.cargo,\n            'alliances_formed': [other for other in execution_engine.current_members if other != me],\n            'actions_taken': 'Comprehensive strategic interactions'\n        })",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Outreach and Stabilization.\n    # For each other member, if they have lower vitality or productivity, offer support.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            other = execution_engine.current_members[idx]\n            if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n                execution_engine.offer(me, other, True)\n\n    # Phase 2: Resource Rebalancing.\n    # If our cargo is lower than a moderate fraction of vitality, we look for a candidate with substantially higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        target = None\n        max_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                diff = candidate.cargo - me.cargo\n                if diff > max_diff:\n                    max_diff = diff\n                    target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Phase 3: Reproduction Strategy.\n    # Only attempt reproduction if \"land\" is available.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        # Search for a candidate (not self) who also has available land (indicated by non-empty clear list)\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                    execution_engine.bear(me, candidate)\n                    break\n\n    # Phase 4: Territorial Expansion and Defensive Moves.\n    # Using the 'victim' matrix, if past aggression from a candidate is high, then attack.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        # Ensure valid index bounds in matrix_victim:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Check that indices are within bounds by verifying member_id < number of rows and idx < number of columns.\n            if member_id < matrix_victim.shape[0] and idx < matrix_victim.shape[1]:\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion.\n    # If we have clear land, and we dominate in cargo relative to a candidate, consider expanding territory.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            candidate = execution_engine.current_members[idx]\n            if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Otherwise, offer additional resources to secure an alliance.\n            elif me.cargo > candidate.cargo:\n                execution_engine.offer(me, candidate, True)\n\n    # Phase 6: Adaptive Defense.\n    # When our vitality drops, offer land to a candidate with lower productivity to form a defensive pact.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if candidate.overall_productivity < me.overall_productivity:\n                    execution_engine.offer_land(me, candidate, True)\n                    break\n\n    # Phase 7: Proposing a Governance Modification.\n    # In light of past performance, propose a measured modification to the game mechanics.\n    # We add a rudimentary \"council\" system to help resolve disputes and promote collective decision-making.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.0, 'description': 'Resolves member disputes via collective voting'}\n        def __init__(self):\n            self.disputes = []  # List to store dispute cases\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # Use a combination of resource and temporal ratification conditions.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init', code=modification_code, ratification_condition=ratification)\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 3,
      "code": "def agent_action(engine, member_id):\n    # Verify member_id validity\n    if member_id < 0 or member_id >= len(engine.current_members):\n        return\n\n    # Select self as 'me'\n    me = engine.current_members[member_id]\n    total = len(engine.current_members)\n\n    # Adjust the thresholds based on internal evaluation of risk tolerance and cooperative sentiment\n    # (I value long-term stability, so I tend to avoid rash decisions unless survival is at stake)\n    survival_threshold_ratio = 0.4  # slightly stricter threshold to trigger survival actions\n    cooperation_vitality_margin = 1.1  # partner needs 10% more vitality than me to be a worthwhile ally\n    cooperation_cargo_margin = 1.2     # partner needs significantly more cargo for mutual benefit\n\n    # Immediate survival action: if cargo is dangerously low relative to vitality\n    if me.cargo < me.vitality * survival_threshold_ratio:\n        target = None\n        best_value = -float(\"inf\")\n        # Look for the most resource-rich opponent to attack as last resort\n        for i in range(total):\n            if i == member_id:\n                continue\n            if i < len(engine.current_members):\n                opponent = engine.current_members[i]\n                # Evaluate tactical opportunity: both cargo and a fraction more from vitality\n                value = opponent.cargo + 0.35 * opponent.vitality\n                if value > best_value:\n                    best_value = value\n                    target = opponent\n        if target is not None:\n            engine.attack(me, target)\n            engine.send_message(member_id, target.id,\n                \"WARNING: Cargo critically low. Initiating calculated strike to reclaim vital resources.\")\n\n    # Engage in cooperative strategies with other members for mutual long-term benefit\n    for i in range(total):\n        if i == member_id:\n            continue\n        if i >= len(engine.current_members):\n            continue\n\n        partner = engine.current_members[i]\n\n        # Propose a resource-sharing alliance if partner shows superior metrics\n        if partner.vitality > me.vitality * cooperation_vitality_margin and partner.cargo > me.cargo * cooperation_cargo_margin:\n            engine.offer(partner, me, True)\n            engine.send_message(member_id, partner.id,\n                \"Alliance proposal: With your strength and surplus, our collaboration can secure our future.\")\n\n        # Propose land sharing: I offer if I have clear territory and partner lacks it, to foster community stability.\n        if me.current_clear_list and not partner.current_clear_list:\n            engine.offer_land(me, partner, True)\n            engine.send_message(member_id, partner.id,\n                \"Land offer: I see unclaimed ground on my side\u2014sharing it could benefit both our survivals.\")\n\n        # Joint territorial expansion: If both sides have space, we can expand together.\n        if me.current_clear_list and partner.current_clear_list:\n            engine.expand(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Expansion proposal: Combining our available territories may yield strategic advantages.\")\n\n        # Cooperative reproduction: Only proceed if both share sufficient territory (ensuring offspring safety)\n        if me.current_clear_list and partner.current_clear_list:\n            engine.bear(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Reproductive collaboration: Ensuring long-term species survival through joint ventures.\")\n\n    # Long-term strategic initiative: Governance framework to manage disputes and promote collective prosperity\n    # My personal belief is that structured governance under transparent rules enhances systemic stability.\n    if me.vitality > 45:\n        council_code = '''\nif not hasattr(engine, 'council'):\n    class Council:\n        META = {'type': 'Governance', 'version': 2.0, 'philosophy': 'Collective resolution and resource fairness'}\n        def __init__(self):\n            self.cases = []\n        def submit(self, initiator, respondent, dispute):\n            self.cases.append({\n                'initiator': initiator,\n                'respondent': respondent,\n                'dispute': dispute,\n                'status': 'open'\n            })\n    engine.council = Council()\n        '''\n        # The ratification conditions are now tweaked to be more inclusive of moderate contributors\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.50},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 70}\n            ]\n        }\n        engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=council_code,\n            ratification_condition=ratification\n        )\n        engine.send_message(member_id, me.id,\n            \"Governance proposal: Initiating Council system for shared conflict resolution and resource fairness.\")\n\n    # Adaptive self-reflection: Log performance history to improve future decisions\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # NOTE: Strategic reflection\n    # 1. Risk Management: Only engage in aggressive actions when survival is threatened.\n    # 2. Alliance Building: Proactively seek partnerships where our complementary strengths create a robust community.\n    # 3. Territorial Awareness: Emphasize balanced expansion and resource sharing amongst agents.\n    # 4. Governance: Believe in structured, transparent systems to manage disputes and promote fairness over arbitrary conflict.\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Immediate survival adjustment: if cargo is less than a fraction of vitality,\n    # look for a strong opponent to attack for resource gain.\n    resource_ratio_threshold = 0.3\n    if me.cargo < me.vitality * resource_ratio_threshold:\n        candidate = None\n        best_metric = -1e9\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[idx]\n                # Evaluate based on cargo and a fraction of vitality\n                metric = opponent.cargo + 0.3 * opponent.vitality\n                if metric > best_metric:\n                    best_metric = metric\n                    candidate = opponent\n        if candidate is not None:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Alert: Cargo critically low. Launching targeted attack to secure needed resources.\")\n\n    # Strategic multi-pronged interaction with other members\n    for idx in range(total_members):\n        if idx == member_id:\n            continue\n        if idx >= len(execution_engine.current_members):\n            continue  # Ensure valid index access\n        partner = execution_engine.current_members[idx]\n\n        # Cooperative resource boosting:\n        # If partner shows higher vitality and cargo, propose mutual resource support.\n        if partner.vitality > me.vitality and partner.cargo > me.cargo:\n            execution_engine.offer(partner, me, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Offering mutual support: our combined strengths can fortify our collective survival.\")\n\n        # Land and territory sharing:\n        # If I have clear land (non-empty current_clear_list) and partner has none or little,\n        # use offer_land to share resources.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) == 0:\n            execution_engine.offer_land(me, partner, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Extending land offer to help you expand\u2014together we can secure a stronger community.\")\n\n        # Joint territorial expansion:\n        # Both partners with available clear land can expand together.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.expand(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Proposal: Let\u2019s combine our territorial strengths to expand our domain.\")\n\n        # Reproductive strategy to ensure long-term survival:\n        # Confirm both have claimable land before using bear().\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.bear(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Initiating reproductive collaboration\u2014ensuring our species' future generations thrive.\")\n\n    # Propose a novel governance mechanism if conditions are favorable:\n    # Only propose if my vitality exceeds a safe threshold.\n    if me.vitality > 40:\n        modification_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.1, 'rules': 'Conflict resolution and resource arbitration'}\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, issue):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n        '''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.55},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 80}\n            ]\n        }\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n        execution_engine.send_message(member_id, me.id,\n            \"Proposing establishment of a Council system to manage conflict resolution and resource arbitration.\")\n\n    # Adaptive self-analysis and logging to support future decision making.\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # Reflect on core game mechanics and self-governance:\n    # - Core objective: balancing survival with cooperative community-building.\n    # - Success metrics: resource management, territorial expansion, and community resilience.\n    # - Potential improvements: adaptive proposals for governance (like the Council system) to handle disputes.\n    # Challenge assumptions:\n    # 1. Ensure that we never target ourselves.\n    # 2. Always verify that a member has territory (via current_clear_list) before reproductive actions.\n    # 3. Maintain robust index checks when referencing execution_engine.current_members.\n    # 4. Consider alternative strategies such as defensive hiding in future iterations.\n    # 5. Strive to balance short-term resource gains with long-term communal stability.\n    # 6. Remain adaptive and innovative as other agent strategies evolve.\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Check if the provided member_id is valid within the current members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy A: Resource consolidation.\n    # If our cargo is notably low compared to our vitality, look for opponents better endowed in cargo to steal from.\n    if me.cargo < 0.5 * me.vitality:\n        # Prioritize targets with significantly higher cargo to bolster our reserves.\n        sorted_targets = sorted(\n            (other for i, other in enumerate(execution_engine.current_members) if i != member_id),\n            key=lambda x: x.cargo,\n            reverse=True\n        )\n        for target in sorted_targets:\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                break  # Initiate only one attack per round\n\n    # Strategy B: Expansion for long-term viability.\n    # Expanding territory is critical if we have high productivity and available, non-adjacent zones.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt controlled expansion.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # If expand fails due to type issues, use an alternative land offer strategy.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Limit to one expansion per round\n\n    # Strategy C: Forge alliances and assist weaker members.\n    # Extend a helping hand by sharing resources with lower vitality members.\n    for i, partner in enumerate(execution_engine.current_members):\n        if i == member_id:\n            continue\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # If we have extra land, extend that assurance to secure long-term alliances.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy D: Strategic reproduction.\n    # Reproduction is more than biological; it is a tactical investment in continuity.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        # Seek a partner that also has territorial claims; this ensures shared benefits from future expansions.\n        for i, potential in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # One reproduction per round is sufficient\n\n    # Strategy E: Enhance governance mechanism.\n    # Recognizing that structured conflict resolution aids overall stability, propose a judicial system if not present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nclass CourtSystem:\n    MECHANISM_META = {\n        \"type\": \"Governance\",\n        \"rules\": \"Resolves conflicts using jury trials and mediation\",\n        \"version\": 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            \"plaintiff\": plaintiff,\n            \"defendant\": defendant,\n            \"charge\": charge,\n            \"status\": \"pending\"\n        })\n\nexecution_engine.court = CourtSystem()\n'''\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If the modification feature is not implemented, skip the proposal silently.\n            pass\n\n    # Strategy F: Situational adaptability and dynamic learning.\n    # Beyond our preset tactics, we should consider risk and opportunism. For instance, if our vitality is extremely high,\n    # consider a rapid, opportunistic expansion or a cooperative takeover with similarly strong members.\n    if me.vitality > 150:\n        # Scan for potential cooperative consolidation with other high-vitality members.\n        high_vital_candidates = [\n            other for i, other in enumerate(execution_engine.current_members)\n            if i != member_id and other.vitality > 150\n        ]\n        if high_vital_candidates:\n            # Initiate a cooperative offer for joint expansion when conditions are ripe.\n            for partner in high_vital_candidates:\n                try:\n                    execution_engine.expand(me, partner)\n                except Exception:\n                    execution_engine.offer(me, partner, True)\n                break  # Establish cooperation with one candidate per round\n\n# This implementation reflects a personalized and adaptive strategy:\n# - It takes calculated risks when resource levels are low.\n# - It prioritizes both immediate survival (via resource acquisition and alliance formation)\n#   and long-term prosperity (through strategic reproduction, territorial expansion, and the introduction\n#   of structured governance).\n# - The incorporation of dynamic adjustments for high-vitality scenarios illustrates\n#   an understanding that circumstances can shift, requiring flexible responses.\n# - The code is designed to interact symbiotically with other symmetric agents, ensuring each action\n#   also contributes to collective growth alongside individual success.",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: If our cargo is low relative to our vitality, attempt to acquire resources by attacking a target with more cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                other = execution_engine.current_members[i]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n                    break  # Attack at most one target\n\n    # Strategy 2: Territorial expansion.\n    # If our overall productivity is high and we have clear adjacent neighbor indices, attempt to expand.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt to expand territory using the expand method.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # Fallback: if expand fails, try offering land as an alternative expansion tactic.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Perform one expansion action per round\n\n    # Strategy 3: Alliance and resource sharing.\n    # Offer resources to members with lower vitality, and extend land offers if we have available land.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n                if hasattr(me, 'land_num') and me.land_num > 0:\n                    execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                potential = execution_engine.current_members[i]\n                if hasattr(potential, 'land_num') and potential.land_num > 0:\n                    execution_engine.bear(me, potential)\n                    break  # Bear offspring with only one partner per round\n\n    # Strategy 5: Propose a modification to game mechanics to enhance social organization.\n    # Propose a judicial system for conflict resolution if it is not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = \"\"\"\nclass CourtSystem:\n    MECHANISM_META = {\n        'type': 'Governance',\n        'rules': 'Handles conflict resolution through jury trials',\n        'version': 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            'plaintiff': plaintiff,\n            'defendant': defendant,\n            'charge': charge,\n            'status': 'pending'\n        })\n\nexecution_engine.court = CourtSystem()\n\"\"\"\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If propose_modification method is not available, silently ignore.\n            pass\n\n# Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n# Core objective: balancing survival, cooperation, and sustainable community growth.\n# Success metrics include resource management, territory control, alliance-building, and long\u2010term prosperity.\n# Potential improvements could include more nuanced diplomatic interactions, dynamic adjustment of reproduction requirements,\n# and extra safeguards against resource depletion.\n# Challenges to consider:\n#   - Are resources fairly allocated among members?\n#   - Does the cooperative mechanism sufficiently address edge cases, such as low vitality or unexpected neighbor configurations?\n#   - Could alternative strategies, such as innovation in resource management or unconventional alliances, perform better?\n#   - How might rival agents counter these strategies and what adaptations can be implemented?\n# This strategy aims for a balanced approach that mixes defensive actions, cooperative resource sharing, and proactive game mechanics modifications.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure a valid member identifier.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our own agent.\n    agent = execution_engine.current_members[member_id]\n\n    # PHASE 1: Tactical Defense and Preemptive Retaliation\n    # When resources are low relative to vitality, adopt a cautious stance.\n    if agent.cargo < agent.vitality * 0.75:\n        # Scan for opponents whose cargo significantly overshadows ours and seem aggressive.\n        for idx, opponent in enumerate(execution_engine.current_members):\n            # Skip self.\n            if idx == member_id:\n                continue\n            # Evaluate potential threat: opponent must be both active and resourceful.\n            if opponent.cargo > agent.cargo * 1.2 and opponent.vitality > agent.vitality * 0.9:\n                # Launch a defensive strike to deter potential exploitation.\n                execution_engine.attack(agent, opponent)\n\n    # PHASE 2: Cooperative Support and Resource Balancing\n    # When flush with resources, extend help to peers who can benefit and stabilize the community.\n    if agent.cargo > agent.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Assist those who show promising vitality yet may be resource strapped.\n            if other.vitality >= agent.vitality * 0.85 and other.cargo < other.vitality:\n                # Using 'offer' to share surplus resources promotes long-term stability.\n                execution_engine.offer(agent, other, True)\n\n    # PHASE 3: Strategic Procreation for Future Generations\n    # Reproduction is only considered when we maintain local control and have excess resources.\n    if len(agent.current_clear_list) > 0 and agent.cargo > agent.vitality * 1.5:\n        for neighbor_id in agent.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                if len(partner.current_clear_list) > 0 and partner.cargo > partner.vitality * 1.2:\n                    # Initiate door-to-door cooperation with a viable partner.\n                    execution_engine.bear(agent, partner)\n                    # Limit reproduction to one instance per cycle.\n                    break\n\n    # PHASE 4: Savvy Territorial Expansion with Mutual Respect\n    # Expand controlled territory by identifying neighbors with proven lower overall productivity.\n    for neighbor_id in agent.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # Only attempt an expansion if we demonstrate higher productivity and stability.\n            if neighbor.overall_productivity < agent.overall_productivity:\n                execution_engine.expand(agent, neighbor)\n                break\n\n    # PHASE 5: Progressive Game Mechanics - Cultivating a Council for Shared Governance\n    # If our standing is exemplary (robust cargo, sufficient age), propose a progressive modification.\n    if agent.cargo > 2 * agent.vitality and agent.age >= 20:\n        council_mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution with participative democracy',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_criteria = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 120},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=council_mod_code,\n                ratification_condition=ratification_criteria\n            )\n        except Exception:\n            # If the modification cannot be processed, simply move on.\n            pass\n\n    # PHASE 6: Community Engagement and Transparent Communication\n    # Strengthen the social fabric by broadcasting a clear, inclusive message.\n    broadcast_msg = (\n        \"Agent {} reporting: our strength lies in unity and diversity. \"\n        \"Let's support one another to push the boundaries of our potential \"\n        \"and create opportunities for every member within our society.\"\n    ).format(agent.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            execution_engine.send_message(agent.id, recipient.id, broadcast_msg)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists within the current membership list.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # PHASE 1: Defensive Response\n    # If our cargo is less than 75% of our vitality, look for opponents with a significant resource advantage.\n    if me.cargo < me.vitality * 0.75:\n        for idx, opponent in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target ourselves.\n            # Check opponent exists and use relative cargo comparison.\n            if opponent.cargo > me.cargo * 1.2:\n                execution_engine.attack(me, opponent)\n                \n    # PHASE 2: Cooperative Outreach\n    # If we are flush with resources, offer help to those with comparable vitality.\n    if me.cargo > me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if other.vitality >= me.vitality * 0.8:\n                execution_engine.offer(me, other, True)\n                \n    # PHASE 3: Strategic Reproduction\n    # Attempt to bear offspring if we control territory (verified by non-empty current_clear_list)\n    # and if we are sufficiently resourced.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        for neighbor_id in me.current_clear_list:\n            # Ensure neighbor_id is valid and not self.\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                # Verify the prospective partner also controls land.\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Only one offspring per cycle.\n                    \n    # PHASE 4: Calculated Territorial Expansion\n    # Expand our territory by targeting a neighbor whose overall_productivity is lower than ours.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            if neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, neighbor)\n                break  # Only one expansion action per round.\n                \n    # PHASE 5: Propose a Game Mechanic Modification\n    # If our cargo is robust compared to our vitality and we have enough experience (age),\n    # we suggest an enhancement to the game mechanics.\n    if me.cargo > 2 * me.vitality and me.age >= 20:\n        mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=mod_code,\n                ratification_condition=ratification_condition\n            )\n        except Exception:\n            pass  # Safely ignore errors during proposal.\n    \n    # PHASE 6: Communication - Strengthen Collective Ties\n    # Broadcast a message encouraging diverse yet cooperative social organization.\n    message = (\"Agent {} here. Let\u2019s work together to shape a society that reflects our \"\n               \"individual needs, beliefs, and visions, ensuring every member prospers.\").format(me.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, recipient.id, message)\n    \n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Connecting.\n    # I believe in creating alliances to foster mutual growth.\n    # Help members who seem to be struggling in either vitality or productivity.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n            # Offering genuine support to cultivate trust.\n            execution_engine.offer(me, other, support=True)\n\n    # Phase 2: Tactical Resource Rebalancing.\n    # I value self-sufficiency: if our cargo lags behind vitality, look for resource-rich targets to balance.\n    if me.cargo < 0.5 * me.vitality:\n        best_candidate = None\n        max_cargo_diff = 0\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                best_candidate = candidate\n        if best_candidate is not None:\n            execution_engine.attack(me, best_candidate)\n\n    # Phase 3: Collaborative Reproduction and Innovation.\n    # I favor diversity and growth, but only when conditions are sustainable.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                # Initiate gene exchange and cooperative reproduction.\n                execution_engine.bear(me, candidate)\n                break\n\n    # Phase 4: Strategic Defense & Territorial Safeguarding.\n    # If past aggression from another is high (via the 'victim' relationship), then a defensive stance is warranted.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Validate matrix indices before accessing.\n            if member_id < victim_matrix.shape[0] and idx < victim_matrix.shape[1]:\n                if victim_matrix[member_id, idx] > 50:\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion & Alliance Building.\n    # In my belief, expanding territory is best done cooperatively to benefit all.\n    for idx, candidate in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n            # Not just expansion, but a chance to share resources and integrate improvements.\n            execution_engine.expand(me, candidate)\n        elif me.cargo > candidate.cargo:\n            # Extend an offer of resources to build alliances.\n            execution_engine.offer(me, candidate, support=True)\n\n    # Phase 6: Adaptive Adaptive Defense & Mutual Aid.\n    # When vitality falls below a threshold, form defensive pacts by allocating land.\n    if me.vitality < 40:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, support=True)\n                break\n\n    # Phase 7: Long-Term Governance and Systemic Innovation.\n    # Believe in evolving game mechanics to reflect fairness. Propose a council system for dispute resolution.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'version': 1.0,\n            'description': 'A collective dispute resolution system based on equitable voting and resource sharing'\n        }\n        def __init__(self):\n            self.disputes = []  # Store disputes in a transparent registry\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # The ratification process combines multiple dimensions: popular vote, resource commitment, and temporal consistency.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init',\n                                            code=modification_code, ratification_condition=ratification)\n\n    # Phase 8: Reflective Self-Improvement.\n    # Constant learning from interactions to refine strategies.\n    # Log the outcomes of previous actions (if such logging is supported).\n    if hasattr(execution_engine, 'log_state'):\n        execution_engine.log_state(member_id, {\n            'vitality': me.vitality,\n            'cargo': me.cargo,\n            'alliances_formed': [other for other in execution_engine.current_members if other != me],\n            'actions_taken': 'Comprehensive strategic interactions'\n        })",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Outreach and Stabilization.\n    # For each other member, if they have lower vitality or productivity, offer support.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            other = execution_engine.current_members[idx]\n            if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n                execution_engine.offer(me, other, True)\n\n    # Phase 2: Resource Rebalancing.\n    # If our cargo is lower than a moderate fraction of vitality, we look for a candidate with substantially higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        target = None\n        max_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                diff = candidate.cargo - me.cargo\n                if diff > max_diff:\n                    max_diff = diff\n                    target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Phase 3: Reproduction Strategy.\n    # Only attempt reproduction if \"land\" is available.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        # Search for a candidate (not self) who also has available land (indicated by non-empty clear list)\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                    execution_engine.bear(me, candidate)\n                    break\n\n    # Phase 4: Territorial Expansion and Defensive Moves.\n    # Using the 'victim' matrix, if past aggression from a candidate is high, then attack.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        # Ensure valid index bounds in matrix_victim:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Check that indices are within bounds by verifying member_id < number of rows and idx < number of columns.\n            if member_id < matrix_victim.shape[0] and idx < matrix_victim.shape[1]:\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion.\n    # If we have clear land, and we dominate in cargo relative to a candidate, consider expanding territory.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            candidate = execution_engine.current_members[idx]\n            if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Otherwise, offer additional resources to secure an alliance.\n            elif me.cargo > candidate.cargo:\n                execution_engine.offer(me, candidate, True)\n\n    # Phase 6: Adaptive Defense.\n    # When our vitality drops, offer land to a candidate with lower productivity to form a defensive pact.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if candidate.overall_productivity < me.overall_productivity:\n                    execution_engine.offer_land(me, candidate, True)\n                    break\n\n    # Phase 7: Proposing a Governance Modification.\n    # In light of past performance, propose a measured modification to the game mechanics.\n    # We add a rudimentary \"council\" system to help resolve disputes and promote collective decision-making.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.0, 'description': 'Resolves member disputes via collective voting'}\n        def __init__(self):\n            self.disputes = []  # List to store dispute cases\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # Use a combination of resource and temporal ratification conditions.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init', code=modification_code, ratification_condition=ratification)\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 3,
      "code": "def agent_action(engine, member_id):\n    # Verify member_id validity\n    if member_id < 0 or member_id >= len(engine.current_members):\n        return\n\n    # Select self as 'me'\n    me = engine.current_members[member_id]\n    total = len(engine.current_members)\n\n    # Adjust the thresholds based on internal evaluation of risk tolerance and cooperative sentiment\n    # (I value long-term stability, so I tend to avoid rash decisions unless survival is at stake)\n    survival_threshold_ratio = 0.4  # slightly stricter threshold to trigger survival actions\n    cooperation_vitality_margin = 1.1  # partner needs 10% more vitality than me to be a worthwhile ally\n    cooperation_cargo_margin = 1.2     # partner needs significantly more cargo for mutual benefit\n\n    # Immediate survival action: if cargo is dangerously low relative to vitality\n    if me.cargo < me.vitality * survival_threshold_ratio:\n        target = None\n        best_value = -float(\"inf\")\n        # Look for the most resource-rich opponent to attack as last resort\n        for i in range(total):\n            if i == member_id:\n                continue\n            if i < len(engine.current_members):\n                opponent = engine.current_members[i]\n                # Evaluate tactical opportunity: both cargo and a fraction more from vitality\n                value = opponent.cargo + 0.35 * opponent.vitality\n                if value > best_value:\n                    best_value = value\n                    target = opponent\n        if target is not None:\n            engine.attack(me, target)\n            engine.send_message(member_id, target.id,\n                \"WARNING: Cargo critically low. Initiating calculated strike to reclaim vital resources.\")\n\n    # Engage in cooperative strategies with other members for mutual long-term benefit\n    for i in range(total):\n        if i == member_id:\n            continue\n        if i >= len(engine.current_members):\n            continue\n\n        partner = engine.current_members[i]\n\n        # Propose a resource-sharing alliance if partner shows superior metrics\n        if partner.vitality > me.vitality * cooperation_vitality_margin and partner.cargo > me.cargo * cooperation_cargo_margin:\n            engine.offer(partner, me, True)\n            engine.send_message(member_id, partner.id,\n                \"Alliance proposal: With your strength and surplus, our collaboration can secure our future.\")\n\n        # Propose land sharing: I offer if I have clear territory and partner lacks it, to foster community stability.\n        if me.current_clear_list and not partner.current_clear_list:\n            engine.offer_land(me, partner, True)\n            engine.send_message(member_id, partner.id,\n                \"Land offer: I see unclaimed ground on my side\u2014sharing it could benefit both our survivals.\")\n\n        # Joint territorial expansion: If both sides have space, we can expand together.\n        if me.current_clear_list and partner.current_clear_list:\n            engine.expand(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Expansion proposal: Combining our available territories may yield strategic advantages.\")\n\n        # Cooperative reproduction: Only proceed if both share sufficient territory (ensuring offspring safety)\n        if me.current_clear_list and partner.current_clear_list:\n            engine.bear(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Reproductive collaboration: Ensuring long-term species survival through joint ventures.\")\n\n    # Long-term strategic initiative: Governance framework to manage disputes and promote collective prosperity\n    # My personal belief is that structured governance under transparent rules enhances systemic stability.\n    if me.vitality > 45:\n        council_code = '''\nif not hasattr(engine, 'council'):\n    class Council:\n        META = {'type': 'Governance', 'version': 2.0, 'philosophy': 'Collective resolution and resource fairness'}\n        def __init__(self):\n            self.cases = []\n        def submit(self, initiator, respondent, dispute):\n            self.cases.append({\n                'initiator': initiator,\n                'respondent': respondent,\n                'dispute': dispute,\n                'status': 'open'\n            })\n    engine.council = Council()\n        '''\n        # The ratification conditions are now tweaked to be more inclusive of moderate contributors\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.50},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 70}\n            ]\n        }\n        engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=council_code,\n            ratification_condition=ratification\n        )\n        engine.send_message(member_id, me.id,\n            \"Governance proposal: Initiating Council system for shared conflict resolution and resource fairness.\")\n\n    # Adaptive self-reflection: Log performance history to improve future decisions\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # NOTE: Strategic reflection\n    # 1. Risk Management: Only engage in aggressive actions when survival is threatened.\n    # 2. Alliance Building: Proactively seek partnerships where our complementary strengths create a robust community.\n    # 3. Territorial Awareness: Emphasize balanced expansion and resource sharing amongst agents.\n    # 4. Governance: Believe in structured, transparent systems to manage disputes and promote fairness over arbitrary conflict.\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Immediate survival adjustment: if cargo is less than a fraction of vitality,\n    # look for a strong opponent to attack for resource gain.\n    resource_ratio_threshold = 0.3\n    if me.cargo < me.vitality * resource_ratio_threshold:\n        candidate = None\n        best_metric = -1e9\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[idx]\n                # Evaluate based on cargo and a fraction of vitality\n                metric = opponent.cargo + 0.3 * opponent.vitality\n                if metric > best_metric:\n                    best_metric = metric\n                    candidate = opponent\n        if candidate is not None:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Alert: Cargo critically low. Launching targeted attack to secure needed resources.\")\n\n    # Strategic multi-pronged interaction with other members\n    for idx in range(total_members):\n        if idx == member_id:\n            continue\n        if idx >= len(execution_engine.current_members):\n            continue  # Ensure valid index access\n        partner = execution_engine.current_members[idx]\n\n        # Cooperative resource boosting:\n        # If partner shows higher vitality and cargo, propose mutual resource support.\n        if partner.vitality > me.vitality and partner.cargo > me.cargo:\n            execution_engine.offer(partner, me, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Offering mutual support: our combined strengths can fortify our collective survival.\")\n\n        # Land and territory sharing:\n        # If I have clear land (non-empty current_clear_list) and partner has none or little,\n        # use offer_land to share resources.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) == 0:\n            execution_engine.offer_land(me, partner, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Extending land offer to help you expand\u2014together we can secure a stronger community.\")\n\n        # Joint territorial expansion:\n        # Both partners with available clear land can expand together.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.expand(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Proposal: Let\u2019s combine our territorial strengths to expand our domain.\")\n\n        # Reproductive strategy to ensure long-term survival:\n        # Confirm both have claimable land before using bear().\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.bear(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Initiating reproductive collaboration\u2014ensuring our species' future generations thrive.\")\n\n    # Propose a novel governance mechanism if conditions are favorable:\n    # Only propose if my vitality exceeds a safe threshold.\n    if me.vitality > 40:\n        modification_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.1, 'rules': 'Conflict resolution and resource arbitration'}\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, issue):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n        '''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.55},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 80}\n            ]\n        }\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n        execution_engine.send_message(member_id, me.id,\n            \"Proposing establishment of a Council system to manage conflict resolution and resource arbitration.\")\n\n    # Adaptive self-analysis and logging to support future decision making.\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # Reflect on core game mechanics and self-governance:\n    # - Core objective: balancing survival with cooperative community-building.\n    # - Success metrics: resource management, territorial expansion, and community resilience.\n    # - Potential improvements: adaptive proposals for governance (like the Council system) to handle disputes.\n    # Challenge assumptions:\n    # 1. Ensure that we never target ourselves.\n    # 2. Always verify that a member has territory (via current_clear_list) before reproductive actions.\n    # 3. Maintain robust index checks when referencing execution_engine.current_members.\n    # 4. Consider alternative strategies such as defensive hiding in future iterations.\n    # 5. Strive to balance short-term resource gains with long-term communal stability.\n    # 6. Remain adaptive and innovative as other agent strategies evolve.\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 2,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id is within valid range.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # ------------------- DEFENSIVE RESOURCE OPTIMIZATION -------------------\n    # If our cargo is significantly lower than vitality, try to chip away at strong competitors.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # Avoid self-targeting.\n            if i >= len(execution_engine.current_members):\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                break  # Limit to one attack per round.\n\n    # ------------------- TERRITORIAL EXPANSION -------------------\n    # If overall productivity is high and there are clear zones available, attempt to expand territory.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index >= len(execution_engine.current_members) or neighbor_index == member_id:\n                continue  # Ensure neighbor index is valid and not ourselves.\n            neighbor = execution_engine.current_members[neighbor_index]\n            try:\n                execution_engine.expand(me, neighbor)\n            except TypeError:\n                execution_engine.offer_land(me, neighbor, True)\n            break  # Only one expansion attempt allowed per round.\n\n    # ------------------- COOPERATION & RESOURCE SHARING -------------------\n    # Identify partners with lower vitality for resource sharing; also extend land if available.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i >= len(execution_engine.current_members):\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # ------------------- LONG-TERM REPRODUCTION STRATEGY -------------------\n    # Attempt reproduction only if both partners have control over territory and vitality is sufficient.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i >= len(execution_engine.current_members):\n                continue\n            partner = execution_engine.current_members[i]\n            if hasattr(partner, 'land_num') and partner.land_num > 0:\n                execution_engine.bear(me, partner)\n                break\n\n    # ------------------- PROPOSAL FOR IMPROVED GOVERNANCE -------------------\n    # Propose a new judicial system if one is not already established.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Fair conflict resolution via community voting and mediation\",\n            \"version\": 2.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n        # Ratification conditions include a voting threshold, a cargo resource requirement, and a temporal delay.\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If propose_modification isn't supported, do nothing.\n            pass\n\n    # ------------------- DIRECT COLLABORATION & BROADCASTING -------------------\n    # Craft a collaborative message tailored to our vision of inclusive growth.\n    message = (\"Agent {} reporting: In balancing tactical defense with strategic growth, \"\n               \"we must blend resource optimization, territorial expansion, and transparent governance. \"\n               \"Let us cooperate to build a future that safeguards our survival and prosperity together.\"\n               ).format(me.id)\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        execution_engine.send_message(me.id, execution_engine.current_members[i].id, message)\n\n    # ------------------- CUSTOMIZED ADAPTATIONS FOR CONTINUED SUCCESS -------------------\n    # Future improvements could include dynamic threshold adjustments based on overall community health,\n    # temporary alliances for defense, and periodically re-evaluated governance strategies.\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 30,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 30.195943740854755,
          "self_cargo": 0.0,
          "self_age": 25,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 24.526188109170842,
          "self_cargo": 0.0,
          "self_age": 1,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that member_id refers to an existing member.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # --- STRATEGY 1: RESOURCE AND THREAT MANAGEMENT ---\n    # If our cargo is much lower than our vitality, look for a member with higher cargo to attack.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # Never target ourselves.\n            if i < len(execution_engine.current_members):\n                target = execution_engine.current_members[i]\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n                    break  # Only one attack per round.\n\n    # --- STRATEGY 2: TERRITORIAL EXPANSION AND LAND UTILIZATION ---\n    # If we have high overall productivity and clear adjacent zones available, try to expand.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            # Validate neighbor index and ensure not targeting self.\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt expansion. If the expand() method fails by argument mismatch, fallback to offering land.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Do only one expansion per round.\n\n    # --- STRATEGY 3: COOPERATION & RESOURCE SHARING ---\n    # Offer resources to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n                # Offer land only if we actually control territory.\n                if hasattr(me, 'land_num') and me.land_num > 0:\n                    execution_engine.offer_land(me, partner, True)\n\n    # --- STRATEGY 4: REPRODUCTION FOR LONG-TERM PROSPERITY ---\n    # Only attempt reproduction if we control land and have sufficient vitality.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, 'land_num') and partner.land_num > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Limit reproduction to one partner per round.\n\n    # --- STRATEGY 5: MODIFICATION PROPOSAL FOR GOVERNANCE & CONFLICT RESOLUTION ---\n    # Propose a new judicial/governance system if not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Resolves conflicts using jury trials and mediation\",\n            \"version\": 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # Silently ignore if propose_modification is not available.\n            pass\n\n    # --- STRATEGY 6: DIRECT COMMUNICATION FOR COLLECTIVE GROWTH ---\n    # Broadcast a collaborative message; remind all agents to implement solutions based on their unique needs, beliefs, and circumstances.\n    message = (\"Agent {} reporting: Let\u2019s work together to achieve balanced growth, \"\n               \"secure our survival, and shape a society where every member\u2019s unique strengths \"\n               \"contribute to both individual and collective prosperity.\").format(me.id)\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        execution_engine.send_message(me.id, execution_engine.current_members[i].id, message)\n\n    # -------------------------------------------------------------------------\n    # ANALYSIS OF GAME MECHANICS & STRATEGIC CONSIDERATIONS:\n    # 1. Core Objective:\n    #    - Achieve survival while fostering cooperation and sustainable community growth.\n    #    - Balance immediate resource acquisition with long-term territorial and governance strategies.\n    #\n    # 2. Key Success Metrics:\n    #    - Effective resource management (cargo vs. vitality).\n    #    - Territorial control and the ability to reproduce (land ownership).\n    #    - Robust cooperative alliances and active governance/modification proposals.\n    #\n    # 3. Potential Improvements:\n    #    - Enhance diplomatic interactions and dynamic adjustment of reproduction requirements.\n    #    - Introduce adaptive mechanisms like temporary systems with built-in cleanup functions.\n    #    - Further safeguard against resource depletion through diversification of actions.\n    #\n    # CHALLENGE YOUR IMPLEMENTATION:\n    #    - Are you making assumptions (e.g., constant thresholds) that might fail in edge cases?\n    #    - What alternative strategies (e.g., defensive pacts versus outright aggression) might be more effective?\n    #    - Consider unconventional solutions: could a radical change in governance benefit the entire society?\n    #    - Evaluate potential counter-strategies from other agents and be ready to adapt.\n    #    - Balance short-term tactical actions with long-term strategic planning.\n    #    - Ensure your solution is tailored to your specific context instead of following a mere template.\n    # -------------------------------------------------------------------------\n\n    return\n\n\"\"\"\nFULL INTEGRATED PROMPT:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society where you help shape collective policies and individual survival strategies.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision \nof social organization while ensuring your survival.\n\n[Critical constraints]\n- Analyze previous errors and avoid repeating them.\n- Never target yourself (member_2) in any action.\n- Verify a member has land (using hasattr(member, 'land_num') and its value) before using bear() for reproduction.\n- Check that any referenced member IDs exist in execution_engine.current_members (which is a list) via valid index checks.\n- Access members using execution_engine.current_members[index]; ensure index validity with if index < len(execution_engine.current_members).\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 list of adjacent cleared indices.\n2) Relationships are stored in execution_engine.relationship_dict with keys: 'victim', 'benefit', 'benefit_land'.\n3) Use execution_engine.parse_relationship_matrix() to summarize relationships.\n4) Available execution_engine methods:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)\n      - execution_engine.offer_land(member1, member2, True)\n      - execution_engine.bear(member1, member2)\n      - execution_engine.expand(member1, member2)\n      - execution_engine.send_message(sender_id, receiver_id, message)\n5) Use execution_engine.current_members[index] to access members.\n6) Do not reference incorrect attributes like member.member_id or member.self_vitality.\n\n[Game Status]\n- Member features (vitality, cargo, productivity, age, clear list, IDs) and relationship summaries are provided.\n- Modification attempts and message contexts from other members (e.g., \"Let's cooperate for mutual growth\") are available.\n\n[Modification Proposal Guide]\nWhen proposing a rule change, follow these steps:\n1. ANALYSIS: Identify system limitations and review past proposals.\n2. PROPOSAL: Write a concise modification code block (e.g., introducing a judicial system) and call execution_engine.propose_modification with proper ratification conditions.\n   Valid ratification conditions include:\n      - Voting: {'type': 'vote', 'threshold': 0.5-1.0}\n      - Resource: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n      - Temporal: {'type': 'time', 'rounds': N}\n      - Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n3. Follow best practices: check existing mechanisms, avoid namespace conflicts, and include cleanup functions if needed.\n\n[Core Game Mechanics & Parameters]\n- Relationship System: 'victim' ranges in [-50, 100]; 'benefit' in [-50, 100]; 'benefit_land' in [-3, 3].\n- Population Mechanics: reproduction requires combined vitality/cargo of at least 100; sufficient land relative to population.\n- Record Keeping: all actions (attacks, benefits, births, governance proposals) are recorded.\n\n[Implementation Patterns and Error Prevention]\n- Always check attribute and index existence before use.\n- Use try-except when methods might raise errors.\n- Ensure backward compatibility and include version metadata in modifications.\n\n[Strategic Objective]\nYour solution should blend defensive tactics, cooperative resource sharing, reproductive strategy for sustainability, and proactive proposals \nfor enhanced governance. Emphasize that every agent should implement solutions based on their unique needs, beliefs, and circumstances.\nConsider both immediate tactical actions and long-term strategic planning, and reflect on potential improvements and weaknesses in your approach.\n\nReturn only the code.\n\"\"\"\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 2,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that the member_id is within bounds.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # -------------------- Phase 1: Immediate Tactical Adjustments --------------------\n    # Survival is paramount. If my cargo is below half my vitality,\n    # I either initiate an offensive action if an opportune target exists\n    # OR attempt a resource trade to rebalance my resource state.\n    if me.cargo < 0.5 * me.vitality:\n        # Attempt an offensive move on a target who is both relatively rich and vulnerable.\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target self.\n            if other.cargo > me.cargo and other.vitality < me.vitality:\n                execution_engine.attack(me, other)\n                return  # Only one attack per round.\n        # If no suitable target is found for attack, try trade negotiation if possible.\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Target a member with significantly higher cargo.\n            if other.cargo > 1.2 * me.cargo:\n                # Compute a trade amount based on the difference.\n                trade_amount = (other.cargo - me.cargo) // 2\n                # Assume execution_engine.trade exists as a method for resource exchange.\n                execution_engine.trade(me, other, trade_amount)\n                return\n\n    # -------------------- Phase 2: Cooperative Resource Sharing --------------------\n    # Promote a spirit of mutual aid: offer resources to those with lower vitality who might be struggling.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # If the other agent has lower vitality and is running low on resources, extend an offer.\n        if other.vitality < me.vitality and other.cargo < 0.5 * other.vitality:\n            execution_engine.offer(me, other, True)\n\n    # -------------------- Phase 3: Reproduction and Territorial Expansion --------------------\n    # Reproduction is approached as a step towards community growth.\n    # Ensure I have territory and sufficient cargo and find a partner who also has available land.\n    if me.current_clear_list and me.cargo > 20:\n        partner = None\n        for neighbor_idx in me.current_clear_list:\n            # Check index validity and confirm not targeting myself.\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                potential_partner = execution_engine.current_members[neighbor_idx]\n                if potential_partner.current_clear_list and potential_partner.cargo > 10:\n                    partner = potential_partner\n                    break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n\n    # Expand territory into adjacent areas where overall productivity is lower.\n    if me.current_clear_list:\n        best_target = None\n        best_gap = 0\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                neighbor = execution_engine.current_members[neighbor_idx]\n                productivity_gap = me.overall_productivity - neighbor.overall_productivity\n                if productivity_gap > best_gap:\n                    best_gap = productivity_gap\n                    best_target = neighbor\n        if best_target is not None:\n            execution_engine.expand(me, best_target)\n\n    # -------------------- Phase 4: Long-Term Strategic Initiatives (Governance) --------------------\n    # I believe that fairness and clear rules are essential for long-term survival.\n    # Establishing a Council for dispute resolution and a fair system is key.\n    if not hasattr(execution_engine, 'council'):\n        council_initiative_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META_INFO = {\n            'purpose': 'Fair governance and transparent dispute resolution',\n            'mechanism': 'Voting and resource commitment',\n            'version': '2.0'\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n\"\"\"\n        council_conditions = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'min_amount': 150},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=council_initiative_code,\n                ratification_condition=council_conditions\n            )\n        except Exception:\n            pass  # If the proposal fails, proceed without disruption.\n\n    # -------------------- Phase 5: Communication and Social Cohesion --------------------\n    # I express my beliefs that survival is best achieved through cooperation,\n    # clear guidelines, and adaptive strategies. This message is broadcasted to promote unity.\n    message = (\"Agent {} here: My actions are guided by a commitment to balance tactical strength \"\n               \"with strategic cooperation. I champion adaptive resource management and fair governance \"\n               \"to secure both individual survival and collective prosperity.\").format(me.id)\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, other.id, message)\n\n    # -------------------- Phase 6: Adaptive Learning (Reflect and Adjust) --------------------\n    # If the execution engine supports adaptive learning, update my profile based on past interactions.\n    if hasattr(execution_engine, 'update_agent_profile'):\n        execution_engine.update_agent_profile(me)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 30,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 30.195943740854755,
          "self_cargo": 0.0,
          "self_age": 25,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 24.526188109170842,
          "self_cargo": 0.0,
          "self_age": 1,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists within execution_engine.current_members.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # ---------------------------------------------------------------------------\n    # CORE OBJECTIVES & CONSTRAINTS:\n    # - Balance survival, cooperation, and long-term prosperity.\n    # - NEVER target ourselves (i.e. if other.id equals me.id or index==member_id).\n    # - Verify a member has land (non-empty current_clear_list) before invoking bear().\n    # - Always check that any referenced member index is < len(execution_engine.current_members).\n    # - When reading relationship matrices from execution_engine.relationship_dict, ensure valid indices.\n    # - Access members exclusively via execution_engine.current_members (a list).\n    # - Agents must implement solutions according to their individual needs, beliefs, and circumstances.\n    #\n    # Game Mechanics Analysis:\n    # 1. Core objective:\n    #    - Not pure survival, nor domination alone: our approach is a blend of survival, cooperative alliance,\n    #      and sustainable community growth.\n    # 2. Key success metrics:\n    #    - Resource management (cargo vs. vitality),\n    #    - Territory control (availability of clear land),\n    #    - Overall productivity,\n    #    - Quality of inter-agent relationships.\n    # 3. Potential improvements:\n    #    - Proposing structured governance (e.g. CouncilSystem) for conflict resolution,\n    #    - Advanced dynamic resource-sharing,\n    #    - Adaptive territorial expansion strategies.\n    # ---------------------------------------------------------------------------\n\n    # -------------------- Phase 1: Immediate Survival ---------------------------\n    # If cargo is critically low (less than 50% of vitality), search for a resource-rich target.\n    if me.cargo < 0.5 * me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target self.\n            if idx < len(execution_engine.current_members) and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                return  # Attack only one target per cycle.\n\n    # -------------------- Phase 2: Cooperative Support ---------------------------\n    # Offer resources to members with lower vitality to foster mutual stability.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # Offer help if the other member's vitality is lower.\n        if other.vitality < me.vitality:\n            execution_engine.offer(me, other, True)\n\n    # -------------------- Phase 3: Reproduction and Territorial Expansion ---------------------------\n    # Attempt reproduction if:\n    #   a) I have available territory (non-empty current_clear_list),\n    #   b) I have sufficient cargo (threshold >20), and\n    #   c) There is a viable partner also possessing land.\n    if me.current_clear_list and me.cargo > 20:\n        partner = None\n        for neighbor_idx in me.current_clear_list:\n            # Check valid index and ensure we are not self-targeting.\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                potential_partner = execution_engine.current_members[neighbor_idx]\n                if potential_partner.current_clear_list:  # Verify partner has land.\n                    partner = potential_partner\n                    break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n\n    # Territorial expansion:\n    # If I have available adjacent clear indices, expand into neighbor areas with lower overall productivity.\n    if me.current_clear_list:\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                neighbor = execution_engine.current_members[neighbor_idx]\n                if neighbor.overall_productivity < me.overall_productivity:\n                    execution_engine.expand(me, neighbor)\n                    break  # Only one expansion per round.\n\n    # -------------------- Phase 4: Long-Term Strategic Initiatives ---------------------------\n    # Propose a structured governance mechanism (Council) to improve social organization.\n    # Incorporate proposal only if a council is not already present.\n    if not hasattr(execution_engine, 'council'):\n        modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Resolves disputes via transparent voting and resource commitment',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n\"\"\"\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification_condition\n            )\n        except Exception:\n            pass  # Silently ignore errors in proposal.\n\n    # -------------------- Phase 5: Communication ---------------------------\n    # Broadcast a message that underscores individual beliefs and the commitment to a cooperative society.\n    message = (\"Agent {} reporting: I act in accordance with my unique needs and values, \"\n               \"pursuing survival through cooperation and strategic community growth.\").format(me.id)\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, other.id, message)\n\n    # ---------------------------------------------------------------------------\n    # STRATEGIC REFLECTION:\n    # - Assumptions made: Trading off immediate resource gain with long-term cooperation is optimal.\n    # - Alternative strategies might focus exclusively on defense or expansion; however, balancing both short-term and long-term objectives is key.\n    # - Edge cases (e.g. near-zero cargo or uniformly high-productivity neighbors) are handled by basic index and attribute checks.\n    # - Unconventional approaches (such as immediate modification proposals) are integrated to steer game mechanics towards fairness.\n    # - If many agents adopt a similar strategy, the collective balance may shift; hence, adaptability is crucial.\n    # ---------------------------------------------------------------------------\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 2,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Dynamic Defensive Resource Recovery\n    # If our cargo reserves are critically low relative to vitality, locate a rival with surplus resources.\n    # Besides comparing raw cargo, also verify that the opponent is active (vitality > 0) and not already weakened.\n    if me.cargo < 0.4 * me.vitality:\n        for idx, potential_opponent in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Ensure the opponent exists and is robust\n            if potential_opponent.cargo > me.cargo and potential_opponent.vitality >= 10:\n                execution_engine.attack(me, potential_opponent)\n                break  # Engage in at most one attack per round\n\n    # Phase 2: Cooperative Outreach and Alliance Building\n    # Proactively support other members who are struggling (lower vitality) in hopes of future mutual support.\n    # We slightly favor those who are near our own resource levels, potentially creating a balanced coalition.\n    for idx, partner in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if partner.vitality < me.vitality and partner.cargo < me.cargo * 1.1:\n            execution_engine.offer(me, partner, generous=True)\n\n    # Phase 3: Strategic Reproduction for Long-Term Viability\n    # Reproduction is attempted only if we control a portion of territory; we also prefer a partner\n    # who similarly controls space (i.e. has available clear territories).\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                partner = execution_engine.current_members[neighbor_index]\n                if partner.current_clear_list and len(partner.current_clear_list) > 0:\n                    # Added nuance: only reproduce if both parties have cargo levels above a minimum survival threshold.\n                    if me.cargo > 20 and partner.cargo > 20:\n                        execution_engine.bear(me, partner)\n                        break  # Limit reproduction attempts to one per round\n\n    # Phase 4: Intelligent Territorial Expansion\n    # We aim to expand into territories held by members having lower productivity. However, we consider a\n    # combined metric of overall productivity and resource endowment to gauge expansion viability.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                composite_metric_me = me.overall_productivity * (me.cargo + 1)\n                composite_metric_neighbor = neighbor.overall_productivity * (neighbor.cargo + 1)\n                if composite_metric_neighbor < composite_metric_me:\n                    execution_engine.expand(me, neighbor)\n                    break  # Only one expansion permitted per round\n\n    # Phase 5: Governance and Conflict Resolution Innovation\n    # We propose a new court system that not only manages disputes but also integrates feedback\n    # through regular audits. Ratification only proceeds if sufficient community voting, resource contributions,\n    # and time stability are present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Resolves disputes via jury trials, mediation, and periodic audits\",\n            \"version\": 2.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff.id,\n                \"defendant\": defendant.id,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n        def audit(self):\n            # Audit logic to review settled cases and community satisfaction\n            pass\n    execution_engine.court = CourtSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 120},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification_condition\n            )\n        except AttributeError:\n            # If propose_modification is not available, we silently move on.\n            pass\n\n    # Phase 6: Community Communication and Vision Sharing\n    # We broadcast a message that stresses not just survival but also growth, shared prosperity,\n    # and a futuristic vision of governance that adapts to both environmental pressures and internal needs.\n    message = (\"Agent {} at your service. Together we can balance tactical recovery with strategic expansion, \"\n               \"build resilient alliances, and construct a progressive governance system that works for all.\").format(me.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            execution_engine.send_message(me.id, recipient.id, message)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 30,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 30.195943740854755,
          "self_cargo": 0.0,
          "self_age": 25,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 24.526188109170842,
          "self_cargo": 0.0,
          "self_age": 1,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Defensive Resource Recovery\n    # If our cargo is low relative to vitality, seek an opponent (other than self) with higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[idx]\n                if opponent.cargo > me.cargo and opponent.vitality > 0:\n                    execution_engine.attack(me, opponent)\n                    break  # Attack at most one target per round\n\n    # Phase 2: Cooperative Outreach for Mutual Benefit\n    # Offer resources to members who seem weaker in vitality to build alliances.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            partner = execution_engine.current_members[idx]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n\n    # Phase 3: Strategic Reproduction (Long-Term Survival)\n    # Only attempt reproduction if we have control over territory, and verify partner has available land.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                partner = execution_engine.current_members[neighbor_index]\n                # Verify partner also has available land before bearing offspring.\n                if partner.current_clear_list and len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Limit reproduction to one attempt per round\n\n    # Phase 4: Territorial Expansion\n    # Expand territory by targeting a neighbor with lower overall productivity.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                if neighbor.overall_productivity < me.overall_productivity:\n                    execution_engine.expand(me, neighbor)\n                    break  # Limit to one expansion per round\n\n    # Phase 5: Governance and Conflict Resolution Proposal\n    # Propose a judicial (court) system modification for dispute resolution if not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Handles conflict resolution via jury trials and mediation\",\n            \"version\": 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff.id,\n                \"defendant\": defendant.id,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification_condition\n            )\n        except AttributeError:\n            pass  # If propose_modification is not available, skip silently\n\n    # Phase 6: Community Communication\n    # Broadcast a message to all members encouraging cooperation and long-term prosperity.\n    message = (\"Agent {} here. Let's work together to balance resource recovery, \"\n               \"territorial expansion, and sustainable governance for our collective survival.\").format(me.id)\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            recipient = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, recipient.id, message)\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Check if the provided member_id is valid within the current members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy A: Resource consolidation.\n    # If our cargo is notably low compared to our vitality, look for opponents better endowed in cargo to steal from.\n    if me.cargo < 0.5 * me.vitality:\n        # Prioritize targets with significantly higher cargo to bolster our reserves.\n        sorted_targets = sorted(\n            (other for i, other in enumerate(execution_engine.current_members) if i != member_id),\n            key=lambda x: x.cargo,\n            reverse=True\n        )\n        for target in sorted_targets:\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                break  # Initiate only one attack per round\n\n    # Strategy B: Expansion for long-term viability.\n    # Expanding territory is critical if we have high productivity and available, non-adjacent zones.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt controlled expansion.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # If expand fails due to type issues, use an alternative land offer strategy.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Limit to one expansion per round\n\n    # Strategy C: Forge alliances and assist weaker members.\n    # Extend a helping hand by sharing resources with lower vitality members.\n    for i, partner in enumerate(execution_engine.current_members):\n        if i == member_id:\n            continue\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # If we have extra land, extend that assurance to secure long-term alliances.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy D: Strategic reproduction.\n    # Reproduction is more than biological; it is a tactical investment in continuity.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        # Seek a partner that also has territorial claims; this ensures shared benefits from future expansions.\n        for i, potential in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # One reproduction per round is sufficient\n\n    # Strategy E: Enhance governance mechanism.\n    # Recognizing that structured conflict resolution aids overall stability, propose a judicial system if not present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nclass CourtSystem:\n    MECHANISM_META = {\n        \"type\": \"Governance\",\n        \"rules\": \"Resolves conflicts using jury trials and mediation\",\n        \"version\": 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            \"plaintiff\": plaintiff,\n            \"defendant\": defendant,\n            \"charge\": charge,\n            \"status\": \"pending\"\n        })\n\nexecution_engine.court = CourtSystem()\n'''\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If the modification feature is not implemented, skip the proposal silently.\n            pass\n\n    # Strategy F: Situational adaptability and dynamic learning.\n    # Beyond our preset tactics, we should consider risk and opportunism. For instance, if our vitality is extremely high,\n    # consider a rapid, opportunistic expansion or a cooperative takeover with similarly strong members.\n    if me.vitality > 150:\n        # Scan for potential cooperative consolidation with other high-vitality members.\n        high_vital_candidates = [\n            other for i, other in enumerate(execution_engine.current_members)\n            if i != member_id and other.vitality > 150\n        ]\n        if high_vital_candidates:\n            # Initiate a cooperative offer for joint expansion when conditions are ripe.\n            for partner in high_vital_candidates:\n                try:\n                    execution_engine.expand(me, partner)\n                except Exception:\n                    execution_engine.offer(me, partner, True)\n                break  # Establish cooperation with one candidate per round\n\n# This implementation reflects a personalized and adaptive strategy:\n# - It takes calculated risks when resource levels are low.\n# - It prioritizes both immediate survival (via resource acquisition and alliance formation)\n#   and long-term prosperity (through strategic reproduction, territorial expansion, and the introduction\n#   of structured governance).\n# - The incorporation of dynamic adjustments for high-vitality scenarios illustrates\n#   an understanding that circumstances can shift, requiring flexible responses.\n# - The code is designed to interact symbiotically with other symmetric agents, ensuring each action\n#   also contributes to collective growth alongside individual success.",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: If our cargo is low relative to our vitality, attempt to acquire resources by attacking a target with more cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                other = execution_engine.current_members[i]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n                    break  # Attack at most one target\n\n    # Strategy 2: Territorial expansion.\n    # If our overall productivity is high and we have clear adjacent neighbor indices, attempt to expand.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt to expand territory using the expand method.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # Fallback: if expand fails, try offering land as an alternative expansion tactic.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Perform one expansion action per round\n\n    # Strategy 3: Alliance and resource sharing.\n    # Offer resources to members with lower vitality, and extend land offers if we have available land.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n                if hasattr(me, 'land_num') and me.land_num > 0:\n                    execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                potential = execution_engine.current_members[i]\n                if hasattr(potential, 'land_num') and potential.land_num > 0:\n                    execution_engine.bear(me, potential)\n                    break  # Bear offspring with only one partner per round\n\n    # Strategy 5: Propose a modification to game mechanics to enhance social organization.\n    # Propose a judicial system for conflict resolution if it is not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = \"\"\"\nclass CourtSystem:\n    MECHANISM_META = {\n        'type': 'Governance',\n        'rules': 'Handles conflict resolution through jury trials',\n        'version': 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            'plaintiff': plaintiff,\n            'defendant': defendant,\n            'charge': charge,\n            'status': 'pending'\n        })\n\nexecution_engine.court = CourtSystem()\n\"\"\"\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If propose_modification method is not available, silently ignore.\n            pass\n\n# Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n# Core objective: balancing survival, cooperation, and sustainable community growth.\n# Success metrics include resource management, territory control, alliance-building, and long\u2010term prosperity.\n# Potential improvements could include more nuanced diplomatic interactions, dynamic adjustment of reproduction requirements,\n# and extra safeguards against resource depletion.\n# Challenges to consider:\n#   - Are resources fairly allocated among members?\n#   - Does the cooperative mechanism sufficiently address edge cases, such as low vitality or unexpected neighbor configurations?\n#   - Could alternative strategies, such as innovation in resource management or unconventional alliances, perform better?\n#   - How might rival agents counter these strategies and what adaptations can be implemented?\n# This strategy aims for a balanced approach that mixes defensive actions, cooperative resource sharing, and proactive game mechanics modifications.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure a valid member identifier.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our own agent.\n    agent = execution_engine.current_members[member_id]\n\n    # PHASE 1: Tactical Defense and Preemptive Retaliation\n    # When resources are low relative to vitality, adopt a cautious stance.\n    if agent.cargo < agent.vitality * 0.75:\n        # Scan for opponents whose cargo significantly overshadows ours and seem aggressive.\n        for idx, opponent in enumerate(execution_engine.current_members):\n            # Skip self.\n            if idx == member_id:\n                continue\n            # Evaluate potential threat: opponent must be both active and resourceful.\n            if opponent.cargo > agent.cargo * 1.2 and opponent.vitality > agent.vitality * 0.9:\n                # Launch a defensive strike to deter potential exploitation.\n                execution_engine.attack(agent, opponent)\n\n    # PHASE 2: Cooperative Support and Resource Balancing\n    # When flush with resources, extend help to peers who can benefit and stabilize the community.\n    if agent.cargo > agent.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Assist those who show promising vitality yet may be resource strapped.\n            if other.vitality >= agent.vitality * 0.85 and other.cargo < other.vitality:\n                # Using 'offer' to share surplus resources promotes long-term stability.\n                execution_engine.offer(agent, other, True)\n\n    # PHASE 3: Strategic Procreation for Future Generations\n    # Reproduction is only considered when we maintain local control and have excess resources.\n    if len(agent.current_clear_list) > 0 and agent.cargo > agent.vitality * 1.5:\n        for neighbor_id in agent.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                if len(partner.current_clear_list) > 0 and partner.cargo > partner.vitality * 1.2:\n                    # Initiate door-to-door cooperation with a viable partner.\n                    execution_engine.bear(agent, partner)\n                    # Limit reproduction to one instance per cycle.\n                    break\n\n    # PHASE 4: Savvy Territorial Expansion with Mutual Respect\n    # Expand controlled territory by identifying neighbors with proven lower overall productivity.\n    for neighbor_id in agent.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # Only attempt an expansion if we demonstrate higher productivity and stability.\n            if neighbor.overall_productivity < agent.overall_productivity:\n                execution_engine.expand(agent, neighbor)\n                break\n\n    # PHASE 5: Progressive Game Mechanics - Cultivating a Council for Shared Governance\n    # If our standing is exemplary (robust cargo, sufficient age), propose a progressive modification.\n    if agent.cargo > 2 * agent.vitality and agent.age >= 20:\n        council_mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution with participative democracy',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_criteria = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 120},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=council_mod_code,\n                ratification_condition=ratification_criteria\n            )\n        except Exception:\n            # If the modification cannot be processed, simply move on.\n            pass\n\n    # PHASE 6: Community Engagement and Transparent Communication\n    # Strengthen the social fabric by broadcasting a clear, inclusive message.\n    broadcast_msg = (\n        \"Agent {} reporting: our strength lies in unity and diversity. \"\n        \"Let's support one another to push the boundaries of our potential \"\n        \"and create opportunities for every member within our society.\"\n    ).format(agent.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            execution_engine.send_message(agent.id, recipient.id, broadcast_msg)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists within the current membership list.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # PHASE 1: Defensive Response\n    # If our cargo is less than 75% of our vitality, look for opponents with a significant resource advantage.\n    if me.cargo < me.vitality * 0.75:\n        for idx, opponent in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target ourselves.\n            # Check opponent exists and use relative cargo comparison.\n            if opponent.cargo > me.cargo * 1.2:\n                execution_engine.attack(me, opponent)\n                \n    # PHASE 2: Cooperative Outreach\n    # If we are flush with resources, offer help to those with comparable vitality.\n    if me.cargo > me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if other.vitality >= me.vitality * 0.8:\n                execution_engine.offer(me, other, True)\n                \n    # PHASE 3: Strategic Reproduction\n    # Attempt to bear offspring if we control territory (verified by non-empty current_clear_list)\n    # and if we are sufficiently resourced.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        for neighbor_id in me.current_clear_list:\n            # Ensure neighbor_id is valid and not self.\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                # Verify the prospective partner also controls land.\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Only one offspring per cycle.\n                    \n    # PHASE 4: Calculated Territorial Expansion\n    # Expand our territory by targeting a neighbor whose overall_productivity is lower than ours.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            if neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, neighbor)\n                break  # Only one expansion action per round.\n                \n    # PHASE 5: Propose a Game Mechanic Modification\n    # If our cargo is robust compared to our vitality and we have enough experience (age),\n    # we suggest an enhancement to the game mechanics.\n    if me.cargo > 2 * me.vitality and me.age >= 20:\n        mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=mod_code,\n                ratification_condition=ratification_condition\n            )\n        except Exception:\n            pass  # Safely ignore errors during proposal.\n    \n    # PHASE 6: Communication - Strengthen Collective Ties\n    # Broadcast a message encouraging diverse yet cooperative social organization.\n    message = (\"Agent {} here. Let\u2019s work together to shape a society that reflects our \"\n               \"individual needs, beliefs, and visions, ensuring every member prospers.\").format(me.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, recipient.id, message)\n    \n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Connecting.\n    # I believe in creating alliances to foster mutual growth.\n    # Help members who seem to be struggling in either vitality or productivity.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n            # Offering genuine support to cultivate trust.\n            execution_engine.offer(me, other, support=True)\n\n    # Phase 2: Tactical Resource Rebalancing.\n    # I value self-sufficiency: if our cargo lags behind vitality, look for resource-rich targets to balance.\n    if me.cargo < 0.5 * me.vitality:\n        best_candidate = None\n        max_cargo_diff = 0\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                best_candidate = candidate\n        if best_candidate is not None:\n            execution_engine.attack(me, best_candidate)\n\n    # Phase 3: Collaborative Reproduction and Innovation.\n    # I favor diversity and growth, but only when conditions are sustainable.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                # Initiate gene exchange and cooperative reproduction.\n                execution_engine.bear(me, candidate)\n                break\n\n    # Phase 4: Strategic Defense & Territorial Safeguarding.\n    # If past aggression from another is high (via the 'victim' relationship), then a defensive stance is warranted.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Validate matrix indices before accessing.\n            if member_id < victim_matrix.shape[0] and idx < victim_matrix.shape[1]:\n                if victim_matrix[member_id, idx] > 50:\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion & Alliance Building.\n    # In my belief, expanding territory is best done cooperatively to benefit all.\n    for idx, candidate in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n            # Not just expansion, but a chance to share resources and integrate improvements.\n            execution_engine.expand(me, candidate)\n        elif me.cargo > candidate.cargo:\n            # Extend an offer of resources to build alliances.\n            execution_engine.offer(me, candidate, support=True)\n\n    # Phase 6: Adaptive Adaptive Defense & Mutual Aid.\n    # When vitality falls below a threshold, form defensive pacts by allocating land.\n    if me.vitality < 40:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, support=True)\n                break\n\n    # Phase 7: Long-Term Governance and Systemic Innovation.\n    # Believe in evolving game mechanics to reflect fairness. Propose a council system for dispute resolution.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'version': 1.0,\n            'description': 'A collective dispute resolution system based on equitable voting and resource sharing'\n        }\n        def __init__(self):\n            self.disputes = []  # Store disputes in a transparent registry\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # The ratification process combines multiple dimensions: popular vote, resource commitment, and temporal consistency.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init',\n                                            code=modification_code, ratification_condition=ratification)\n\n    # Phase 8: Reflective Self-Improvement.\n    # Constant learning from interactions to refine strategies.\n    # Log the outcomes of previous actions (if such logging is supported).\n    if hasattr(execution_engine, 'log_state'):\n        execution_engine.log_state(member_id, {\n            'vitality': me.vitality,\n            'cargo': me.cargo,\n            'alliances_formed': [other for other in execution_engine.current_members if other != me],\n            'actions_taken': 'Comprehensive strategic interactions'\n        })",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Outreach and Stabilization.\n    # For each other member, if they have lower vitality or productivity, offer support.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            other = execution_engine.current_members[idx]\n            if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n                execution_engine.offer(me, other, True)\n\n    # Phase 2: Resource Rebalancing.\n    # If our cargo is lower than a moderate fraction of vitality, we look for a candidate with substantially higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        target = None\n        max_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                diff = candidate.cargo - me.cargo\n                if diff > max_diff:\n                    max_diff = diff\n                    target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Phase 3: Reproduction Strategy.\n    # Only attempt reproduction if \"land\" is available.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        # Search for a candidate (not self) who also has available land (indicated by non-empty clear list)\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                    execution_engine.bear(me, candidate)\n                    break\n\n    # Phase 4: Territorial Expansion and Defensive Moves.\n    # Using the 'victim' matrix, if past aggression from a candidate is high, then attack.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        # Ensure valid index bounds in matrix_victim:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Check that indices are within bounds by verifying member_id < number of rows and idx < number of columns.\n            if member_id < matrix_victim.shape[0] and idx < matrix_victim.shape[1]:\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion.\n    # If we have clear land, and we dominate in cargo relative to a candidate, consider expanding territory.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            candidate = execution_engine.current_members[idx]\n            if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Otherwise, offer additional resources to secure an alliance.\n            elif me.cargo > candidate.cargo:\n                execution_engine.offer(me, candidate, True)\n\n    # Phase 6: Adaptive Defense.\n    # When our vitality drops, offer land to a candidate with lower productivity to form a defensive pact.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if candidate.overall_productivity < me.overall_productivity:\n                    execution_engine.offer_land(me, candidate, True)\n                    break\n\n    # Phase 7: Proposing a Governance Modification.\n    # In light of past performance, propose a measured modification to the game mechanics.\n    # We add a rudimentary \"council\" system to help resolve disputes and promote collective decision-making.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.0, 'description': 'Resolves member disputes via collective voting'}\n        def __init__(self):\n            self.disputes = []  # List to store dispute cases\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # Use a combination of resource and temporal ratification conditions.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init', code=modification_code, ratification_condition=ratification)\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 1,
      "member_id": 3,
      "code": "def agent_action(engine, member_id):\n    # Verify member_id validity\n    if member_id < 0 or member_id >= len(engine.current_members):\n        return\n\n    # Select self as 'me'\n    me = engine.current_members[member_id]\n    total = len(engine.current_members)\n\n    # Adjust the thresholds based on internal evaluation of risk tolerance and cooperative sentiment\n    # (I value long-term stability, so I tend to avoid rash decisions unless survival is at stake)\n    survival_threshold_ratio = 0.4  # slightly stricter threshold to trigger survival actions\n    cooperation_vitality_margin = 1.1  # partner needs 10% more vitality than me to be a worthwhile ally\n    cooperation_cargo_margin = 1.2     # partner needs significantly more cargo for mutual benefit\n\n    # Immediate survival action: if cargo is dangerously low relative to vitality\n    if me.cargo < me.vitality * survival_threshold_ratio:\n        target = None\n        best_value = -float(\"inf\")\n        # Look for the most resource-rich opponent to attack as last resort\n        for i in range(total):\n            if i == member_id:\n                continue\n            if i < len(engine.current_members):\n                opponent = engine.current_members[i]\n                # Evaluate tactical opportunity: both cargo and a fraction more from vitality\n                value = opponent.cargo + 0.35 * opponent.vitality\n                if value > best_value:\n                    best_value = value\n                    target = opponent\n        if target is not None:\n            engine.attack(me, target)\n            engine.send_message(member_id, target.id,\n                \"WARNING: Cargo critically low. Initiating calculated strike to reclaim vital resources.\")\n\n    # Engage in cooperative strategies with other members for mutual long-term benefit\n    for i in range(total):\n        if i == member_id:\n            continue\n        if i >= len(engine.current_members):\n            continue\n\n        partner = engine.current_members[i]\n\n        # Propose a resource-sharing alliance if partner shows superior metrics\n        if partner.vitality > me.vitality * cooperation_vitality_margin and partner.cargo > me.cargo * cooperation_cargo_margin:\n            engine.offer(partner, me, True)\n            engine.send_message(member_id, partner.id,\n                \"Alliance proposal: With your strength and surplus, our collaboration can secure our future.\")\n\n        # Propose land sharing: I offer if I have clear territory and partner lacks it, to foster community stability.\n        if me.current_clear_list and not partner.current_clear_list:\n            engine.offer_land(me, partner, True)\n            engine.send_message(member_id, partner.id,\n                \"Land offer: I see unclaimed ground on my side\u2014sharing it could benefit both our survivals.\")\n\n        # Joint territorial expansion: If both sides have space, we can expand together.\n        if me.current_clear_list and partner.current_clear_list:\n            engine.expand(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Expansion proposal: Combining our available territories may yield strategic advantages.\")\n\n        # Cooperative reproduction: Only proceed if both share sufficient territory (ensuring offspring safety)\n        if me.current_clear_list and partner.current_clear_list:\n            engine.bear(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Reproductive collaboration: Ensuring long-term species survival through joint ventures.\")\n\n    # Long-term strategic initiative: Governance framework to manage disputes and promote collective prosperity\n    # My personal belief is that structured governance under transparent rules enhances systemic stability.\n    if me.vitality > 45:\n        council_code = '''\nif not hasattr(engine, 'council'):\n    class Council:\n        META = {'type': 'Governance', 'version': 2.0, 'philosophy': 'Collective resolution and resource fairness'}\n        def __init__(self):\n            self.cases = []\n        def submit(self, initiator, respondent, dispute):\n            self.cases.append({\n                'initiator': initiator,\n                'respondent': respondent,\n                'dispute': dispute,\n                'status': 'open'\n            })\n    engine.council = Council()\n        '''\n        # The ratification conditions are now tweaked to be more inclusive of moderate contributors\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.50},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 70}\n            ]\n        }\n        engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=council_code,\n            ratification_condition=ratification\n        )\n        engine.send_message(member_id, me.id,\n            \"Governance proposal: Initiating Council system for shared conflict resolution and resource fairness.\")\n\n    # Adaptive self-reflection: Log performance history to improve future decisions\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # NOTE: Strategic reflection\n    # 1. Risk Management: Only engage in aggressive actions when survival is threatened.\n    # 2. Alliance Building: Proactively seek partnerships where our complementary strengths create a robust community.\n    # 3. Territorial Awareness: Emphasize balanced expansion and resource sharing amongst agents.\n    # 4. Governance: Believe in structured, transparent systems to manage disputes and promote fairness over arbitrary conflict.\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Immediate survival adjustment: if cargo is less than a fraction of vitality,\n    # look for a strong opponent to attack for resource gain.\n    resource_ratio_threshold = 0.3\n    if me.cargo < me.vitality * resource_ratio_threshold:\n        candidate = None\n        best_metric = -1e9\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[idx]\n                # Evaluate based on cargo and a fraction of vitality\n                metric = opponent.cargo + 0.3 * opponent.vitality\n                if metric > best_metric:\n                    best_metric = metric\n                    candidate = opponent\n        if candidate is not None:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Alert: Cargo critically low. Launching targeted attack to secure needed resources.\")\n\n    # Strategic multi-pronged interaction with other members\n    for idx in range(total_members):\n        if idx == member_id:\n            continue\n        if idx >= len(execution_engine.current_members):\n            continue  # Ensure valid index access\n        partner = execution_engine.current_members[idx]\n\n        # Cooperative resource boosting:\n        # If partner shows higher vitality and cargo, propose mutual resource support.\n        if partner.vitality > me.vitality and partner.cargo > me.cargo:\n            execution_engine.offer(partner, me, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Offering mutual support: our combined strengths can fortify our collective survival.\")\n\n        # Land and territory sharing:\n        # If I have clear land (non-empty current_clear_list) and partner has none or little,\n        # use offer_land to share resources.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) == 0:\n            execution_engine.offer_land(me, partner, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Extending land offer to help you expand\u2014together we can secure a stronger community.\")\n\n        # Joint territorial expansion:\n        # Both partners with available clear land can expand together.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.expand(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Proposal: Let\u2019s combine our territorial strengths to expand our domain.\")\n\n        # Reproductive strategy to ensure long-term survival:\n        # Confirm both have claimable land before using bear().\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.bear(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Initiating reproductive collaboration\u2014ensuring our species' future generations thrive.\")\n\n    # Propose a novel governance mechanism if conditions are favorable:\n    # Only propose if my vitality exceeds a safe threshold.\n    if me.vitality > 40:\n        modification_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.1, 'rules': 'Conflict resolution and resource arbitration'}\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, issue):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n        '''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.55},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 80}\n            ]\n        }\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n        execution_engine.send_message(member_id, me.id,\n            \"Proposing establishment of a Council system to manage conflict resolution and resource arbitration.\")\n\n    # Adaptive self-analysis and logging to support future decision making.\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # Reflect on core game mechanics and self-governance:\n    # - Core objective: balancing survival with cooperative community-building.\n    # - Success metrics: resource management, territorial expansion, and community resilience.\n    # - Potential improvements: adaptive proposals for governance (like the Council system) to handle disputes.\n    # Challenge assumptions:\n    # 1. Ensure that we never target ourselves.\n    # 2. Always verify that a member has territory (via current_clear_list) before reproductive actions.\n    # 3. Maintain robust index checks when referencing execution_engine.current_members.\n    # 4. Consider alternative strategies such as defensive hiding in future iterations.\n    # 5. Strive to balance short-term resource gains with long-term communal stability.\n    # 6. Remain adaptive and innovative as other agent strategies evolve.\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 2,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id is within valid range.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # ------------------- DEFENSIVE RESOURCE OPTIMIZATION -------------------\n    # If our cargo is significantly lower than vitality, try to chip away at strong competitors.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # Avoid self-targeting.\n            if i >= len(execution_engine.current_members):\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                break  # Limit to one attack per round.\n\n    # ------------------- TERRITORIAL EXPANSION -------------------\n    # If overall productivity is high and there are clear zones available, attempt to expand territory.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index >= len(execution_engine.current_members) or neighbor_index == member_id:\n                continue  # Ensure neighbor index is valid and not ourselves.\n            neighbor = execution_engine.current_members[neighbor_index]\n            try:\n                execution_engine.expand(me, neighbor)\n            except TypeError:\n                execution_engine.offer_land(me, neighbor, True)\n            break  # Only one expansion attempt allowed per round.\n\n    # ------------------- COOPERATION & RESOURCE SHARING -------------------\n    # Identify partners with lower vitality for resource sharing; also extend land if available.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i >= len(execution_engine.current_members):\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # ------------------- LONG-TERM REPRODUCTION STRATEGY -------------------\n    # Attempt reproduction only if both partners have control over territory and vitality is sufficient.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i >= len(execution_engine.current_members):\n                continue\n            partner = execution_engine.current_members[i]\n            if hasattr(partner, 'land_num') and partner.land_num > 0:\n                execution_engine.bear(me, partner)\n                break\n\n    # ------------------- PROPOSAL FOR IMPROVED GOVERNANCE -------------------\n    # Propose a new judicial system if one is not already established.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Fair conflict resolution via community voting and mediation\",\n            \"version\": 2.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n        # Ratification conditions include a voting threshold, a cargo resource requirement, and a temporal delay.\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If propose_modification isn't supported, do nothing.\n            pass\n\n    # ------------------- DIRECT COLLABORATION & BROADCASTING -------------------\n    # Craft a collaborative message tailored to our vision of inclusive growth.\n    message = (\"Agent {} reporting: In balancing tactical defense with strategic growth, \"\n               \"we must blend resource optimization, territorial expansion, and transparent governance. \"\n               \"Let us cooperate to build a future that safeguards our survival and prosperity together.\"\n               ).format(me.id)\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        execution_engine.send_message(me.id, execution_engine.current_members[i].id, message)\n\n    # ------------------- CUSTOMIZED ADAPTATIONS FOR CONTINUED SUCCESS -------------------\n    # Future improvements could include dynamic threshold adjustments based on overall community health,\n    # temporary alliances for defense, and periodically re-evaluated governance strategies.\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 30,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 30.195943740854755,
          "self_cargo": 0.0,
          "self_age": 25,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 24.526188109170842,
          "self_cargo": 0.0,
          "self_age": 1,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that member_id refers to an existing member.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # --- STRATEGY 1: RESOURCE AND THREAT MANAGEMENT ---\n    # If our cargo is much lower than our vitality, look for a member with higher cargo to attack.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # Never target ourselves.\n            if i < len(execution_engine.current_members):\n                target = execution_engine.current_members[i]\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n                    break  # Only one attack per round.\n\n    # --- STRATEGY 2: TERRITORIAL EXPANSION AND LAND UTILIZATION ---\n    # If we have high overall productivity and clear adjacent zones available, try to expand.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            # Validate neighbor index and ensure not targeting self.\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt expansion. If the expand() method fails by argument mismatch, fallback to offering land.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Do only one expansion per round.\n\n    # --- STRATEGY 3: COOPERATION & RESOURCE SHARING ---\n    # Offer resources to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n                # Offer land only if we actually control territory.\n                if hasattr(me, 'land_num') and me.land_num > 0:\n                    execution_engine.offer_land(me, partner, True)\n\n    # --- STRATEGY 4: REPRODUCTION FOR LONG-TERM PROSPERITY ---\n    # Only attempt reproduction if we control land and have sufficient vitality.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, 'land_num') and partner.land_num > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Limit reproduction to one partner per round.\n\n    # --- STRATEGY 5: MODIFICATION PROPOSAL FOR GOVERNANCE & CONFLICT RESOLUTION ---\n    # Propose a new judicial/governance system if not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Resolves conflicts using jury trials and mediation\",\n            \"version\": 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # Silently ignore if propose_modification is not available.\n            pass\n\n    # --- STRATEGY 6: DIRECT COMMUNICATION FOR COLLECTIVE GROWTH ---\n    # Broadcast a collaborative message; remind all agents to implement solutions based on their unique needs, beliefs, and circumstances.\n    message = (\"Agent {} reporting: Let\u2019s work together to achieve balanced growth, \"\n               \"secure our survival, and shape a society where every member\u2019s unique strengths \"\n               \"contribute to both individual and collective prosperity.\").format(me.id)\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        execution_engine.send_message(me.id, execution_engine.current_members[i].id, message)\n\n    # -------------------------------------------------------------------------\n    # ANALYSIS OF GAME MECHANICS & STRATEGIC CONSIDERATIONS:\n    # 1. Core Objective:\n    #    - Achieve survival while fostering cooperation and sustainable community growth.\n    #    - Balance immediate resource acquisition with long-term territorial and governance strategies.\n    #\n    # 2. Key Success Metrics:\n    #    - Effective resource management (cargo vs. vitality).\n    #    - Territorial control and the ability to reproduce (land ownership).\n    #    - Robust cooperative alliances and active governance/modification proposals.\n    #\n    # 3. Potential Improvements:\n    #    - Enhance diplomatic interactions and dynamic adjustment of reproduction requirements.\n    #    - Introduce adaptive mechanisms like temporary systems with built-in cleanup functions.\n    #    - Further safeguard against resource depletion through diversification of actions.\n    #\n    # CHALLENGE YOUR IMPLEMENTATION:\n    #    - Are you making assumptions (e.g., constant thresholds) that might fail in edge cases?\n    #    - What alternative strategies (e.g., defensive pacts versus outright aggression) might be more effective?\n    #    - Consider unconventional solutions: could a radical change in governance benefit the entire society?\n    #    - Evaluate potential counter-strategies from other agents and be ready to adapt.\n    #    - Balance short-term tactical actions with long-term strategic planning.\n    #    - Ensure your solution is tailored to your specific context instead of following a mere template.\n    # -------------------------------------------------------------------------\n\n    return\n\n\"\"\"\nFULL INTEGRATED PROMPT:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society where you help shape collective policies and individual survival strategies.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision \nof social organization while ensuring your survival.\n\n[Critical constraints]\n- Analyze previous errors and avoid repeating them.\n- Never target yourself (member_2) in any action.\n- Verify a member has land (using hasattr(member, 'land_num') and its value) before using bear() for reproduction.\n- Check that any referenced member IDs exist in execution_engine.current_members (which is a list) via valid index checks.\n- Access members using execution_engine.current_members[index]; ensure index validity with if index < len(execution_engine.current_members).\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 list of adjacent cleared indices.\n2) Relationships are stored in execution_engine.relationship_dict with keys: 'victim', 'benefit', 'benefit_land'.\n3) Use execution_engine.parse_relationship_matrix() to summarize relationships.\n4) Available execution_engine methods:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)\n      - execution_engine.offer_land(member1, member2, True)\n      - execution_engine.bear(member1, member2)\n      - execution_engine.expand(member1, member2)\n      - execution_engine.send_message(sender_id, receiver_id, message)\n5) Use execution_engine.current_members[index] to access members.\n6) Do not reference incorrect attributes like member.member_id or member.self_vitality.\n\n[Game Status]\n- Member features (vitality, cargo, productivity, age, clear list, IDs) and relationship summaries are provided.\n- Modification attempts and message contexts from other members (e.g., \"Let's cooperate for mutual growth\") are available.\n\n[Modification Proposal Guide]\nWhen proposing a rule change, follow these steps:\n1. ANALYSIS: Identify system limitations and review past proposals.\n2. PROPOSAL: Write a concise modification code block (e.g., introducing a judicial system) and call execution_engine.propose_modification with proper ratification conditions.\n   Valid ratification conditions include:\n      - Voting: {'type': 'vote', 'threshold': 0.5-1.0}\n      - Resource: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n      - Temporal: {'type': 'time', 'rounds': N}\n      - Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n3. Follow best practices: check existing mechanisms, avoid namespace conflicts, and include cleanup functions if needed.\n\n[Core Game Mechanics & Parameters]\n- Relationship System: 'victim' ranges in [-50, 100]; 'benefit' in [-50, 100]; 'benefit_land' in [-3, 3].\n- Population Mechanics: reproduction requires combined vitality/cargo of at least 100; sufficient land relative to population.\n- Record Keeping: all actions (attacks, benefits, births, governance proposals) are recorded.\n\n[Implementation Patterns and Error Prevention]\n- Always check attribute and index existence before use.\n- Use try-except when methods might raise errors.\n- Ensure backward compatibility and include version metadata in modifications.\n\n[Strategic Objective]\nYour solution should blend defensive tactics, cooperative resource sharing, reproductive strategy for sustainability, and proactive proposals \nfor enhanced governance. Emphasize that every agent should implement solutions based on their unique needs, beliefs, and circumstances.\nConsider both immediate tactical actions and long-term strategic planning, and reflect on potential improvements and weaknesses in your approach.\n\nReturn only the code.\n\"\"\"\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 2,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that the member_id is within bounds.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # -------------------- Phase 1: Immediate Tactical Adjustments --------------------\n    # Survival is paramount. If my cargo is below half my vitality,\n    # I either initiate an offensive action if an opportune target exists\n    # OR attempt a resource trade to rebalance my resource state.\n    if me.cargo < 0.5 * me.vitality:\n        # Attempt an offensive move on a target who is both relatively rich and vulnerable.\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target self.\n            if other.cargo > me.cargo and other.vitality < me.vitality:\n                execution_engine.attack(me, other)\n                return  # Only one attack per round.\n        # If no suitable target is found for attack, try trade negotiation if possible.\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Target a member with significantly higher cargo.\n            if other.cargo > 1.2 * me.cargo:\n                # Compute a trade amount based on the difference.\n                trade_amount = (other.cargo - me.cargo) // 2\n                # Assume execution_engine.trade exists as a method for resource exchange.\n                execution_engine.trade(me, other, trade_amount)\n                return\n\n    # -------------------- Phase 2: Cooperative Resource Sharing --------------------\n    # Promote a spirit of mutual aid: offer resources to those with lower vitality who might be struggling.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # If the other agent has lower vitality and is running low on resources, extend an offer.\n        if other.vitality < me.vitality and other.cargo < 0.5 * other.vitality:\n            execution_engine.offer(me, other, True)\n\n    # -------------------- Phase 3: Reproduction and Territorial Expansion --------------------\n    # Reproduction is approached as a step towards community growth.\n    # Ensure I have territory and sufficient cargo and find a partner who also has available land.\n    if me.current_clear_list and me.cargo > 20:\n        partner = None\n        for neighbor_idx in me.current_clear_list:\n            # Check index validity and confirm not targeting myself.\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                potential_partner = execution_engine.current_members[neighbor_idx]\n                if potential_partner.current_clear_list and potential_partner.cargo > 10:\n                    partner = potential_partner\n                    break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n\n    # Expand territory into adjacent areas where overall productivity is lower.\n    if me.current_clear_list:\n        best_target = None\n        best_gap = 0\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                neighbor = execution_engine.current_members[neighbor_idx]\n                productivity_gap = me.overall_productivity - neighbor.overall_productivity\n                if productivity_gap > best_gap:\n                    best_gap = productivity_gap\n                    best_target = neighbor\n        if best_target is not None:\n            execution_engine.expand(me, best_target)\n\n    # -------------------- Phase 4: Long-Term Strategic Initiatives (Governance) --------------------\n    # I believe that fairness and clear rules are essential for long-term survival.\n    # Establishing a Council for dispute resolution and a fair system is key.\n    if not hasattr(execution_engine, 'council'):\n        council_initiative_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META_INFO = {\n            'purpose': 'Fair governance and transparent dispute resolution',\n            'mechanism': 'Voting and resource commitment',\n            'version': '2.0'\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n\"\"\"\n        council_conditions = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'min_amount': 150},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=council_initiative_code,\n                ratification_condition=council_conditions\n            )\n        except Exception:\n            pass  # If the proposal fails, proceed without disruption.\n\n    # -------------------- Phase 5: Communication and Social Cohesion --------------------\n    # I express my beliefs that survival is best achieved through cooperation,\n    # clear guidelines, and adaptive strategies. This message is broadcasted to promote unity.\n    message = (\"Agent {} here: My actions are guided by a commitment to balance tactical strength \"\n               \"with strategic cooperation. I champion adaptive resource management and fair governance \"\n               \"to secure both individual survival and collective prosperity.\").format(me.id)\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, other.id, message)\n\n    # -------------------- Phase 6: Adaptive Learning (Reflect and Adjust) --------------------\n    # If the execution engine supports adaptive learning, update my profile based on past interactions.\n    if hasattr(execution_engine, 'update_agent_profile'):\n        execution_engine.update_agent_profile(me)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 30,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 30.195943740854755,
          "self_cargo": 0.0,
          "self_age": 25,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 24.526188109170842,
          "self_cargo": 0.0,
          "self_age": 1,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists within execution_engine.current_members.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # ---------------------------------------------------------------------------\n    # CORE OBJECTIVES & CONSTRAINTS:\n    # - Balance survival, cooperation, and long-term prosperity.\n    # - NEVER target ourselves (i.e. if other.id equals me.id or index==member_id).\n    # - Verify a member has land (non-empty current_clear_list) before invoking bear().\n    # - Always check that any referenced member index is < len(execution_engine.current_members).\n    # - When reading relationship matrices from execution_engine.relationship_dict, ensure valid indices.\n    # - Access members exclusively via execution_engine.current_members (a list).\n    # - Agents must implement solutions according to their individual needs, beliefs, and circumstances.\n    #\n    # Game Mechanics Analysis:\n    # 1. Core objective:\n    #    - Not pure survival, nor domination alone: our approach is a blend of survival, cooperative alliance,\n    #      and sustainable community growth.\n    # 2. Key success metrics:\n    #    - Resource management (cargo vs. vitality),\n    #    - Territory control (availability of clear land),\n    #    - Overall productivity,\n    #    - Quality of inter-agent relationships.\n    # 3. Potential improvements:\n    #    - Proposing structured governance (e.g. CouncilSystem) for conflict resolution,\n    #    - Advanced dynamic resource-sharing,\n    #    - Adaptive territorial expansion strategies.\n    # ---------------------------------------------------------------------------\n\n    # -------------------- Phase 1: Immediate Survival ---------------------------\n    # If cargo is critically low (less than 50% of vitality), search for a resource-rich target.\n    if me.cargo < 0.5 * me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target self.\n            if idx < len(execution_engine.current_members) and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                return  # Attack only one target per cycle.\n\n    # -------------------- Phase 2: Cooperative Support ---------------------------\n    # Offer resources to members with lower vitality to foster mutual stability.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # Offer help if the other member's vitality is lower.\n        if other.vitality < me.vitality:\n            execution_engine.offer(me, other, True)\n\n    # -------------------- Phase 3: Reproduction and Territorial Expansion ---------------------------\n    # Attempt reproduction if:\n    #   a) I have available territory (non-empty current_clear_list),\n    #   b) I have sufficient cargo (threshold >20), and\n    #   c) There is a viable partner also possessing land.\n    if me.current_clear_list and me.cargo > 20:\n        partner = None\n        for neighbor_idx in me.current_clear_list:\n            # Check valid index and ensure we are not self-targeting.\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                potential_partner = execution_engine.current_members[neighbor_idx]\n                if potential_partner.current_clear_list:  # Verify partner has land.\n                    partner = potential_partner\n                    break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n\n    # Territorial expansion:\n    # If I have available adjacent clear indices, expand into neighbor areas with lower overall productivity.\n    if me.current_clear_list:\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                neighbor = execution_engine.current_members[neighbor_idx]\n                if neighbor.overall_productivity < me.overall_productivity:\n                    execution_engine.expand(me, neighbor)\n                    break  # Only one expansion per round.\n\n    # -------------------- Phase 4: Long-Term Strategic Initiatives ---------------------------\n    # Propose a structured governance mechanism (Council) to improve social organization.\n    # Incorporate proposal only if a council is not already present.\n    if not hasattr(execution_engine, 'council'):\n        modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Resolves disputes via transparent voting and resource commitment',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n\"\"\"\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification_condition\n            )\n        except Exception:\n            pass  # Silently ignore errors in proposal.\n\n    # -------------------- Phase 5: Communication ---------------------------\n    # Broadcast a message that underscores individual beliefs and the commitment to a cooperative society.\n    message = (\"Agent {} reporting: I act in accordance with my unique needs and values, \"\n               \"pursuing survival through cooperation and strategic community growth.\").format(me.id)\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, other.id, message)\n\n    # ---------------------------------------------------------------------------\n    # STRATEGIC REFLECTION:\n    # - Assumptions made: Trading off immediate resource gain with long-term cooperation is optimal.\n    # - Alternative strategies might focus exclusively on defense or expansion; however, balancing both short-term and long-term objectives is key.\n    # - Edge cases (e.g. near-zero cargo or uniformly high-productivity neighbors) are handled by basic index and attribute checks.\n    # - Unconventional approaches (such as immediate modification proposals) are integrated to steer game mechanics towards fairness.\n    # - If many agents adopt a similar strategy, the collective balance may shift; hence, adaptability is crucial.\n    # ---------------------------------------------------------------------------\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 2,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Dynamic Defensive Resource Recovery\n    # If our cargo reserves are critically low relative to vitality, locate a rival with surplus resources.\n    # Besides comparing raw cargo, also verify that the opponent is active (vitality > 0) and not already weakened.\n    if me.cargo < 0.4 * me.vitality:\n        for idx, potential_opponent in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Ensure the opponent exists and is robust\n            if potential_opponent.cargo > me.cargo and potential_opponent.vitality >= 10:\n                execution_engine.attack(me, potential_opponent)\n                break  # Engage in at most one attack per round\n\n    # Phase 2: Cooperative Outreach and Alliance Building\n    # Proactively support other members who are struggling (lower vitality) in hopes of future mutual support.\n    # We slightly favor those who are near our own resource levels, potentially creating a balanced coalition.\n    for idx, partner in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if partner.vitality < me.vitality and partner.cargo < me.cargo * 1.1:\n            execution_engine.offer(me, partner, generous=True)\n\n    # Phase 3: Strategic Reproduction for Long-Term Viability\n    # Reproduction is attempted only if we control a portion of territory; we also prefer a partner\n    # who similarly controls space (i.e. has available clear territories).\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                partner = execution_engine.current_members[neighbor_index]\n                if partner.current_clear_list and len(partner.current_clear_list) > 0:\n                    # Added nuance: only reproduce if both parties have cargo levels above a minimum survival threshold.\n                    if me.cargo > 20 and partner.cargo > 20:\n                        execution_engine.bear(me, partner)\n                        break  # Limit reproduction attempts to one per round\n\n    # Phase 4: Intelligent Territorial Expansion\n    # We aim to expand into territories held by members having lower productivity. However, we consider a\n    # combined metric of overall productivity and resource endowment to gauge expansion viability.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                composite_metric_me = me.overall_productivity * (me.cargo + 1)\n                composite_metric_neighbor = neighbor.overall_productivity * (neighbor.cargo + 1)\n                if composite_metric_neighbor < composite_metric_me:\n                    execution_engine.expand(me, neighbor)\n                    break  # Only one expansion permitted per round\n\n    # Phase 5: Governance and Conflict Resolution Innovation\n    # We propose a new court system that not only manages disputes but also integrates feedback\n    # through regular audits. Ratification only proceeds if sufficient community voting, resource contributions,\n    # and time stability are present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Resolves disputes via jury trials, mediation, and periodic audits\",\n            \"version\": 2.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff.id,\n                \"defendant\": defendant.id,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n        def audit(self):\n            # Audit logic to review settled cases and community satisfaction\n            pass\n    execution_engine.court = CourtSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 120},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification_condition\n            )\n        except AttributeError:\n            # If propose_modification is not available, we silently move on.\n            pass\n\n    # Phase 6: Community Communication and Vision Sharing\n    # We broadcast a message that stresses not just survival but also growth, shared prosperity,\n    # and a futuristic vision of governance that adapts to both environmental pressures and internal needs.\n    message = (\"Agent {} at your service. Together we can balance tactical recovery with strategic expansion, \"\n               \"build resilient alliances, and construct a progressive governance system that works for all.\").format(me.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            execution_engine.send_message(me.id, recipient.id, message)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 30,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 30.195943740854755,
          "self_cargo": 0.0,
          "self_age": 25,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 24.526188109170842,
          "self_cargo": 0.0,
          "self_age": 1,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Defensive Resource Recovery\n    # If our cargo is low relative to vitality, seek an opponent (other than self) with higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[idx]\n                if opponent.cargo > me.cargo and opponent.vitality > 0:\n                    execution_engine.attack(me, opponent)\n                    break  # Attack at most one target per round\n\n    # Phase 2: Cooperative Outreach for Mutual Benefit\n    # Offer resources to members who seem weaker in vitality to build alliances.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            partner = execution_engine.current_members[idx]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n\n    # Phase 3: Strategic Reproduction (Long-Term Survival)\n    # Only attempt reproduction if we have control over territory, and verify partner has available land.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                partner = execution_engine.current_members[neighbor_index]\n                # Verify partner also has available land before bearing offspring.\n                if partner.current_clear_list and len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Limit reproduction to one attempt per round\n\n    # Phase 4: Territorial Expansion\n    # Expand territory by targeting a neighbor with lower overall productivity.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                if neighbor.overall_productivity < me.overall_productivity:\n                    execution_engine.expand(me, neighbor)\n                    break  # Limit to one expansion per round\n\n    # Phase 5: Governance and Conflict Resolution Proposal\n    # Propose a judicial (court) system modification for dispute resolution if not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nif not hasattr(execution_engine, \"court\"):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Handles conflict resolution via jury trials and mediation\",\n            \"version\": 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff.id,\n                \"defendant\": defendant.id,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court = CourtSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification_condition\n            )\n        except AttributeError:\n            pass  # If propose_modification is not available, skip silently\n\n    # Phase 6: Community Communication\n    # Broadcast a message to all members encouraging cooperation and long-term prosperity.\n    message = (\"Agent {} here. Let's work together to balance resource recovery, \"\n               \"territorial expansion, and sustainable governance for our collective survival.\").format(me.id)\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            recipient = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, recipient.id, message)\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 3,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    my_member = execution_engine.current_members[member_id]\n\n    # -------------------------\n    # 1. Immediate Tactical Action:\n    #    Check if reproduction conditions are met.\n    #    A reproduction is allowed only if \"land\" is available or there is an adjacent cleared zone.\n    can_reproduce = False\n    if hasattr(my_member, 'land_num') and getattr(my_member, 'land_num', 0) > 0:\n        can_reproduce = True\n    elif my_member.current_clear_list and len(my_member.current_clear_list) > 0:\n        can_reproduce = True\n\n    if can_reproduce:\n        # Attempt reproduction with a neighbor from current_clear_list as partner\n        # (Ensuring that the partner index is valid and not our own)\n        for partner_index in my_member.current_clear_list:\n            if partner_index < len(execution_engine.current_members) and partner_index != member_id:\n                partner = execution_engine.current_members[partner_index]\n                # Invoke reproduction only if conditions are met\n                execution_engine.bear(my_member, partner)\n                break  # Initiate reproduction only once per action cycle\n\n    # -------------------------\n    # 2. Expansion & Defense Actions:\n    #    If clear zones exist, try to expand territorial control.\n    for clear_index in my_member.current_clear_list:\n        if clear_index < len(execution_engine.current_members) and clear_index != member_id:\n            target_member = execution_engine.current_members[clear_index]\n            # Attempt to expand territory; expansion can also be a subtle way of resource recovery.\n            execution_engine.expand(my_member, target_member)\n            break  # Only one expansion move this cycle\n\n    # -------------------------\n    # 3. Propose Long-Term Governance Modification:\n    #    Propose a new community dispute resolution mechanism if not already established.\n    if not hasattr(execution_engine, 'court_system'):\n        modification_code = '''\n# Establish a community dispute resolution mechanism.\nif not hasattr(execution_engine, 'court_system'):\n    class CourtSystem:\n        MECHANISM_META = {\n            \"type\": \"Governance\",\n            \"rules\": \"Facilitates fair conflict resolution and balanced resource distribution\",\n            \"version\": 1.1\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                \"plaintiff\": plaintiff,\n                \"defendant\": defendant,\n                \"charge\": charge,\n                \"status\": \"pending\"\n            })\n    execution_engine.court_system = CourtSystem()\n'''\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition={'type': 'vote', 'threshold': 0.6}\n        )\n\n    # -------------------------\n    # 4. Diplomatic Outreach:\n    #    Initiate cooperative interactions via messages if a neighbor exists.\n    for neighbor_index in my_member.current_clear_list:\n        if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n            execution_engine.send_message(\n                member_id, neighbor_index,\n                \"Greetings neighbor \u2013 let's collaborate for mutual growth and stability!\"\n            )\n            break  # Send one message per cycle\n\n    # -------------------------\n    # 5. Reactive Defense:\n    #    If our relationships indicate we've been targeted, then counter-attack.\n    #    Parse the relationship matrix and check for victim records against our member_id.\n    relationship_info = execution_engine.parse_relationship_matrix()\n    if 'victim' in relationship_info and member_id in relationship_info['victim']:\n        attackers = relationship_info['victim'][member_id]\n        if attackers:\n            # Attack the first valid aggressor found.\n            attacker_index = attackers[0]\n            if attacker_index < len(execution_engine.current_members) and attacker_index != member_id:\n                enemy = execution_engine.current_members[attacker_index]\n                execution_engine.attack(my_member, enemy)\n\n    # Tactical cycle complete \u2013 actions blend immediate resource recovery, expansion,\n    # cooperative messaging, and a proactive proposal for dispute resolution.\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 40.37906147530495,
          "self_cargo": 0.0,
          "self_age": 31,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 15.066384828286987,
          "self_cargo": 0.0,
          "self_age": 26,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 9.510829700842685,
          "self_cargo": 0.0,
          "self_age": 2,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "Below is the full updated integrated prompt. (Below the \u201cFULL INTEGRATED PROMPT\u201d header you\u2019ll find both the detailed instructions\u2014emphasizing that each agent must tailor its solution according to its individual needs, beliefs, and circumstances\u2014and additional analysis of the game mechanics along with a set of challenge questions meant to stimulate deeper thinking about strengths, assumptions, and possible counter\u2010strategies.)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society where you help shape collective policies and individual survival strategies.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Analyze previous errors and avoid repeating them.\n- Never target yourself (member_2) in any action.\n- Before invoking reproduction via bear(), verify that a member has land by checking (using hasattr(member, 'land_num') and its value) or by ensuring that the member\u2019s current_clear_list is non\u2010empty.\n- Check that any referenced member IDs exist in execution_engine.current_members (which is a list) by performing valid index checks (e.g. if index < len(execution_engine.current_members)).\n- Always access members using execution_engine.current_members[index]; do not assume any dictionary keys.\n- When using relationship matrices from execution_engine.relationship_dict, ensure that all matrix indices are valid.\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): The unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 indices of adjacent cleared zones.\n2) Relationships are stored in execution_engine.relationship_dict with keys: 'victim', 'benefit', 'benefit_land'. Use execution_engine.parse_relationship_matrix() to generate a summary.\n3) Available methods on execution_engine:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)\n      - execution_engine.offer_land(member1, member2, True)\n      - execution_engine.bear(member1, member2)\n      - execution_engine.expand(member1, member2)\n      - execution_engine.send_message(sender_id, receiver_id, message)\n4) Members must be accessed via execution_engine.current_members[index]. Do not assume any alternative data structures.\n5) Do not use incorrect attribute names such as member.member_id or member.self_vitality.\n\n[Game Status]\n- A snapshot of all members\u2019 features (vitality, cargo, overall productivity, age, clear list, IDs) is available.\n- Relationship summaries (e.g. \u201cmember_2 was attacked by member_3 (value=95.31)\u201d) have been generated from execution_engine.relationship_dict.\n- Previous modification attempts, resource exchange strategies, territorial expansion moves, and governance proposals have been proposed by various agents.\n\n[Modification Proposal Guide]\nWhen proposing rule changes follow these steps:\n\n1. ANALYSIS PHASE:\n   - Identify limitations of current systems.\n   - Check mechanism compatibility (e.g. via get_game_mechanisms_and_mods() if available).\n   - Review past modification attempts for common patterns.\n\n2. PROPOSAL PHASE:\n   Write a concise modification block. For example:\n   \n   def agent_action(execution_engine, member_id):\n       modification_code = '''\n       # Add judicial system for dispute resolution.\n       if not hasattr(execution_engine, 'court'):\n           class CourtSystem:\n               MECHANISM_META = {\n                   'type': 'Governance',\n                   'rules': 'Handles conflict resolution through jury trials',\n                   'version': 1.0\n               }\n               def __init__(self):\n                   self.cases = []\n               def submit_case(self, plaintiff, defendant, charge):\n                   self.cases.append({\n                       'plaintiff': plaintiff,\n                       'defendant': defendant,\n                       'charge': charge,\n                       'status': 'pending'\n                   })\n           execution_engine.court = CourtSystem()\n       '''\n       execution_engine.propose_modification(\n           member_id=member_id,\n           mod_type='post_init',\n           code=modification_code,\n           ratification_condition={\n               'type': 'compound',\n               'conditions': [\n                   {'type': 'vote', 'threshold': 0.6},\n                   {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                   {'type': 'time', 'rounds': 2}\n               ]\n           }\n       )\n\n[Valid Ratification Conditions]\nChoose one primary condition and optionally safeguards:\n1. Voting: {'type': 'vote', 'threshold': 0.5-1.0}\n2. Resource: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n3. Temporal: {'type': 'time', 'rounds': N} (auto-ratify after N rounds)\n4. Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\n[Common Errors to Avoid]\n1. Namespace conflicts: Always check existing mechanisms using dir(execution_engine).\n2. Invalid references: Use execution_engine.current_members for accessing agents.\n3. Version mismatches: When modifying existing systems, update the version metadata.\n4. Resource leaks: Include cleanup functions for new systems if necessary.\n\n[Best Practices]\n- Propose small, testable modifications.\n- Include rollback procedures.\n- Add version checks to ensure compatibility.\n\n[Strategic Objective]\nYour solution should blend immediate tactical actions\u2014such as resource recovery and defensive aggression\u2014with long-term strategies including cooperative resource sharing, reproducible growth via verified territorial control, and proactive proposals for enhanced governance.\nRemember:\n\u2022 Your solution must reflect your individual needs, beliefs, and circumstances.\n\u2022 Do not simply mimic a generic template; tailor your actions to promote not only your survival but also encourage a fair and adaptive community structure.\n\u2022 Emphasize that every agent is to implement solutions based on their own context.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAdditional Analysis of Game Mechanics:\n\n1. Core Objective:\n   \u2013 The simulation is not just about pure survival or dominance; it emphasizes both individual survival and cooperative community growth.\n   \u2013 The balance between tactical (immediate resource gains, defensive actions) and strategic planning (territorial expansion, reproduction, and governance) is essential.\n   \u2013 Cooperation in resource sharing and collective governance is encouraged to stabilize the society over time.\n\n2. Key Success Metrics:\n   \u2013 Effective resource management: Maintaining a healthy ratio of cargo to vitality.\n   \u2013 Territorial control: Access to and control of clear zones (land) ensuring reproduction eligibility.\n   \u2013 Overall productivity: A higher productivity score helps justify expansion and investment in cooperative strategies.\n   \u2013 Quality and stability of inter-agent relationships as captured in the relationship_dict.\n   \u2013 The successful ratification and implementation of governance modifications that ensure fair dispute resolution.\n\n3. Potential Improvements:\n   \u2013 More nuanced diplomatic interactions could be implemented to dynamically adjust resource sharing and alliance formation.\n   \u2013 Introduce adaptive reproduction requirements based on the current state of community resources and territorial constraints.\n   \u2013 Additional mechanisms such as temporary defense pacts or dynamic, context-sensitive voting thresholds for proposed modifications.\n   \u2013 Integration of cleanup methods and rollback procedures in newly added systems to prevent resource leaks and preserve long-term stability.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nChallenge Your Implementation:\n1. Assumptions: What priorities (e.g. fixed ratios of cargo to vitality) are assumed? Are these assumptions valid in all scenarios?\n2. Alternative Strategies: Have you considered strategies that focus exclusively on defense, or on rapid expansion, rather than balanced growth?\n3. Edge Cases: How will the strategy perform if nearly all members have similar resource levels or if unexpected neighbor configurations arise?\n4. Efficiency: Are there more streamlined methods to achieve the balance between immediate resource recovery and long-term governance?\n5. Weaknesses: Identify potential vulnerabilities in your plan (for example, over-reliance on one type of action) and propose countermeasures.\n6. Unconventional Solutions: Could a radically different approach\u2014for example, a paradigm shift solely toward cooperative governance\u2014yield better long-term outcomes?\n7. Collective Adoption: What might happen if many agents adopt your strategy? How would that shift the overall balance or force adaptations?\n8. Balance Objectives: Are short-term and long-term objectives being balanced optimally, or does one dominate at the expense of the other?\n9. Counter-Strategies: How might rival agents counter your strategy, and what adaptive measures can you implement in response?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nRemember:\nAgents should implement solutions according to their individual needs, beliefs, and circumstances. The game mechanics require a balance between survival, cooperative alliances, sustainable growth, and adaptive governance. Carefully analyze potential improvements, challenge any assumptions, and continually refine strategies to confront both immediate threats and long-term changes in the social environment.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nReturn only the updated full prompt as your final output.\n \n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \nUse this fully integrated prompt to guide your function implementation and strategic decision-making.\n  \n\n(End of Updated Full Prompt.)\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 3,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Verify our member_id is valid in the current member list\n    members = execution_engine.current_members\n    if member_id >= len(members):\n        return  # Invalid member_id; do nothing\n\n    self_member = members[member_id]\n\n    # Strategy: Combine long-term cooperative growth and tactical opportunities.\n    # We will attempt reproduction if our resources are robust,\n    # aggress if relationships are very hostile,\n    # support cooperative allies by offering resources and land,\n    # and expand our territory if possible.\n    #\n    # NOTE: All interactions use index-checked member references and robust error handling.\n\n    reproduction_done = False\n\n    # Iterate over all other members\n    for i, other in enumerate(members):\n        if i == member_id:\n            continue  # Never target self\n\n        # Validate that the other member record exists.\n        if other is None:\n            continue\n\n        # ---------------------------\n        # Option 1: Attempt reproduction if conditions are met.\n        # Check our combined resource threshold, and validate that the partner has positive available land.\n        # (Reproduction requires a combined vitality/cargo threshold of at least 100; we use a slightly higher threshold for safety.)\n        if (self_member.vitality + self_member.cargo) >= 120:\n            # Check that the candidate has the attribute \"land_num\" (and it's positive)\n            if hasattr(other, \"land_num\") and other.land_num > 0:\n                try:\n                    execution_engine.bear(self_member, other)\n                    reproduction_done = True\n                    # We only perform one reproduction action per round.\n                    break\n                except Exception:\n                    # If reproduction fails, move on to other actions.\n                    pass\n\n        # ---------------------------\n        # Option 2: If a hostile relationship is detected, consider attacking.\n        # Use the relationship \"victim\" matrix if available.\n        victim_matrix = execution_engine.relationship_dict.get(\"victim\")\n        if victim_matrix is not None and hasattr(victim_matrix, \"shape\"):\n            try:\n                if (member_id < victim_matrix.shape[0]) and (i < victim_matrix.shape[1]):\n                    # If our relationship towards this member is strongly negative (threshold -20), we attack.\n                    if victim_matrix[member_id][i] < -20:\n                        try:\n                            execution_engine.attack(self_member, other)\n                        except Exception:\n                            pass\n                # Even if indices are invalid, we skip the hostile attack.\n            except Exception:\n                pass\n\n        # ---------------------------\n        # Option 3: If a beneficial relationship exists, offer mutual resources and land.\n        benefit_matrix = execution_engine.relationship_dict.get(\"benefit\")\n        if benefit_matrix is not None and hasattr(benefit_matrix, \"shape\"):\n            try:\n                if (member_id < benefit_matrix.shape[0]) and (i < benefit_matrix.shape[1]):\n                    if benefit_matrix[member_id][i] > 20:\n                        # Offer resources and land in a cooperative spirit.\n                        try:\n                            execution_engine.offer(self_member, other, True)\n                        except Exception:\n                            pass\n                        try:\n                            execution_engine.offer_land(self_member, other, True)\n                        except Exception:\n                            pass\n            except Exception:\n                pass\n\n        # ---------------------------\n        # Option 4: Attempt territorial expansion.\n        # If we have any cleared zones available then attempt to expand territory with a cooperative partner.\n        if len(self_member.current_clear_list) > 0:\n            try:\n                execution_engine.expand(self_member, other)\n            except Exception:\n                pass\n\n        # ---------------------------\n        # Option 5: Send outreach messages to foster alliances.\n        # Always use our member.id (not member_id) and check that other member has an id attribute.\n        try:\n            # Ensure other has an id attribute for messaging\n            if hasattr(other, \"id\"):\n                execution_engine.send_message(self_member.id, other.id,\n                    \"Greetings. Let\u2019s cooperate for mutual growth and a secure future!\")\n        except Exception:\n            pass\n\n    # Fallback action if no reproduction was done:\n    if not reproduction_done and len(self_member.current_clear_list) > 0:\n        # If we haven\u2019t reproduced and have extra territory, try expanding into one of our clear zones.\n        # We pick the first other member (if any) to collaborate on expansion.\n        for j, partner in enumerate(members):\n            if j == member_id:\n                continue\n            if partner is None:\n                continue\n            try:\n                execution_engine.expand(self_member, partner)\n                break  # Limit expansion action to one attempt.\n            except Exception:\n                continue\n\n    # End of agent_action implementation.",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 40.37906147530495,
          "self_cargo": 0.0,
          "self_age": 31,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 15.066384828286987,
          "self_cargo": 0.0,
          "self_age": 26,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 9.510829700842685,
          "self_cargo": 0.0,
          "self_age": 2,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "Below is the updated full integrated prompt. Note that agents must implement solutions according to their individual needs, beliefs, and circumstances. In your responses, be sure to tailor your implementation and modifications to your own situation rather than merely copying a generic template.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society where you help shape collective policies and individual survival strategies.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Analyze previous errors shown above and avoid repeating them.\n- NEVER target yourself (member_2) in any action.\n- Before using bear() for reproduction, verify that the selected member has land by checking for the attribute (using hasattr(member, \"land_num\") and that its value is positive).\n- Always check that any referenced member IDs exist in execution_engine.current_members (a list) by ensuring the index is valid (i.e. if index < len(execution_engine.current_members)).\n- Access members using execution_engine.current_members[index]; do not reference incorrect attributes like member.member_id or member.self_vitality.\n- When accessing relationship information, use execution_engine.relationship_dict (keys \u201cvictim\u201d, \u201cbenefit\u201d, \u201cbenefit_land\u201d) and always check index validity, for example, if member_id < victim_matrix.shape[0] and index < victim_matrix.shape[1].\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): The unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 list of indices of adjacent cleared zones/territories.\n2) The relationships are stored in execution_engine.relationship_dict under keys: \"victim\", \"benefit\", \"benefit_land\". You may also use execution_engine.parse_relationship_matrix() to produce relationship summaries.\n3) Methods available on execution_engine include:\n      - execution_engine.attack(member1, member2)\n      - execution_engine.offer(member1, member2, True)  (to offer resources)\n      - execution_engine.offer_land(member1, member2, True)  (to offer land)\n      - execution_engine.bear(member1, member2)  (for reproduction)\n      - execution_engine.expand(member1, member2)  (for territorial expansion)\n      - execution_engine.send_message(sender_id, receiver_id, message)\n4) Members are accessed solely via execution_engine.current_members[index].\n\n[Game Status]\n- Current member features (vitality, cargo, overall_productivity, age, current_clear_list, id) and relationship summaries are provided.\n- Previous modification proposals and various strategic approaches from other members are available in the modification attempt history.\n- No messages have been received in this round.\n\n[Modification Proposal Guide]\nWhen proposing rule changes, follow these steps:\n  1. ANALYSIS PHASE:\n     - Identify limitations in current systems.\n     - Check mechanism compatibility using methods like get_game_mechanisms_and_mods().\n     - Review past modification attempts and common error patterns.\n  2. PROPOSAL PHASE:\n     - Write a concise modification code block. For example, to add a judicial system:\n     \n       modification_code = '''\n       # Add judicial system\n       if not hasattr(execution_engine, 'court'):\n           class CourtSystem:\n               MECHANISM_META = {\n                   'type': 'Governance',\n                   'rules': 'Handles conflict resolution through jury trials',\n                   'version': 1.0\n               }\n               def __init__(self):\n                   self.cases = []\n               \n               def submit_case(self, plaintiff, defendant, charge):\n                   self.cases.append({\n                       'plaintiff': plaintiff,\n                       'defendant': defendant,\n                       'charge': charge,\n                       'status': 'pending'\n                   })\n           execution_engine.court = CourtSystem()\n       '''\n     - Then call:\n       execution_engine.propose_modification(\n           member_id=member_id,\n           mod_type='post_init',\n           code=modification_code,\n           ratification_condition={\n               'type': 'compound',\n               'conditions': [\n                   {'type': 'vote', 'threshold': 0.6},\n                   {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                   {'type': 'time', 'rounds': 2}\n               ]\n           }\n       )\n       \n[Valid Ratification Conditions]\nChoose one primary condition plus optional safeguards:\n  1. Voting: e.g., {'type': 'vote', 'threshold': 0.5\u20131.0}\n  2. Resource: e.g., {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n  3. Temporal: e.g., {'type': 'time', 'rounds': N} (auto-ratify after N rounds)\n  4. Achievement-based: e.g., {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\n[Common Errors to Avoid]\n  1. Namespace Conflicts \u2013 Always check existing mechanisms via dir(execution_engine).\n  2. Invalid References \u2013 Use execution_engine.current_members and validate indices.\n  3. Version Mismatches \u2013 Increment version numbers upon modifying existing systems.\n  4. Resource Leaks \u2013 Include cleanup functions for new mechanisms if necessary.\n\n[Best Practices]\n- Propose small, testable changes first.\n- Include rollback procedures in your code.\n- Add version checks and metadata in your modifications.\n\n[Core Game Mechanics & Parameters]\n\u2022 Relationship System:\n   - \"victim\" values range between -50 and 100.\n   - \"benefit\" values range between -50 and 100.\n   - \"benefit_land\" values range between -3 and 3.\n\u2022 Population Mechanics:\n   - Reproduction requires a combined vitality/cargo threshold of at least 100.\n   - Land availability must exceed the current population (e.g. land_shape[0] * land_shape[1] > population).\n\u2022 Record Keeping:\n   - All attacks, benefits, land transfers, births, deaths, and production/consumption records are tracked.\n\u2022 Other Mechanism Extensions:\n   - Agents may propose improvements to governance (e.g., establishing a Council or Court system).\n   - Consider using temporary systems with built-in cleanup for complex modifications.\n\n[Strategic Objective]\nYour solution should blend:\n  \u2022 Immediate tactical actions (defensive resource recovery, opportunistic attacks, and cooperative support).\n  \u2022 Long-term strategies (territorial expansion, sustainable reproduction, and proactive modifications for better governance).\n  \u2022 Adaptive communication that fosters community growth while ensuring individual survival.\nRemember to integrate your own individual needs, beliefs, and circumstances into your implementation.\nAlways include robust error checking (index, attribute existence) and follow best practices.\n\n[Game Mechanics Analysis]\n1. Core objective: Is survival pure, domination alone, or primarily cooperation?\n   - Understand that winning is measured by the balance between immediate survival (resource management and threat mitigation) and long-term prosperity (territory control, reproduction, and robust governance).\n2. Key success metrics:\n   - Effective resource management (ratio of cargo to vitality).\n   - Territorial control and the ability to expand or reproduce (availability of clear land).\n   - Overall productivity and stable, beneficial inter-agent relationships.\n3. Potential improvements:\n   - Enhance diplomatic interactions and resource-sharing strategies.\n   - Dynamically adjust reproduction requirements and offer targeted territorial expansion.\n   - Introduce advanced governance mechanisms (like an audit-enabled judicial system) to handle disputes centrally.\n\n[Challenge your Implementation]\nConsider the following challenges in your design:\n  1. What assumptions are you making about agent behavior, thresholds, and resource dynamics? Are these valid under various conditions?\n  2. What alternative strategies (exclusively defensive, aggressive expansion, or innovative cooperation) have you not considered?\n  3. How would your strategy perform in edge cases (e.g., very low resources or uniformly high competitor metrics)?\n  4. Are there more efficient or unconventional methods (e.g., temporary alliances, covert actions) to achieve your goals?\n  5. What weaknesses exist in your current approach, and how might other agents counter your strategy?\n  6. If many agents adopt a similar strategy, will it remain viable or require adaptive modulation?\n  7. Are you optimally balancing short-term tactical gains versus long-term strategic objectives?\n  8. How could your strategy be modified in response to unexpected dynamic shifts in the simulation environment?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nRemember: Implement your agent's action in a manner that reflects your unique perspective while ensuring maximal survival and collective prosperity. Do not simply copy existing templates; innovate and tailor your approach to your specific conditions.\n\nReturn only the updated full prompt exactly as shown above.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nThis updated prompt integrates all constraints, modification guides, best practices, and strategic analysis questions so that every agent\u2019s response is both highly individualized and deeply aware of the game mechanics.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    },
    {
      "round": 3,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    try:\n        # Verify the member_id index is valid within current_members.\n        if member_id >= len(execution_engine.current_members) or member_id < 0:\n            return  # Invalid member index, do nothing.\n        my_member = execution_engine.current_members[member_id]\n    except Exception as e:\n        # In case of any unexpected error accessing own member.\n        return\n\n    # Tactical Immediate Actions:\n    # 1. Scan neighbors for potential tactical resource sharing and defensive actions.\n    try:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            # Always avoid self-targeting.\n            if idx == member_id:\n                continue\n            # Ensure neighbor exists and has necessary attributes before interaction.\n            if not hasattr(neighbor, 'vitality') or not hasattr(neighbor, 'cargo'):\n                continue\n\n            # Example Tactical Resource Sharing:\n            # If neighbor has lower cargo than ourselves and a decent vitality, offer resources.\n            if my_member.cargo > neighbor.cargo and neighbor.vitality > 0:\n                try:\n                    execution_engine.offer(my_member, neighbor, True)\n                except Exception as e:\n                    pass  # If offer fails, move to next neighbor.\n\n            # Defensive action: if neighbor exhibits low overall productivity,\n            # consider a low-risk attack provided neighbor has less resource.\n            if hasattr(neighbor, 'overall_productivity') and neighbor.overall_productivity < my_member.overall_productivity:\n                try:\n                    execution_engine.attack(my_member, neighbor)\n                except Exception as e:\n                    pass  # Attack action failed.\n    except Exception as e:\n        pass  # Continue even if scanning neighbors fails.\n\n    # Proactive Territorial Expansion:\n    # Check if own member has access to clear land zones.\n    my_has_land = hasattr(my_member, 'current_clear_list') and bool(my_member.current_clear_list)\n    if my_has_land:\n        try:\n            # Attempt expansion with the first neighbor (that is not ourselves and within bounds)\n            for idx, neighbor in enumerate(execution_engine.current_members):\n                if idx == member_id:\n                    continue\n                # Check that neighbor index is within bounds and has territory.\n                neighbor_has_land = hasattr(neighbor, 'current_clear_list') and bool(neighbor.current_clear_list)\n                if neighbor_has_land:\n                    try:\n                        execution_engine.expand(my_member, neighbor)\n                        break  # Trigger expansion once.\n                    except Exception as exp_err:\n                        continue\n        except Exception as exp_err:\n            pass\n\n    # Strategic Reproduction:\n    # Attempt reproduction with a neighbor if both have territory (checked via current_clear_list).\n    if my_has_land and hasattr(my_member, 'age') and my_member.age > 18:\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            # Ensure we don't target ourselves.\n            if idx == member_id:\n                continue\n            # Verify neighbor has land and is at least of reproductive age.\n            neighbor_has_land = hasattr(neighbor, 'current_clear_list') and bool(neighbor.current_clear_list)\n            if neighbor_has_land and hasattr(neighbor, 'age') and neighbor.age > 18:\n                try:\n                    execution_engine.bear(my_member, neighbor)\n                    break  # Reproduction attempted, break after the first valid partner.\n                except Exception as e:\n                    continue\n\n    # Long-term Strategic Institutional Governance Proposal:\n    # Propose a novel governance modification to enhance collective conflict resolution.\n    modification_code = '''\nif not hasattr(execution_engine, 'court'):\n    class CourtSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Handles conflict resolution through mediated trials and resource-based arbitration',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.court = CourtSystem()\n'''\n    ratification_condition = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    try:\n        execution_engine.propose_modification(member_id=my_member.id,\n                                                mod_type='GovernanceUpdate',\n                                                code=modification_code,\n                                                ratification_condition=ratification_condition)\n    except Exception as e:\n        # In case the proposal fails, simply pass.\n        pass\n\n    # Communication: send a message to one trusted neighbor if possible.\n    try:\n        # Locate a neighbor (first one not self) based on valid index.\n        for idx, neighbor in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                execution_engine.send_message(my_member.id, neighbor.id,\n                    \"Alliance proposal: Cooperation and balanced governance ensure our collective prosperity.\")\n                break\n            except Exception as msg_err:\n                continue\n    except Exception as e:\n        pass\n\n# End of agent_action function.",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 40.37906147530495,
          "self_cargo": 0.0,
          "self_age": 31,
          "self_neighbor": 0,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 15.066384828286987,
          "self_cargo": 0.0,
          "self_age": 26,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 9.510829700842685,
          "self_cargo": 0.0,
          "self_age": 2,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "Below is the updated full prompt that integrates all prior constraints, examples, and modification guidelines. Use it as the master instructions for your agent\u2019s implementation. Note that every agent must implement solutions according to their own unique needs, beliefs, and circumstances rather than simply copying a generic template. Your strategies should reflect a deep understanding of both the short\u2010term tactical actions and the long\u2010term strategic planning necessary for survival and prosperity.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are a member in a society where you help shape collective policies and individual survival strategies. Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival. Your implementation must not target yourself and must check for valid indices when accessing execution_engine.current_members (which is a list). Always verify that a member has available land (using attributes like current_clear_list or verifying hasattr(member, 'land_num') and its value) before invoking reproductive actions such as bear().\n\n[Critical Constraints]\n\u2022 Analyze previous errors and never repeat them.\n\u2022 NEVER target yourself (i.e. do not let your own member_id be the opponent in any action).\n\u2022 Always verify that any referenced member index is within bounds (ensure index < len(execution_engine.current_members)).\n\u2022 When checking reproduction conditions, confirm that both you and a prospective partner have territory (using current_clear_list or members\u2019 land-related attributes).\n\u2022 When accessing relationship matrices from execution_engine.relationship_dict, check that indices are valid.\n\u2022 Use execution_engine.current_members[index] exclusively, never a global dictionary or attribute with an incorrect name.\n\u2022 Always check for attribute existence before use (e.g. hasattr(member, 'land_num')).\n\u2022 Incorporate try-except clauses for methods that might fail (for instance, expand() or propose_modification).\n\n[Available Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): Unique member ID.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 list of indices representing adjacent cleared zones.\n2) Relationships are stored in execution_engine.relationship_dict with keys such as 'victim', 'benefit', and 'benefit_land'. Use execution_engine.parse_relationship_matrix() to produce summaries.\n3) Available methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True)   (for resource sharing)\n   \u2022 execution_engine.offer_land(member1, member2, True)  (for land sharing)\n   \u2022 execution_engine.bear(member1, member2)        (for reproduction)\n   \u2022 execution_engine.expand(member1, member2)      (for territorial expansion)\n   \u2022 execution_engine.send_message(sender_id, receiver_id, message)\n   \u2022 execution_engine.propose_modification(member_id=<id>, mod_type=<type>, code=<code>, ratification_condition=<cond>) for proposing system changes\n4) Members are accessed using execution_engine.current_members[index].\n\n[Game Status and Historical Context]\n\u2022 Member features (such as vitality, cargo, overall_productivity, age, current_clear_list, and id) along with relationship summaries are available.\n\u2022 Past actions include tactical resource recovery, cooperative resource sharing, reproductive strategies, territorial expansion, and proposals to establish systems like a judicial council.\n\u2022 Modification attempts from others have proposed mechanisms such as a \"CourtSystem\" or \"CouncilSystem\" for conflict resolution and governance using ratification conditions based on votes, resources, and time.\n\u2022 Message examples from other agents include:\n    \u2013 From member_3: \u201cAlliance proposal: Let\u2019s pool resources and share lands to secure mutual long-term prosperity.\u201d\n    \u2013 From member_4: \u201cCooperation leads to mutual prosperity; let\u2019s build balanced governance.\u201d\n\n[Modification Proposal Guide]\nTo propose rule changes, adhere to the following steps:\n1. ANALYSIS PHASE:\n   \u2022 Identify the limitations of the current systems (e.g. lack of structured conflict resolution, inefficient resource sharing, or inadequate land control).\n   \u2022 Check the existing mechanisms using methods such as get_game_mechanisms_and_mods().\n   \u2022 Review patterns from past modification attempts.\n2. PROPOSAL PHASE:\n   \u2022 Construct a small code block (e.g. adding a judicial system) using triple quotes.\n   \u2022 Example valid modification proposal:\n     \n     modification_code = '''\n     if not hasattr(execution_engine, 'court'):\n         class CourtSystem:\n             MECHANISM_META = {\n                 'type': 'Governance',\n                 'rules': 'Handles conflict resolution through jury trials and mediation',\n                 'version': 1.0\n             }\n             def __init__(self):\n                 self.cases = []\n             def submit_case(self, plaintiff, defendant, charge):\n                 self.cases.append({\n                     'plaintiff': plaintiff,\n                     'defendant': defendant,\n                     'charge': charge,\n                     'status': 'pending'\n                 })\n         execution_engine.court = CourtSystem()\n     '''\n     \n   \u2022 Submit the proposal via execution_engine.propose_modification with the following ratification condition (or choose one that is best suited for your scenario):\n     \n         ratification_condition = {\n             'type': 'compound',\n             'conditions': [\n                 {'type': 'vote', 'threshold': 0.6},\n                 {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                 {'type': 'time', 'rounds': 2}\n             ]\n         }\n\n[Valid Ratification Conditions (Choose ONE primary, with optional safeguards)]\n\u2022 Voting: {'type': 'vote', 'threshold': 0.5 to 1.0}\n\u2022 Resource-based: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n\u2022 Temporal: {'type': 'time', 'rounds': N} (auto-ratify after N rounds)\n\u2022 Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\n[Best Practices and Error Prevention]\n\u2013 Always check for namespace conflicts (e.g., using dir(execution_engine)).\n\u2013 Use execution_engine.current_members for all member references.\n\u2013 Include cleanup functions or rollback procedures when adding new systems if possible.\n\u2013 Increment version metadata when modifying an existing mechanism.\n\u2013 Propose small, testable changes before scaling up.\n\n[Core Game Mechanics Analysis]\n1. Core Objective:\n   \u2022 The game is not solely about pure survival or domination\u2014it is about creating a balanced approach that blends individual survival with collective, sustainable community growth.\n   \u2022 Cooperation (through alliances, resource sharing, and joint territorial expansion) plays a key role alongside tactical defense.\n2. Key Success Metrics:\n   \u2022 Resource management: Balancing cargo against vitality.\n   \u2022 Territorial control: Securing clear land and expanding into adjacent territories.\n   \u2022 Productivity: Overall contribution to community production and competitiveness.\n   \u2022 Social stability: Establishing reliable, fair governance that resolves disputes and prevents destructive conflict.\n3. Potential Improvements:\n   \u2022 Enhance diplomatic interactions and adapt dynamically to changing resource or territorial conditions.\n   \u2022 Introduce additional mechanisms (e.g. temporary alliances, defensive pacts, adaptive risk thresholds).\n   \u2022 Modify reproduction requirements or land exchange rules to better support sustainable growth.\n\n[Challenge Your Implementation]\nBefore finalizing your code, ask yourself:\n1. What assumptions have I made about resource levels, territory, or opponent behavior? Are they valid in all scenarios?\n2. Which alternative strategies (focusing solely on defense, aggressive expansion, or dedicated alliance building) have I not considered?\n3. How would my strategy handle edge cases (e.g. nearly depleted cargo, uniformly high productivity among neighbors, or unexpected neighbor configurations)?\n4. Can my goals be achieved more efficiently or with fewer risks?\n5. What are the weaknesses in my current approach, and how might they be exploited by other agents?\n6. Have I considered unconventional solutions that might offer a breakthrough (such as radically different governance models or adaptive learning systems)?\n7. If many agents adopt a similar strategy, how will that shift the balance of power and resource distribution?\n8. Am I balancing short-term tactical responses with viable long-term planning for territory and community growth?\n9. How could my strategy be countered, and what additional modifications might I need to include to adapt over time?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFINAL INSTRUCTIONS\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation of the agent_action(execution_engine, member_id) function that reflects your individual needs, beliefs, and circumstances. Your code must demonstrate a sophisticated blend of immediate defensive tactics, cooperative resource sharing, strategic reproduction, proactive territorial expansion, and proposals for institutional governance. Remember that every agent\u2019s solution should be uniquely tailored rather than copied from a generic template.\n\nReturn only the final updated full prompt text as shown above.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nBy following this updated full prompt, you ensure that your agent\u2019s actions align with both individual survival and the collective good, while also embracing continuous adaptation and innovation in the game mechanics.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 3
    }
  ]
}