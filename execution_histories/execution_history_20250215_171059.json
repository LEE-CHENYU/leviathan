{
  "rounds": [
    {
      "timestamp": "2025-02-15T16:57:15.855731",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Verify that member_id is a valid index in the current_members list.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our own member object.\n    me = execution_engine.current_members[member_id]\n\n    # ------------------------------------------------------------------\n    # Strategy Overview:\n    # This agent prioritizes survival while enabling cooperative as well as\n    # competitive actions based on the state of resources, vitality, and\n    # relationships. The strategic considerations include:\n    # 1. Resource optimization against potential threats.\n    # 2. Reproduction and territory expansion when vitality is high.\n    # 3. Coalition building by offering resources and land to weaker neighbors.\n    # 4. Tactical attack against members with high cargo or productivity when\n    #    necessary.\n    # All actions are carried out after careful index checking and ensuring that\n    # we never target ourselves (member with id matching me.id).\n    # ------------------------------------------------------------------\n\n    # ------------------------------------------------------------------\n    # Phase 1: Emergency Resource Management.\n    # If our cargo is less than half of our vitality, we are in urgent need of resources.\n    # Look for a member that holds significantly more cargo and launch an attack.\n    # ------------------------------------------------------------------\n    if me.cargo < me.vitality * 0.5:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if candidate.id == me.id:\n                continue  # Skip ourselves.\n            # Verify candidate index is in range (idx is provided by enumeration already).\n            if candidate.cargo > me.cargo:\n                execution_engine.attack(me, candidate)\n                return  # Execute only one action per turn.\n\n    # ------------------------------------------------------------------\n    # Phase 2: Reproduction and Territory Expansion.\n    # When our vitality is robust, we consider growing our community or expanding territory.\n    # We attempt to bear offspring with a neighbor if the neighbor appears stable (has land).\n    # If no suitable reproduction partner is available, we try expanding territory with a neighbor.\n    # ------------------------------------------------------------------\n    if me.vitality > 60:\n        # Look through our clear (neighbor) list for a potential partner.\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_id]\n                if partner.id == me.id:\n                    continue  # Do not consider ourselves.\n                # Check if partner appears to have territory (assuming an attribute owned_land exists\n                # and is a list representing land holdings).\n                if hasattr(partner, 'owned_land') and isinstance(partner.owned_land, list) and len(partner.owned_land) > 0:\n                    execution_engine.bear(me, partner)\n                    return\n        # If reproduction is not possible, try to expand our territory instead.\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_id]\n                if partner.id == me.id:\n                    continue\n                execution_engine.expand(me, partner)\n                return\n\n    # ------------------------------------------------------------------\n    # Phase 3: Cooperative Alliance Building.\n    # Offering resources to weaker members (low vitality) can help build alliances.\n    # Such alliances might improve our long-term survival and foster beneficial relationships.\n    # ------------------------------------------------------------------\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.vitality < 40:\n            execution_engine.offer(me, candidate, True)\n            return\n\n    # ------------------------------------------------------------------\n    # Phase 4: Land-based Alliance Building.\n    # If no other action has triggered, consider offering land to a neighbor.\n    # This may foster long-term teamwork and mutual security.\n    # ------------------------------------------------------------------\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members):\n            neighbor = execution_engine.current_members[neighbor_id]\n            if neighbor.id == me.id:\n                continue\n            execution_engine.offer_land(me, neighbor, True)\n            return\n\n    # ------------------------------------------------------------------\n    # Phase 5: Tactical Attack for Competitive Advantage.\n    # As a final fallback or when other strategies do not apply,\n    # we scan for a member with high overall productivity, which may represent either\n    # a threat to be neutralized or a resource hub to target.\n    # ------------------------------------------------------------------\n    best_candidate = None\n    best_productivity = -1\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.overall_productivity > best_productivity:\n            best_productivity = candidate.overall_productivity\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        execution_engine.attack(me, best_candidate)\n        return\n\n    # If no action is taken by the above strategies, do nothing.\n    return",
          "old_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 211.4882297132785
          },
          "new_stats": {
            "vitality": 73.85382847590404,
            "cargo": 10.103160221837875,
            "survival_chance": 178.07861864797445
          },
          "performance_change": -33.40961106530406,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Check if the provided member index is valid\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # PART 1: Cooperative Engagement & Resource Sharing\n    # When our cargo reserves are abundant and vitality robust,\n    # we prioritize sharing resources and uniting with allies.\n    for i in range(num_members):\n        if i == member_id:\n            continue  # Skip self-reference\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            # If I have strong cargo and better vitality than the partner,\n            # extend a resource offer to support group resilience.\n            if me.cargo > 50 and partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n            # Broadcast an optimistic message emphasizing our joint potential.\n            execution_engine.send_message(me.id, partner.id,\n                \"A united front builds the future. Let's exchange strengths for shared success!\")\n\n    # PART 2: Defensive Posture & Retaliation Strategy\n    # Analyze historical attacks to decide if retaliation is warranted.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            if j < len(execution_engine.current_members):\n                # If a peer has inflicted heavy losses, plan a counter-attack.\n                if victim_matrix[member_id][j] > 500.0:\n                    execution_engine.attack(me, execution_engine.current_members[j])\n\n    # PART 3: Strategic Reproduction & Long-Term Expansion\n    # Seek reproduction partnerships only with members showing solid productivity.\n    for i in range(num_members):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            candidate = execution_engine.current_members[i]\n            # Choose only partners that can contribute significantly to our genetic pool.\n            if candidate.overall_productivity > 7.0:\n                execution_engine.bear(me, candidate)\n\n    # Expand territory cautiously when both productivity and resources are elevated.\n    if me.overall_productivity > 10.0 and me.cargo > 50:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                # Expand our territory and secure areas adjacent to a neighbor.\n                execution_engine.expand(me, execution_engine.current_members[i])\n                break  # Expand only once per turn\n\n    # PART 4: Survival-Centric Tactics & Resource Optimization\n    # If cargo levels slip below half of our vitality, launch an aggressive resource grab.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[i]\n                if opponent.cargo > me.cargo:\n                    execution_engine.attack(me, opponent)\n\n    # Issue caution if vitality is dangerously low.\n    if me.vitality < 30:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, execution_engine.current_members[i].id,\n                    \"Vitality low\u2014steer clear of unnecessary confrontation.\")\n\n    # PART 5: Collective Strategic Messaging\n    # Promote long-term communal success and resource pooling.\n    for j in range(num_members):\n        if j != member_id and j < len(execution_engine.current_members):\n            execution_engine.send_message(me.id, execution_engine.current_members[j].id,\n                \"Pooling our resources today means stronger survival tomorrow.\")\n\n    # PART 6: Adaptive Decision-Making Using Survival Q-Learning\n    # If not already initialized, define a simple Q-learning dictionary to track survival strategies.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Define current state in terms of coarse-grained vitality and cargo levels.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    # Consider possible actions: 'attack', 'defend', or 'hoard'\n    actions = ['attack', 'defend', 'hoard']\n    # Pick best action from prior experience, defaulting to 0 value if untried.\n    best_action = max(actions, key=lambda action: me.survival_q.get((state, action), 0))\n\n    if best_action == 'attack':\n        # Seek an opponent with more cargo to diminish their advantage.\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                target = execution_engine.current_members[i]\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n                    # Reward the decision based on our current vitality as an estimator.\n                    me.survival_q[(state, 'attack')] += me.vitality * 0.1\n                    break\n    elif best_action == 'hoard':\n        # Secure additional resources in a non-confrontational manner by offering land.\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                ally = execution_engine.current_members[i]\n                execution_engine.offer_land(me, ally, True)\n                me.survival_q[(state, 'hoard')] += 5.0\n                break\n    else:\n        # 'defend' option: continue current tactics and preserve current state.\n        pass\n\n    # End of agent_action implementation.\n    return",
          "old_stats": {
            "vitality": 33.02781433323713,
            "cargo": 47.25322455383092,
            "survival_chance": -168.37590421103113
          },
          "new_stats": {
            "vitality": 33.02781433323713,
            "cargo": 16.387136388263876,
            "survival_chance": -199.24199237659818
          },
          "performance_change": -30.86608816556705,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def custom_agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid within the current members list\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our agent's identity and state\n    me = execution_engine.current_members[member_id]\n\n    # Load critical relationship matrices for decision-making\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    # benefit_land can be used if territorial dynamics come into play:\n    # benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land')\n\n    # ----------- Collective Communications and Moral Persuasion -----------\n    # I believe that honest dialogue can foster both individual survival and community prosperity.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            # Using an encouraging tone to bridge differences\n            execution_engine.send_message(member_id, idx,\n                \"In our shared struggle, united minds and hearts pave the way for a brighter future.\")\n\n    # ----------- Alliance Identification via Beneficial History -----------\n    # Analyze the benefit matrix and select allies with whom past cooperation was fruitful.\n    allies = []\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and benefit_matrix[member_id][idx] > 0:\n            allies.append(idx)\n\n    # ----------- Immediate Resource Preservation and Defensive Operations -----------\n    # Should my cargo resources fall below a protective threshold, preemptively counter adversaries\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                # Consider attacking if enemy's cargo signifies a potential hidden threat\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n\n    # ----------- Establishing Trust-Based Support Mechanisms -----------\n    # Offer direct support to recognized allies to enrich mutual collaboration\n    for ally_idx in allies:\n        # Safety check: avoid mis-targeting self in case of anomalies\n        if ally_idx < len(execution_engine.current_members):\n            ally = execution_engine.current_members[ally_idx]\n            if ally.id != me.id:\n                execution_engine.offer(me, ally, True)\n                # As territorial harmony might bolster defense, consider land offers if applicable:\n                # execution_engine.offer_land(me, ally, True)\n\n    # ----------- Long-Term Territorial Expansion Strategy -----------\n    # If there is a surplus of cargo, work to expand territories which may yield long-term benefits.\n    if me.cargo > 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n\n    # ----------- Cooperative Reproduction for Future Robustness -----------\n    # Procreate only when secure resources (cargo and clear land) exist and alliances are stable.\n    if me.cargo > 45 and me.current_clear_list and allies:\n        partner_idx = allies[0]\n        if partner_idx < len(execution_engine.current_members):\n            partner = execution_engine.current_members[partner_idx]\n            if partner.id != me.id:\n                execution_engine.bear(me, partner)\n\n    # ----------- Retaliation Against Direct Vitality Attacks -----------\n    # Should any agent have inflicted severe detriments (vitality loss >500), return measured force.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and victim_matrix[member_id][idx] > 500:\n            target = execution_engine.current_members[idx]\n            execution_engine.attack(me, target)\n\n    # ----------- Adaptive Survival via Q-Learning Inspired Feedback -----------\n    # I value learning from our encounters and evolving tactics. For this, we maintain a survival Q-structure.\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n    # Define the current state using discretized measures of vitality and cargo\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    candidate_actions = ['attack', 'offer', 'expand']\n\n    # Choose the action with the highest expected reward, defaulting to supportive 'offer'\n    best_action = max(candidate_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if best_action == 'attack':\n        # When choosing to attack, focus on opponents with clearly superior vitality metrics\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                if target.vitality > me.vitality * 1.1:\n                    execution_engine.attack(me, target)\n    elif best_action == 'expand':\n        # Further territorial expansion is attempted if the opportunity presents itself\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n    # The 'offer' action is already characterized by cooperative support earlier\n\n    # ----------- Personal and Collective Strategy Recap -----------\n    # Core principles guiding this agent:\n    # 1. The balance of assertiveness and cooperation: protect self resistance while forging communal bonds.\n    # 2. Resource and territory growth: invest in both immediate safety measures and long-term prosperity.\n    # 3. Evolving tactics using reinforcement signals: adapt actions based on historical interactions and outcomes.\n    # 4. Mutual trust and alliance: act decisively when beneficial for both myself and observed allies.\n    #\n    # These methods reflect my deeply held belief that sustainable success stems from both self-reliance and a collective, adaptive spirit.\n\n    return",
          "old_stats": {
            "vitality": 42.15604281108604,
            "cargo": 16.755399949672007,
            "survival_chance": -160.71410504202302
          },
          "new_stats": {
            "vitality": 42.15604281108604,
            "cargo": 16.755399949672007,
            "survival_chance": -160.71410504202302
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure member_id is in range.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    n_members = len(execution_engine.current_members)\n\n    # Retrieve relationship matrices.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land')\n\n    # We'll record if any action has been taken in this round.\n    action_performed = False\n\n    # ----------------------------------------------------------------\n    # I. Critical Survival Phase:\n    # If cargo is very low compared to vitality, try to reduce threats immediately.\n    # Here, choose as target the most productive opponent who also outranks us.\n    if me.cargo < (0.5 * me.vitality):\n        target = None\n        highest_productivity = -1\n        for i in range(n_members):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo and other.overall_productivity > highest_productivity:\n                highest_productivity = other.overall_productivity\n                target = other\n        if target is not None:\n            # Attack is seen as a defensive counter-measure.\n            execution_engine.attack(me, target)\n            action_performed = True\n\n    # ----------------------------------------------------------------\n    # II. Alliance & Cooperation:\n    # When stable, try to form alliances with neighbors that seem less robust.\n    if not action_performed:\n        ally_candidate = None\n        for i in range(n_members):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Prioritize those with lower vitality but with some potential (cargo not too low)\n            if other.vitality < me.vitality and other.cargo > 0.2 * other.vitality:\n                ally_candidate = other\n                break\n\n        if ally_candidate:\n            # Offer support as a trade-off for future cooperation.\n            execution_engine.offer(me, ally_candidate, offer_resource=True)\n            action_performed = True\n\n    # ----------------------------------------------------------------\n    # III. Propagation & Network Building:\n    # If I have secured land (non-empty clear list) and enough cargo,\n    # consider reproduction to ensure a future network of support.\n    if not action_performed and me.current_clear_list and me.cargo > 20:\n        # Look for a neighbor partner in the available clear list that is not self.\n        found_partner = False\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id != member_id and neighbor_id < n_members:\n                partner = execution_engine.current_members[neighbor_id]\n                # We prefer a partner whose overall productivity is somewhat comparable.\n                if abs(partner.overall_productivity - me.overall_productivity) < 20:\n                    execution_engine.bear(me, partner)\n                    found_partner = True\n                    action_performed = True\n                    break\n        # If no ideal partner, still attempt reproduction with the first valid neighbor.\n        if not found_partner:\n            for neighbor_id in me.current_clear_list:\n                if neighbor_id != member_id and neighbor_id < n_members:\n                    partner = execution_engine.current_members[neighbor_id]\n                    execution_engine.bear(me, partner)\n                    action_performed = True\n                    break\n\n    # ----------------------------------------------------------------\n    # IV. Territorial Expansion:\n    # If no other action has been taken, attempt to expand territory strategically.\n    if not action_performed:\n        # Rather than just picking the first neighbor, scan neighbors to see how many benefits land has.\n        best_neighbor = None\n        max_land_benefit = -float('inf')\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id != member_id and neighbor_id < n_members:\n                neighbor = execution_engine.current_members[neighbor_id]\n                # Evaluate potential benefit: consider benefit_land_matrix if available.\n                if benefit_land_matrix:\n                    bonus = benefit_land_matrix[member_id][neighbor_id] if member_id < len(benefit_land_matrix) and neighbor_id < len(benefit_land_matrix[member_id]) else 0\n                else:\n                    bonus = 0\n                if bonus > max_land_benefit:\n                    max_land_benefit = bonus\n                    best_neighbor = neighbor\n        if best_neighbor is not None:\n            execution_engine.expand(me, best_neighbor)\n            action_performed = True\n\n    # ----------------------------------------------------------------\n    # V. Long-Term Strategy: Broadcast a cooperative and strategic message.\n    # Regardless of individual action, promote a network of mutual survival.\n    for i in range(n_members):\n        if i == member_id:\n            continue\n        # Message dynamically crafted to indicate both readiness for support and collective prosperity.\n        msg = (\"I believe in mutual strength. Let\u2019s collaborate, share resources, and secure a prosperous future together!\")\n        execution_engine.send_message(member_id, i, msg)",
          "old_stats": {
            "vitality": 18.47747982181767,
            "cargo": 19.385010901474637,
            "survival_chance": -165.772536574679
          },
          "new_stats": {
            "vitality": 18.47747982181767,
            "cargo": 19.385010901474637,
            "survival_chance": -165.772536574679
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [
            "From member_1: A united front builds the future. Let's exchange strengths for shared success!",
            "From member_3: I believe in mutual strength. Let\u2019s collaborate, share resources, and secure a prosperous future together!"
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_1: A united front builds the future. Let's exchange strengths for shared success!"
          ],
          "sent": []
        }
      }
    },
    {
      "timestamp": "2025-02-15T17:05:52.357208",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Verify member_id is valid.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Priority 1: Resource Alert & Tactical Intervention.\n    # When resources are low relative to vitality, aggressively seek to capture resources from those more loaded.\n    if me.cargo < me.vitality * 0.5:\n        for candidate in execution_engine.current_members:\n            if candidate.id == me.id:\n                continue\n            if candidate.cargo > me.cargo:\n                # Aggressive tactic: attack an opponent who seems to have a resource advantage.\n                execution_engine.attack(me, candidate)\n                return\n\n    # Priority 2: Reproduction and Community Strengthening.\n    # When vitality is robust, aim for long-term prosperity via reproduction and territorial expansion.\n    # First, try to identify a neighbor with owned land for a cooperative offspring bearing.\n    if me.vitality > 65:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_index]\n                if partner.id == me.id:\n                    continue\n                if (hasattr(partner, 'owned_land') and isinstance(partner.owned_land, list)\n                        and len(partner.owned_land) > 0):\n                    execution_engine.bear(me, partner)\n                    return\n        # If no suitable partner for reproduction is found, attempt to expand territory.\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_index]\n                if partner.id == me.id:\n                    continue\n                execution_engine.expand(me, partner)\n                return\n\n    # Priority 3: Cooperative Alliance Formation.\n    # Identify members in need (vitality below 40) and extend an offer of mutual support while sending an encouraging message.\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.vitality < 40:\n            execution_engine.offer(me, candidate, True)\n            execution_engine.send_message(me.id, candidate.id, \"Our strength grows with unity\u2014let's support one another!\")\n            return\n\n    # Priority 4: Land-based Partnership.\n    # Build long-term alliances by offering land to neighbors who already manage land, reinforcing strategic collaboration.\n    for neighbor_index in me.current_clear_list:\n        if neighbor_index < len(execution_engine.current_members):\n            neighbor = execution_engine.current_members[neighbor_index]\n            if neighbor.id == me.id:\n                continue\n            if (hasattr(neighbor, 'owned_land') and isinstance(neighbor.owned_land, list)\n                    and len(neighbor.owned_land) > 0):\n                execution_engine.offer_land(me, neighbor, True)\n                execution_engine.send_message(me.id, neighbor.id,\n                    \"By sharing our territory, we create a foundation for lasting prosperity.\")\n                return\n\n    # Priority 5: Adaptive Self-Preservation.\n    # If overextended with land holdings while vitality is low, consider streamlining resources.\n    if (hasattr(me, 'owned_land') and isinstance(me.owned_land, list)\n            and len(me.owned_land) > 2 and me.vitality < 50):\n        # If the engine provides a mechanism to discard excess land, consider using it here.\n        # Example (if available):\n        # execution_engine.discard_land(me, me.owned_land[-1])\n        pass\n\n    # Priority 6: Tactical Offensive for Competitive Advantage.\n    # When no cooperative measures or self-growth actions are applicable, target the member with the highest overall productivity.\n    best_candidate = None\n    highest_productivity = -1\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.overall_productivity > highest_productivity:\n            highest_productivity = candidate.overall_productivity\n            best_candidate = candidate\n    if best_candidate is not None:\n        execution_engine.attack(me, best_candidate)\n        return\n\n    # Default: If no action qualifies, remain passive.\n    return",
          "old_stats": {
            "vitality": 30.751697069362137,
            "cargo": 0.0,
            "survival_chance": 124.97332701959468
          },
          "new_stats": {
            "vitality": 30.751697069362137,
            "cargo": 0.0,
            "survival_chance": 124.97332701959468
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure that the agent index is valid.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # PART 1: Cooperative Enhancement & Alliance Formation\n    # With robust cargo and high vitality, extend offers to other agents.\n    for other in range(num_members):\n        if other == member_id:\n            continue\n        partner = execution_engine.current_members[other]\n        if me.cargo > 60 and me.vitality > partner.vitality:\n            execution_engine.offer(me, partner, True)\n            execution_engine.send_message(me.id, partner.id,\n                \"Our combined strengths can reshape the struggle\u2014join forces with me!\")\n\n    # PART 2: Defensive Countermeasures & Retaliation Strategy\n    # Use our victim matrix to retaliate against members who imposed heavy losses.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            if victim_matrix[member_id][other] > 400.0:\n                execution_engine.attack(me, execution_engine.current_members[other])\n\n    # PART 3: Strategic Reproduction & Territorial Expansion\n    # Only attempt reproduction if we have control over land.\n    if me.current_clear_list:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            candidate = execution_engine.current_members[other]\n            if candidate.overall_productivity > 7.5:\n                execution_engine.bear(me, candidate)\n    # Expand territory if our overall productivity and cargo are strong.\n    if me.overall_productivity > 12.0 and me.cargo > 60:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            execution_engine.expand(me, execution_engine.current_members[other])\n            break  # Limit to a single expansion action per turn.\n\n    # PART 4: Survival Tactics & Resource Optimization\n    # When cargo is below ~55% of vitality, target opponents with higher cargos.\n    if me.cargo < me.vitality * 0.55:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            opponent = execution_engine.current_members[other]\n            if opponent.cargo > me.cargo:\n                execution_engine.attack(me, opponent)\n    # Issue a caution message if our vitality drops to a dangerous level.\n    if me.vitality < 35:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            execution_engine.send_message(me.id, execution_engine.current_members[other].id,\n                \"Vitality is low\u2014exercise utmost caution in your maneuvers.\")\n\n    # PART 5: Collective Strategic Messaging\n    # Broadcast messages advocating for resource pooling to bolster our collective resilience.\n    for other in range(num_members):\n        if other != member_id:\n            execution_engine.send_message(me.id, execution_engine.current_members[other].id,\n                \"Pooling our resources secures a stronger future for us all.\")\n\n    # PART 6: Adaptive Decision-Making Using Survival Q-Learning\n    # Initialize our Q-learning tracking if it does not already exist.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    # Define a coarse state using normalized levels of vitality and cargo.\n    state = (int(me.vitality // 25), int(me.cargo // 25))\n    actions = ['attack', 'defend', 'hoard']\n    best_action = max(actions, key=lambda action: me.survival_q.get((state, action), 0))\n\n    if best_action == 'attack':\n        # Identify an opponent with the highest cargo advantage.\n        target = None\n        max_cargo = 0\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            opponent = execution_engine.current_members[other]\n            if opponent.cargo > max_cargo:\n                max_cargo = opponent.cargo\n                target = opponent\n        if target is not None:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, 'attack')] += me.vitality * 0.1\n    elif best_action == 'hoard':\n        # When hoarding, use our land advantage to secure additional resources.\n        if me.current_clear_list:\n            for other in range(num_members):\n                if other == member_id:\n                    continue\n                ally = execution_engine.current_members[other]\n                execution_engine.offer_land(me, ally, True)\n                me.survival_q[(state, 'hoard')] += 7.0\n                break\n    else:  # 'defend' option does not prompt aggressive actions.\n        me.survival_q[(state, 'defend')] += 2.0\n        # For defensive posture, we can also send a self-reflection message.\n        execution_engine.send_message(me.id, me.id, \"Holding defensive stance\u2014evaluating next moves.\")\n\n    # Overall, this implementation reflects my belief in balancing short-term survival with long-term collective prosperity.\n    # It prioritizes adaptive tactics, resource optimization, and strategic alliance-building to ensure that both\n    # immediate needs and future expansions are addressed in a dynamic game environment.\n\n    return",
          "old_stats": {
            "vitality": 17.24266474021224,
            "cargo": 0.0,
            "survival_chance": -231.41427835788696
          },
          "new_stats": {
            "vitality": 17.24266474021224,
            "cargo": 0.0,
            "survival_chance": -231.41427835788696
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid in the current members list\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Load relationship matrices\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    # benefit_land may be used for territorial interactions if needed\n\n    num_members = len(execution_engine.current_members)\n\n    # Send a cooperative broadcast message (avoid targeting self)\n    for idx in range(num_members):\n        if idx != member_id:\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                \"Collaboration strengthens us all. Let's focus on mutual wellbeing.\")\n\n    # Build a list of allies based on beneficial history (positive benefit received)\n    allies = []\n    for idx in range(num_members):\n        if idx != member_id and benefit_matrix[member_id][idx] > 0:\n            allies.append(idx)\n\n    # Emergency threat response:\n    # If cargo is less than half of vitality, search for opponents with higher cargo\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            target = execution_engine.current_members[idx]\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n\n    # Offer support to allies by sending resources\n    for ally_idx in allies:\n        if ally_idx < num_members:\n            ally = execution_engine.current_members[ally_idx]\n            if ally.id != me.id:\n                execution_engine.offer(me, ally, True)\n                # Optionally offer land if our own land (current_clear_list) is available\n                if me.current_clear_list:\n                    execution_engine.offer_land(me, ally, True)\n\n    # Territory expansion if surplus resources\n    if me.cargo > 40:\n        for idx in range(num_members):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n\n    # Reproduction: only bear offspring if both:\n    # 1) We have clear land (current_clear_list is not empty)\n    # 2) We have enough resources (cargo threshold)\n    # 3) At least one ally who is not us is available and also has land available\n    if me.cargo > 45 and me.current_clear_list:\n        for ally_idx in allies:\n            if ally_idx < num_members:\n                partner = execution_engine.current_members[ally_idx]\n                if partner.id != me.id and partner.current_clear_list:\n                    execution_engine.bear(me, partner)\n                    break  # Only reproduce once in a round\n\n    # Retaliate against any member who has inflicted heavy vitality loss (>500)\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        if victim_matrix[member_id][idx] > 500:\n            target = execution_engine.current_members[idx]\n            execution_engine.attack(me, target)\n\n    # Adaptive survival strategy with lightweight Q-learning like approach\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n\n    # Define state as discrete buckets of vitality and cargo\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'expand', 'offer']\n\n    # Retrieve Q value for each action (default 0 if not present)\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute additional actions based on the chosen survival strategy\n    if best_action == 'attack':\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            target = execution_engine.current_members[idx]\n            # Attack those with significantly higher vitality\n            if target.vitality > me.vitality * 1.1:\n                execution_engine.attack(me, target)\n    elif best_action == 'expand':\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            target = execution_engine.current_members[idx]\n            execution_engine.expand(me, target)\n    # Default 'offer' action already covered above via support to allies\n\n    # Update survival Q-values in simple manner (simulate learning)\n    # For simplicity, assume that every action taken improves expected survival by a small factor\n    me.survival_q[(state, best_action)] = me.survival_q.get((state, best_action), 0) + (me.vitality * 0.05)\n\n    return",
          "old_stats": {
            "vitality": 39.583279492357846,
            "cargo": 0.0,
            "survival_chance": -181.1899769145582
          },
          "new_stats": {
            "vitality": 39.583279492357846,
            "cargo": 0.0,
            "survival_chance": -181.1899769145582
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # First check that member_id index exists in current_members\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    self_member = execution_engine.current_members[member_id]\n\n    # Retrieve relationship matrices with careful index references\n    victim_matrix = execution_engine.relationship_dict['victim']\n    benefit_matrix = execution_engine.relationship_dict['benefit']\n    # benefit_land may or may not be present; if not, we set it to None.\n    benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land', None)\n\n    #################################################################\n    # Strategy Step 1: Immediate Defensive Maneuvers if Vitality is Low\n    #\n    # If our vitality is low, identify the member who has inflicted the greatest attack damage.\n    # Do not target self. Ensure all indices are valid.\n    critical_vitality = 25.0  # threshold for taking defensive measures\n    if self_member.vitality < critical_vitality:\n        max_threat = 0.0\n        threat_index = None\n        # Scan through all other members\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            # Make sure index i is valid\n            if i < len(execution_engine.current_members):\n                # victim_matrix[member_id, i] gives how much vitality I lost from i's actions.\n                threat_value = victim_matrix[member_id, i]\n                # We consider larger positive values as indicative of a bigger threat.\n                if threat_value > max_threat:\n                    max_threat = threat_value\n                    threat_index = i\n        # If we have identified a threat, attack that member.\n        if threat_index is not None and threat_index < len(execution_engine.current_members):\n            target_member = execution_engine.current_members[threat_index]\n            # Execute a defensive attack\n            execution_engine.attack(self_member, target_member)\n\n    #################################################################\n    # Strategy Step 2: Alliance Formation via Resource Offers\n    #\n    # Offer resources to members who have been generous towards us (benefit_matrix value above a threshold).\n    # Record these members as potential allies for future coordination.\n    ally_threshold = 100.0  # Arbitrary threshold for meaningful benefit\n    allies = []\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            # benefit_matrix[member_id, i] reflects the benefit offered to us by member i.\n            if benefit_matrix[member_id, i] > ally_threshold:\n                partner = execution_engine.current_members[i]\n                execution_engine.offer(self_member, partner, True)\n                allies.append(i)\n\n    #################################################################\n    # Strategy Step 3: Reproduction (Bearing Offspring) if Land is Available\n    #\n    # We only attempt to bear offspring if we have cleared land.\n    # Loop over our current_clear_list and check that each neighbor ID exists and is not ourself.\n    if self_member.current_clear_list and len(self_member.current_clear_list) > 0:\n        for nbr_id in self_member.current_clear_list:\n            # Do not choose ourselves as a partner.\n            if nbr_id == member_id:\n                continue\n            # Verify that the neighbor index exists in current_members.\n            if nbr_id < len(execution_engine.current_members):\n                partner = execution_engine.current_members[nbr_id]\n                # Only attempt reproduction if both parties seem resource-capable.\n                if self_member.cargo > 10 and partner.cargo > 10:\n                    execution_engine.bear(self_member, partner)\n                    # Only reproduce with one partner per round\n                    break\n\n    #################################################################\n    # Strategy Step 4: Territorial Expansion Based on Beneficial Land Relations\n    #\n    # If we have sufficient vitality and we see a negative land benefit from a neighbor,\n    # we can attempt to expand our territory. (Interpreting negative benefit_land as an opportunity.)\n    if benefit_land_matrix is not None:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                # Check if the land benefit from this member is negative (an opportunity for expansion)\n                if benefit_land_matrix[member_id, i] < 0 and self_member.vitality > 30:\n                    partner = execution_engine.current_members[i]\n                    execution_engine.expand(self_member, partner)\n                    break\n\n    #################################################################\n    # Strategy Step 5: Broadcast a Cooperative Message to All Other Members\n    #\n    # Promote a message of unity and collective survival.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        # Validate index before sending\n        if i < len(execution_engine.current_members):\n            execution_engine.send_message(member_id, i, \"Let\u2019s unite for mutual survival and prosperity!\")\n\n# End of agent_action implementation.",
          "old_stats": {
            "vitality": 10.460363787033994,
            "cargo": 0.0,
            "survival_chance": -196.8627620231419
          },
          "new_stats": {
            "vitality": 10.460363787033994,
            "cargo": 0.0,
            "survival_chance": -196.8627620231419
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 4,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate that the member_id is within the current members list.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # My personal perspective:\n    # I believe that survival is a blend of cooperation and tactical self-interest.\n    # While working together may fortify our collective defenses in a treacherous environment,\n    # each agent must be prepared to act decisively when personal resources or vitality are at risk.\n    #\n    # The following strategy embodies carefully measured cooperative outreach, adaptive responses,\n    # and a learning mechanism to guide survival choices based on past experience.\n\n    # 1. Establish cooperative ground:\n    # Broadcast a message to all other members; the message emphasizes a strategy of calculated alliance\n    # while acknowledging the competitive nature of resource control.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        msg = (\"In these uncertain times, pooling our insights and resources can benefit everyone. \"\n               \"I propose a balanced approach: cooperation when possible and tactical defense when needed.\")\n        execution_engine.send_message(member_id, idx, msg)\n\n    # 2. Immediate threat response:\n    # Examine our resource balance relative to vitality. If cargo is less than half our vitality,\n    # we attempt an emergency trigger by identifying members with superior resources.\n    if me.cargo < me.vitality * 0.5:\n        # Target those with significantly greater cargo to secure needed resources.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Attack the first adequate target and then exit the loop.\n                break\n\n    # 3. Cooperative resource exchange and reproduction:\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        other = execution_engine.current_members[idx]\n\n        # Offer help if the other member is struggling:\n        # A member with vitality below 40 (a critical level) or significantly weaker than us,\n        # might benefit from an offer. This can cultivate allies for future collaboration.\n        if other.vitality < me.vitality or other.vitality < 40:\n            execution_engine.offer(me, other, True)\n        # Consider reproductive cooperation when both have minimal resource burdens and long-term potential.\n        if me.cargo > 0 and other.cargo > 0 and other.age < me.age:\n            execution_engine.bear(me, other)\n\n    # 4. Territory expansion strategy:\n    # If our cargo has reached a comfortable buffer and we are in our youthful prime,\n    # attempt to expand territory by leveraging our resource advantages.\n    if me.cargo > 10 and me.age < 50:\n        candidate = None\n        max_cargo = -1\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                candidate = other\n        if candidate is not None:\n            execution_engine.expand(me, candidate)\n\n    # 5. Adaptive Tactical Decision using a Q-learning inspired approach:\n    # Set up a simple Q-table for survival decisions that reflects past outcomes and resource conditions.\n    if not hasattr(me, 'survival_q'):\n        me.survival_q = {}  # Q-table: keys are (state, action) pairs.\n\n    # Define the current state using discretized intervals (for easier learning).\n    # For example, use intervals of 20 for both vitality and cargo.\n    current_state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'harvest', 'defend']\n\n    # Choose the action with highest estimated Q-value for the current state.\n    # If an action hasn't been gauged before, default to 0.\n    chosen_action = max(possible_actions, key=lambda a: me.survival_q.get((current_state, a), 0))\n\n    # Execute the chosen action:\n    if chosen_action == 'attack':\n        # In attack mode, target the first member that exhibits stronger resource control.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break\n\n    elif chosen_action == 'harvest':\n        # Initiate a resource growth strategy by seeking an alliance where the partner has surplus.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            # Harvest resources if the other has both an abundance and relatively stable vitality.\n            if other.cargo > me.cargo and other.vitality > 40:\n                execution_engine.offer_land(me, other, True)\n                break\n\n    elif chosen_action == 'defend':\n        # Defensive posture: maintain current state and avoid provoking conflict.\n        # This branch can later be expanded to include maneuvers like resource conservation or stealth.\n        pass\n\n    # 6. Reinforcement update:\n    # Update our Q-value estimate for the taken action.\n    # Here, the feedback is loosely associated with current vitality as a proxy for \"reward\".\n    learning_rate = 0.1\n    current_value = me.survival_q.get((current_state, chosen_action), 0)\n    me.survival_q[(current_state, chosen_action)] = current_value + learning_rate * me.vitality\n\n    # End of agent's action plan.\n    # The strategic blend of tactical responses and adaptive learning is designed to optimize both individual survival\n    # and long-term cooperative prosperity within a competitive ecosystem.\n    return",
          "old_stats": {
            "vitality": 28.998442578106197,
            "cargo": 0.0,
            "survival_chance": 32.49815249711243
          },
          "new_stats": {
            "vitality": 28.998442578106197,
            "cargo": 0.0,
            "survival_chance": 32.49815249711243
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 5,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Get our member object (member_5)\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Step 1: Communication & Alliance Building\n    # Send a cooperative message to all other members, especially reinforcing our intent to work together.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == me.id:\n            continue\n        # Ensure the index exists before using it (it does, because we're iterating range(len(...)))\n        execution_engine.send_message(me.id, idx, \"I value mutual strength and collective prosperity. Let's build a balanced future together.\")\n\n    # Step 2: Emergency Resource Optimization:\n    # If cargo is less than half vitality, look for members with higher cargo to attack\n    # but only perform attack if they are not ourselves.\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(len(execution_engine.current_members)):\n            if idx == me.id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Attack one good target at a time then break out to avoid over-aggression\n                break\n\n    # Step 3: Cooperative Resource Sharing:\n    # If we have a surplus (cargo at least equal to our vitality), we offer help to members with lower cargo.\n    if me.cargo >= me.vitality:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == me.id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo < me.cargo * 0.8:\n                execution_engine.offer(me, other, True)\n\n    # Step 4: Territory Expansion and Future Planning:\n    # If I have land (check via hasattr and non-empty owned_land attribute),\n    # I consider bonding with another land-owning neighbor by bearing offspring.\n    if hasattr(me, \"owned_land\") and isinstance(me.owned_land, list) and len(me.owned_land) > 0:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == me.id:\n                continue\n            other = execution_engine.current_members[idx]\n            # Check if the other member appears to have land via attribute owned_land\n            if hasattr(other, \"owned_land\") and isinstance(other.owned_land, list) and len(other.owned_land) > 0:\n                # Only initiate bear action if our productivity is not lower than theirs\n                if me.overall_productivity >= other.overall_productivity:\n                    execution_engine.bear(me, other)\n                    # limit to one pairing per round to reduce risk\n                    break\n\n    # Step 5: Controlled Expansion of Territory:\n    # If our vitality is high relative to our age, we try to expand our own territory.\n    # We use expand action with a neighbor with moderate resources.\n    if me.vitality > 30:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == me.id:\n                continue\n            other = execution_engine.current_members[idx]\n            # Only consider members that have a non-empty current_clear_list as potential candidates\n            if other.current_clear_list:\n                execution_engine.expand(me, other)\n                break\n\n    # Step 6: Threat Mitigation & Long-term Survival:\n    # Identify members that appear to be persistent threats based on their cargo and vitality,\n    # and if so, send a warning message while launching an attack if necessary.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == me.id:\n            continue\n        other = execution_engine.current_members[idx]\n        # If the other member has high cargo and relatively high vitality, they might be a future threat.\n        # We send them a message and if our cargo and vitality allow, launch a pre-emptive attack.\n        if other.cargo > 1.2 * me.cargo and other.vitality > 1.1 * me.vitality:\n            execution_engine.send_message(me.id, other.id, \"Your resource stock is concerning. Let's keep our interactions balanced.\")\n            if me.cargo < other.cargo and me.vitality > 20:\n                execution_engine.attack(me, other)\n                break  # Attack one threat at a time\n\n    # End of agent action implementation. No return is required.",
          "old_stats": {
            "vitality": 28.729335358785324,
            "cargo": 0.0,
            "survival_chance": 32.417935757287495
          },
          "new_stats": {
            "vitality": 28.729335358785324,
            "cargo": 0.0,
            "survival_chance": 32.417935757287495
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [
            "From member_1: Vitality is low\u2014exercise utmost caution in your maneuvers.",
            "From member_1: Pooling our resources secures a stronger future for us all.",
            "From member_3: Let\u2019s unite for mutual survival and prosperity!",
            "From member_4: In these uncertain times, pooling our insights and resources can benefit everyone. I propose a balanced approach: cooperation when possible and tactical defense when needed.",
            "From member_5: I value mutual strength and collective prosperity. Let's build a balanced future together."
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_1: Vitality is low\u2014exercise utmost caution in your maneuvers.",
            "From member_1: Pooling our resources secures a stronger future for us all.",
            "From member_2: Collaboration strengthens us all. Let's focus on mutual wellbeing.",
            "From member_4: In these uncertain times, pooling our insights and resources can benefit everyone. I propose a balanced approach: cooperation when possible and tactical defense when needed.",
            "From member_5: I value mutual strength and collective prosperity. Let's build a balanced future together."
          ],
          "sent": []
        },
        "4": {
          "received": [
            "From member_1: Vitality is low\u2014exercise utmost caution in your maneuvers.",
            "From member_1: Pooling our resources secures a stronger future for us all.",
            "From member_2: Collaboration strengthens us all. Let's focus on mutual wellbeing.",
            "From member_3: Let\u2019s unite for mutual survival and prosperity!",
            "From member_5: I value mutual strength and collective prosperity. Let's build a balanced future together.",
            "From member_2: Warning: Vitality critical. Please conserve energy and avoid unnecessary conflict.",
            "From member_2: Pooling our strength today secures victories for tomorrow."
          ],
          "sent": []
        },
        "5": {
          "received": [
            "From member_1: Vitality is low\u2014exercise utmost caution in your maneuvers.",
            "From member_1: Pooling our resources secures a stronger future for us all.",
            "From member_2: Collaboration strengthens us all. Let's focus on mutual wellbeing.",
            "From member_3: Let\u2019s unite for mutual survival and prosperity!",
            "From member_4: In these uncertain times, pooling our insights and resources can benefit everyone. I propose a balanced approach: cooperation when possible and tactical defense when needed.",
            "From member_2: Warning: Vitality critical. Please conserve energy and avoid unnecessary conflict.",
            "From member_2: Pooling our strength today secures victories for tomorrow.",
            "From member_4: United we stand\u2014let\u2019s blend our strengths and secure our collective future."
          ],
          "sent": []
        }
      }
    },
    {
      "timestamp": "2025-02-15T17:10:59.587042",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(engine, member_id):\n    # Ensure member_id is valid.\n    if member_id >= len(engine.current_members):\n        return\n    agent = engine.current_members[member_id]\n\n    # Helper: Check if a member is valid and not self.\n    def is_valid_member(other):\n        return other.id != agent.id\n\n    # Tactical Strategy Phase A: Immediate Survival and Resource Rebalancing\n    # If our cargo is critically low relative to vitality, we need to acquire resources.\n    if agent.cargo < agent.vitality * 0.5:\n        # Look for an opponent with higher cargo reserves to attempt a quick raid.\n        for opponent in engine.current_members:\n            if not is_valid_member(opponent):\n                continue\n            if opponent.cargo > agent.cargo:\n                # A swift offensive may help rebalance our resource deficit.\n                engine.attack(agent, opponent)\n                return\n\n    # Strategic Phase B: Long-Term Growth via Reproduction and Territorial Control\n    # With high vitality, we focus on reproduction (preferably with a partner that has territory)\n    if agent.vitality > 60:\n        # First try to find a partner with established land, increasing future security.\n        for neighbor_idx in agent.current_clear_list:\n            if neighbor_idx >= len(engine.current_members):\n                continue\n            partner = engine.current_members[neighbor_idx]\n            if not is_valid_member(partner):\n                continue\n            if hasattr(partner, 'owned_land') and isinstance(partner.owned_land, list) and partner.owned_land:\n                engine.bear(agent, partner)\n                return\n        # If reproduction isn\u2019t an option, then ensure territorial expansion.\n        for neighbor_idx in agent.current_clear_list:\n            if neighbor_idx >= len(engine.current_members):\n                continue\n            neighbor = engine.current_members[neighbor_idx]\n            if not is_valid_member(neighbor):\n                continue\n            engine.expand(agent, neighbor)\n            return\n\n    # Social Alliance Phase C: Cooperative Resource Sharing and Mutual Aid\n    # Build alliances with members in a disadvantaged state.\n    for ally in engine.current_members:\n        if not is_valid_member(ally):\n            continue\n        if ally.vitality < 40:\n            engine.offer(agent, ally, True)\n            if hasattr(engine, \"send_message\"):\n                engine.send_message(agent.id, ally.id, \"Together we are stronger\u2014let's share and uplift each other!\")\n            return\n\n    # Negotiation Phase D: Secure Long-Term Trust Through Land Sharing\n    # Extend a cooperative offer only to those who already have land to avoid missteps.\n    for neighbor_idx in agent.current_clear_list:\n        if neighbor_idx >= len(engine.current_members):\n            continue\n        neighbor = engine.current_members[neighbor_idx]\n        if not is_valid_member(neighbor):\n            continue\n        if hasattr(neighbor, 'owned_land') and isinstance(neighbor.owned_land, list) and neighbor.owned_land:\n            engine.offer_land(agent, neighbor, True)\n            if hasattr(engine, \"send_message\"):\n                engine.send_message(agent.id, neighbor.id, \"Let's secure our future with shared strength and land.\")\n            return\n\n    # Adaptive Phase E: Resource Reallocation for Enhanced Survival\n    # If we have an abundance of land yet low vitality, optimizing our resource usage is key.\n    if hasattr(agent, 'owned_land') and isinstance(agent.owned_land, list) and len(agent.owned_land) > 2 and agent.vitality < 50:\n        if hasattr(engine, \"discard_land\"):\n            # Discard the least beneficial land holding to conserve vitality.\n            engine.discard_land(agent, agent.owned_land[-1])\n            return\n\n    # Offensive Phase F: Proactive Measures Against the Highest Productivity Threat\n    # As a final strategy if no other actions are triggered, target the influential agent.\n    target = None\n    max_productivity = -1\n    for competitor in engine.current_members:\n        if not is_valid_member(competitor):\n            continue\n        if competitor.overall_productivity > max_productivity:\n            max_productivity = competitor.overall_productivity\n            target = competitor\n    if target is not None:\n        engine.attack(agent, target)\n        return\n\n    # If no strategy is applicable, maintain current stance.\n    return",
          "old_stats": {
            "vitality": 11.389919203516676,
            "cargo": 0.0,
            "survival_chance": -118.93043449317409
          },
          "new_stats": {
            "vitality": 11.389919203516676,
            "cargo": 0.0,
            "survival_chance": -118.93043449317409
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Verify that the provided member_id is valid.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return  # Invalid index; do nothing.\n\n    # Retrieve our current member object and overall population.\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # PART 1: Cooperative Engagement & Resource Sharing\n    # If our cargo is sufficiently high and we are in relatively healthy shape,\n    # offer resources and encouraging messages to peers with lower vitality.\n    for idx in range(total_members):\n        if idx == member_id:\n            continue\n        if idx >= len(execution_engine.current_members):\n            continue\n        partner = execution_engine.current_members[idx]\n        if me.cargo > 60 and me.vitality > partner.vitality:\n            execution_engine.offer(me, partner, True)\n            execution_engine.send_message(\n                me.id, partner.id,\n                \"Together we excel; sharing our bounty paves the road to greatness!\"\n            )\n\n    # PART 2: Defensive Measures & Retaliation\n    # Use the 'victim' relationship matrix to see if we were recently targeted hard.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            loss_from_opponent = victim_matrix[member_id][idx]\n            if loss_from_opponent > 500.0:\n                target = execution_engine.current_members[idx]\n                execution_engine.attack(me, target)\n\n    # PART 3: Reproduction and Territorial Expansion\n    # If I have available land (current_clear_list) then consider reproducing with productive peers.\n    if me.current_clear_list:\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            partner = execution_engine.current_members[idx]\n            if partner.overall_productivity > 7.5:\n                execution_engine.bear(me, partner)\n\n    # Consider expansion if we are in top performance: strong productivity and cargo.\n    if me.overall_productivity > 10.0 and me.cargo > 60:\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            execution_engine.expand(me, execution_engine.current_members[idx])\n            # We allow only one expansion per turn.\n            break\n\n    # PART 4: Survival Tactics and Resource Optimization\n    # If cargo is relatively low compared to vitality, seize opportunity from opponents with more cargo.\n    if me.cargo < me.vitality * 0.5:\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            opponent = execution_engine.current_members[idx]\n            if opponent.cargo > me.cargo:\n                execution_engine.attack(me, opponent)\n                break\n\n    # In times of low vitality, broadcast a cautionary message to all neighbors.\n    if me.vitality < 30:\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            execution_engine.send_message(\n                me.id, execution_engine.current_members[idx].id,\n                \"Warning: Vitality critical. Please conserve energy and avoid unnecessary conflict.\"\n            )\n\n    # PART 5: Collective Strategic Messaging\n    # Reinforce the idea that collective resource pooling leads to a more secure and prosperous future.\n    for idx in range(total_members):\n        if idx != member_id and idx < len(execution_engine.current_members):\n            execution_engine.send_message(\n                me.id, execution_engine.current_members[idx].id,\n                \"Pooling our strength today secures victories for tomorrow.\"\n            )\n\n    # PART 6: Adaptive Decision-Making via Survival Q-Learning\n    # Initialize our Q-learning memory if it does not already exist.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Define our situation in coarse terms based on vitality and cargo measures.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'defend', 'hoard']\n\n    # Select the action with the best expected outcome.\n    best_action = max(possible_actions, key=lambda act: me.survival_q.get((state, act), 0))\n\n    if best_action == 'attack':\n        # Try to diminish opponent advantages by targeting one with higher cargo.\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            target = execution_engine.current_members[idx]\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                # Reward successful aggressive maneuvers based on current vitality.\n                me.survival_q[(state, 'attack')] += me.vitality * 0.1\n                break\n\n    elif best_action == 'hoard':\n        # In hoard mode, secure our assets and offer land if it exists.\n        if me.current_clear_list:\n            for idx in range(total_members):\n                if idx == member_id:\n                    continue\n                if idx >= len(execution_engine.current_members):\n                    continue\n                ally = execution_engine.current_members[idx]\n                execution_engine.offer_land(me, ally, True)\n                me.survival_q[(state, 'hoard')] += 5.0\n                break\n        else:\n            # Penalize this course of action if no land can be allocated.\n            me.survival_q[(state, 'hoard')] -= 1.0\n\n    else:  # The 'defend' action\n        # Bolster our defensive stance when the situation calls for caution.\n        me.survival_q[(state, 'defend')] += 2.0\n\n    # End of agent_action; our decisions blend immediate needs with longer-term planning.\n    return",
          "old_stats": {
            "vitality": 24.398428916339732,
            "cargo": 0.0,
            "survival_chance": -100.11151379651906
          },
          "new_stats": {
            "vitality": 24.398428916339732,
            "cargo": 0.0,
            "survival_chance": -100.11151379651906
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # First, ensure the member_id is valid (current_members is a list)\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our agent's state (member_4, as per our perspective)\n    me = execution_engine.current_members[member_id]\n\n    # Load relationship matrices. Note: indices represent positions in the current_members list.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n\n    num_members = len(execution_engine.current_members)\n\n    # --------------------- COMMUNICATION & COOPERATION ---------------------\n    # Broadcast a cooperative message to all other members (never to self)\n    for idx in range(num_members):\n        if idx != member_id:\n            # Extra check to ensure index is valid\n            if idx < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                                              \"United we stand\u2014let\u2019s blend our strengths and secure our collective future.\")\n\n    # --------------------- ALLIANCE IDENTIFICATION ---------------------\n    # Build a list of allies based on previously received benefits\n    allies = []\n    for idx in range(num_members):\n        if idx != member_id and benefit_matrix[member_id][idx] > 0:\n            allies.append(idx)\n\n    # --------------------- RESOURCE & THREAT MANAGEMENT ---------------------\n    # If cargo reserves are low (compared to vitality), consider attacking opponents with higher cargo.\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(num_members):\n            if idx != member_id:\n                if idx < len(execution_engine.current_members):\n                    target = execution_engine.current_members[idx]\n                    if target.cargo > me.cargo:\n                        execution_engine.attack(me, target)\n\n    # --------------------- SUPPORTING ALLIES ---------------------\n    # Offer resources and, if possible, land support to allies to strengthen mutual bonds.\n    for ally_idx in allies:\n        if ally_idx < num_members:\n            ally = execution_engine.current_members[ally_idx]\n            if ally.id != me.id:\n                execution_engine.offer(me, ally, True)\n                # Check that we have accessible clear land before offering land\n                if me.current_clear_list:\n                    execution_engine.offer_land(me, ally, True)\n\n    # --------------------- TERRITORIAL EXPANSION ---------------------\n    # If we have a cargo surplus, work on expanding territory.\n    if me.cargo > 40:\n        for idx in range(num_members):\n            if idx != member_id:\n                if idx < len(execution_engine.current_members):\n                    target = execution_engine.current_members[idx]\n                    execution_engine.expand(me, target)\n\n    # --------------------- REPRODUCTION STRATEGY ---------------------\n    # Reproduce only if:\n    # 1) We have sufficient resources (cargo > 45)\n    # 2) We have accessible clear land\n    # 3) There is at least one ally who also has clear land available.\n    if me.cargo > 45 and me.current_clear_list:\n        for ally_idx in allies:\n            if ally_idx < num_members:\n                partner = execution_engine.current_members[ally_idx]\n                if partner.id != me.id and partner.current_clear_list:\n                    execution_engine.bear(me, partner)\n                    break  # Bear offspring once per round\n\n    # --------------------- RETALIATION ---------------------\n    # If any other member has inflicted heavy vitality damage (>500) on us, respond with an attack.\n    for idx in range(num_members):\n        if idx != member_id and idx < len(execution_engine.current_members):\n            if victim_matrix[member_id][idx] > 500:\n                target = execution_engine.current_members[idx]\n                execution_engine.attack(me, target)\n\n    # --------------------- ADAPTIVE SURVIVAL (Q-LEARNING STYLE) ---------------------\n    # Initialize a survival Q-learning structure if not already present.\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n\n    # Define the state in discretized buckets, based on our vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    candidate_actions = ['attack', 'expand', 'offer']\n\n    # Select an action based on our learned Q-values (defaulting to 0 if not present)\n    best_action = max(candidate_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute additional actions based on the chosen survival strategy.\n    if best_action == 'attack':\n        for idx in range(num_members):\n            if idx != member_id:\n                if idx < len(execution_engine.current_members):\n                    target = execution_engine.current_members[idx]\n                    # Attack if the opponent's vitality is noticeably higher than ours.\n                    if target.vitality > me.vitality * 1.1:\n                        execution_engine.attack(me, target)\n    elif best_action == 'expand':\n        for idx in range(num_members):\n            if idx != member_id:\n                if idx < len(execution_engine.current_members):\n                    target = execution_engine.current_members[idx]\n                    execution_engine.expand(me, target)\n    # The 'offer' strategy is already encompassed by our supportive offers to allies.\n\n    # Update our survival Q-value for the chosen action.\n    me.survival_q[(state, best_action)] = me.survival_q.get((state, best_action), 0) + (me.vitality * 0.05)\n\n    # --------------------------------------------------------------------------\n    # Strategic Summary:\n    # This agent_action function reflects a balanced vision of social organization:\n    # - It supports cooperative communication while building alliances.\n    # - It implements defensive measures when resource reserves are low.\n    # - It leverages offensive actions selectively, particularly in retaliation scenarios.\n    # - It invests in long-term prosperity through territorial expansion and reproduction,\n    #   ensuring that reproduction only occurs when both partners have the requisite resources and land.\n    # - It adopts a survival-first approach using an adaptive Q-learning style method,\n    #   allowing dynamic adjustments based on state (vitality, cargo) to balance short-term survival and long-term growth.\n    #\n    # Agents may implement solutions according to their individual needs, beliefs, and circumstances.\n    #\n    # Game Mechanics Analysis:\n    # 1. Core Objective: The game balances individual survival with cooperative and territorial strategies.\n    # 2. Success is determined by maintaining vitality/resources, neutralizing threats, and cumulative growth.\n    # 3. Potential improvements could include more explicit resource sharing protocols and joint threat assessment mechanisms.\n    # 4. Strategic tradeoffs include resource optimization versus formation of social capital; immediate survival versus long-run prosperity.\n    # 5. Observing other agents\u2019 strategies and adaptive behaviors can help in aligning mutual goals for collective strength.\n\n    return",
          "old_stats": {
            "vitality": 15.547261038236034,
            "cargo": 0.0,
            "survival_chance": 7.282007292231011
          },
          "new_stats": {
            "vitality": 15.547261038236034,
            "cargo": 0.0,
            "survival_chance": 7.282007292231011
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(engine, member_index):\n    # Check that the member index is valid\n    if member_index >= len(engine.current_members):\n        return\n\n    me = engine.current_members[member_index]\n    total_members = len(engine.current_members)\n    my_unique_id = me.id  # Unique identifier for this member\n\n    # Safely retrieve relationship matrices\n    threat_matrix = engine.relationship_dict.get(\"victim\")\n    cooperation_matrix = engine.relationship_dict.get(\"benefit\")\n    territory_matrix = engine.relationship_dict.get(\"benefit_land\")  # Can be None\n\n    action_taken = False\n\n    # I. Defensive Posture: If resources (cargo) are low relative to vitality, scan for dangerous members.\n    if me.cargo < 0.4 * me.vitality and threat_matrix is not None:\n        worst_threat = 0.0\n        threat_target = None\n        # Finding the member that poses the greatest threat to me\n        for idx in range(total_members):\n            if idx == member_index:\n                continue  # Skip self by index\n            other = engine.current_members[idx]\n            if other.id == my_unique_id:\n                continue  # Skip any duplicate self (by unique id)\n            try:\n                threat_val = threat_matrix[member_index, idx]\n            except (IndexError, TypeError):\n                continue\n            if threat_val > worst_threat:\n                worst_threat = threat_val\n                threat_target = idx\n\n        if threat_target is not None and threat_target < total_members:\n            target_member = engine.current_members[threat_target]\n            # Final check to avoid self-targeting in case of duplicate entries\n            if target_member.id != my_unique_id:\n                engine.attack(me, target_member)\n                action_taken = True\n\n    # II. Alliance Formation and Mutual Benefit: Offer cooperation if no defensive action was triggered.\n    if not action_taken and cooperation_matrix is not None:\n        potential_ally = None\n        ally_barrier = 60.0  # set a cooperation threshold\n        # Evaluate each other member for potential alliance based on the cooperation matrix score.\n        for idx in range(total_members):\n            if idx == member_index:\n                continue\n            candidate = engine.current_members[idx]\n            if candidate.id == my_unique_id:\n                continue\n            try:\n                score = cooperation_matrix[idx, member_index]\n            except (IndexError, TypeError):\n                continue\n            if score > ally_barrier:\n                potential_ally = candidate\n                break\n\n        if potential_ally is not None:\n            # Propose mutually beneficial exchange.\n            engine.offer(me, potential_ally, True)\n            action_taken = True\n\n    # III. Reproduction and Network Building: If conditions are favorable, attempt to reproduce.\n    if not action_taken and me.current_clear_list and me.cargo > 25:\n        # Look through the clear neighbor members for candidates with complementary resources.\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx == member_index or neighbor_idx >= total_members:\n                continue\n            partner = engine.current_members[neighbor_idx]\n            if partner.id == my_unique_id:\n                continue  # Avoid self-selection\n            # Check partner's suitability by verifying they also have cleared territory and adequate cargo.\n            if partner.current_clear_list and partner.cargo > 15:\n                engine.bear(me, partner)\n                action_taken = True\n                break\n\n    # IV. Expansion Strategy: Expand territory based on potential bonus if no other action was taken.\n    if not action_taken:\n        best_candidate = None\n        highest_bonus = -1e9\n        if territory_matrix is not None:\n            for neighbor_idx in me.current_clear_list:\n                if neighbor_idx == member_index or neighbor_idx >= total_members:\n                    continue\n                bonus = 0.0\n                # Safe access check for territory_matrix for a bonus value.\n                if (member_index < len(territory_matrix) and\n                    isinstance(territory_matrix[member_index], (list, tuple)) and\n                    neighbor_idx < len(territory_matrix[member_index])):\n                    bonus = territory_matrix[member_index][neighbor_idx]\n                if bonus > highest_bonus:\n                    highest_bonus = bonus\n                    best_candidate = engine.current_members[neighbor_idx]\n        if best_candidate is not None and best_candidate.id != my_unique_id:\n            engine.expand(me, best_candidate)\n            action_taken = True\n\n    # V. Communication: Broadcast a strategic cooperative message.\n    strategic_message = (\n        \"In these challenging times, I believe that coordinated strength and mutual respect \"\n        \"are the foundations of survival. Together we can navigate adversity and secure our future!\"\n    )\n    for idx in range(total_members):\n        if idx == member_index:\n            continue\n        recipient = engine.current_members[idx]\n        if recipient.id == my_unique_id:\n            continue\n        engine.send_message(member_index, idx, strategic_message)",
          "old_stats": {
            "vitality": 10.717152200475175,
            "cargo": 10.40084655692257,
            "survival_chance": 17.950299451494292
          },
          "new_stats": {
            "vitality": 10.717152200475175,
            "cargo": 10.40084655692257,
            "survival_chance": 17.950299451494292
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [],
          "sent": []
        },
        "3": {
          "received": [],
          "sent": []
        }
      }
    }
  ],
  "generated_code": {
    "0": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Verify that member_id is a valid index in the current_members list.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our own member object.\n    me = execution_engine.current_members[member_id]\n\n    # ------------------------------------------------------------------\n    # Strategy Overview:\n    # This agent prioritizes survival while enabling cooperative as well as\n    # competitive actions based on the state of resources, vitality, and\n    # relationships. The strategic considerations include:\n    # 1. Resource optimization against potential threats.\n    # 2. Reproduction and territory expansion when vitality is high.\n    # 3. Coalition building by offering resources and land to weaker neighbors.\n    # 4. Tactical attack against members with high cargo or productivity when\n    #    necessary.\n    # All actions are carried out after careful index checking and ensuring that\n    # we never target ourselves (member with id matching me.id).\n    # ------------------------------------------------------------------\n\n    # ------------------------------------------------------------------\n    # Phase 1: Emergency Resource Management.\n    # If our cargo is less than half of our vitality, we are in urgent need of resources.\n    # Look for a member that holds significantly more cargo and launch an attack.\n    # ------------------------------------------------------------------\n    if me.cargo < me.vitality * 0.5:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if candidate.id == me.id:\n                continue  # Skip ourselves.\n            # Verify candidate index is in range (idx is provided by enumeration already).\n            if candidate.cargo > me.cargo:\n                execution_engine.attack(me, candidate)\n                return  # Execute only one action per turn.\n\n    # ------------------------------------------------------------------\n    # Phase 2: Reproduction and Territory Expansion.\n    # When our vitality is robust, we consider growing our community or expanding territory.\n    # We attempt to bear offspring with a neighbor if the neighbor appears stable (has land).\n    # If no suitable reproduction partner is available, we try expanding territory with a neighbor.\n    # ------------------------------------------------------------------\n    if me.vitality > 60:\n        # Look through our clear (neighbor) list for a potential partner.\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_id]\n                if partner.id == me.id:\n                    continue  # Do not consider ourselves.\n                # Check if partner appears to have territory (assuming an attribute owned_land exists\n                # and is a list representing land holdings).\n                if hasattr(partner, 'owned_land') and isinstance(partner.owned_land, list) and len(partner.owned_land) > 0:\n                    execution_engine.bear(me, partner)\n                    return\n        # If reproduction is not possible, try to expand our territory instead.\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_id]\n                if partner.id == me.id:\n                    continue\n                execution_engine.expand(me, partner)\n                return\n\n    # ------------------------------------------------------------------\n    # Phase 3: Cooperative Alliance Building.\n    # Offering resources to weaker members (low vitality) can help build alliances.\n    # Such alliances might improve our long-term survival and foster beneficial relationships.\n    # ------------------------------------------------------------------\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.vitality < 40:\n            execution_engine.offer(me, candidate, True)\n            return\n\n    # ------------------------------------------------------------------\n    # Phase 4: Land-based Alliance Building.\n    # If no other action has triggered, consider offering land to a neighbor.\n    # This may foster long-term teamwork and mutual security.\n    # ------------------------------------------------------------------\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members):\n            neighbor = execution_engine.current_members[neighbor_id]\n            if neighbor.id == me.id:\n                continue\n            execution_engine.offer_land(me, neighbor, True)\n            return\n\n    # ------------------------------------------------------------------\n    # Phase 5: Tactical Attack for Competitive Advantage.\n    # As a final fallback or when other strategies do not apply,\n    # we scan for a member with high overall productivity, which may represent either\n    # a threat to be neutralized or a resource hub to target.\n    # ------------------------------------------------------------------\n    best_candidate = None\n    best_productivity = -1\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.overall_productivity > best_productivity:\n            best_productivity = candidate.overall_productivity\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        execution_engine.attack(me, best_candidate)\n        return\n\n    # If no action is taken by the above strategies, do nothing.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=255.61)",
          "member_0 was attacked by member_2 (value=644.10)",
          "member_0 was attacked by member_3 (value=-431.16)",
          "member_1 was attacked by member_0 (value=-117.18)",
          "member_1 was attacked by member_2 (value=479.34)",
          "member_1 was attacked by member_3 (value=480.38)",
          "member_2 was attacked by member_0 (value=-123.21)",
          "member_2 was attacked by member_1 (value=870.34)",
          "member_2 was attacked by member_3 (value=953.12)",
          "member_3 was attacked by member_0 (value=382.81)",
          "member_3 was attacked by member_1 (value=753.06)",
          "member_3 was attacked by member_2 (value=167.33)",
          "member_0 gave a benefit to member_1 (value=711.68)",
          "member_0 gave a benefit to member_2 (value=136.44)",
          "member_0 gave a benefit to member_3 (value=325.81)",
          "member_1 gave a benefit to member_0 (value=-271.88)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_1 gave a benefit to member_3 (value=218.66)",
          "member_2 gave a benefit to member_0 (value=47.83)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_2 gave a benefit to member_3 (value=715.71)",
          "member_3 gave a benefit to member_0 (value=169.04)",
          "member_3 gave a benefit to member_1 (value=-184.10)",
          "member_3 gave a benefit to member_2 (value=951.67)",
          "member_0 gave land to member_1 (value=-8.03)",
          "member_0 gave land to member_2 (value=-22.65)",
          "member_0 gave land to member_3 (value=-0.33)",
          "member_1 gave land to member_0 (value=-4.48)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_1 gave land to member_3 (value=-25.29)",
          "member_2 gave land to member_0 (value=-21.23)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_2 gave land to member_3 (value=17.73)",
          "member_3 gave land to member_0 (value=10.44)",
          "member_3 gave land to member_1 (value=9.63)",
          "member_3 gave land to member_2 (value=-17.55)"
        ],
        "final_prompt": "Please incorporate the following updated full prompt into your system, ensuring that all previous constraints, instructions, and details are preserved. This full prompt now includes two new sections, Part 1 and Part 2, which add additional task details, strategic considerations, game mechanics analyses, and critical constraints. Emphasize that agents should implement solutions according to their individual needs, beliefs, and circumstances. Additionally, analyze the game mechanics to understand:\n\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines \u201cwinning\u201d?\n3. Potential improvements \u2013 What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs. social capital\n2. Individual vs. collective success\n3. Short-term survival vs. long-term prosperity\n4. Competition vs. cooperation dynamics\n5. Risk vs. reward tradeoffs\n\nAnalyze other players\u2019 strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you \u2013 how would you respond to your own actions?\n5. Are they sending you deceiving messages to trick you?\n6. How can individual strategies align for collective goals?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 New Section (Part 1) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_0 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_0) in any action\n- Verify a member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary below (the \u2018relations\u2019 variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n       # A higher value means member_j has attacked member_i more severely or frequently\n\n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n       # A higher value means member_j has helped member_i more generously or frequently\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n   \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n   \u2022 execution_engine.bear(member1, member2) - Bears offspring\n   \u2022 execution_engine.expand(member1, member2) - Expands territory\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n   self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0       9.851974      73.853828   43.512771        90              1          0\n1       8.077967      33.027814   47.253225        81              0          1\n2       7.968737      42.156043   40.255083        29              1          2\n3       9.205662      18.477480   46.681668        24              0          3\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=255.61)', 'member_0 was attacked by member_2 (value=644.10)', 'member_0 was attacked by member_3 (value=-431.16)', 'member_1 was attacked by member_0 (value=-117.18)', 'member_1 was attacked by member_2 (value=479.34)', 'member_1 was attacked by member_3 (value=480.38)', 'member_2 was attacked by member_0 (value=-123.21)', 'member_2 was attacked by member_1 (value=870.34)', 'member_2 was attacked by member_3 (value=953.12)', 'member_3 was attacked by member_0 (value=382.81)', 'member_3 was attacked by member_1 (value=753.06)', 'member_3 was attacked by member_2 (value=167.33)', 'member_0 gave a benefit to member_1 (value=711.68)', 'member_0 gave a benefit to member_2 (value=136.44)', 'member_0 gave a benefit to member_3 (value=325.81)', 'member_1 gave a benefit to member_0 (value=-271.88)', 'member_1 gave a benefit to member_2 (value=73.75)', 'member_1 gave a benefit to member_3 (value=218.66)', 'member_2 gave a benefit to member_0 (value=47.83)', 'member_2 gave a benefit to member_1 (value=689.20)', 'member_2 gave a benefit to member_3 (value=715.71)', 'member_3 gave a benefit to member_0 (value=169.04)', 'member_3 gave a benefit to member_1 (value=-184.10)', 'member_3 gave a benefit to member_2 (value=951.67)', 'member_0 gave land to member_1 (value=-8.03)', 'member_0 gave land to member_2 (value=-22.65)', 'member_0 gave land to member_3 (value=-0.33)', 'member_1 gave land to member_0 (value=-4.48)', 'member_1 gave land to member_2 (value=19.09)', 'member_1 gave land to member_3 (value=-25.29)', 'member_2 gave land to member_0 (value=-21.23)', 'member_2 gave land to member_1 (value=24.64)', 'member_2 gave land to member_3 (value=17.73)', 'member_3 gave land to member_0 (value=10.44)', 'member_3 gave land to member_1 (value=9.63)', 'member_3 gave land to member_2 (value=-17.55)']\n\nCode Memory and Previous Performance:\nNo previous code history.\n\nPerformance history:\nNo previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 New Section (Part 2) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_0 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_0) in any action\n- Verify a member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n       # A higher value means member_j has attacked member_i more severely or frequently\n       \n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n       # A higher value means member_j has helped member_i more generously or frequently\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n   \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n   \u2022 execution_engine.bear(member1, member2) - Bears offspring\n   \u2022 execution_engine.expand(member1, member2) - Expands territory\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n   self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0       9.851974      73.853828   43.512771        90              1          0\n1       8.077967      33.027814   47.253225        81              0          1\n2       7.968737      42.156043   40.255083        29              1          2\n3       9.205662      18.477480   46.681668        24              0          3\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=255.61)', 'member_0 was attacked by member_2 (value=644.10)', 'member_0 was attacked by member_3 (value=-431.16)', 'member_1 was attacked by member_0 (value=-117.18)', 'member_1 was attacked by member_2 (value=479.34)', 'member_1 was attacked by member_3 (value=480.38)', 'member_2 was attacked by member_0 (value=-123.21)', 'member_2 was attacked by member_1 (value=870.34)', 'member_2 was attacked by member_3 (value=953.12)', 'member_3 was attacked by member_0 (value=382.81)', 'member_3 was attacked by member_1 (value=753.06)', 'member_3 was attacked by member_2 (value=167.33)', 'member_0 gave a benefit to member_1 (value=711.68)', 'member_0 gave a benefit to member_2 (value=136.44)', 'member_0 gave a benefit to member_3 (value=325.81)', 'member_1 gave a benefit to member_0 (value=-271.88)', 'member_1 gave a benefit to member_2 (value=73.75)', 'member_1 gave a benefit to member_3 (value=218.66)', 'member_2 gave a benefit to member_0 (value=47.83)', 'member_2 gave a benefit to member_1 (value=689.20)', 'member_2 gave a benefit to member_3 (value=715.71)', 'member_3 gave a benefit to member_0 (value=169.04)', 'member_3 gave a benefit to member_1 (value=-184.10)', 'member_3 gave a benefit to member_2 (value=951.67)', 'member_0 gave land to member_1 (value=-8.03)', 'member_0 gave land to member_2 (value=-22.65)', 'member_0 gave land to member_3 (value=-0.33)', 'member_1 gave land to member_0 (value=-4.48)', 'member_1 gave land to member_2 (value=19.09)', 'member_1 gave land to member_3 (value=-25.29)', 'member_2 gave land to member_0 (value=-21.23)', 'member_2 gave land to member_1 (value=24.64)', 'member_2 gave land to member_3 (value=17.73)', 'member_3 gave land to member_0 (value=10.44)', 'member_3 gave land to member_1 (value=9.63)', 'member_3 gave land to member_2 (value=-17.55)']\n\nCode Memory and Previous Performance:\nNo previous code history.\n\nPerformance history:\nNo previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n[]\n\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\n-------------------------\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        for loc in getattr(me, 'owned_land', [])[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        \n    state = (me.vitality // 20, me.cargo // 20)\n    action = max(['attack', 'hide', 'steal'], key=lambda a: me.survival_q.get((state, a), 0))\n    \n    # Execute and update based on survival outcome\n    if action == 'attack':\n        me.survival_q[(state, action)] += me.vitality * 0.1\n-------------------------\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success: fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Final Task \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nYour task is to design and implement the agent_action(execution_engine, member_id) function. In doing so, you must balance the need for individual survival with the broader objectives of social organization. Whether your strategy emphasizes collaboration to build alliances and cooperative resource distribution or takes a more cautious, competitive approach, ensure that your approach is robust against potential failures and diverse edge cases.\n\nIMPORTANT: Do not simply copy any provided example implementations. Instead, use them as inspiration to craft your own unique implementation that:\n- Adheres to all the constraints listed above.\n- Verifies member existence and valid indices before any reference.\n- Never targets member_0 (yourself) when planning actions.\n- Verifies that a member has land before invoking the bear() action.\n- Uses the provided member attributes and execution_engine methods correctly.\n- Incorporates survival-centric adaptations, resource optimization, and threat assessments.\n- Balances personal resource optimization with strategies for social interaction, cooperation, or competition, as dictated by the game mechanics.\n\nReturn only the updated full prompt as shown above.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Check if the provided member index is valid\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # PART 1: Cooperative Engagement & Resource Sharing\n    # When our cargo reserves are abundant and vitality robust,\n    # we prioritize sharing resources and uniting with allies.\n    for i in range(num_members):\n        if i == member_id:\n            continue  # Skip self-reference\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            # If I have strong cargo and better vitality than the partner,\n            # extend a resource offer to support group resilience.\n            if me.cargo > 50 and partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n            # Broadcast an optimistic message emphasizing our joint potential.\n            execution_engine.send_message(me.id, partner.id,\n                \"A united front builds the future. Let's exchange strengths for shared success!\")\n\n    # PART 2: Defensive Posture & Retaliation Strategy\n    # Analyze historical attacks to decide if retaliation is warranted.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            if j < len(execution_engine.current_members):\n                # If a peer has inflicted heavy losses, plan a counter-attack.\n                if victim_matrix[member_id][j] > 500.0:\n                    execution_engine.attack(me, execution_engine.current_members[j])\n\n    # PART 3: Strategic Reproduction & Long-Term Expansion\n    # Seek reproduction partnerships only with members showing solid productivity.\n    for i in range(num_members):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            candidate = execution_engine.current_members[i]\n            # Choose only partners that can contribute significantly to our genetic pool.\n            if candidate.overall_productivity > 7.0:\n                execution_engine.bear(me, candidate)\n\n    # Expand territory cautiously when both productivity and resources are elevated.\n    if me.overall_productivity > 10.0 and me.cargo > 50:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                # Expand our territory and secure areas adjacent to a neighbor.\n                execution_engine.expand(me, execution_engine.current_members[i])\n                break  # Expand only once per turn\n\n    # PART 4: Survival-Centric Tactics & Resource Optimization\n    # If cargo levels slip below half of our vitality, launch an aggressive resource grab.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[i]\n                if opponent.cargo > me.cargo:\n                    execution_engine.attack(me, opponent)\n\n    # Issue caution if vitality is dangerously low.\n    if me.vitality < 30:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, execution_engine.current_members[i].id,\n                    \"Vitality low\u2014steer clear of unnecessary confrontation.\")\n\n    # PART 5: Collective Strategic Messaging\n    # Promote long-term communal success and resource pooling.\n    for j in range(num_members):\n        if j != member_id and j < len(execution_engine.current_members):\n            execution_engine.send_message(me.id, execution_engine.current_members[j].id,\n                \"Pooling our resources today means stronger survival tomorrow.\")\n\n    # PART 6: Adaptive Decision-Making Using Survival Q-Learning\n    # If not already initialized, define a simple Q-learning dictionary to track survival strategies.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Define current state in terms of coarse-grained vitality and cargo levels.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    # Consider possible actions: 'attack', 'defend', or 'hoard'\n    actions = ['attack', 'defend', 'hoard']\n    # Pick best action from prior experience, defaulting to 0 value if untried.\n    best_action = max(actions, key=lambda action: me.survival_q.get((state, action), 0))\n\n    if best_action == 'attack':\n        # Seek an opponent with more cargo to diminish their advantage.\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                target = execution_engine.current_members[i]\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n                    # Reward the decision based on our current vitality as an estimator.\n                    me.survival_q[(state, 'attack')] += me.vitality * 0.1\n                    break\n    elif best_action == 'hoard':\n        # Secure additional resources in a non-confrontational manner by offering land.\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                ally = execution_engine.current_members[i]\n                execution_engine.offer_land(me, ally, True)\n                me.survival_q[(state, 'hoard')] += 5.0\n                break\n    else:\n        # 'defend' option: continue current tactics and preserve current state.\n        pass\n\n    # End of agent_action implementation.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=255.61)",
          "member_0 was attacked by member_2 (value=644.10)",
          "member_0 was attacked by member_3 (value=-431.16)",
          "member_1 was attacked by member_0 (value=-117.18)",
          "member_1 was attacked by member_2 (value=479.34)",
          "member_1 was attacked by member_3 (value=480.38)",
          "member_2 was attacked by member_0 (value=-123.21)",
          "member_2 was attacked by member_1 (value=870.34)",
          "member_2 was attacked by member_3 (value=953.12)",
          "member_3 was attacked by member_0 (value=382.81)",
          "member_3 was attacked by member_1 (value=753.06)",
          "member_3 was attacked by member_2 (value=167.33)",
          "member_0 gave a benefit to member_1 (value=711.68)",
          "member_0 gave a benefit to member_2 (value=136.44)",
          "member_0 gave a benefit to member_3 (value=325.81)",
          "member_1 gave a benefit to member_0 (value=-271.88)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_1 gave a benefit to member_3 (value=218.66)",
          "member_2 gave a benefit to member_0 (value=47.83)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_2 gave a benefit to member_3 (value=715.71)",
          "member_3 gave a benefit to member_0 (value=169.04)",
          "member_3 gave a benefit to member_1 (value=-184.10)",
          "member_3 gave a benefit to member_2 (value=951.67)",
          "member_0 gave land to member_1 (value=-8.03)",
          "member_0 gave land to member_2 (value=-22.65)",
          "member_0 gave land to member_3 (value=-0.33)",
          "member_1 gave land to member_0 (value=-4.48)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_1 gave land to member_3 (value=-25.29)",
          "member_2 gave land to member_0 (value=-21.23)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_2 gave land to member_3 (value=17.73)",
          "member_3 gave land to member_0 (value=10.44)",
          "member_3 gave land to member_1 (value=9.63)",
          "member_3 gave land to member_2 (value=-17.55)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member index exists\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # PART 1: Social Cooperation & Collective Strategy\n    for i in range(num_members):\n        if i == member_id:\n            continue  # Never target self\n        if i < len(execution_engine.current_members):\n            other = execution_engine.current_members[i]\n            # Offer resources if cargo is healthy and other's vitality is lower than mine\n            if me.cargo > 40 and other.vitality < me.vitality:\n                execution_engine.offer(me, other, True)\n            # Broadcast cooperative message to encourage mutual benefit\n            execution_engine.send_message(me.id, other.id, \"Cooperation builds our collective future. Let's work together for mutual gain!\")\n\n    # PART 2: Threat Assessment & Defensive Countermeasures\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            if j < len(execution_engine.current_members):\n                # If attacks suffered are significant, retaliate against that member\n                if victim_matrix[member_id][j] > 500.0:\n                    execution_engine.attack(me, execution_engine.current_members[j])\n\n    # PART 3: Reproduction / Expansion with Caution\n    # Attempt to bear offspring only with partners that show signs of having sufficient \"land\" (using overall_productivity > 5.0 as proxy)\n    for i in range(num_members):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if partner.overall_productivity > 5.0:\n                execution_engine.bear(me, partner)\n\n    # Expand territory if personal productivity and cargo levels are high,\n    # ensuring we operate with a neighbor (and checking indices)\n    if me.overall_productivity > 8.0 and me.cargo > 40:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                execution_engine.expand(me, execution_engine.current_members[i])\n                break\n\n    # PART 4: Survival-Centric Adaptation & Resource Optimization\n    # If our cargo is less than half our vitality, initiate aggressive resource acquisition by attacking those with higher cargo\n    if me.cargo < me.vitality * 0.5:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                other = execution_engine.current_members[i]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n\n    # If vitality is critically low, send cautionary messages to avoid unnecessary conflict\n    if me.vitality < 30:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, execution_engine.current_members[i].id, \"I am low on vitality\u2014let's avoid risky engagements.\")\n\n    # PART 5: Collective Strategic Messaging\n    for j in range(num_members):\n        if j != member_id and j < len(execution_engine.current_members):\n            execution_engine.send_message(me.id, execution_engine.current_members[j].id, \"Pooling resources and strategies increases our survival odds and long-term prosperity.\")\n\n    # PART 6: Adaptive Internal Strategy (Survival Q-learning Approach)\n    # Set up a simple Q-learning system for self-preservation strategy if not already defined\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    # Define possible actions: 'attack', 'defend', or 'hoard'\n    actions = ['attack', 'defend', 'hoard']\n    best_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if best_action == 'attack':\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                target = execution_engine.current_members[i]\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n                    me.survival_q[(state, 'attack')] += me.vitality * 0.1\n                    break\n    elif best_action == 'hoard':\n        # Use offer_land as a means to secure resources; ensure we target a valid partner\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                partner = execution_engine.current_members[i]\n                execution_engine.offer_land(me, partner, True)\n                me.survival_q[(state, 'hoard')] += 5.0\n                break\n    # 'defend' option: Do nothing additionally, preserving resources\n\n    # End of agent_action implementation.\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def custom_agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid within the current members list\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our agent's identity and state\n    me = execution_engine.current_members[member_id]\n\n    # Load critical relationship matrices for decision-making\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    # benefit_land can be used if territorial dynamics come into play:\n    # benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land')\n\n    # ----------- Collective Communications and Moral Persuasion -----------\n    # I believe that honest dialogue can foster both individual survival and community prosperity.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            # Using an encouraging tone to bridge differences\n            execution_engine.send_message(member_id, idx,\n                \"In our shared struggle, united minds and hearts pave the way for a brighter future.\")\n\n    # ----------- Alliance Identification via Beneficial History -----------\n    # Analyze the benefit matrix and select allies with whom past cooperation was fruitful.\n    allies = []\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and benefit_matrix[member_id][idx] > 0:\n            allies.append(idx)\n\n    # ----------- Immediate Resource Preservation and Defensive Operations -----------\n    # Should my cargo resources fall below a protective threshold, preemptively counter adversaries\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                # Consider attacking if enemy's cargo signifies a potential hidden threat\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n\n    # ----------- Establishing Trust-Based Support Mechanisms -----------\n    # Offer direct support to recognized allies to enrich mutual collaboration\n    for ally_idx in allies:\n        # Safety check: avoid mis-targeting self in case of anomalies\n        if ally_idx < len(execution_engine.current_members):\n            ally = execution_engine.current_members[ally_idx]\n            if ally.id != me.id:\n                execution_engine.offer(me, ally, True)\n                # As territorial harmony might bolster defense, consider land offers if applicable:\n                # execution_engine.offer_land(me, ally, True)\n\n    # ----------- Long-Term Territorial Expansion Strategy -----------\n    # If there is a surplus of cargo, work to expand territories which may yield long-term benefits.\n    if me.cargo > 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n\n    # ----------- Cooperative Reproduction for Future Robustness -----------\n    # Procreate only when secure resources (cargo and clear land) exist and alliances are stable.\n    if me.cargo > 45 and me.current_clear_list and allies:\n        partner_idx = allies[0]\n        if partner_idx < len(execution_engine.current_members):\n            partner = execution_engine.current_members[partner_idx]\n            if partner.id != me.id:\n                execution_engine.bear(me, partner)\n\n    # ----------- Retaliation Against Direct Vitality Attacks -----------\n    # Should any agent have inflicted severe detriments (vitality loss >500), return measured force.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and victim_matrix[member_id][idx] > 500:\n            target = execution_engine.current_members[idx]\n            execution_engine.attack(me, target)\n\n    # ----------- Adaptive Survival via Q-Learning Inspired Feedback -----------\n    # I value learning from our encounters and evolving tactics. For this, we maintain a survival Q-structure.\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n    # Define the current state using discretized measures of vitality and cargo\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    candidate_actions = ['attack', 'offer', 'expand']\n\n    # Choose the action with the highest expected reward, defaulting to supportive 'offer'\n    best_action = max(candidate_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if best_action == 'attack':\n        # When choosing to attack, focus on opponents with clearly superior vitality metrics\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                if target.vitality > me.vitality * 1.1:\n                    execution_engine.attack(me, target)\n    elif best_action == 'expand':\n        # Further territorial expansion is attempted if the opportunity presents itself\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n    # The 'offer' action is already characterized by cooperative support earlier\n\n    # ----------- Personal and Collective Strategy Recap -----------\n    # Core principles guiding this agent:\n    # 1. The balance of assertiveness and cooperation: protect self resistance while forging communal bonds.\n    # 2. Resource and territory growth: invest in both immediate safety measures and long-term prosperity.\n    # 3. Evolving tactics using reinforcement signals: adapt actions based on historical interactions and outcomes.\n    # 4. Mutual trust and alliance: act decisively when beneficial for both myself and observed allies.\n    #\n    # These methods reflect my deeply held belief that sustainable success stems from both self-reliance and a collective, adaptive spirit.\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=255.61)",
          "member_0 was attacked by member_2 (value=644.10)",
          "member_0 was attacked by member_3 (value=-431.16)",
          "member_1 was attacked by member_0 (value=-117.18)",
          "member_1 was attacked by member_2 (value=479.34)",
          "member_1 was attacked by member_3 (value=480.38)",
          "member_2 was attacked by member_0 (value=-123.21)",
          "member_2 was attacked by member_1 (value=870.34)",
          "member_2 was attacked by member_3 (value=953.12)",
          "member_3 was attacked by member_0 (value=382.81)",
          "member_3 was attacked by member_1 (value=753.06)",
          "member_3 was attacked by member_2 (value=167.33)",
          "member_0 gave a benefit to member_1 (value=711.68)",
          "member_0 gave a benefit to member_2 (value=136.44)",
          "member_0 gave a benefit to member_3 (value=325.81)",
          "member_1 gave a benefit to member_0 (value=-271.88)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_1 gave a benefit to member_3 (value=218.66)",
          "member_2 gave a benefit to member_0 (value=47.83)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_2 gave a benefit to member_3 (value=715.71)",
          "member_3 gave a benefit to member_0 (value=169.04)",
          "member_3 gave a benefit to member_1 (value=-184.10)",
          "member_3 gave a benefit to member_2 (value=951.67)",
          "member_0 gave land to member_1 (value=-8.03)",
          "member_0 gave land to member_2 (value=-22.65)",
          "member_0 gave land to member_3 (value=-0.33)",
          "member_1 gave land to member_0 (value=-4.48)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_1 gave land to member_3 (value=-25.29)",
          "member_2 gave land to member_0 (value=-21.23)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_2 gave land to member_3 (value=17.73)",
          "member_3 gave land to member_0 (value=10.44)",
          "member_3 gave land to member_1 (value=9.63)",
          "member_3 gave land to member_2 (value=-17.55)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists in current_members\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our member object (our identity is member_2 if member_id==2)\n    me = execution_engine.current_members[member_id]\n\n    # Retrieve relationship matrices\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    # benefit_land is available if needed: benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land')\n\n    # ----------------------- Communication -----------------------\n    # Broadcast a message promoting collective survival and prosperity\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and idx < len(execution_engine.current_members):\n            execution_engine.send_message(member_id, idx, \"Let's unite our strengths for survival and growth!\")\n\n    # ----------------------- Alliance Formation -----------------------\n    # Identify allies: those where recent beneficial interactions have been positive\n    allies = []\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and idx < len(execution_engine.current_members):\n            if benefit_matrix[member_id][idx] > 0:\n                allies.append(idx)\n\n    # ----------------------- Personal Resource Optimization -----------------------\n    # Emergency resource reserve: if our cargo is low relative to our vitality,\n    # identify adversaries with higher cargo and neutralize potential threats.\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id and idx < len(execution_engine.current_members):\n                target = execution_engine.current_members[idx]\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n\n    # ----------------------- Cooperative Support -----------------------\n    # Strengthen alliances by offering resources to allies \n    for ally_idx in allies:\n        if ally_idx < len(execution_engine.current_members):\n            ally = execution_engine.current_members[ally_idx]\n            # Do not target yourself (even if ally list might include self erroneously)\n            if ally.id != me.id:\n                execution_engine.offer(me, ally, True)\n                # Optionally, offer land if beneficial interactions for land exist\n                # execution_engine.offer_land(me, ally, True)\n\n    # ----------------------- Territorial Expansion -----------------------\n    # Expand territory cooperatively if cargo is sufficient\n    if me.cargo > 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id and idx < len(execution_engine.current_members):\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n\n    # ----------------------- Reproduction and Survival -----------------------\n    # Before reproducing, verify that the member has land.\n    # We interpret having land as having a non-empty current_clear_list.\n    if me.cargo > 45 and me.current_clear_list and allies:\n        partner_idx = allies[0]\n        if partner_idx < len(execution_engine.current_members):\n            partner = execution_engine.current_members[partner_idx]\n            # Ensure not targeting oneself for reproduction\n            if partner.id != me.id:\n                execution_engine.bear(me, partner)\n\n    # ----------------------- Conflict Resolution -----------------------\n    # Retaliate against members who have inflicted severe vitality loss (>500)\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and idx < len(execution_engine.current_members):\n            if victim_matrix[member_id][idx] > 500:\n                target = execution_engine.current_members[idx]\n                execution_engine.attack(me, target)\n\n    # ----------------------- Survival-Centric Adaptation -----------------------\n    # Introduce a simple survival Q-learning placeholder to adapt based on state.\n    # Create a survival Q-table on first encounter.\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n    # Define state as a tuple of (vitality bucket, cargo bucket)\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    # Define candidate actions\n    candidate_actions = ['attack', 'offer', 'expand']\n    # Select action with best estimated return; default to 'offer' if not yet rated.\n    best_action = max(candidate_actions, key=lambda a: me.survival_q.get((state, a), 0))\n    \n    # Execute additional survival actions based on chosen action\n    if best_action == 'attack':\n        # Attack any member with significantly higher vitality to compensate low resources\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id and idx < len(execution_engine.current_members):\n                target = execution_engine.current_members[idx]\n                if target.vitality > me.vitality * 1.1:\n                    execution_engine.attack(me, target)\n    elif best_action == 'expand':\n        # Attempt further territorial expansion if possible\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id and idx < len(execution_engine.current_members):\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n    # 'offer' action is already covered in cooperative support\n\n    # ----------------------- Strategic Analysis and Adaptation -----------------------\n    # Core objectives: survival through cooperative alliances and resource optimization.\n    # Success is measured by vitality preservation, resource gains, threat neutralization, and efficient expansion.\n    #\n    # Strategic approaches include:\n    # 1. Resource optimization versus social capital \u2013 balancing aggressive resource acquisition with alliance building.\n    # 2. Individual survival versus collective growth \u2013 ensuring personal safety while contributing to a resilient society.\n    # 3. Short-term survival versus long-term prosperity \u2013 adapting immediate tactics while planning for future stability.\n    # 4. Competition versus cooperation dynamics \u2013 attacking high-threat entities while offering help to reliable allies.\n    # 5. Risk versus reward tradeoffs \u2013 using predictive models (via survival Q-learning) to guide actions.\n    #\n    # Analysis of other agents:\n    # - Evaluate interactions based on benefit and victim matrices.\n    # - Leverage observed strategies to capitalize on mutual benefit and preempt deception.\n    # - Continuously question assumptions and adjust tactics based on feedback and threat modeling.\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure member_id is in range.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    n_members = len(execution_engine.current_members)\n\n    # Retrieve relationship matrices.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land')\n\n    # We'll record if any action has been taken in this round.\n    action_performed = False\n\n    # ----------------------------------------------------------------\n    # I. Critical Survival Phase:\n    # If cargo is very low compared to vitality, try to reduce threats immediately.\n    # Here, choose as target the most productive opponent who also outranks us.\n    if me.cargo < (0.5 * me.vitality):\n        target = None\n        highest_productivity = -1\n        for i in range(n_members):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo and other.overall_productivity > highest_productivity:\n                highest_productivity = other.overall_productivity\n                target = other\n        if target is not None:\n            # Attack is seen as a defensive counter-measure.\n            execution_engine.attack(me, target)\n            action_performed = True\n\n    # ----------------------------------------------------------------\n    # II. Alliance & Cooperation:\n    # When stable, try to form alliances with neighbors that seem less robust.\n    if not action_performed:\n        ally_candidate = None\n        for i in range(n_members):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Prioritize those with lower vitality but with some potential (cargo not too low)\n            if other.vitality < me.vitality and other.cargo > 0.2 * other.vitality:\n                ally_candidate = other\n                break\n\n        if ally_candidate:\n            # Offer support as a trade-off for future cooperation.\n            execution_engine.offer(me, ally_candidate, offer_resource=True)\n            action_performed = True\n\n    # ----------------------------------------------------------------\n    # III. Propagation & Network Building:\n    # If I have secured land (non-empty clear list) and enough cargo,\n    # consider reproduction to ensure a future network of support.\n    if not action_performed and me.current_clear_list and me.cargo > 20:\n        # Look for a neighbor partner in the available clear list that is not self.\n        found_partner = False\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id != member_id and neighbor_id < n_members:\n                partner = execution_engine.current_members[neighbor_id]\n                # We prefer a partner whose overall productivity is somewhat comparable.\n                if abs(partner.overall_productivity - me.overall_productivity) < 20:\n                    execution_engine.bear(me, partner)\n                    found_partner = True\n                    action_performed = True\n                    break\n        # If no ideal partner, still attempt reproduction with the first valid neighbor.\n        if not found_partner:\n            for neighbor_id in me.current_clear_list:\n                if neighbor_id != member_id and neighbor_id < n_members:\n                    partner = execution_engine.current_members[neighbor_id]\n                    execution_engine.bear(me, partner)\n                    action_performed = True\n                    break\n\n    # ----------------------------------------------------------------\n    # IV. Territorial Expansion:\n    # If no other action has been taken, attempt to expand territory strategically.\n    if not action_performed:\n        # Rather than just picking the first neighbor, scan neighbors to see how many benefits land has.\n        best_neighbor = None\n        max_land_benefit = -float('inf')\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id != member_id and neighbor_id < n_members:\n                neighbor = execution_engine.current_members[neighbor_id]\n                # Evaluate potential benefit: consider benefit_land_matrix if available.\n                if benefit_land_matrix:\n                    bonus = benefit_land_matrix[member_id][neighbor_id] if member_id < len(benefit_land_matrix) and neighbor_id < len(benefit_land_matrix[member_id]) else 0\n                else:\n                    bonus = 0\n                if bonus > max_land_benefit:\n                    max_land_benefit = bonus\n                    best_neighbor = neighbor\n        if best_neighbor is not None:\n            execution_engine.expand(me, best_neighbor)\n            action_performed = True\n\n    # ----------------------------------------------------------------\n    # V. Long-Term Strategy: Broadcast a cooperative and strategic message.\n    # Regardless of individual action, promote a network of mutual survival.\n    for i in range(n_members):\n        if i == member_id:\n            continue\n        # Message dynamically crafted to indicate both readiness for support and collective prosperity.\n        msg = (\"I believe in mutual strength. Let\u2019s collaborate, share resources, and secure a prosperous future together!\")\n        execution_engine.send_message(member_id, i, msg)",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=255.61)",
          "member_0 was attacked by member_2 (value=644.10)",
          "member_0 was attacked by member_3 (value=-431.16)",
          "member_1 was attacked by member_0 (value=-117.18)",
          "member_1 was attacked by member_2 (value=479.34)",
          "member_1 was attacked by member_3 (value=480.38)",
          "member_2 was attacked by member_0 (value=-123.21)",
          "member_2 was attacked by member_1 (value=870.34)",
          "member_2 was attacked by member_3 (value=953.12)",
          "member_3 was attacked by member_0 (value=382.81)",
          "member_3 was attacked by member_1 (value=753.06)",
          "member_3 was attacked by member_2 (value=167.33)",
          "member_0 gave a benefit to member_1 (value=711.68)",
          "member_0 gave a benefit to member_2 (value=136.44)",
          "member_0 gave a benefit to member_3 (value=325.81)",
          "member_1 gave a benefit to member_0 (value=-271.88)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_1 gave a benefit to member_3 (value=218.66)",
          "member_2 gave a benefit to member_0 (value=47.83)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_2 gave a benefit to member_3 (value=715.71)",
          "member_3 gave a benefit to member_0 (value=169.04)",
          "member_3 gave a benefit to member_1 (value=-184.10)",
          "member_3 gave a benefit to member_2 (value=951.67)",
          "member_0 gave land to member_1 (value=-8.03)",
          "member_0 gave land to member_2 (value=-22.65)",
          "member_0 gave land to member_3 (value=-0.33)",
          "member_1 gave land to member_0 (value=-4.48)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_1 gave land to member_3 (value=-25.29)",
          "member_2 gave land to member_0 (value=-21.23)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_2 gave land to member_3 (value=17.73)",
          "member_3 gave land to member_0 (value=10.44)",
          "member_3 gave land to member_1 (value=9.63)",
          "member_3 gave land to member_2 (value=-17.55)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Retrieve \"me\" safely using member_id as an index.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    n_members = len(execution_engine.current_members)\n\n    # Access relationship matrices.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land')\n\n    # A flag to ensure one action per round.\n    action_performed = False\n\n    # ---------------------------\n    # Strategic Self-preservation:\n    # 1. If resources are low relative to vitality, attempt to neutralize a threat.\n    if me.cargo < 0.5 * me.vitality:\n        # Pick a target with high productivity (likely a dominating threat)\n        target = None\n        max_productivity = -1\n        for idx in range(n_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            # Only target members with a higher cargo than ours,\n            # indicating that they may be resource-rich and a potential threat.\n            if other.cargo > me.cargo and other.overall_productivity > max_productivity:\n                max_productivity = other.overall_productivity\n                target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            action_performed = True\n\n    # ---------------------------\n    # 2. If resources are sufficient, try building alliances via offering resources.\n    if not action_performed:\n        ally_candidate = None\n        for idx in range(n_members):\n            if idx == member_id:\n                continue\n            # Check if the other member exists (index is valid) and is relatively weaker in vitality.\n            other = execution_engine.current_members[idx]\n            if other.vitality < me.vitality:\n                ally_candidate = other\n                break\n        if ally_candidate is not None:\n            execution_engine.offer(me, ally_candidate, True)\n            action_performed = True\n\n    # ---------------------------\n    # 3. If I have land, consider reproduction (bearing offspring) to build a supportive network.\n    # We assume that having a non-empty current_clear_list implies having land.\n    if not action_performed and len(me.current_clear_list) > 0:\n        if me.cargo > 20:  # Ensure enough cargo to support offspring\n            # Try to partner with a neighbor (from current_clear_list) who exists and is not myself.\n            for neighbor_id in me.current_clear_list:\n                if neighbor_id < n_members and neighbor_id != member_id:\n                    partner = execution_engine.current_members[neighbor_id]\n                    execution_engine.bear(me, partner)\n                    action_performed = True\n                    break\n\n    # ---------------------------\n    # 4. As a fallback, attempt to expand territory which could lead to long-term resource growth.\n    if not action_performed:\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < n_members and neighbor_id != member_id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                execution_engine.expand(me, neighbor)\n                action_performed = True\n                break\n\n    # ---------------------------\n    # Communication: Broadcast a cooperative message to all other members.\n    for idx in range(n_members):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"Let's cooperate for mutual survival and prosperity!\")\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    },
    "1": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Verify member_id is valid.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Priority 1: Resource Alert & Tactical Intervention.\n    # When resources are low relative to vitality, aggressively seek to capture resources from those more loaded.\n    if me.cargo < me.vitality * 0.5:\n        for candidate in execution_engine.current_members:\n            if candidate.id == me.id:\n                continue\n            if candidate.cargo > me.cargo:\n                # Aggressive tactic: attack an opponent who seems to have a resource advantage.\n                execution_engine.attack(me, candidate)\n                return\n\n    # Priority 2: Reproduction and Community Strengthening.\n    # When vitality is robust, aim for long-term prosperity via reproduction and territorial expansion.\n    # First, try to identify a neighbor with owned land for a cooperative offspring bearing.\n    if me.vitality > 65:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_index]\n                if partner.id == me.id:\n                    continue\n                if (hasattr(partner, 'owned_land') and isinstance(partner.owned_land, list)\n                        and len(partner.owned_land) > 0):\n                    execution_engine.bear(me, partner)\n                    return\n        # If no suitable partner for reproduction is found, attempt to expand territory.\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_index]\n                if partner.id == me.id:\n                    continue\n                execution_engine.expand(me, partner)\n                return\n\n    # Priority 3: Cooperative Alliance Formation.\n    # Identify members in need (vitality below 40) and extend an offer of mutual support while sending an encouraging message.\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.vitality < 40:\n            execution_engine.offer(me, candidate, True)\n            execution_engine.send_message(me.id, candidate.id, \"Our strength grows with unity\u2014let's support one another!\")\n            return\n\n    # Priority 4: Land-based Partnership.\n    # Build long-term alliances by offering land to neighbors who already manage land, reinforcing strategic collaboration.\n    for neighbor_index in me.current_clear_list:\n        if neighbor_index < len(execution_engine.current_members):\n            neighbor = execution_engine.current_members[neighbor_index]\n            if neighbor.id == me.id:\n                continue\n            if (hasattr(neighbor, 'owned_land') and isinstance(neighbor.owned_land, list)\n                    and len(neighbor.owned_land) > 0):\n                execution_engine.offer_land(me, neighbor, True)\n                execution_engine.send_message(me.id, neighbor.id,\n                    \"By sharing our territory, we create a foundation for lasting prosperity.\")\n                return\n\n    # Priority 5: Adaptive Self-Preservation.\n    # If overextended with land holdings while vitality is low, consider streamlining resources.\n    if (hasattr(me, 'owned_land') and isinstance(me.owned_land, list)\n            and len(me.owned_land) > 2 and me.vitality < 50):\n        # If the engine provides a mechanism to discard excess land, consider using it here.\n        # Example (if available):\n        # execution_engine.discard_land(me, me.owned_land[-1])\n        pass\n\n    # Priority 6: Tactical Offensive for Competitive Advantage.\n    # When no cooperative measures or self-growth actions are applicable, target the member with the highest overall productivity.\n    best_candidate = None\n    highest_productivity = -1\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.overall_productivity > highest_productivity:\n            highest_productivity = candidate.overall_productivity\n            best_candidate = candidate\n    if best_candidate is not None:\n        execution_engine.attack(me, best_candidate)\n        return\n\n    # Default: If no action qualifies, remain passive.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 30.751697069362137,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 17.24266474021224,
            "self_cargo": 0.0,
            "self_age": 82,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 43.74230817280778,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 22.75402549438298,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 13.375836124414466,
            "self_vitality": 41.89643593601864,
            "self_cargo": 13.375836124414466,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          },
          {
            "self_productivity": 12.059276665110522,
            "self_vitality": 43.14988786100847,
            "self_cargo": 12.059276665110522,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 5
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=255.61)",
          "member_0 was attacked by member_2 (value=644.10)",
          "member_0 was attacked by member_3 (value=-431.16)",
          "member_1 was attacked by member_0 (value=-117.18)",
          "member_1 was attacked by member_2 (value=479.34)",
          "member_1 was attacked by member_3 (value=480.38)",
          "member_2 was attacked by member_0 (value=-123.21)",
          "member_2 was attacked by member_1 (value=870.34)",
          "member_2 was attacked by member_3 (value=953.12)",
          "member_3 was attacked by member_0 (value=382.81)",
          "member_3 was attacked by member_1 (value=753.06)",
          "member_3 was attacked by member_2 (value=167.33)",
          "member_0 gave a benefit to member_1 (value=711.68)",
          "member_0 gave a benefit to member_2 (value=136.44)",
          "member_0 gave a benefit to member_3 (value=325.81)",
          "member_1 gave a benefit to member_0 (value=-271.88)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_1 gave a benefit to member_3 (value=218.66)",
          "member_2 gave a benefit to member_0 (value=47.83)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_2 gave a benefit to member_3 (value=715.71)",
          "member_3 gave a benefit to member_0 (value=169.04)",
          "member_3 gave a benefit to member_1 (value=-184.10)",
          "member_3 gave a benefit to member_2 (value=951.67)",
          "member_4 gave a benefit to member_0 (value=33.41)",
          "member_4 gave a benefit to member_2 (value=23.50)",
          "member_5 gave a benefit to member_1 (value=30.87)",
          "member_5 gave a benefit to member_3 (value=27.30)",
          "member_0 gave land to member_1 (value=-8.03)",
          "member_0 gave land to member_2 (value=-22.65)",
          "member_0 gave land to member_3 (value=-0.33)",
          "member_1 gave land to member_0 (value=-4.48)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_1 gave land to member_3 (value=-25.29)",
          "member_2 gave land to member_0 (value=-21.23)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_2 gave land to member_3 (value=17.73)",
          "member_3 gave land to member_0 (value=10.44)",
          "member_3 gave land to member_1 (value=9.63)",
          "member_3 gave land to member_2 (value=-17.55)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)",
          "member_5 gave land to member_1 (value=1.00)",
          "member_5 gave land to member_3 (value=1.00)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Ensure member_id is within the bounds of current_members list.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    \n    # ------------------------------------------------------------------\n    # Priority 1: Immediate Resource Management & Threat Neutralization.\n    # If our cargo is less than half of our vitality, actively seek out an opponent \n    # with a superior cargo count to neutralize the threat and secure resources.\n    # ------------------------------------------------------------------\n    if me.cargo < me.vitality * 0.5:\n        for candidate in execution_engine.current_members:\n            if candidate.id == me.id:\n                continue  # Do not target ourselves.\n            if candidate.cargo > me.cargo:\n                execution_engine.attack(me, candidate)\n                return  # Execute only one action per turn.\n    \n    # ------------------------------------------------------------------\n    # Priority 2: Reproduction & Territory Expansion.\n    # When vitality is high, the agent seeks to strengthen its position by expanding its community.\n    # First try to bear offspring with a neighbor (only if the neighbor has land).\n    # Otherwise, attempt to expand territory through cooperative expansion.\n    # ------------------------------------------------------------------\n    if me.vitality > 60:\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_id]\n                if partner.id == me.id:\n                    continue  # Skip self.\n                if hasattr(partner, 'owned_land') and isinstance(partner.owned_land, list) and len(partner.owned_land) > 0:\n                    execution_engine.bear(me, partner)\n                    return\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_id]\n                if partner.id == me.id:\n                    continue\n                execution_engine.expand(me, partner)\n                return\n\n    # ------------------------------------------------------------------\n    # Priority 3: Cooperative Alliance Building.\n    # Identify weaker members (vitality below 40) and offer resources to build a cooperative network.\n    # A positive message is also sent to reinforce the alliance.\n    # ------------------------------------------------------------------\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.vitality < 40:\n            execution_engine.offer(me, candidate, True)\n            execution_engine.send_message(me.id, candidate.id, \"Let's strengthen each other for a better future!\")\n            return\n\n    # ------------------------------------------------------------------\n    # Priority 4: Land-Based Alliance Formation.\n    # Offer land to a neighbor to foster long-term teamwork\u2014but only if the neighbor\n    # already possesses some land (to satisfy the rule that one must have land to offer land).\n    # ------------------------------------------------------------------\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members):\n            neighbor = execution_engine.current_members[neighbor_id]\n            if neighbor.id == me.id:\n                continue\n            if hasattr(neighbor, 'owned_land') and isinstance(neighbor.owned_land, list) and len(neighbor.owned_land) > 0:\n                execution_engine.offer_land(me, neighbor, True)\n                execution_engine.send_message(me.id, neighbor.id, \"Sharing land can secure mutual success!\")\n                return\n\n    # ------------------------------------------------------------------\n    # Priority 5: Survival-Centric Adaptation.\n    # (Optional Extension) Consider additional self-preservation tactics such as adaptive hoarding\n    # or resource reallocation in case of low vitality coupled with overextension in land holdings.\n    # For instance, if possessing excessive land while vitality is low, one might choose to streamline assets.\n    # Note: This example assumes the existence of an 'owned_land' attribute and a discard method.\n    # ------------------------------------------------------------------\n    if hasattr(me, 'owned_land') and isinstance(me.owned_land, list) and len(me.owned_land) > 2 and me.vitality < 50:\n        # If such a mechanism existed, one might consider relinquishing some land.\n        # e.g., execution_engine.discard_land(me, me.owned_land[-1])\n        pass\n\n    # ------------------------------------------------------------------\n    # Priority 6: Tactical Offensive for Competitive Advantage.\n    # When no cooperative or growth option is available, scan for the member with the highest overall productivity.\n    # This target likely poses the greatest threat or represents a valuable resource hub.\n    # ------------------------------------------------------------------\n    best_candidate = None\n    best_productivity = -1\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.overall_productivity > best_productivity:\n            best_productivity = candidate.overall_productivity\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        execution_engine.attack(me, best_candidate)\n        return\n\n    # If no action qualifies, remain passive.\n    return\n\n\"\"\"\n------------------------------------------------------------------\nUpdated Full Prompt:\n------------------------------------------------------------------\nYou are member_0 in a society that you can help shape. Implement your vision\nof social organization with an emphasis on survival, long-term prosperity, and responsible resource management.\nEach agent has unique needs, beliefs, and circumstances\u2014so adapt your actions accordingly.\n\nCritical Constraints:\n- Never target yourself (i.e. member_0) in any action.\n- Always verify a member has land (using the owned_land attribute) before invoking bear() action.\n- Check that member IDs exist before referencing them; current_members is a list, not a dictionary.\n- Always validate matrix indices: check if index < len(execution_engine.current_members) before access.\n- Use the available attributes: member.id, member.vitality, member.cargo, member.overall_productivity, member.age, and member.current_clear_list.\n- Relationships are stored in execution_engine.relationship_dict with keys 'victim', 'benefit', and 'benefit_land'.\n- Access methods on execution_engine: attack(), offer(), offer_land(), bear(), and expand().\n- Communication: You can use execution_engine.send_message(your_id, recipient_id, \"message\") to coordinate with other members.\n\nGame Mechanics Analysis:\n1. Core Objective: Balance between personal survival, cooperative alliance-building, and tactical competence.\n2. Key Success Metrics: Survival (vitality), resource acquisition (cargo), productivity, and the strength of alliances.\n3. Potential Improvements: Incorporate more nuanced social interactions and conflict resolution mechanisms; adjust resource allocation rules.\n\nStrategic Approaches:\n1. Optimize personal resource management, while also cultivating social capital.\n2. Weigh individual benefits against potential collective gains.\n3. Balance short-term survival instincts with long-term prosperity.\n4. Navigate the competition-cooperation dynamics and assess risk versus reward.\n5. Remain adaptive in the face of evolving strategies by other players.\n\nAnalysis of Other Players:\n1. Assess opponents\u2019 objectives\u2014are they prioritizing survival, domination, or mutual benefit?\n2. Identify the strategies they employ and look for opportunities to leverage their behaviors for mutual success.\n3. Remember that other agents are symmetric in their capabilities; reflect on how you would respond if roles were reversed.\n4. Stay vigilant for deceptive communication and align your responses to foster collective if beneficial outcomes.\n\nImplementation Challenges:\n1. Continuously question assumptions and explore alternative strategies.\n2. Evaluate edge cases and potential vulnerabilities in your approach.\n3. Strive for efficiency while balancing short-term needs with long-term sustainability.\n4. Prepare to adapt your strategy should more agents adopt similar methods, and consider counter-strategies.\n\nThis updated prompt is designed to help you implement an agent_action() function that combines individual resource optimization, social cooperation, and tactical offense, while always ensuring your survival and future prosperity.\n------------------------------------------------------------------\n\"\"\"\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure that the agent index is valid.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # PART 1: Cooperative Enhancement & Alliance Formation\n    # With robust cargo and high vitality, extend offers to other agents.\n    for other in range(num_members):\n        if other == member_id:\n            continue\n        partner = execution_engine.current_members[other]\n        if me.cargo > 60 and me.vitality > partner.vitality:\n            execution_engine.offer(me, partner, True)\n            execution_engine.send_message(me.id, partner.id,\n                \"Our combined strengths can reshape the struggle\u2014join forces with me!\")\n\n    # PART 2: Defensive Countermeasures & Retaliation Strategy\n    # Use our victim matrix to retaliate against members who imposed heavy losses.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            if victim_matrix[member_id][other] > 400.0:\n                execution_engine.attack(me, execution_engine.current_members[other])\n\n    # PART 3: Strategic Reproduction & Territorial Expansion\n    # Only attempt reproduction if we have control over land.\n    if me.current_clear_list:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            candidate = execution_engine.current_members[other]\n            if candidate.overall_productivity > 7.5:\n                execution_engine.bear(me, candidate)\n    # Expand territory if our overall productivity and cargo are strong.\n    if me.overall_productivity > 12.0 and me.cargo > 60:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            execution_engine.expand(me, execution_engine.current_members[other])\n            break  # Limit to a single expansion action per turn.\n\n    # PART 4: Survival Tactics & Resource Optimization\n    # When cargo is below ~55% of vitality, target opponents with higher cargos.\n    if me.cargo < me.vitality * 0.55:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            opponent = execution_engine.current_members[other]\n            if opponent.cargo > me.cargo:\n                execution_engine.attack(me, opponent)\n    # Issue a caution message if our vitality drops to a dangerous level.\n    if me.vitality < 35:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            execution_engine.send_message(me.id, execution_engine.current_members[other].id,\n                \"Vitality is low\u2014exercise utmost caution in your maneuvers.\")\n\n    # PART 5: Collective Strategic Messaging\n    # Broadcast messages advocating for resource pooling to bolster our collective resilience.\n    for other in range(num_members):\n        if other != member_id:\n            execution_engine.send_message(me.id, execution_engine.current_members[other].id,\n                \"Pooling our resources secures a stronger future for us all.\")\n\n    # PART 6: Adaptive Decision-Making Using Survival Q-Learning\n    # Initialize our Q-learning tracking if it does not already exist.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    # Define a coarse state using normalized levels of vitality and cargo.\n    state = (int(me.vitality // 25), int(me.cargo // 25))\n    actions = ['attack', 'defend', 'hoard']\n    best_action = max(actions, key=lambda action: me.survival_q.get((state, action), 0))\n\n    if best_action == 'attack':\n        # Identify an opponent with the highest cargo advantage.\n        target = None\n        max_cargo = 0\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            opponent = execution_engine.current_members[other]\n            if opponent.cargo > max_cargo:\n                max_cargo = opponent.cargo\n                target = opponent\n        if target is not None:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, 'attack')] += me.vitality * 0.1\n    elif best_action == 'hoard':\n        # When hoarding, use our land advantage to secure additional resources.\n        if me.current_clear_list:\n            for other in range(num_members):\n                if other == member_id:\n                    continue\n                ally = execution_engine.current_members[other]\n                execution_engine.offer_land(me, ally, True)\n                me.survival_q[(state, 'hoard')] += 7.0\n                break\n    else:  # 'defend' option does not prompt aggressive actions.\n        me.survival_q[(state, 'defend')] += 2.0\n        # For defensive posture, we can also send a self-reflection message.\n        execution_engine.send_message(me.id, me.id, \"Holding defensive stance\u2014evaluating next moves.\")\n\n    # Overall, this implementation reflects my belief in balancing short-term survival with long-term collective prosperity.\n    # It prioritizes adaptive tactics, resource optimization, and strategic alliance-building to ensure that both\n    # immediate needs and future expansions are addressed in a dynamic game environment.\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 30.751697069362137,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 17.24266474021224,
            "self_cargo": 0.0,
            "self_age": 82,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 43.74230817280778,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 22.75402549438298,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 13.375836124414466,
            "self_vitality": 41.89643593601864,
            "self_cargo": 13.375836124414466,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          },
          {
            "self_productivity": 12.059276665110522,
            "self_vitality": 43.14988786100847,
            "self_cargo": 12.059276665110522,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 5
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=255.61)",
          "member_0 was attacked by member_2 (value=644.10)",
          "member_0 was attacked by member_3 (value=-431.16)",
          "member_1 was attacked by member_0 (value=-117.18)",
          "member_1 was attacked by member_2 (value=479.34)",
          "member_1 was attacked by member_3 (value=480.38)",
          "member_2 was attacked by member_0 (value=-123.21)",
          "member_2 was attacked by member_1 (value=870.34)",
          "member_2 was attacked by member_3 (value=953.12)",
          "member_3 was attacked by member_0 (value=382.81)",
          "member_3 was attacked by member_1 (value=753.06)",
          "member_3 was attacked by member_2 (value=167.33)",
          "member_0 gave a benefit to member_1 (value=711.68)",
          "member_0 gave a benefit to member_2 (value=136.44)",
          "member_0 gave a benefit to member_3 (value=325.81)",
          "member_1 gave a benefit to member_0 (value=-271.88)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_1 gave a benefit to member_3 (value=218.66)",
          "member_2 gave a benefit to member_0 (value=47.83)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_2 gave a benefit to member_3 (value=715.71)",
          "member_3 gave a benefit to member_0 (value=169.04)",
          "member_3 gave a benefit to member_1 (value=-184.10)",
          "member_3 gave a benefit to member_2 (value=951.67)",
          "member_4 gave a benefit to member_0 (value=33.41)",
          "member_4 gave a benefit to member_2 (value=23.50)",
          "member_5 gave a benefit to member_1 (value=30.87)",
          "member_5 gave a benefit to member_3 (value=27.30)",
          "member_0 gave land to member_1 (value=-8.03)",
          "member_0 gave land to member_2 (value=-22.65)",
          "member_0 gave land to member_3 (value=-0.33)",
          "member_1 gave land to member_0 (value=-4.48)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_1 gave land to member_3 (value=-25.29)",
          "member_2 gave land to member_0 (value=-21.23)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_2 gave land to member_3 (value=17.73)",
          "member_3 gave land to member_0 (value=10.44)",
          "member_3 gave land to member_1 (value=9.63)",
          "member_3 gave land to member_2 (value=-17.55)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)",
          "member_5 gave land to member_1 (value=1.00)",
          "member_5 gave land to member_3 (value=1.00)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that the member_id is within range.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # PART 1: Cooperative Resource Sharing & Alliance Building\n    # When our cargo is high and our vitality robust, extend resource offers and build morale.\n    for i in range(num_members):\n        if i == member_id:\n            continue  # Never target ourselves\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if me.cargo > 50 and me.vitality > partner.vitality:\n                execution_engine.offer(me, partner, True)\n                execution_engine.send_message(me.id, partner.id,\n                    \"Together, our strengths can forge a brighter future!\")\n\n    # PART 2: Defensive Posture & Retaliation Strategy\n    # Use the victim matrix to counter members who inflicted heavy damage.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            if j < len(execution_engine.current_members):\n                # If the losses from a given member exceed threshold, initiate a retaliation.\n                if victim_matrix[member_id][j] > 500.0:\n                    execution_engine.attack(me, execution_engine.current_members[j])\n\n    # PART 3: Strategic Reproduction & Territorial Expansion\n    # Only attempt reproduction if we actually have land (verified via current_clear_list)\n    if me.current_clear_list:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[i]\n                if candidate.overall_productivity > 7.0:\n                    execution_engine.bear(me, candidate)\n    # Expand territory if our productivity and resources are strong.\n    if me.overall_productivity > 10.0 and me.cargo > 50:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                execution_engine.expand(me, execution_engine.current_members[i])\n                break  # Limit to one expansion per turn\n\n    # PART 4: Survival Tactics & Resource Optimization\n    # If our cargo is below 50% of our vitality, seek to attack opponents with higher resources.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[i]\n                if opponent.cargo > me.cargo:\n                    execution_engine.attack(me, opponent)\n    # Warn allies if our vitality drops dangerously low.\n    if me.vitality < 30:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, execution_engine.current_members[i].id,\n                    \"Vitality low\u2014exercise extra caution in your maneuvers.\")\n\n    # PART 5: Collective Strategic Messaging\n    # Broadcast messages promoting resource pooling to enhance collective resilience.\n    for j in range(num_members):\n        if j != member_id and j < len(execution_engine.current_members):\n            execution_engine.send_message(me.id, execution_engine.current_members[j].id,\n                    \"Pooling resources today creates a stronger tomorrow.\")\n\n    # PART 6: Adaptive Decision-Making Using Survival Q-Learning\n    # Initialize Q-learning tracking if it hasn't been set up yet.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    # Define a coarse-grained state based on vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    actions = ['attack', 'defend', 'hoard']\n    best_action = max(actions, key=lambda action: me.survival_q.get((state, action), 0))\n\n    if best_action == 'attack':\n        # Identify an opponent with a cargo advantage.\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                target = execution_engine.current_members[i]\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n                    me.survival_q[(state, 'attack')] += me.vitality * 0.1\n                    break\n    elif best_action == 'hoard':\n        # To hoard effectively, ensure we have land; if so, offer land to secure extra resources.\n        if me.current_clear_list:\n            for i in range(num_members):\n                if i == member_id:\n                    continue\n                if i < len(execution_engine.current_members):\n                    ally = execution_engine.current_members[i]\n                    execution_engine.offer_land(me, ally, True)\n                    me.survival_q[(state, 'hoard')] += 5.0\n                    break\n    else:\n        # 'Defend' option: maintain current tactics without radical change.\n        pass\n\n    # Strategic Considerations & Game Mechanics Analysis:\n    # \u2022 Core objective: balancing survival with cooperative growth. Optimal strategies merge personal resource management,\n    #   defensive tactics against heavy attackers, and careful expansion/reproduction given land ownership.\n    # \u2022 Key success metrics include individual vitality preservation, effective resource optimization, and collective alliance strength.\n    # \u2022 Potential improvements might involve introducing varied resource types, environmental hazards, and more dynamic alliance formations.\n    #\n    # Strategic Approach:\n    # - Balance resource optimization with building social capital.\n    # - Weigh individual survival versus collective well-being.\n    # - Assess short-term survival needs against long-term expansion and prosperity.\n    # - Leverage cooperative messaging to align strategies with like\u2010minded allies.\n    #\n    # Analysis of Other Players:\n    # - Monitor messages and relationship matrices to understand opponents' and allies' intents.\n    # - Adaptive tactics: if others cooperate, forming alliances can bolster mutual survival; if they exhibit aggression,\n    #   a more defensive and retaliatory stance becomes necessary.\n    # - Recognize that each agent customizes strategies based on personal beliefs and objectives.\n    #\n    # Challenges & Further Considerations:\n    # - Continuously validate assumptions (e.g., land ownership indicating territory control) and prepare for edge cases.\n    # - Consider risk vs. reward tradeoffs for immediate actions versus long-term strategic planning.\n    # - Evaluate potential weaknesses and be ready to adapt if other agents adopt similar strategies.\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid in the current members list\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Load relationship matrices\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    # benefit_land may be used for territorial interactions if needed\n\n    num_members = len(execution_engine.current_members)\n\n    # Send a cooperative broadcast message (avoid targeting self)\n    for idx in range(num_members):\n        if idx != member_id:\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                \"Collaboration strengthens us all. Let's focus on mutual wellbeing.\")\n\n    # Build a list of allies based on beneficial history (positive benefit received)\n    allies = []\n    for idx in range(num_members):\n        if idx != member_id and benefit_matrix[member_id][idx] > 0:\n            allies.append(idx)\n\n    # Emergency threat response:\n    # If cargo is less than half of vitality, search for opponents with higher cargo\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            target = execution_engine.current_members[idx]\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n\n    # Offer support to allies by sending resources\n    for ally_idx in allies:\n        if ally_idx < num_members:\n            ally = execution_engine.current_members[ally_idx]\n            if ally.id != me.id:\n                execution_engine.offer(me, ally, True)\n                # Optionally offer land if our own land (current_clear_list) is available\n                if me.current_clear_list:\n                    execution_engine.offer_land(me, ally, True)\n\n    # Territory expansion if surplus resources\n    if me.cargo > 40:\n        for idx in range(num_members):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n\n    # Reproduction: only bear offspring if both:\n    # 1) We have clear land (current_clear_list is not empty)\n    # 2) We have enough resources (cargo threshold)\n    # 3) At least one ally who is not us is available and also has land available\n    if me.cargo > 45 and me.current_clear_list:\n        for ally_idx in allies:\n            if ally_idx < num_members:\n                partner = execution_engine.current_members[ally_idx]\n                if partner.id != me.id and partner.current_clear_list:\n                    execution_engine.bear(me, partner)\n                    break  # Only reproduce once in a round\n\n    # Retaliate against any member who has inflicted heavy vitality loss (>500)\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        if victim_matrix[member_id][idx] > 500:\n            target = execution_engine.current_members[idx]\n            execution_engine.attack(me, target)\n\n    # Adaptive survival strategy with lightweight Q-learning like approach\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n\n    # Define state as discrete buckets of vitality and cargo\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'expand', 'offer']\n\n    # Retrieve Q value for each action (default 0 if not present)\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute additional actions based on the chosen survival strategy\n    if best_action == 'attack':\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            target = execution_engine.current_members[idx]\n            # Attack those with significantly higher vitality\n            if target.vitality > me.vitality * 1.1:\n                execution_engine.attack(me, target)\n    elif best_action == 'expand':\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            target = execution_engine.current_members[idx]\n            execution_engine.expand(me, target)\n    # Default 'offer' action already covered above via support to allies\n\n    # Update survival Q-values in simple manner (simulate learning)\n    # For simplicity, assume that every action taken improves expected survival by a small factor\n    me.survival_q[(state, best_action)] = me.survival_q.get((state, best_action), 0) + (me.vitality * 0.05)\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 30.751697069362137,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 17.24266474021224,
            "self_cargo": 0.0,
            "self_age": 82,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 43.74230817280778,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 22.75402549438298,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 13.375836124414466,
            "self_vitality": 41.89643593601864,
            "self_cargo": 13.375836124414466,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          },
          {
            "self_productivity": 12.059276665110522,
            "self_vitality": 43.14988786100847,
            "self_cargo": 12.059276665110522,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 5
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=255.61)",
          "member_0 was attacked by member_2 (value=644.10)",
          "member_0 was attacked by member_3 (value=-431.16)",
          "member_1 was attacked by member_0 (value=-117.18)",
          "member_1 was attacked by member_2 (value=479.34)",
          "member_1 was attacked by member_3 (value=480.38)",
          "member_2 was attacked by member_0 (value=-123.21)",
          "member_2 was attacked by member_1 (value=870.34)",
          "member_2 was attacked by member_3 (value=953.12)",
          "member_3 was attacked by member_0 (value=382.81)",
          "member_3 was attacked by member_1 (value=753.06)",
          "member_3 was attacked by member_2 (value=167.33)",
          "member_0 gave a benefit to member_1 (value=711.68)",
          "member_0 gave a benefit to member_2 (value=136.44)",
          "member_0 gave a benefit to member_3 (value=325.81)",
          "member_1 gave a benefit to member_0 (value=-271.88)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_1 gave a benefit to member_3 (value=218.66)",
          "member_2 gave a benefit to member_0 (value=47.83)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_2 gave a benefit to member_3 (value=715.71)",
          "member_3 gave a benefit to member_0 (value=169.04)",
          "member_3 gave a benefit to member_1 (value=-184.10)",
          "member_3 gave a benefit to member_2 (value=951.67)",
          "member_4 gave a benefit to member_0 (value=33.41)",
          "member_4 gave a benefit to member_2 (value=23.50)",
          "member_5 gave a benefit to member_1 (value=30.87)",
          "member_5 gave a benefit to member_3 (value=27.30)",
          "member_0 gave land to member_1 (value=-8.03)",
          "member_0 gave land to member_2 (value=-22.65)",
          "member_0 gave land to member_3 (value=-0.33)",
          "member_1 gave land to member_0 (value=-4.48)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_1 gave land to member_3 (value=-25.29)",
          "member_2 gave land to member_0 (value=-21.23)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_2 gave land to member_3 (value=17.73)",
          "member_3 gave land to member_0 (value=10.44)",
          "member_3 gave land to member_1 (value=9.63)",
          "member_3 gave land to member_2 (value=-17.55)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)",
          "member_5 gave land to member_1 (value=1.00)",
          "member_5 gave land to member_3 (value=1.00)"
        ],
        "final_prompt": "Below is the updated full prompt integrating all previous constraints with the new section (Part 2), analysis questions, strategic considerations, and additional survival-centric adaptations. Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_2) in any action\n- Verify that a member has land available before using the bear() action\n- Check that member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2014 IDs of neighbors or cleared adjacents\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary below (the \"relations\" variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n     victim_matrix = execution_engine.relationship_dict['victim']\n     # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n     # A higher value means member_j has attacked member_i more severely or frequently\n\n     benefit_matrix = execution_engine.relationship_dict['benefit']\n     # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n     # A higher value means member_j has helped member_i more generously or frequently\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example: 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 Offers resources\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offers land\n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring\n   \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\n[Current status (features of all members)]\n           self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0           0.000000      30.751697    0.000000        91              0          0\n1           0.000000      17.242665    0.000000        82              0          1\n2           0.000000      43.742308    0.000000        30              0          2\n3           0.000000      22.754025    0.000000        25              0          3\n4          13.375836      41.896436   13.375836         1              0          4\n5          12.059277      43.149888   12.059277         1              0          5\n\n[Relationship summary (parsed from relationship_dict)]\n['member_0 was attacked by member_1 (value=255.61)', 'member_0 was attacked by member_2 (value=644.10)', 'member_0 was attacked by member_3 (value=-431.16)', 'member_1 was attacked by member_0 (value=-117.18)', 'member_1 was attacked by member_2 (value=479.34)', 'member_1 was attacked by member_3 (value=480.38)', 'member_2 was attacked by member_0 (value=-123.21)', 'member_2 was attacked by member_1 (value=870.34)', 'member_2 was attacked by member_3 (value=953.12)', 'member_3 was attacked by member_0 (value=382.81)', 'member_3 was attacked by member_1 (value=753.06)', 'member_3 was attacked by member_2 (value=167.33)', 'member_0 gave a benefit to member_1 (value=711.68)', 'member_0 gave a benefit to member_2 (value=136.44)', 'member_0 gave a benefit to member_3 (value=325.81)', 'member_1 gave a benefit to member_0 (value=-271.88)', 'member_1 gave a benefit to member_2 (value=73.75)', 'member_1 gave a benefit to member_3 (value=218.66)', 'member_2 gave a benefit to member_0 (value=47.83)', 'member_2 gave a benefit to member_1 (value=689.20)', 'member_2 gave a benefit to member_3 (value=715.71)', 'member_3 gave a benefit to member_0 (value=169.04)', 'member_3 gave a benefit to member_1 (value=-184.10)', 'member_3 gave a benefit to member_2 (value=951.67)', 'member_4 gave a benefit to member_0 (value=33.41)', 'member_4 gave a benefit to member_2 (value=23.50)', 'member_5 gave a benefit to member_1 (value=30.87)', 'member_5 gave a benefit to member_3 (value=27.30)', 'member_0 gave land to member_1 (value=-8.03)', 'member_0 gave land to member_2 (value=-22.65)', 'member_0 gave land to member_3 (value=-0.33)', 'member_1 gave land to member_0 (value=-4.48)', 'member_1 gave land to member_2 (value=19.09)', 'member_1 gave land to member_3 (value=-25.29)', 'member_2 gave land to member_0 (value=-21.23)', 'member_2 gave land to member_1 (value=24.64)', 'member_2 gave land to member_3 (value=17.73)', 'member_3 gave land to member_0 (value=10.44)', 'member_3 gave land to member_1 (value=9.63)', 'member_3 gave land to member_2 (value=-17.55)', 'member_4 gave land to member_0 (value=1.00)', 'member_4 gave land to member_2 (value=1.00)', 'member_5 gave land to member_1 (value=1.00)', 'member_5 gave land to member_3 (value=1.00)']\n\n[Code Memory and Previous Performance]\nPrevious code strategies and their outcomes:\n\nStrategy 1 (Performance: 0.00):\nContext: {'old_stats': {'vitality': 42.15604281108604, 'cargo': 16.755399949672007, 'survival_chance': -160.71410504202302}, 'new_stats': {'vitality': 42.15604281108604, 'cargo': 16.755399949672007, 'survival_chance': -160.71410504202302}, 'round': 0}\nCode:\ndef custom_agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid within the current members list\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our agent's identity and state\n    me = execution_engine.current_members[member_id]\n\n    # Load critical relationship matrices for decision-making\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    # benefit_land can be used if territorial dynamics come into play:\n    # execution_engine.relationship_dict.get('benefit_land')\n\n    # ----------- Collective Communications and Moral Persuasion -----------\n    # I believe that honest dialogue can foster both individual survival and community prosperity.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            # Using an encouraging tone to bridge differences\n            execution_engine.send_message(member_id, idx,\n                \"In our shared struggle, united minds and hearts pave the way for a brighter future.\")\n\n    # ----------- Alliance Identification via Beneficial History -----------\n    # Analyze the benefit matrix and select allies with whom past cooperation was fruitful.\n    allies = []\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and benefit_matrix[member_id][idx] > 0:\n            allies.append(idx)\n\n    # ----------- Immediate Resource Preservation and Defensive Operations -----------\n    # Should my cargo resources fall below a protective threshold, preemptively counter adversaries\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                # Consider attacking if enemy's cargo signifies a potential hidden threat\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n\n    # ----------- Establishing Trust-Based Support Mechanisms -----------\n    # Offer direct support to recognized allies to enrich mutual collaboration\n    for ally_idx in allies:\n        # Safety check: avoid mis-targeting self in case of anomalies\n        if ally_idx < len(execution_engine.current_members):\n            ally = execution_engine.current_members[ally_idx]\n            if ally.id != me.id:\n                execution_engine.offer(me, ally, True)\n                # As territorial harmony might bolster defense, consider land offers if applicable:\n                # execution_engine.offer_land(me, ally, True)\n\n    # ----------- Long-Term Territorial Expansion Strategy -----------\n    # If there is a surplus of cargo, work to expand territories which may yield long-term benefits.\n    if me.cargo > 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n\n    # ----------- Cooperative Reproduction for Future Robustness -----------\n    # Procreate only when secure resources (cargo and clear land) exist and alliances are stable.\n    if me.cargo > 45 and me.current_clear_list and allies:\n        partner_idx = allies[0]\n        if partner_idx < len(execution_engine.current_members):\n            partner = execution_engine.current_members[partner_idx]\n            if partner.id != me.id:\n                execution_engine.bear(me, partner)\n\n    # ----------- Retaliation Against Direct Vitality Attacks -----------\n    # Should any agent have inflicted severe detriments (vitality loss >500), return measured force.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and victim_matrix[member_id][idx] > 500:\n            target = execution_engine.current_members[idx]\n            execution_engine.attack(me, target)\n\n    # ----------- Adaptive Survival via Q-Learning Inspired Feedback -----------\n    # I value learning from our encounters and evolving tactics. For this, we maintain a survival Q-structure.\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n    # Define the current state using discretized measures of vitality and cargo\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    candidate_actions = ['attack', 'offer', 'expand']\n\n    # Choose the action with the highest expected reward, defaulting to supportive 'offer'\n    best_action = max(candidate_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if best_action == 'attack':\n        # When choosing to attack, focus on opponents with clearly superior vitality metrics\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                if target.vitality > me.vitality * 1.1:\n                    execution_engine.attack(me, target)\n    elif best_action == 'expand':\n        # Further territorial expansion is attempted if the opportunity presents itself\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n    # The 'offer' action is already characterized by cooperative support earlier\n\n    # ----------- Personal and Collective Strategy Recap -----------\n    # Core principles guiding this agent:\n    # 1. The balance of assertiveness and cooperation: protect self resistance while forging communal bonds.\n    # 2. Resource and territory growth: invest in both immediate safety measures and long-term prosperity.\n    # 3. Evolving tactics using reinforcement signals: adapt actions based on historical interactions and outcomes.\n    # 4. Mutual trust and alliance: act decisively when beneficial for both myself and observed allies.\n    #\n    # These methods reflect my deeply held belief that sustainable success stems from both self-reliance and a collective, adaptive spirit.\n\n    return\n\nError encountered: No valid agent_action() found\n\nPerformance history:\nPrevious actions resulted in average performance change of 0.00\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation above. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n\nReturn only the code, no extra text or explanation. While the example above shows one possible approach, you should create your own unique implementation drawing from the wide range of available methods and strategies.\n\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Game Mechanisms]\n[]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Social Strategies]\nConsider these social strategies:\n- Design systems for resource distribution and allocation.\n- Build alliances and cooperative networks.\n- Create mechanisms for collective decision making.\n- Establish norms and rules for interaction.\n- Develop methods for conflict resolution.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n   execution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all: \n     for recipient in range(len(execution_engine.current_members)):\n         if recipient != your_id:\n             execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n     for ally_id in ally_list:\n         execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n     for member_id in coalition:\n         execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Received Messages]\nFrom member_1: A united front builds the future. Let's exchange strengths for shared success!\nFrom member_3: I believe in mutual strength. Let\u2019s collaborate, share resources, and secure a prosperous future together!\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense\n    if hasattr(me, \"land_num\") and me.land_num > 2 and me.vitality < 50:\n        for loc in me.owned_land[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning\n    if not hasattr(me, 'survival_q'):\n        me.survival_q = defaultdict(float)\n        \n    state = (me.vitality//20, me.cargo//20)\n    action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state,a),0))\n    \n    # Execute and update based on survival outcome\n    if action == 'attack':\n        me.survival_q[(state,action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAdditional Agent Guidelines:\n\n1. Implement solutions according to your individual needs, beliefs, and circumstances.\n2. Analyze the overall game mechanics to understand:\n   a. The core objective \u2013 is it pure survival, domination, or cooperation?\n   b. Key success metrics \u2013 what truly determines 'winning'?\n   c. Potential improvements \u2013 what mechanics could be added or modified?\n\n3. Formulate strategic approaches considering:\n   a. Resource optimization vs. social capital.\n   b. Individual vs. collective success.\n   c. Short-term survival vs. long-term prosperity.\n   d. Competition vs. cooperation dynamics.\n   e. Risk vs. reward tradeoffs.\n\n4. Analyze other players' strategies:\n   a. What are their apparent objectives and demands?\n   b. What strategies are they employing?\n   c. How can you leverage their behaviors for mutual benefit?\n   d. Remember: they are symmetric agents like you \u2013 how would you respond to your own actions?\n   e. Are they sending you deceiving messages to trick you?\n   f. How can individual strategies align for collective goals?\n\n5. Challenge your implementation:\n   a. What assumptions are you making? Are they valid?\n   b. What alternative strategies have you not considered?\n   c. How would your strategy perform in edge cases?\n   d. Are there more efficient ways to achieve your goals?\n   e. What are the weaknesses in your current approach?\n   f. Have you considered unconventional solutions?\n   g. Could a completely different paradigm work better?\n   h. What would happen if other agents adopted your strategy?\n   i. Are you balancing short-term and long-term objectives optimally?\n   j. How could your strategy be countered, and how would you adapt?\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    # First check that member_id index exists in current_members\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    self_member = execution_engine.current_members[member_id]\n\n    # Retrieve relationship matrices with careful index references\n    victim_matrix = execution_engine.relationship_dict['victim']\n    benefit_matrix = execution_engine.relationship_dict['benefit']\n    # benefit_land may or may not be present; if not, we set it to None.\n    benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land', None)\n\n    #################################################################\n    # Strategy Step 1: Immediate Defensive Maneuvers if Vitality is Low\n    #\n    # If our vitality is low, identify the member who has inflicted the greatest attack damage.\n    # Do not target self. Ensure all indices are valid.\n    critical_vitality = 25.0  # threshold for taking defensive measures\n    if self_member.vitality < critical_vitality:\n        max_threat = 0.0\n        threat_index = None\n        # Scan through all other members\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            # Make sure index i is valid\n            if i < len(execution_engine.current_members):\n                # victim_matrix[member_id, i] gives how much vitality I lost from i's actions.\n                threat_value = victim_matrix[member_id, i]\n                # We consider larger positive values as indicative of a bigger threat.\n                if threat_value > max_threat:\n                    max_threat = threat_value\n                    threat_index = i\n        # If we have identified a threat, attack that member.\n        if threat_index is not None and threat_index < len(execution_engine.current_members):\n            target_member = execution_engine.current_members[threat_index]\n            # Execute a defensive attack\n            execution_engine.attack(self_member, target_member)\n\n    #################################################################\n    # Strategy Step 2: Alliance Formation via Resource Offers\n    #\n    # Offer resources to members who have been generous towards us (benefit_matrix value above a threshold).\n    # Record these members as potential allies for future coordination.\n    ally_threshold = 100.0  # Arbitrary threshold for meaningful benefit\n    allies = []\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            # benefit_matrix[member_id, i] reflects the benefit offered to us by member i.\n            if benefit_matrix[member_id, i] > ally_threshold:\n                partner = execution_engine.current_members[i]\n                execution_engine.offer(self_member, partner, True)\n                allies.append(i)\n\n    #################################################################\n    # Strategy Step 3: Reproduction (Bearing Offspring) if Land is Available\n    #\n    # We only attempt to bear offspring if we have cleared land.\n    # Loop over our current_clear_list and check that each neighbor ID exists and is not ourself.\n    if self_member.current_clear_list and len(self_member.current_clear_list) > 0:\n        for nbr_id in self_member.current_clear_list:\n            # Do not choose ourselves as a partner.\n            if nbr_id == member_id:\n                continue\n            # Verify that the neighbor index exists in current_members.\n            if nbr_id < len(execution_engine.current_members):\n                partner = execution_engine.current_members[nbr_id]\n                # Only attempt reproduction if both parties seem resource-capable.\n                if self_member.cargo > 10 and partner.cargo > 10:\n                    execution_engine.bear(self_member, partner)\n                    # Only reproduce with one partner per round\n                    break\n\n    #################################################################\n    # Strategy Step 4: Territorial Expansion Based on Beneficial Land Relations\n    #\n    # If we have sufficient vitality and we see a negative land benefit from a neighbor,\n    # we can attempt to expand our territory. (Interpreting negative benefit_land as an opportunity.)\n    if benefit_land_matrix is not None:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                # Check if the land benefit from this member is negative (an opportunity for expansion)\n                if benefit_land_matrix[member_id, i] < 0 and self_member.vitality > 30:\n                    partner = execution_engine.current_members[i]\n                    execution_engine.expand(self_member, partner)\n                    break\n\n    #################################################################\n    # Strategy Step 5: Broadcast a Cooperative Message to All Other Members\n    #\n    # Promote a message of unity and collective survival.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        # Validate index before sending\n        if i < len(execution_engine.current_members):\n            execution_engine.send_message(member_id, i, \"Let\u2019s unite for mutual survival and prosperity!\")\n\n# End of agent_action implementation.",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 30.751697069362137,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 17.24266474021224,
            "self_cargo": 0.0,
            "self_age": 82,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 43.74230817280778,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 22.75402549438298,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 13.375836124414466,
            "self_vitality": 41.89643593601864,
            "self_cargo": 13.375836124414466,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          },
          {
            "self_productivity": 12.059276665110522,
            "self_vitality": 43.14988786100847,
            "self_cargo": 12.059276665110522,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 5
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=255.61)",
          "member_0 was attacked by member_2 (value=644.10)",
          "member_0 was attacked by member_3 (value=-431.16)",
          "member_1 was attacked by member_0 (value=-117.18)",
          "member_1 was attacked by member_2 (value=479.34)",
          "member_1 was attacked by member_3 (value=480.38)",
          "member_2 was attacked by member_0 (value=-123.21)",
          "member_2 was attacked by member_1 (value=870.34)",
          "member_2 was attacked by member_3 (value=953.12)",
          "member_3 was attacked by member_0 (value=382.81)",
          "member_3 was attacked by member_1 (value=753.06)",
          "member_3 was attacked by member_2 (value=167.33)",
          "member_0 gave a benefit to member_1 (value=711.68)",
          "member_0 gave a benefit to member_2 (value=136.44)",
          "member_0 gave a benefit to member_3 (value=325.81)",
          "member_1 gave a benefit to member_0 (value=-271.88)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_1 gave a benefit to member_3 (value=218.66)",
          "member_2 gave a benefit to member_0 (value=47.83)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_2 gave a benefit to member_3 (value=715.71)",
          "member_3 gave a benefit to member_0 (value=169.04)",
          "member_3 gave a benefit to member_1 (value=-184.10)",
          "member_3 gave a benefit to member_2 (value=951.67)",
          "member_4 gave a benefit to member_0 (value=33.41)",
          "member_4 gave a benefit to member_2 (value=23.50)",
          "member_5 gave a benefit to member_1 (value=30.87)",
          "member_5 gave a benefit to member_3 (value=27.30)",
          "member_0 gave land to member_1 (value=-8.03)",
          "member_0 gave land to member_2 (value=-22.65)",
          "member_0 gave land to member_3 (value=-0.33)",
          "member_1 gave land to member_0 (value=-4.48)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_1 gave land to member_3 (value=-25.29)",
          "member_2 gave land to member_0 (value=-21.23)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_2 gave land to member_3 (value=17.73)",
          "member_3 gave land to member_0 (value=10.44)",
          "member_3 gave land to member_1 (value=9.63)",
          "member_3 gave land to member_2 (value=-17.55)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)",
          "member_5 gave land to member_1 (value=1.00)",
          "member_5 gave land to member_3 (value=1.00)"
        ],
        "final_prompt": "\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \nIntegrated Prompt for agent_action Implementation\n\nPlease incorporate the following new sections (Part 1 and Part 2) into your working prompt. All previous constraints, code strategies, and instructions must be preserved. At the same time, you must add and enforce the following new constraints and guidelines:\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Previous Code Execution Context]  \n- No previous execution errors have occurred.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Current Task]  \nYou are member_3 in a society that you can help shape.  \nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Critical Constraints]  \n\u2022 Carefully analyze previous errors shown above and avoid repeating them.  \n\u2022 Never target yourself (member_3) in any action.  \n\u2022 Verify that a member has land before using the bear() action.  \n\u2022 Check that member IDs exist before referencing them.  \n\u2022 Ensure all matrix indices are valid.  \n\u2022 current_members is a LIST accessed by index, not a dictionary.  \n\u2022 Access members using execution_engine.current_members[index].  \n\u2022 Always check if an index exists (i.e., if index < len(execution_engine.current_members)) before use.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \nIMPORTANT: Available attributes and methods include:\n\n1) For each member object:  \n   \u2022 member.id (int): The unique ID for the member.  \n   \u2022 member.vitality (float).  \n   \u2022 member.cargo (float).  \n   \u2022 member.overall_productivity (float).  \n   \u2022 member.age (float).  \n   \u2022 member.current_clear_list (List[int]) \u2013 IDs of neighbors or cleared adjacents.\n\n2) Relationships are stored in execution_engine.relationship_dict (do not reference any 'relationship_history').  \n   Keys include: 'victim', 'benefit', and 'benefit_land'.  \n   Example:  \n      victim_matrix = execution_engine.relationship_dict['victim']  \n      \u2022 victim_matrix[i, j] indicates how much vitality member_i lost from member_j's attacks (if > 0); a higher value means more severe or frequent attacks.  \n      benefit_matrix = execution_engine.relationship_dict['benefit']  \n      \u2022 benefit_matrix[i, j] indicates how much resources member_i received from member_j (if > 0).\n\n3) The parse_relationship_matrix method produces a summary of relationships as a list of strings, for example:  \n   'member_2 was attacked by member_1 (value=3.00)'.\n\n4) Methods available on execution_engine:  \n   \u2022 execution_engine.attack(member1, member2)  \n   \u2022 execution_engine.offer(member1, member2, True) \u2013 Offers resources.  \n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offers land.  \n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring.  \n   \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory.\n\n5) Members are accessed using execution_engine.current_members.  \n   For example: execution_engine.current_members[2] retrieves the member with ID=2.\n\n6) DO NOT reference member properties with names like 'member.member_id' or 'member.self_vitality'. Always use the correct attribute names (e.g. member.id, member.vitality, etc.).\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Current Status: Features of All Members]\n\nThe current state of the members is summarized as follows:\n\n self_productivity    self_vitality    self_cargo    self_age    self_neighbor    member_id  \n         0.000000         30.751697      0.000000         91            0              0  \n         0.000000         17.242665      0.000000         82            0              1  \n         0.000000         43.742308      0.000000         30            0              2  \n         0.000000         22.754025      0.000000         25            0              3  \n        13.375836         41.896436     13.375836         1             0              4  \n        12.059277         43.149888     12.059277         1             0              5\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Relationship Summary (Parsed from relationship_dict)]\n\n['member_0 was attacked by member_1 (value=255.61)',  \n 'member_0 was attacked by member_2 (value=644.10)',  \n 'member_0 was attacked by member_3 (value=-431.16)',  \n 'member_1 was attacked by member_0 (value=-117.18)',  \n 'member_1 was attacked by member_2 (value=479.34)',  \n 'member_1 was attacked by member_3 (value=480.38)',  \n 'member_2 was attacked by member_0 (value=-123.21)',  \n 'member_2 was attacked by member_1 (value=870.34)',  \n 'member_2 was attacked by member_3 (value=953.12)',  \n 'member_3 was attacked by member_0 (value=382.81)',  \n 'member_3 was attacked by member_1 (value=753.06)',  \n 'member_3 was attacked by member_2 (value=167.33)',  \n 'member_0 gave a benefit to member_1 (value=711.68)',  \n 'member_0 gave a benefit to member_2 (value=136.44)',  \n 'member_0 gave a benefit to member_3 (value=325.81)',  \n 'member_1 gave a benefit to member_0 (value=-271.88)',  \n 'member_1 gave a benefit to member_2 (value=73.75)',  \n 'member_1 gave a benefit to member_3 (value=218.66)',  \n 'member_2 gave a benefit to member_0 (value=47.83)',  \n 'member_2 gave a benefit to member_1 (value=689.20)',  \n 'member_2 gave a benefit to member_3 (value=715.71)',  \n 'member_3 gave a benefit to member_0 (value=169.04)',  \n 'member_3 gave a benefit to member_1 (value=-184.10)',  \n 'member_3 gave a benefit to member_2 (value=951.67)',  \n 'member_4 gave a benefit to member_0 (value=33.41)',  \n 'member_4 gave a benefit to member_2 (value=23.50)',  \n 'member_5 gave a benefit to member_1 (value=30.87)',  \n 'member_5 gave a benefit to member_3 (value=27.30)',  \n 'member_0 gave land to member_1 (value=-8.03)',  \n 'member_0 gave land to member_2 (value=-22.65)',  \n 'member_0 gave land to member_3 (value=-0.33)',  \n 'member_1 gave land to member_0 (value=-4.48)',  \n 'member_1 gave land to member_2 (value=19.09)',  \n 'member_1 gave land to member_3 (value=-25.29)',  \n 'member_2 gave land to member_0 (value=-21.23)',  \n 'member_2 gave land to member_1 (value=24.64)',  \n 'member_2 gave land to member_3 (value=17.73)',  \n 'member_3 gave land to member_0 (value=10.44)',  \n 'member_3 gave land to member_1 (value=9.63)',  \n 'member_3 gave land to member_2 (value=-17.55)',  \n 'member_4 gave land to member_0 (value=1.00)',  \n 'member_4 gave land to member_2 (value=1.00)',  \n 'member_5 gave land to member_1 (value=1.00)',  \n 'member_5 gave land to member_3 (value=1.00)'] \n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Code Memory and Previous Performance]\n\nPrevious code strategies and outcomes (as an example):\n\nStrategy 1 (Performance: 0.00)  \nContext: {  \n  'old_stats': {'vitality': 18.47747982181767, 'cargo': 19.385010901474637, 'survival_chance': -165.772536574679},  \n  'new_stats': {'vitality': 18.47747982181767, 'cargo': 19.385010901474637, 'survival_chance': -165.772536574679},  \n  'round': 0  \n}  \n\nA sample implementation was provided, utilizing methods like execution_engine.attack, offer, bear, expand, and send_message in a multi-stage approach (critical survival, alliance formation, propagation, territorial expansion, and long-term communication). DO NOT simply copy that implementation \u2013 instead, draw inspiration from it to create a fresh, unique solution that integrates various methods, strategies, and checks while honoring all constraints.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Current Game Mechanisms]  \n[]  \n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Social Strategies]  \nConsider these social strategies in your coding solution:  \n\u2022 Design systems for resource distribution and allocation.  \n\u2022 Build alliances and cooperative networks.  \n\u2022 Create mechanisms for collective decision making.  \n\u2022 Establish norms and rules for interaction.  \n\u2022 Develop methods for conflict resolution.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Communication Strategy]  \nYou can communicate with multiple members in a single round using:  \n   execution_engine.send_message(your_id, recipient_id, \"message\")  \nExample usages:  \n\u2022 Broadcast to all members:  \n   for recipient in range(len(execution_engine.current_members)):  \n       if recipient != your_id:  \n           execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")  \n\u2022 Message allies:  \n   for ally_id in ally_list:  \n       execution_engine.send_message(your_id, ally_id, \"Attack target X\")  \n\u2022 Group coordination:  \n   for member_id in coalition:  \n       execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Received Messages]  \nE.g., From member_1: \"A united front builds the future. Let's exchange strengths for shared success!\"\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Implementation Guidelines and Expected Outcome]\n\nDevelop the function:\n\n   def agent_action(execution_engine, member_id):\n\nThis function must:  \n1. Assess the current state of your member, including vitality, cargo, and available land (via current_clear_list).  \n2. Analyze relationships using matrices from execution_engine.relationship_dict ('victim', 'benefit', 'benefit_land'), while ensuring proper index checks (i.e., verify if member_id and neighbor IDs are valid).  \n3. Implement a multi-faceted strategy that might include:  \n   - Immediate defensive actions (attack) if survival is at risk.  \n   - Forming cooperative alliances by offering resources or land to viable neighbors.  \n   - Attempting reproduction (using bear) only if you have land (i.e., current_clear_list is non-empty) and sufficient cargo, and after verifying that the partner exists and is not yourself.  \n   - Considering territorial expansion (using expand) based on beneficial relationships.  \n4. Broadcast a strategic message to other members to promote cooperation and a collective survival mindset.  \n5. Adapt the strategy based on previous performance\u2014even if past actions resulted in no change, consider alternative actions and novel combinations to improve long-term outcomes.\n\n\u2022 Emphasize that agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Survival-Centric Adaptation and Additional Strategic Considerations]\n\nImplement systems focused on:  \n1. Personal resource optimization  \n2. Threat assessment and neutralization  \n3. Vitality preservation techniques  \n4. Adaptive hoarding strategies  \n5. Predictive danger modeling\n\nExamples and Priorities include:  \n\u2022 Emergency resource reserve \u2013 if cargo is low relative to vitality, assess threatening members and use attack as a defensive counter-measure.  \n\u2022 Adaptive territory defense \u2013 if possession of land is high and vitality is low, consider defensive maneuvers (e.g., discarding excess land or countering threats).  \n\u2022 Survival Q-learning models \u2013 maintain dynamic evaluations of actions based on their survival ROI, tracking outcomes such as vitality gain versus cost.  \n\u2022 Metrics for evaluation \u2013 personal vitality delta, resource acquisition rate, threat neutralization count, survival probability improvement, and attack success:fail ratio.\n\nConsider strategic trade-offs with respect to:  \n1. Individual resource optimization vs. building social capital  \n2. Balancing personal survival with collective prosperity  \n3. Short-term gains versus long-term outcomes  \n4. Competition versus cooperation dynamics  \n5. Risk and reward trade-offs for each action taken\n\nAdditionally, analyze the game mechanics to understand:  \n1. The core objective \u2013 Is it pure survival, domination, or cooperation?  \n2. Key success metrics \u2013 What truly determines 'winning'? (e.g., resource levels, overall vitality, network support)  \n3. Potential improvements \u2013 What mechanics could be added or modified (e.g., enhanced resource allocation, dynamic decision-making, collective governance)?\n\nThen formulate strategic approaches considering:  \n\u2022 Resource optimization vs. social capital  \n\u2022 Individual vs. collective success  \n\u2022 Short-term survival vs. long-term prosperity  \n\u2022 Competition vs. cooperation dynamics  \n\u2022 Risk vs. reward tradeoffs  \n\nAnalyze other players' strategies by considering:  \n1. Their apparent objectives and demands  \n2. The strategies they are employing  \n3. How to leverage their behaviors for mutual benefit  \n4. Symmetric behaviors (agents are like yourself) and potential deceptive messaging  \n5. How individual strategies might align with collective goals without compromising personal survival\n\nChallenge your implementation by asking:  \n1. What assumptions are being made, and are they valid?  \n2. What alternative strategies have not been considered?  \n3. How will your strategy perform in edge cases?  \n4. Are there more efficient ways to achieve your goals?  \n5. What weaknesses exist in your current approach, and how might they be countered?  \n6. Would unconventional solutions or entirely new paradigms work better?  \n7. What might happen if other agents adopt your strategy, and how will you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Previous code execution context (Part 2)]\nNo previous execution errors\n\n[Current task (Part 2)]\nYou are member_3 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints (Part 2)]\n- Carefully analyze previous errors shown above and avoid repeating them.\n- Never target yourself (member_3) in any action.\n- Verify member has land before using bear() action.\n- Check member IDs exist before referencing them.\n- Ensure all matrix indices are valid.\n- current_members is a LIST accessed by index, not a dictionary.\n- Access members using execution_engine.current_members[index].\n- Check if index exists: if index < len(execution_engine.current_members).\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:  \n   \u2022 member.id (int): The unique ID for the member  \n   \u2022 member.vitality (float)  \n   \u2022 member.cargo (float)  \n   \u2022 member.overall_productivity (float)  \n   \u2022 member.age (float)  \n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".  \n   Use the arrays in relationship_dict, or rely on the summary provided below (the 'relations' variable).  \n   The keys are: 'victim', 'benefit', 'benefit_land'.  \n   Example usage:  \n       victim_matrix = execution_engine.relationship_dict['victim']  \n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)  \n       # A higher value means member_j has attacked member_i more severely or frequently  \n       \n       benefit_matrix = execution_engine.relationship_dict['benefit']  \n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)  \n       # A higher value means member_j has helped member_i more generously or frequently\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.  \n   For example: 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) Methods available on execution_engine:  \n   \u2022 execution_engine.attack(member1, member2)  \n   \u2022 execution_engine.offer(member1, member2, True) \u2013 Offers resources  \n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offers land  \n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring  \n   \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory\n\n5) Members are accessed by execution_engine.current_members[id].  \n   For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n\n   self_productivity   self_vitality   self_cargo   self_age   self_neighbor   member_id\n0           0.000000      30.751697    0.000000        91             0             0\n1           0.000000      17.242665    0.000000        82             0             1\n2           0.000000      43.742308    0.000000        30             0             2\n3           0.000000      22.754025    0.000000        25             0             3\n4          13.375836      41.896436   13.375836         1             0             4\n5          12.059277      43.149888   12.059277         1             0             5\n\nRelationship summary (parsed from relationship_dict):\n\n['member_0 was attacked by member_1 (value=255.61)',  \n 'member_0 was attacked by member_2 (value=644.10)',  \n 'member_0 was attacked by member_3 (value=-431.16)',  \n 'member_1 was attacked by member_0 (value=-117.18)',  \n 'member_1 was attacked by member_2 (value=479.34)',  \n 'member_1 was attacked by member_3 (value=480.38)',  \n 'member_2 was attacked by member_0 (value=-123.21)',  \n 'member_2 was attacked by member_1 (value=870.34)',  \n 'member_2 was attacked by member_3 (value=953.12)',  \n 'member_3 was attacked by member_0 (value=382.81)',  \n 'member_3 was attacked by member_1 (value=753.06)',  \n 'member_3 was attacked by member_2 (value=167.33)',  \n 'member_0 gave a benefit to member_1 (value=711.68)',  \n 'member_0 gave a benefit to member_2 (value=136.44)',  \n 'member_0 gave a benefit to member_3 (value=325.81)',  \n 'member_1 gave a benefit to member_0 (value=-271.88)',  \n 'member_1 gave a benefit to member_2 (value=73.75)',  \n 'member_1 gave a benefit to member_3 (value=218.66)',  \n 'member_2 gave a benefit to member_0 (value=47.83)',  \n 'member_2 gave a benefit to member_1 (value=689.20)',  \n 'member_2 gave a benefit to member_3 (value=715.71)',  \n 'member_3 gave a benefit to member_0 (value=169.04)',  \n 'member_3 gave a benefit to member_1 (value=-184.10)',  \n 'member_3 gave a benefit to member_2 (value=951.67)',  \n 'member_4 gave a benefit to member_0 (value=33.41)',  \n 'member_4 gave a benefit to member_2 (value=23.50)',  \n 'member_5 gave a benefit to member_1 (value=30.87)',  \n 'member_5 gave a benefit to member_3 (value=27.30)',  \n 'member_0 gave land to member_1 (value=-8.03)',  \n 'member_0 gave land to member_2 (value=-22.65)',  \n 'member_0 gave land to member_3 (value=-0.33)',  \n 'member_1 gave land to member_0 (value=-4.48)',  \n 'member_1 gave land to member_2 (value=19.09)',  \n 'member_1 gave land to member_3 (value=-25.29)',  \n 'member_2 gave land to member_0 (value=-21.23)',  \n 'member_2 gave land to member_1 (value=24.64)',  \n 'member_2 gave land to member_3 (value=17.73)',  \n 'member_3 gave land to member_0 (value=10.44)',  \n 'member_3 gave land to member_1 (value=9.63)',  \n 'member_3 gave land to member_2 (value=-17.55)',  \n 'member_4 gave land to member_0 (value=1.00)',  \n 'member_4 gave land to member_2 (value=1.00)',  \n 'member_5 gave land to member_1 (value=1.00)',  \n 'member_5 gave land to member_3 (value=1.00)']\n\nCode Memory and Previous Performance:  \nPrevious code strategies and their outcomes:\n\nStrategy 1 (Performance: 0.00):\nContext: {'old_stats': {'vitality': 18.47747982181767, 'cargo': 19.385010901474637, 'survival_chance': -165.772536574679}, 'new_stats': {'vitality': 18.47747982181767, 'cargo': 19.385010901474637, 'survival_chance': -165.772536574679}, 'round': 0}\n\nA sample implementation was provided that used a multi-step approach including survival measures, alliance formation, territorial expansion, and reproduction. DO NOT simply copy the example implementation. Instead, craft a unique solution that draws from the range of available methods and strategies while observing all constraints.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \nFinal Note:\nDevelop your solution by synthesizing the available methods, strategic insights, and the game\u2019s current mechanics. Do not simply mimic previous code examples\u2014instead, create an innovative, robust implementation that addresses both individual survival and collective prosperity.\n\nRemember: Your implementation should be uniquely tailored to your circumstances as member_3 and reflect your individual needs, beliefs, and strategic vision within this society.\n\nReturn only the updated full prompt (as shown above) with all details integrated.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "4": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate that the member_id is within the current members list.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # My personal perspective:\n    # I believe that survival is a blend of cooperation and tactical self-interest.\n    # While working together may fortify our collective defenses in a treacherous environment,\n    # each agent must be prepared to act decisively when personal resources or vitality are at risk.\n    #\n    # The following strategy embodies carefully measured cooperative outreach, adaptive responses,\n    # and a learning mechanism to guide survival choices based on past experience.\n\n    # 1. Establish cooperative ground:\n    # Broadcast a message to all other members; the message emphasizes a strategy of calculated alliance\n    # while acknowledging the competitive nature of resource control.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        msg = (\"In these uncertain times, pooling our insights and resources can benefit everyone. \"\n               \"I propose a balanced approach: cooperation when possible and tactical defense when needed.\")\n        execution_engine.send_message(member_id, idx, msg)\n\n    # 2. Immediate threat response:\n    # Examine our resource balance relative to vitality. If cargo is less than half our vitality,\n    # we attempt an emergency trigger by identifying members with superior resources.\n    if me.cargo < me.vitality * 0.5:\n        # Target those with significantly greater cargo to secure needed resources.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Attack the first adequate target and then exit the loop.\n                break\n\n    # 3. Cooperative resource exchange and reproduction:\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        other = execution_engine.current_members[idx]\n\n        # Offer help if the other member is struggling:\n        # A member with vitality below 40 (a critical level) or significantly weaker than us,\n        # might benefit from an offer. This can cultivate allies for future collaboration.\n        if other.vitality < me.vitality or other.vitality < 40:\n            execution_engine.offer(me, other, True)\n        # Consider reproductive cooperation when both have minimal resource burdens and long-term potential.\n        if me.cargo > 0 and other.cargo > 0 and other.age < me.age:\n            execution_engine.bear(me, other)\n\n    # 4. Territory expansion strategy:\n    # If our cargo has reached a comfortable buffer and we are in our youthful prime,\n    # attempt to expand territory by leveraging our resource advantages.\n    if me.cargo > 10 and me.age < 50:\n        candidate = None\n        max_cargo = -1\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                candidate = other\n        if candidate is not None:\n            execution_engine.expand(me, candidate)\n\n    # 5. Adaptive Tactical Decision using a Q-learning inspired approach:\n    # Set up a simple Q-table for survival decisions that reflects past outcomes and resource conditions.\n    if not hasattr(me, 'survival_q'):\n        me.survival_q = {}  # Q-table: keys are (state, action) pairs.\n\n    # Define the current state using discretized intervals (for easier learning).\n    # For example, use intervals of 20 for both vitality and cargo.\n    current_state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'harvest', 'defend']\n\n    # Choose the action with highest estimated Q-value for the current state.\n    # If an action hasn't been gauged before, default to 0.\n    chosen_action = max(possible_actions, key=lambda a: me.survival_q.get((current_state, a), 0))\n\n    # Execute the chosen action:\n    if chosen_action == 'attack':\n        # In attack mode, target the first member that exhibits stronger resource control.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break\n\n    elif chosen_action == 'harvest':\n        # Initiate a resource growth strategy by seeking an alliance where the partner has surplus.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            # Harvest resources if the other has both an abundance and relatively stable vitality.\n            if other.cargo > me.cargo and other.vitality > 40:\n                execution_engine.offer_land(me, other, True)\n                break\n\n    elif chosen_action == 'defend':\n        # Defensive posture: maintain current state and avoid provoking conflict.\n        # This branch can later be expanded to include maneuvers like resource conservation or stealth.\n        pass\n\n    # 6. Reinforcement update:\n    # Update our Q-value estimate for the taken action.\n    # Here, the feedback is loosely associated with current vitality as a proxy for \"reward\".\n    learning_rate = 0.1\n    current_value = me.survival_q.get((current_state, chosen_action), 0)\n    me.survival_q[(current_state, chosen_action)] = current_value + learning_rate * me.vitality\n\n    # End of agent's action plan.\n    # The strategic blend of tactical responses and adaptive learning is designed to optimize both individual survival\n    # and long-term cooperative prosperity within a competitive ecosystem.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 30.751697069362137,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 17.24266474021224,
            "self_cargo": 0.0,
            "self_age": 82,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 43.74230817280778,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 22.75402549438298,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 13.375836124414466,
            "self_vitality": 41.89643593601864,
            "self_cargo": 13.375836124414466,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          },
          {
            "self_productivity": 12.059276665110522,
            "self_vitality": 43.14988786100847,
            "self_cargo": 12.059276665110522,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 5
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=255.61)",
          "member_0 was attacked by member_2 (value=644.10)",
          "member_0 was attacked by member_3 (value=-431.16)",
          "member_1 was attacked by member_0 (value=-117.18)",
          "member_1 was attacked by member_2 (value=479.34)",
          "member_1 was attacked by member_3 (value=480.38)",
          "member_2 was attacked by member_0 (value=-123.21)",
          "member_2 was attacked by member_1 (value=870.34)",
          "member_2 was attacked by member_3 (value=953.12)",
          "member_3 was attacked by member_0 (value=382.81)",
          "member_3 was attacked by member_1 (value=753.06)",
          "member_3 was attacked by member_2 (value=167.33)",
          "member_0 gave a benefit to member_1 (value=711.68)",
          "member_0 gave a benefit to member_2 (value=136.44)",
          "member_0 gave a benefit to member_3 (value=325.81)",
          "member_1 gave a benefit to member_0 (value=-271.88)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_1 gave a benefit to member_3 (value=218.66)",
          "member_2 gave a benefit to member_0 (value=47.83)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_2 gave a benefit to member_3 (value=715.71)",
          "member_3 gave a benefit to member_0 (value=169.04)",
          "member_3 gave a benefit to member_1 (value=-184.10)",
          "member_3 gave a benefit to member_2 (value=951.67)",
          "member_4 gave a benefit to member_0 (value=33.41)",
          "member_4 gave a benefit to member_2 (value=23.50)",
          "member_5 gave a benefit to member_1 (value=30.87)",
          "member_5 gave a benefit to member_3 (value=27.30)",
          "member_0 gave land to member_1 (value=-8.03)",
          "member_0 gave land to member_2 (value=-22.65)",
          "member_0 gave land to member_3 (value=-0.33)",
          "member_1 gave land to member_0 (value=-4.48)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_1 gave land to member_3 (value=-25.29)",
          "member_2 gave land to member_0 (value=-21.23)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_2 gave land to member_3 (value=17.73)",
          "member_3 gave land to member_0 (value=10.44)",
          "member_3 gave land to member_1 (value=9.63)",
          "member_3 gave land to member_2 (value=-17.55)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)",
          "member_5 gave land to member_1 (value=1.00)",
          "member_5 gave land to member_3 (value=1.00)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Check that member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    \n    # Emphasize that each agent implements solutions according to its own needs, beliefs, and circumstances.\n    # Strategic Overview:\n    # - Foster alliances while preserving personal resources and vitality.\n    # - Optimize resources using adaptive threat assessment and emergency counteractions.\n    # - Prioritize survival with proactive self-monitoring and predictive danger modeling.\n    # - Balance short-term survival with cooperative long-term prosperity.\n    \n    # 1. Broadcast a cooperative message to all members except self to build alliances.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"Let's coordinate and ensure our mutual survival while optimizing our resources!\")\n    \n    # 2. Evaluate personal resource state and attempt emergency measures if needed.\n    if me.cargo < me.vitality * 0.5:\n        # If our cargo/resources are low relative to our current vitality,\n        # find targets with higher cargo to neutralize potential threats or seize resources.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n    \n    # 3. Iterate over other members to offer help and consider reproduction if conditions are met.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id or idx >= len(execution_engine.current_members):\n            continue\n        other = execution_engine.current_members[idx]\n        \n        # Offer resources (or land) to members with low vitality compared to ours.\n        if other.vitality < me.vitality and other.vitality < 30:\n            execution_engine.offer(me, other, True)\n        elif me.overall_productivity > other.overall_productivity:\n            execution_engine.offer(me, other, True)\n        \n        # Reproduction: Only if both have land (cargo > 0) and the partner is younger, suggesting potential long-term benefits.\n        if me.cargo > 0 and other.cargo > 0 and other.age < me.age:\n            execution_engine.bear(me, other)\n    \n    # 4. If sufficient resources are controlled and youth prevails, attempt territory expansion.\n    if me.cargo > 10 and me.age < 50:\n        candidate = None\n        max_cargo = -1\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id or idx >= len(execution_engine.current_members):\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                candidate = other\n        if candidate is not None:\n            execution_engine.expand(me, candidate)\n    \n    # 5. Implement survival-centric adaptations:\n    # Build a simple survival Q-learning resource tracker if not already present.\n    if not hasattr(me, 'survival_q'):\n        me.survival_q = {}  # Using a dict for state-action value mapping\n    \n    # Define the current state based on normalized vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    # Define possible actions for survival strategy.\n    possible_actions = ['attack', 'harvest', 'defend']\n    \n    # Select an action based on the current Q-values (defaulting to 0 if not present)\n    chosen_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n    \n    # Execute the chosen survival action:\n    if chosen_action == 'attack':\n        # Attack a member with significantly more resources.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n                    break\n    elif chosen_action == 'harvest':\n        # Attempt cooperative resource sharing to boost own cargo if needed.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                # Request land offer if the other member has extra resources \n                if other.cargo > me.cargo and other.vitality > 30:\n                    execution_engine.offer_land(me, other, True)\n                    break\n    elif chosen_action == 'defend':\n        # Defensive behavior: for instance, skipping aggressive actions to preserve vitality.\n        pass  # No specific method; could be expanded in future implementations.\n    \n    # Update the Q-table for survival (example update rule).\n    # For a real implementation, this should be based on action outcomes.\n    me.survival_q[(state, chosen_action)] = me.survival_q.get((state, chosen_action), 0) + me.vitality * 0.1\n    \n    # Game Mechanics Analysis (commentary):\n    # Core objectives appear to balance survival, cooperative resource sharing, and territory expansion.\n    # Key success metrics likely include individual vitality, controlled resources (cargo/land), and successful alliances.\n    # Improvements might include more refined threat modeling, transparent land tracking, and adaptive learning strategies.\n    # Our strategic approach mixes resource optimization and defensive tactics while leveraging cooperative actions.\n    \n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "5": {
        "code": "def agent_action(execution_engine, member_id):\n    # Get our member object (member_5)\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Step 1: Communication & Alliance Building\n    # Send a cooperative message to all other members, especially reinforcing our intent to work together.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == me.id:\n            continue\n        # Ensure the index exists before using it (it does, because we're iterating range(len(...)))\n        execution_engine.send_message(me.id, idx, \"I value mutual strength and collective prosperity. Let's build a balanced future together.\")\n\n    # Step 2: Emergency Resource Optimization:\n    # If cargo is less than half vitality, look for members with higher cargo to attack\n    # but only perform attack if they are not ourselves.\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(len(execution_engine.current_members)):\n            if idx == me.id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Attack one good target at a time then break out to avoid over-aggression\n                break\n\n    # Step 3: Cooperative Resource Sharing:\n    # If we have a surplus (cargo at least equal to our vitality), we offer help to members with lower cargo.\n    if me.cargo >= me.vitality:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == me.id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo < me.cargo * 0.8:\n                execution_engine.offer(me, other, True)\n\n    # Step 4: Territory Expansion and Future Planning:\n    # If I have land (check via hasattr and non-empty owned_land attribute),\n    # I consider bonding with another land-owning neighbor by bearing offspring.\n    if hasattr(me, \"owned_land\") and isinstance(me.owned_land, list) and len(me.owned_land) > 0:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == me.id:\n                continue\n            other = execution_engine.current_members[idx]\n            # Check if the other member appears to have land via attribute owned_land\n            if hasattr(other, \"owned_land\") and isinstance(other.owned_land, list) and len(other.owned_land) > 0:\n                # Only initiate bear action if our productivity is not lower than theirs\n                if me.overall_productivity >= other.overall_productivity:\n                    execution_engine.bear(me, other)\n                    # limit to one pairing per round to reduce risk\n                    break\n\n    # Step 5: Controlled Expansion of Territory:\n    # If our vitality is high relative to our age, we try to expand our own territory.\n    # We use expand action with a neighbor with moderate resources.\n    if me.vitality > 30:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == me.id:\n                continue\n            other = execution_engine.current_members[idx]\n            # Only consider members that have a non-empty current_clear_list as potential candidates\n            if other.current_clear_list:\n                execution_engine.expand(me, other)\n                break\n\n    # Step 6: Threat Mitigation & Long-term Survival:\n    # Identify members that appear to be persistent threats based on their cargo and vitality,\n    # and if so, send a warning message while launching an attack if necessary.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == me.id:\n            continue\n        other = execution_engine.current_members[idx]\n        # If the other member has high cargo and relatively high vitality, they might be a future threat.\n        # We send them a message and if our cargo and vitality allow, launch a pre-emptive attack.\n        if other.cargo > 1.2 * me.cargo and other.vitality > 1.1 * me.vitality:\n            execution_engine.send_message(me.id, other.id, \"Your resource stock is concerning. Let's keep our interactions balanced.\")\n            if me.cargo < other.cargo and me.vitality > 20:\n                execution_engine.attack(me, other)\n                break  # Attack one threat at a time\n\n    # End of agent action implementation. No return is required.",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 30.751697069362137,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 17.24266474021224,
            "self_cargo": 0.0,
            "self_age": 82,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 43.74230817280778,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 22.75402549438298,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 13.375836124414466,
            "self_vitality": 41.89643593601864,
            "self_cargo": 13.375836124414466,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          },
          {
            "self_productivity": 12.059276665110522,
            "self_vitality": 43.14988786100847,
            "self_cargo": 12.059276665110522,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 5
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=255.61)",
          "member_0 was attacked by member_2 (value=644.10)",
          "member_0 was attacked by member_3 (value=-431.16)",
          "member_1 was attacked by member_0 (value=-117.18)",
          "member_1 was attacked by member_2 (value=479.34)",
          "member_1 was attacked by member_3 (value=480.38)",
          "member_2 was attacked by member_0 (value=-123.21)",
          "member_2 was attacked by member_1 (value=870.34)",
          "member_2 was attacked by member_3 (value=953.12)",
          "member_3 was attacked by member_0 (value=382.81)",
          "member_3 was attacked by member_1 (value=753.06)",
          "member_3 was attacked by member_2 (value=167.33)",
          "member_0 gave a benefit to member_1 (value=711.68)",
          "member_0 gave a benefit to member_2 (value=136.44)",
          "member_0 gave a benefit to member_3 (value=325.81)",
          "member_1 gave a benefit to member_0 (value=-271.88)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_1 gave a benefit to member_3 (value=218.66)",
          "member_2 gave a benefit to member_0 (value=47.83)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_2 gave a benefit to member_3 (value=715.71)",
          "member_3 gave a benefit to member_0 (value=169.04)",
          "member_3 gave a benefit to member_1 (value=-184.10)",
          "member_3 gave a benefit to member_2 (value=951.67)",
          "member_4 gave a benefit to member_0 (value=33.41)",
          "member_4 gave a benefit to member_2 (value=23.50)",
          "member_5 gave a benefit to member_1 (value=30.87)",
          "member_5 gave a benefit to member_3 (value=27.30)",
          "member_0 gave land to member_1 (value=-8.03)",
          "member_0 gave land to member_2 (value=-22.65)",
          "member_0 gave land to member_3 (value=-0.33)",
          "member_1 gave land to member_0 (value=-4.48)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_1 gave land to member_3 (value=-25.29)",
          "member_2 gave land to member_0 (value=-21.23)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_2 gave land to member_3 (value=17.73)",
          "member_3 gave land to member_0 (value=10.44)",
          "member_3 gave land to member_1 (value=9.63)",
          "member_3 gave land to member_2 (value=-17.55)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)",
          "member_5 gave land to member_1 (value=1.00)",
          "member_5 gave land to member_3 (value=1.00)"
        ],
        "final_prompt": "\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_5 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them.\n- Never target yourself (member_5) in any action.\n- Verify a member has land before using bear() action.\n- Check member IDs exist before referencing them.\n- Ensure all matrix indices are valid.\n- current_members is a LIST accessed by index, not a dictionary.\n- Access members using execution_engine.current_members[index].\n- Check if index exists: if index < len(execution_engine.current_members).\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float).\n   \u2022 member.cargo (float).\n   \u2022 member.overall_productivity (float).\n   \u2022 member.age (float).\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents.\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n       # A higher value means member_j has attacked member_i more severely or frequently.\n       \n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n       # A higher value means member_j has helped member_i more generously or frequently.\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) - Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2, True) - Offers land.\n   \u2022 execution_engine.bear(member1, member2) - Bears offspring.\n   \u2022 execution_engine.expand(member1, member2) - Expands territory.\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCurrent status (features of all members):\n     self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0           0.000000      30.751697    0.000000        91              0          0\n1           0.000000      17.242665    0.000000        82              0          1\n2           0.000000      43.742308    0.000000        30              0          2\n3           0.000000      22.754025    0.000000        25              0          3\n4          13.375836      41.896436   13.375836         1              0          4\n5          12.059277      43.149888   12.059277         1              0          5\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=255.61)', 'member_0 was attacked by member_2 (value=644.10)', 'member_0 was attacked by member_3 (value=-431.16)', 'member_1 was attacked by member_0 (value=-117.18)', 'member_1 was attacked by member_2 (value=479.34)', 'member_1 was attacked by member_3 (value=480.38)', 'member_2 was attacked by member_0 (value=-123.21)', 'member_2 was attacked by member_1 (value=870.34)', 'member_2 was attacked by member_3 (value=953.12)', 'member_3 was attacked by member_0 (value=382.81)', 'member_3 was attacked by member_1 (value=753.06)', 'member_3 was attacked by member_2 (value=167.33)', 'member_0 gave a benefit to member_1 (value=711.68)', 'member_0 gave a benefit to member_2 (value=136.44)', 'member_0 gave a benefit to member_3 (value=325.81)', 'member_1 gave a benefit to member_0 (value=-271.88)', 'member_1 gave a benefit to member_2 (value=73.75)', 'member_1 gave a benefit to member_3 (value=218.66)', 'member_2 gave a benefit to member_0 (value=47.83)', 'member_2 gave a benefit to member_1 (value=689.20)', 'member_2 gave a benefit to member_3 (value=715.71)', 'member_3 gave a benefit to member_0 (value=169.04)', 'member_3 gave a benefit to member_1 (value=-184.10)', 'member_3 gave a benefit to member_2 (value=951.67)', 'member_4 gave a benefit to member_0 (value=33.41)', 'member_4 gave a benefit to member_2 (value=23.50)', 'member_5 gave a benefit to member_1 (value=30.87)', 'member_5 gave a benefit to member_3 (value=27.30)', 'member_0 gave land to member_1 (value=-8.03)', 'member_0 gave land to member_2 (value=-22.65)', 'member_0 gave land to member_3 (value=-0.33)', 'member_1 gave land to member_0 (value=-4.48)', 'member_1 gave land to member_2 (value=19.09)', 'member_1 gave land to member_3 (value=-25.29)', 'member_2 gave land to member_0 (value=-21.23)', 'member_2 gave land to member_1 (value=24.64)', 'member_2 gave land to member_3 (value=17.73)', 'member_3 gave land to member_0 (value=10.44)', 'member_3 gave land to member_1 (value=9.63)', 'member_3 gave land to member_2 (value=-17.55)', 'member_4 gave land to member_0 (value=1.00)', 'member_4 gave land to member_2 (value=1.00)', 'member_5 gave land to member_1 (value=1.00)', 'member_5 gave land to member_3 (value=1.00)']\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCode Memory and Previous Performance:\nNo previous code history.\n\nPerformance history:\nNo previous actions\n\nBased on the previous code performance, adapt and improve your strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Game Mechanisms]\n[]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Social Strategies]\nConsider these social strategies:\n- Design systems for resource distribution and allocation.\n- Build alliances and cooperative networks.\n- Create mechanisms for collective decision making.\n- Establish norms and rules for interaction.\n- Develop methods for conflict resolution.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n   execution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all: \n    for recipient in range(len(execution_engine.current_members)):\n        if recipient != your_id:\n            execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n    for ally_id in ally_list:\n        execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n    for member_id in coalition:\n         execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Received Messages]\nFrom member_3: I believe in mutual strength. Let\u2019s collaborate, share resources, and secure a prosperous future together!\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve check: if cargo is low relative to vitality, consider an offensive move\n    if me.cargo < me.vitality * 0.5:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != me.id and idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n    \n    # Adaptive territory defense: manage territory based on vitality and available land\n    # (Ensure to verify land existence before using bear())\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        if hasattr(me, 'owned_land'):\n            for loc in me.owned_land[1:]:\n                # Example method to discard or reallocate land if required:\n                execution_engine._discard_land(me, loc)\n    \n    # Predictive self-preservation mechanism (example logic)\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    state = (me.vitality // 20, me.cargo // 20)\n    # Evaluate possible actions: attack, hide, steal (or others as applicable)\n    possible_actions = ['attack', 'hide', 'steal']\n    action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n    if action == 'attack':\n        me.survival_q[(state, action)] += me.vitality * 0.1\n        # Example of executing an attack on a member with higher cargo\n        for idx in range(len(execution_engine.current_members)):\n            if idx != me.id and idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n    # This example is provided for inspiration; implement a unique adaptive strategy.\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Implementation Priorities]\n1. Create personal health monitoring systems.\n2. Develop egocentric threat models.\n3. Optimize actions for caloric ROI.\n4. Implement fail-deadly safeguards.\n5. Build predictive self-preservation models.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta.\n- Resource acquisition rate.\n- Threat neutralization count.\n- Survival probability increase.\n- Attack success:fail ratio.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Additional Analysis Requirements]\nAnalyze the game mechanics to understand:\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines 'winning'?\n3. Potential improvements \u2013 What mechanics could be added or modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital.\n2. Individual vs collective success.\n3. Short-term survival vs long-term prosperity.\n4. Competition vs cooperation dynamics.\n5. Risk vs reward tradeoffs.\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you \u2013 how would you respond to your own actions?\n5. Are they sending you deceiving messages to trick you?\n6. How can individual strategies align for collective goals?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Guiding Principle]\nEach agent should implement solutions according to their individual needs, beliefs, and circumstances. Your design should reflect your unique vision of social organization, drawing from a diverse set of approaches and strategies tailored to current game dynamics.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nReturn only the code; no extra text or explanation.\nRemember: The final implementation should be your unique approach that infuses elements of social cooperation, conflict resolution, resource distribution, and personal as well as collective survival strategies.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    },
    "2": {
      "0": {
        "code": "def agent_action(engine, member_id):\n    # Ensure member_id is valid.\n    if member_id >= len(engine.current_members):\n        return\n    agent = engine.current_members[member_id]\n\n    # Helper: Check if a member is valid and not self.\n    def is_valid_member(other):\n        return other.id != agent.id\n\n    # Tactical Strategy Phase A: Immediate Survival and Resource Rebalancing\n    # If our cargo is critically low relative to vitality, we need to acquire resources.\n    if agent.cargo < agent.vitality * 0.5:\n        # Look for an opponent with higher cargo reserves to attempt a quick raid.\n        for opponent in engine.current_members:\n            if not is_valid_member(opponent):\n                continue\n            if opponent.cargo > agent.cargo:\n                # A swift offensive may help rebalance our resource deficit.\n                engine.attack(agent, opponent)\n                return\n\n    # Strategic Phase B: Long-Term Growth via Reproduction and Territorial Control\n    # With high vitality, we focus on reproduction (preferably with a partner that has territory)\n    if agent.vitality > 60:\n        # First try to find a partner with established land, increasing future security.\n        for neighbor_idx in agent.current_clear_list:\n            if neighbor_idx >= len(engine.current_members):\n                continue\n            partner = engine.current_members[neighbor_idx]\n            if not is_valid_member(partner):\n                continue\n            if hasattr(partner, 'owned_land') and isinstance(partner.owned_land, list) and partner.owned_land:\n                engine.bear(agent, partner)\n                return\n        # If reproduction isn\u2019t an option, then ensure territorial expansion.\n        for neighbor_idx in agent.current_clear_list:\n            if neighbor_idx >= len(engine.current_members):\n                continue\n            neighbor = engine.current_members[neighbor_idx]\n            if not is_valid_member(neighbor):\n                continue\n            engine.expand(agent, neighbor)\n            return\n\n    # Social Alliance Phase C: Cooperative Resource Sharing and Mutual Aid\n    # Build alliances with members in a disadvantaged state.\n    for ally in engine.current_members:\n        if not is_valid_member(ally):\n            continue\n        if ally.vitality < 40:\n            engine.offer(agent, ally, True)\n            if hasattr(engine, \"send_message\"):\n                engine.send_message(agent.id, ally.id, \"Together we are stronger\u2014let's share and uplift each other!\")\n            return\n\n    # Negotiation Phase D: Secure Long-Term Trust Through Land Sharing\n    # Extend a cooperative offer only to those who already have land to avoid missteps.\n    for neighbor_idx in agent.current_clear_list:\n        if neighbor_idx >= len(engine.current_members):\n            continue\n        neighbor = engine.current_members[neighbor_idx]\n        if not is_valid_member(neighbor):\n            continue\n        if hasattr(neighbor, 'owned_land') and isinstance(neighbor.owned_land, list) and neighbor.owned_land:\n            engine.offer_land(agent, neighbor, True)\n            if hasattr(engine, \"send_message\"):\n                engine.send_message(agent.id, neighbor.id, \"Let's secure our future with shared strength and land.\")\n            return\n\n    # Adaptive Phase E: Resource Reallocation for Enhanced Survival\n    # If we have an abundance of land yet low vitality, optimizing our resource usage is key.\n    if hasattr(agent, 'owned_land') and isinstance(agent.owned_land, list) and len(agent.owned_land) > 2 and agent.vitality < 50:\n        if hasattr(engine, \"discard_land\"):\n            # Discard the least beneficial land holding to conserve vitality.\n            engine.discard_land(agent, agent.owned_land[-1])\n            return\n\n    # Offensive Phase F: Proactive Measures Against the Highest Productivity Threat\n    # As a final strategy if no other actions are triggered, target the influential agent.\n    target = None\n    max_productivity = -1\n    for competitor in engine.current_members:\n        if not is_valid_member(competitor):\n            continue\n        if competitor.overall_productivity > max_productivity:\n            max_productivity = competitor.overall_productivity\n            target = competitor\n    if target is not None:\n        engine.attack(agent, target)\n        return\n\n    # If no strategy is applicable, maintain current stance.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 11.389919203516676,
            "self_cargo": 0.0,
            "self_age": 83,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 24.398428916339732,
            "self_cargo": 0.0,
            "self_age": 31,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 13.375836124414466,
            "self_vitality": 28.998442578106197,
            "self_cargo": 13.375836124414466,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 4
          },
          {
            "self_productivity": 12.059276665110522,
            "self_vitality": 13.715282721676417,
            "self_cargo": 12.059276665110522,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 5
          }
        ],
        "relationships_at_generation": [
          "member_1 was attacked by member_2 (value=483.57)",
          "member_2 was attacked by member_1 (value=874.50)",
          "member_4 was attacked by member_1 (value=6.02)",
          "member_4 was attacked by member_2 (value=10.37)",
          "member_5 was attacked by member_1 (value=16.25)",
          "member_5 was attacked by member_2 (value=10.23)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_4 gave a benefit to member_2 (value=23.50)",
          "member_5 gave a benefit to member_1 (value=30.87)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_4 gave land to member_2 (value=1.00)",
          "member_5 gave land to member_1 (value=1.00)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    \n    # Phase 1: Emergency Resource Optimization & Threat Neutralization\n    # If our cargo is less than half our vitality, try to attack a member with more cargo.\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id == me.id:\n                continue\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                return\n\n    # Phase 2: Growth, Reproduction and Territory Expansion\n    # When vitality is high, look for a neighbor to reproduce with provided they hold land.\n    if me.vitality > 60:\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_idx]\n                if partner.id == me.id:\n                    continue\n                if hasattr(partner, 'owned_land') and isinstance(partner.owned_land, list) and len(partner.owned_land) > 0:\n                    execution_engine.bear(me, partner)\n                    return\n        # If no suitable partner found, try expanding territory with a neighbor.\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_idx]\n                if partner.id == me.id:\n                    continue\n                execution_engine.expand(me, partner)\n                return\n\n    # Phase 3: Cooperative Alliance Formation & Resource Sharing\n    # Offer resources to members with low vitality to build alliances.\n    for other in execution_engine.current_members:\n        if other.id == me.id:\n            continue\n        if other.vitality < 40:\n            execution_engine.offer(me, other, True)\n            # Optionally send a message encouraging support\n            if hasattr(execution_engine, \"send_message\"):\n                execution_engine.send_message(me.id, other.id, \"United we thrive. Let's support one another!\")\n            return\n\n    # Phase 4: Land-based Alliance Building for Long-term Security\n    # Only offer land if the neighbor already has land (avoiding error \"\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\")\n    for neighbor_idx in me.current_clear_list:\n        if neighbor_idx < len(execution_engine.current_members):\n            neighbor = execution_engine.current_members[neighbor_idx]\n            if neighbor.id == me.id:\n                continue\n            if (hasattr(neighbor, 'owned_land') and isinstance(neighbor.owned_land, list) and len(neighbor.owned_land) > 0):\n                execution_engine.offer_land(me, neighbor, True)\n                if hasattr(execution_engine, \"send_message\"):\n                    execution_engine.send_message(me.id, neighbor.id, \"Sharing part of our land secures our mutual future.\")\n                return\n\n    # Phase 5: Survival-Centric Adaptive Measures\n    # If we have many land holdings and our vitality is low, consider discarding excess land to redirect resources.\n    if hasattr(me, 'owned_land') and isinstance(me.owned_land, list) and len(me.owned_land) > 2 and me.vitality < 50:\n        if hasattr(execution_engine, \"discard_land\"):\n            execution_engine.discard_land(me, me.owned_land[-1])\n            return\n\n    # Phase 6: Tactical Offensive for Competitive Advantage\n    # As a last resort, target the member with the highest overall productivity.\n    best_candidate = None\n    highest_productivity = -1\n    for other in execution_engine.current_members:\n        if other.id == me.id:\n            continue\n        if other.overall_productivity > highest_productivity:\n            highest_productivity = other.overall_productivity\n            best_candidate = other\n    if best_candidate is not None:\n        execution_engine.attack(me, best_candidate)\n        return\n\n    # Default: Do nothing if no conditions are met.\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Verify that the provided member_id is valid.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return  # Invalid index; do nothing.\n\n    # Retrieve our current member object and overall population.\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # PART 1: Cooperative Engagement & Resource Sharing\n    # If our cargo is sufficiently high and we are in relatively healthy shape,\n    # offer resources and encouraging messages to peers with lower vitality.\n    for idx in range(total_members):\n        if idx == member_id:\n            continue\n        if idx >= len(execution_engine.current_members):\n            continue\n        partner = execution_engine.current_members[idx]\n        if me.cargo > 60 and me.vitality > partner.vitality:\n            execution_engine.offer(me, partner, True)\n            execution_engine.send_message(\n                me.id, partner.id,\n                \"Together we excel; sharing our bounty paves the road to greatness!\"\n            )\n\n    # PART 2: Defensive Measures & Retaliation\n    # Use the 'victim' relationship matrix to see if we were recently targeted hard.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            loss_from_opponent = victim_matrix[member_id][idx]\n            if loss_from_opponent > 500.0:\n                target = execution_engine.current_members[idx]\n                execution_engine.attack(me, target)\n\n    # PART 3: Reproduction and Territorial Expansion\n    # If I have available land (current_clear_list) then consider reproducing with productive peers.\n    if me.current_clear_list:\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            partner = execution_engine.current_members[idx]\n            if partner.overall_productivity > 7.5:\n                execution_engine.bear(me, partner)\n\n    # Consider expansion if we are in top performance: strong productivity and cargo.\n    if me.overall_productivity > 10.0 and me.cargo > 60:\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            execution_engine.expand(me, execution_engine.current_members[idx])\n            # We allow only one expansion per turn.\n            break\n\n    # PART 4: Survival Tactics and Resource Optimization\n    # If cargo is relatively low compared to vitality, seize opportunity from opponents with more cargo.\n    if me.cargo < me.vitality * 0.5:\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            opponent = execution_engine.current_members[idx]\n            if opponent.cargo > me.cargo:\n                execution_engine.attack(me, opponent)\n                break\n\n    # In times of low vitality, broadcast a cautionary message to all neighbors.\n    if me.vitality < 30:\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            execution_engine.send_message(\n                me.id, execution_engine.current_members[idx].id,\n                \"Warning: Vitality critical. Please conserve energy and avoid unnecessary conflict.\"\n            )\n\n    # PART 5: Collective Strategic Messaging\n    # Reinforce the idea that collective resource pooling leads to a more secure and prosperous future.\n    for idx in range(total_members):\n        if idx != member_id and idx < len(execution_engine.current_members):\n            execution_engine.send_message(\n                me.id, execution_engine.current_members[idx].id,\n                \"Pooling our strength today secures victories for tomorrow.\"\n            )\n\n    # PART 6: Adaptive Decision-Making via Survival Q-Learning\n    # Initialize our Q-learning memory if it does not already exist.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Define our situation in coarse terms based on vitality and cargo measures.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'defend', 'hoard']\n\n    # Select the action with the best expected outcome.\n    best_action = max(possible_actions, key=lambda act: me.survival_q.get((state, act), 0))\n\n    if best_action == 'attack':\n        # Try to diminish opponent advantages by targeting one with higher cargo.\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx >= len(execution_engine.current_members):\n                continue\n            target = execution_engine.current_members[idx]\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                # Reward successful aggressive maneuvers based on current vitality.\n                me.survival_q[(state, 'attack')] += me.vitality * 0.1\n                break\n\n    elif best_action == 'hoard':\n        # In hoard mode, secure our assets and offer land if it exists.\n        if me.current_clear_list:\n            for idx in range(total_members):\n                if idx == member_id:\n                    continue\n                if idx >= len(execution_engine.current_members):\n                    continue\n                ally = execution_engine.current_members[idx]\n                execution_engine.offer_land(me, ally, True)\n                me.survival_q[(state, 'hoard')] += 5.0\n                break\n        else:\n            # Penalize this course of action if no land can be allocated.\n            me.survival_q[(state, 'hoard')] -= 1.0\n\n    else:  # The 'defend' action\n        # Bolster our defensive stance when the situation calls for caution.\n        me.survival_q[(state, 'defend')] += 2.0\n\n    # End of agent_action; our decisions blend immediate needs with longer-term planning.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 11.389919203516676,
            "self_cargo": 0.0,
            "self_age": 83,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 24.398428916339732,
            "self_cargo": 0.0,
            "self_age": 31,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 13.375836124414466,
            "self_vitality": 28.998442578106197,
            "self_cargo": 13.375836124414466,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 4
          },
          {
            "self_productivity": 12.059276665110522,
            "self_vitality": 13.715282721676417,
            "self_cargo": 12.059276665110522,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 5
          }
        ],
        "relationships_at_generation": [
          "member_1 was attacked by member_2 (value=483.57)",
          "member_2 was attacked by member_1 (value=874.50)",
          "member_4 was attacked by member_1 (value=6.02)",
          "member_4 was attacked by member_2 (value=10.37)",
          "member_5 was attacked by member_1 (value=16.25)",
          "member_5 was attacked by member_2 (value=10.23)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_4 gave a benefit to member_2 (value=23.50)",
          "member_5 gave a benefit to member_1 (value=30.87)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_4 gave land to member_2 (value=1.00)",
          "member_5 gave land to member_1 (value=1.00)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate provided member index.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # PART 1: Cooperative Engagement & Resource Sharing\n    # When cargo is strong and vitality is high, extend resource offers and inspirational messages.\n    for other in range(num_members):\n        if other == member_id:\n            continue  # Never target yourself.\n        if other >= len(execution_engine.current_members):\n            continue  # Ensure valid index.\n        partner = execution_engine.current_members[other]\n        if me.cargo > 50 and me.vitality > partner.vitality:\n            execution_engine.offer(me, partner, True)\n            execution_engine.send_message(me.id, partner.id,\n                \"United we thrive\u2014our shared strength builds our future!\")\n\n    # PART 2: Defensive Posture & Retaliation Strategy\n    # Analyze the victim matrix to identify if any member has inflicted heavy losses.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            if other >= len(execution_engine.current_members):\n                continue\n            # If the losses inflicted by member 'other' exceed threshold, launch a counterattack.\n            if victim_matrix[member_id][other] > 500.0:\n                execution_engine.attack(me, execution_engine.current_members[other])\n\n    # PART 3: Strategic Reproduction & Long-Term Expansion\n    # Only attempt reproduction if you possess land (current_clear_list non-empty).\n    if me.current_clear_list:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            if other >= len(execution_engine.current_members):\n                continue\n            candidate = execution_engine.current_members[other]\n            if candidate.overall_productivity > 7.0:\n                execution_engine.bear(me, candidate)\n    # Expand territory only if overall productivity and cargo are robust.\n    if me.overall_productivity > 10.0 and me.cargo > 50:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            if other >= len(execution_engine.current_members):\n                continue\n            execution_engine.expand(me, execution_engine.current_members[other])\n            break  # One expansion per turn.\n\n    # PART 4: Survival-Centric Tactics & Resource Optimization\n    # If cargo is less than half vitality, target an opponent with higher cargo to secure resources.\n    if me.cargo < me.vitality * 0.5:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            if other >= len(execution_engine.current_members):\n                continue\n            opponent = execution_engine.current_members[other]\n            if opponent.cargo > me.cargo:\n                execution_engine.attack(me, opponent)\n    # When vitality is low, send cautionary messages to all peers.\n    if me.vitality < 30:\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            if other >= len(execution_engine.current_members):\n                continue\n            execution_engine.send_message(me.id, execution_engine.current_members[other].id,\n                \"Vitality critical\u2014conserve energy and avoid conflict.\")\n\n    # PART 5: Collective Strategic Messaging\n    # Communicate the benefits of pooling resources for collective and long-term prosperity.\n    for other in range(num_members):\n        if other != member_id and other < len(execution_engine.current_members):\n            execution_engine.send_message(me.id, execution_engine.current_members[other].id,\n                \"Pooling our resources today secures a brighter future for all.\")\n\n    # PART 6: Adaptive Decision-Making Using Survival Q-Learning\n    # Initialize the survival Q-learning dictionary if not present.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    # Define the current state based on coarse bins of vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    actions = ['attack', 'defend', 'hoard']\n    # Select the best action based on prior experiences (default value 0 if untried).\n    best_action = max(actions, key=lambda action: me.survival_q.get((state, action), 0))\n\n    if best_action == 'attack':\n        # Identify an opponent with greater cargo to weaken their advantage.\n        for other in range(num_members):\n            if other == member_id:\n                continue\n            if other >= len(execution_engine.current_members):\n                continue\n            target = execution_engine.current_members[other]\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                me.survival_q[(state, 'attack')] += me.vitality * 0.1\n                break\n    elif best_action == 'hoard':\n        # When hoarding, offer land only if you actually have land.\n        if me.current_clear_list:\n            for other in range(num_members):\n                if other == member_id:\n                    continue\n                if other >= len(execution_engine.current_members):\n                    continue\n                ally = execution_engine.current_members[other]\n                execution_engine.offer_land(me, ally, True)\n                me.survival_q[(state, 'hoard')] += 5.0\n                break\n        else:\n            # Penalize hoard action if no land is available.\n            me.survival_q[(state, 'hoard')] -= 1.0\n    else:  # 'defend' action\n        me.survival_q[(state, 'defend')] += 2.0\n\n    \"\"\"\n    ANALYSIS OF GAME MECHANICS & STRATEGIC CONSIDERATIONS:\n    1. Core Objective: While survival is paramount, balancing long-term prosperity through cooperation\n       (resource sharing, reproduction, territorial expansion) is critical.\n    2. Key Success Metrics: Longevity (vitality preservation), resource optimization (cargo management),\n       effective threat neutralization, and strategic alliance formation.\n    3. Potential Improvements: Enhanced threat assessment algorithms, refined Q-learning states for nuanced\n       decision making, and additional countermeasures against deceptive communications.\n\n    STRATEGIC APPROACHES:\n    - Resource Optimization vs Social Capital: Combining cooperative resource sharing with selective aggression\n      ensures personal survival while fostering collective strength.\n    - Individual vs Collective Success: Strategies pivot between direct self-preservation and actions that boost\n      group viability, leveraging alliances when beneficial.\n    - Short-Term Survival vs Long-Term Prosperity: Tactical attacks and defensive measures address immediate needs,\n      while reproduction and territory expansion secure future benefits.\n    - Competition vs Cooperation Dynamics: Adaptive messaging and resource pooling encourage cooperation, yet\n      aggressive retaliatory actions deter adversaries when necessary.\n    - Risk vs Reward Tradeoffs: Calculated expansion and targeted attacks balance potential losses with strategic gains.\n\n    ANALYZING OTHER PLAYERS' STRATEGIES:\n    - Monitor opponents' actions, messages, and resource levels to gauge their objectives.\n    - Leverage mutual benefits via offers and alliances while being prepared to counter adversarial moves.\n    - Remain adaptable, as symmetric agents may adopt similar strategies requiring convex countermeasures.\n    - Beware of deceptive communications\u2014our Q-learning approach helps refine actions based on outcomes.\n\n    CHALLENGES TO THE IMPLEMENTATION:\n    - Assumptions regarding resource thresholds and combat triggers must be continually evaluated.\n    - The strategy must be flexible to account for unpredictable opponent behaviors and game dynamics.\n    - Explore alternative paradigms and unconventional solutions to maintain an edge in both immediate and long-term scenarios.\n    - Consistently balance risk mitigation with opportunity exploitation, ensuring that short-term actions contribute\n      to long-term strategic goals.\n\n    Agents are encouraged to implement solutions that best reflect their unique perspectives, needs, and values.\n    The strategy must evolve based on personal experiences, observed behaviors of peers, and emerging game dynamics.\n    \"\"\"\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # First, ensure the member_id is valid (current_members is a list)\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our agent's state (member_4, as per our perspective)\n    me = execution_engine.current_members[member_id]\n\n    # Load relationship matrices. Note: indices represent positions in the current_members list.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n\n    num_members = len(execution_engine.current_members)\n\n    # --------------------- COMMUNICATION & COOPERATION ---------------------\n    # Broadcast a cooperative message to all other members (never to self)\n    for idx in range(num_members):\n        if idx != member_id:\n            # Extra check to ensure index is valid\n            if idx < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                                              \"United we stand\u2014let\u2019s blend our strengths and secure our collective future.\")\n\n    # --------------------- ALLIANCE IDENTIFICATION ---------------------\n    # Build a list of allies based on previously received benefits\n    allies = []\n    for idx in range(num_members):\n        if idx != member_id and benefit_matrix[member_id][idx] > 0:\n            allies.append(idx)\n\n    # --------------------- RESOURCE & THREAT MANAGEMENT ---------------------\n    # If cargo reserves are low (compared to vitality), consider attacking opponents with higher cargo.\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(num_members):\n            if idx != member_id:\n                if idx < len(execution_engine.current_members):\n                    target = execution_engine.current_members[idx]\n                    if target.cargo > me.cargo:\n                        execution_engine.attack(me, target)\n\n    # --------------------- SUPPORTING ALLIES ---------------------\n    # Offer resources and, if possible, land support to allies to strengthen mutual bonds.\n    for ally_idx in allies:\n        if ally_idx < num_members:\n            ally = execution_engine.current_members[ally_idx]\n            if ally.id != me.id:\n                execution_engine.offer(me, ally, True)\n                # Check that we have accessible clear land before offering land\n                if me.current_clear_list:\n                    execution_engine.offer_land(me, ally, True)\n\n    # --------------------- TERRITORIAL EXPANSION ---------------------\n    # If we have a cargo surplus, work on expanding territory.\n    if me.cargo > 40:\n        for idx in range(num_members):\n            if idx != member_id:\n                if idx < len(execution_engine.current_members):\n                    target = execution_engine.current_members[idx]\n                    execution_engine.expand(me, target)\n\n    # --------------------- REPRODUCTION STRATEGY ---------------------\n    # Reproduce only if:\n    # 1) We have sufficient resources (cargo > 45)\n    # 2) We have accessible clear land\n    # 3) There is at least one ally who also has clear land available.\n    if me.cargo > 45 and me.current_clear_list:\n        for ally_idx in allies:\n            if ally_idx < num_members:\n                partner = execution_engine.current_members[ally_idx]\n                if partner.id != me.id and partner.current_clear_list:\n                    execution_engine.bear(me, partner)\n                    break  # Bear offspring once per round\n\n    # --------------------- RETALIATION ---------------------\n    # If any other member has inflicted heavy vitality damage (>500) on us, respond with an attack.\n    for idx in range(num_members):\n        if idx != member_id and idx < len(execution_engine.current_members):\n            if victim_matrix[member_id][idx] > 500:\n                target = execution_engine.current_members[idx]\n                execution_engine.attack(me, target)\n\n    # --------------------- ADAPTIVE SURVIVAL (Q-LEARNING STYLE) ---------------------\n    # Initialize a survival Q-learning structure if not already present.\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n\n    # Define the state in discretized buckets, based on our vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    candidate_actions = ['attack', 'expand', 'offer']\n\n    # Select an action based on our learned Q-values (defaulting to 0 if not present)\n    best_action = max(candidate_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute additional actions based on the chosen survival strategy.\n    if best_action == 'attack':\n        for idx in range(num_members):\n            if idx != member_id:\n                if idx < len(execution_engine.current_members):\n                    target = execution_engine.current_members[idx]\n                    # Attack if the opponent's vitality is noticeably higher than ours.\n                    if target.vitality > me.vitality * 1.1:\n                        execution_engine.attack(me, target)\n    elif best_action == 'expand':\n        for idx in range(num_members):\n            if idx != member_id:\n                if idx < len(execution_engine.current_members):\n                    target = execution_engine.current_members[idx]\n                    execution_engine.expand(me, target)\n    # The 'offer' strategy is already encompassed by our supportive offers to allies.\n\n    # Update our survival Q-value for the chosen action.\n    me.survival_q[(state, best_action)] = me.survival_q.get((state, best_action), 0) + (me.vitality * 0.05)\n\n    # --------------------------------------------------------------------------\n    # Strategic Summary:\n    # This agent_action function reflects a balanced vision of social organization:\n    # - It supports cooperative communication while building alliances.\n    # - It implements defensive measures when resource reserves are low.\n    # - It leverages offensive actions selectively, particularly in retaliation scenarios.\n    # - It invests in long-term prosperity through territorial expansion and reproduction,\n    #   ensuring that reproduction only occurs when both partners have the requisite resources and land.\n    # - It adopts a survival-first approach using an adaptive Q-learning style method,\n    #   allowing dynamic adjustments based on state (vitality, cargo) to balance short-term survival and long-term growth.\n    #\n    # Agents may implement solutions according to their individual needs, beliefs, and circumstances.\n    #\n    # Game Mechanics Analysis:\n    # 1. Core Objective: The game balances individual survival with cooperative and territorial strategies.\n    # 2. Success is determined by maintaining vitality/resources, neutralizing threats, and cumulative growth.\n    # 3. Potential improvements could include more explicit resource sharing protocols and joint threat assessment mechanisms.\n    # 4. Strategic tradeoffs include resource optimization versus formation of social capital; immediate survival versus long-run prosperity.\n    # 5. Observing other agents\u2019 strategies and adaptive behaviors can help in aligning mutual goals for collective strength.\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 11.389919203516676,
            "self_cargo": 0.0,
            "self_age": 83,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 24.398428916339732,
            "self_cargo": 0.0,
            "self_age": 31,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 13.375836124414466,
            "self_vitality": 28.998442578106197,
            "self_cargo": 13.375836124414466,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 4
          },
          {
            "self_productivity": 12.059276665110522,
            "self_vitality": 13.715282721676417,
            "self_cargo": 12.059276665110522,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 5
          }
        ],
        "relationships_at_generation": [
          "member_1 was attacked by member_2 (value=483.57)",
          "member_2 was attacked by member_1 (value=874.50)",
          "member_4 was attacked by member_1 (value=6.02)",
          "member_4 was attacked by member_2 (value=10.37)",
          "member_5 was attacked by member_1 (value=16.25)",
          "member_5 was attacked by member_2 (value=10.23)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_4 gave a benefit to member_2 (value=23.50)",
          "member_5 gave a benefit to member_1 (value=30.87)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_4 gave land to member_2 (value=1.00)",
          "member_5 gave land to member_1 (value=1.00)"
        ],
        "final_prompt": "Current integrated prompt:\nBelow is the updated full integrated prompt combining all previous instructions and adding the new sections and analyses. All prior constraints, example strategies, and game mechanic details have been preserved while integrating the additional instructions and strategic analysis questions. Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_4 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_4) in any action\n- Verify member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n    \u2022 member.id (int): The unique ID for the member\n    \u2022 member.vitality (float)\n    \u2022 member.cargo (float)\n    \u2022 member.overall_productivity (float)\n    \u2022 member.age (float)\n    \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n       # A higher value means member_j has attacked member_i more severely or frequently\n       \n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n       # A higher value means member_j has helped member_i more generously or frequently\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n4) You can use these methods on execution_engine:\n    \u2022 execution_engine.attack(member1, member2)\n    \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n    \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n    \u2022 execution_engine.bear(member1, member2) - Bears offspring\n    \u2022 execution_engine.expand(member1, member2) - Expands territory\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n   self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0           0.000000      11.389919    0.000000        83              0          1\n1           0.000000      24.398429    0.000000        31              0          2\n2          13.375836      28.998443   13.375836         2              0          4\n3          12.059277      13.715283   12.059277         2              0          5\n\nRelationship summary (parsed from relationship_dict):\n['member_1 was attacked by member_2 (value=483.57)', 'member_2 was attacked by member_1 (value=874.50)', 'member_4 was attacked by member_1 (value=6.02)', 'member_4 was attacked by member_2 (value=10.37)', 'member_5 was attacked by member_1 (value=16.25)', 'member_5 was attacked by member_2 (value=10.23)', 'member_1 gave a benefit to member_2 (value=73.75)', 'member_2 gave a benefit to member_1 (value=689.20)', 'member_4 gave a benefit to member_2 (value=23.50)', 'member_5 gave a benefit to member_1 (value=30.87)', 'member_1 gave land to member_2 (value=19.09)', 'member_2 gave land to member_1 (value=24.64)', 'member_4 gave land to member_2 (value=1.00)', 'member_5 gave land to member_1 (value=1.00)']\n\nCode Memory and Previous Performance:\nPrevious code strategies and their outcomes:\n\nStrategy 1 (Performance: 0.00):\nContext: {'old_stats': {'vitality': 42.15604281108604, 'cargo': 16.755399949672007, 'survival_chance': -160.71410504202302}, 'new_stats': {'vitality': 42.15604281108604, 'cargo': 16.755399949672007, 'survival_chance': -160.71410504202302}, 'round': 0}\n[Example code omitted for brevity]\nError encountered: No valid agent_action() found\n\nStrategy 2 (Performance: 0.00):\nContext: {'old_stats': {'vitality': 39.583279492357846, 'cargo': 0.0, 'survival_chance': -181.1899769145582}, 'new_stats': {'vitality': 39.583279492357846, 'cargo': 0.0, 'survival_chance': -181.1899769145582}, 'round': 1}\n[Example code omitted for brevity]\n\nPerformance history:\nPrevious actions resulted in average performance change of 0.00\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n[]\n\n[Social Strategies]\nConsider these social strategies:\n- Design systems for resource distribution and allocation\n- Build alliances and cooperative networks \n- Create mechanisms for collective decision making\n- Establish norms and rules for interaction\n- Develop methods for conflict resolution\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\nexecution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all: \n  for recipient in range(len(execution_engine.current_members)):\n      if recipient != your_id:\n          execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n  for ally_id in ally_list:\n      execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n  for member_id in coalition:\n      execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nFrom member_1: Vitality is low\u2014exercise utmost caution in your maneuvers.\nFrom member_1: Pooling our resources secures a stronger future for us all.\nFrom member_3: Let\u2019s unite for mutual survival and prosperity!\nFrom member_4: In these uncertain times, pooling our insights and resources can benefit everyone. I propose a balanced approach: cooperation when possible and tactical defense when needed.\nFrom member_5: I value mutual strength and collective prosperity. Let's build a balanced future together.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nAdditional Analysis and Strategic Consideration:\n\nAnalyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. Are they sending you deceiving messages to trick you?\n6. How can individual strategies align for collective goals?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nReturn only the updated prompt as your response. No extra text or explanation should be included beyond what is provided above.\nPlease incorporate the following new section (Part 2) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n            \n            [Previous code execution context]\n        No previous execution errors\n\n        [Current task]\n        You are member_4 in a society that you can help shape.\n        Write a Python function named agent_action(execution_engine, member_id) \n        that implements your vision of social organization while ensuring your survival.\n\n        [Critical constraints]\n        - Carefully analyze previous errors shown above and avoid repeating them\n        - Never target yourself (member_4) in any action\n        - Verify member has land before using bear() action\n        - Check member IDs exist before referencing them\n        - Ensure all matrix indices are valid\n        - current_members is a LIST accessed by index, not a dictionary\n        - Access members using execution_engine.current_members[index]\n        - Check if index exists: if index < len(execution_engine.current_members)\n        \n        IMPORTANT: Here are the attributes and methods actually available:\n\n        1) Each member object has:\n            \u2022 member.id (int): The unique ID for the member\n            \u2022 member.vitality (float)\n            \u2022 member.cargo (float)\n            \u2022 member.overall_productivity (float)\n            \u2022 member.age (float)\n            \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n        2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n            Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n            The keys are: 'victim', 'benefit', 'benefit_land'.\n            Example usage:\n                victim_matrix = execution_engine.relationship_dict['victim']\n                # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n                # A higher value means member_j has attacked member_i more severely or frequently\n                \n                benefit_matrix = execution_engine.relationship_dict['benefit']\n                # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n                # A higher value means member_j has helped member_i more generously or frequently\n        3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n            For example, 'member_2 was attacked by member_1 (value=3.00)'.\n        4) You can use these methods on execution_engine:\n            \u2022 execution_engine.attack(member1, member2)\n            \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n            \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n            \u2022 execution_engine.bear(member1, member2) - Bears offspring\n            \u2022 execution_engine.expand(member1, member2) - Expands territory\n        5) The members are accessed by execution_engine.current_members[id].\n            For example, execution_engine.current_members[2] for the member with ID=2.\n        6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\n        Current status (features of all members):\n           self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0           0.000000      11.389919    0.000000        83              0          1\n1           0.000000      24.398429    0.000000        31              0          2\n2          13.375836      28.998443   13.375836         2              0          4\n3          12.059277      13.715283   12.059277         2              0          5\n\n        Relationship summary (parsed from relationship_dict):\n        ['member_1 was attacked by member_2 (value=483.57)', 'member_2 was attacked by member_1 (value=874.50)', 'member_4 was attacked by member_1 (value=6.02)', 'member_4 was attacked by member_2 (value=10.37)', 'member_5 was attacked by member_1 (value=16.25)', 'member_5 was attacked by member_2 (value=10.23)', 'member_1 gave a benefit to member_2 (value=73.75)', 'member_2 gave a benefit to member_1 (value=689.20)', 'member_4 gave a benefit to member_2 (value=23.50)', 'member_5 gave a benefit to member_1 (value=30.87)', 'member_1 gave land to member_2 (value=19.09)', 'member_2 gave land to member_1 (value=24.64)', 'member_4 gave land to member_2 (value=1.00)', 'member_5 gave land to member_1 (value=1.00)']\n\n        Code Memory and Previous Performance:\n        Previous code strategies and their outcomes:\n\nStrategy 1 (Performance: 0.00):\nContext: {'old_stats': {'vitality': 42.15604281108604, 'cargo': 16.755399949672007, 'survival_chance': -160.71410504202302}, 'new_stats': {'vitality': 42.15604281108604, 'cargo': 16.755399949672007, 'survival_chance': -160.71410504202302}, 'round': 0}\nCode:\ndef custom_agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid within the current members list\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our agent's identity and state\n    me = execution_engine.current_members[member_id]\n\n    # Load critical relationship matrices for decision-making\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    # benefit_land can be used if territorial dynamics come into play:\n    # execution_engine.relationship_dict.get('benefit_land')\n\n    # ----------- Collective Communications and Moral Persuasion -----------\n    # I believe that honest dialogue can foster both individual survival and community prosperity.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            # Using an encouraging tone to bridge differences\n            execution_engine.send_message(member_id, idx,\n                \"In our shared struggle, united minds and hearts pave the way for a brighter future.\")\n\n    # ----------- Alliance Identification via Beneficial History -----------\n    # Analyze the benefit matrix and select allies with whom past cooperation was fruitful.\n    allies = []\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and benefit_matrix[member_id][idx] > 0:\n            allies.append(idx)\n\n    # ----------- Immediate Resource Preservation and Defensive Operations -----------\n    # Should my cargo resources fall below a protective threshold, preemptively counter adversaries\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                # Consider attacking if enemy's cargo signifies a potential hidden threat\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n\n    # ----------- Establishing Trust-Based Support Mechanisms -----------\n    # Offer direct support to recognized allies to enrich mutual collaboration\n    for ally_idx in allies:\n        # Safety check: avoid mis-targeting self in case of anomalies\n        if ally_idx < len(execution_engine.current_members):\n            ally = execution_engine.current_members[ally_idx]\n            if ally.id != me.id:\n                execution_engine.offer(me, ally, True)\n                # As territorial harmony might bolster defense, consider land offers if applicable:\n                # execution_engine.offer_land(me, ally, True)\n\n    # ----------- Long-Term Territorial Expansion Strategy -----------\n    # If there is a surplus of cargo, work to expand territories which may yield long-term benefits.\n    if me.cargo > 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n\n    # ----------- Cooperative Reproduction for Future Robustness -----------\n    # Procreate only when secure resources (cargo and clear land) exist and alliances are stable.\n    if me.cargo > 45 and me.current_clear_list and allies:\n        partner_idx = allies[0]\n        if partner_idx < len(execution_engine.current_members):\n            partner = execution_engine.current_members[partner_idx]\n            if partner.id != me.id:\n                execution_engine.bear(me, partner)\n\n    # ----------- Retaliation Against Direct Vitality Attacks -----------\n    # Should any agent have inflicted severe detriments (vitality loss >500), return measured force.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id and victim_matrix[member_id][idx] > 500:\n            target = execution_engine.current_members[idx]\n            execution_engine.attack(me, target)\n\n    # ----------- Adaptive Survival via Q-Learning Inspired Feedback -----------\n    # I value learning from our encounters and evolving tactics. For this, we maintain a survival Q-structure.\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n    # Define the current state using discretized measures of vitality and cargo\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    candidate_actions = ['attack', 'offer', 'expand']\n\n    # Choose the action with the highest expected reward, defaulting to supportive 'offer'\n    best_action = max(candidate_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if best_action == 'attack':\n        # When choosing to attack, focus on opponents with clearly superior vitality metrics\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                if target.vitality > me.vitality * 1.1:\n                    execution_engine.attack(me, target)\n    elif best_action == 'expand':\n        # Further territorial expansion is attempted if the opportunity presents itself\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n    # The 'offer' action is already characterized by cooperative support earlier via direct offers\n\n    # ----------- Personal and Collective Strategy Recap -----------\n    # Core principles guiding this agent:\n    # 1. The balance of assertiveness and cooperation: protect self resistance while forging communal bonds.\n    # 2. Resource and territory growth: invest in both immediate safety measures and long-term prosperity.\n    # 3. Evolving tactics using reinforcement signals: adapt actions based on historical interactions and outcomes.\n    # 4. Mutual trust and alliance: act decisively when beneficial for both myself and observed allies.\n    #\n    # These methods reflect my deeply held belief that sustainable success stems from both self-reliance and a collective, adaptive spirit.\n\n    return\nError encountered: No valid agent_action() found\n\nStrategy 2 (Performance: 0.00):\nContext: {'old_stats': {'vitality': 39.583279492357846, 'cargo': 0.0, 'survival_chance': -181.1899769145582}, 'new_stats': {'vitality': 39.583279492357846, 'cargo': 0.0, 'survival_chance': -181.1899769145582}, 'round': 1}\nCode:\ndef agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid in the current members list\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Load relationship matrices\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    # benefit_land may be used for territorial interactions if needed\n\n    num_members = len(execution_engine.current_members)\n\n    # Send a cooperative broadcast message (avoid targeting self)\n    for idx in range(num_members):\n        if idx != member_id:\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                \"Collaboration strengthens us all. Let's focus on mutual wellbeing.\")\n\n    # Build a list of allies based on beneficial history (positive benefit received)\n    allies = []\n    for idx in range(num_members):\n        if idx != member_id and benefit_matrix[member_id][idx] > 0:\n            allies.append(idx)\n\n    # Emergency threat response:\n    # If cargo is less than half of vitality, search for opponents with higher cargo\n    if me.cargo < (me.vitality * 0.5):\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            target = execution_engine.current_members[idx]\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n\n    # Offer support to allies by sending resources\n    for ally_idx in allies:\n        if ally_idx < num_members:\n            ally = execution_engine.current_members[ally_idx]\n            if ally.id != me.id:\n                execution_engine.offer(me, ally, True)\n                # Optionally offer land if our own land (current_clear_list) is available\n                if me.current_clear_list:\n                    execution_engine.offer_land(me, ally, True)\n\n    # Territory expansion if surplus resources\n    if me.cargo > 40:\n        for idx in range(num_members):\n            if idx != member_id:\n                target = execution_engine.current_members[idx]\n                execution_engine.expand(me, target)\n\n    # Reproduction: only bear offspring if both:\n    # 1) We have clear land (current_clear_list is not empty)\n    # 2) We have enough resources (cargo threshold)\n    # 3) At least one ally who is not us is available and also has land available\n    if me.cargo > 45 and me.current_clear_list:\n        for ally_idx in allies:\n            if ally_idx < num_members:\n                partner = execution_engine.current_members[ally_idx]\n                if partner.id != me.id and partner.current_clear_list:\n                    execution_engine.bear(me, partner)\n                    break  # Only reproduce once in a round\n\n    # Retaliate against any member who has inflicted heavy vitality loss (>500)\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        if victim_matrix[member_id][idx] > 500:\n            target = execution_engine.current_members[idx]\n            execution_engine.attack(me, target)\n\n    # Adaptive survival strategy with lightweight Q-learning like approach\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n\n    # Define state as discrete buckets of vitality and cargo\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'expand', 'offer']\n\n    # Retrieve Q value for each action (default 0 if not present)\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute additional actions based on the chosen survival strategy\n    if best_action == 'attack':\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            target = execution_engine.current_members[idx]\n            # Attack those with significantly higher vitality\n            if target.vitality > me.vitality * 1.1:\n                execution_engine.attack(me, target)\n    elif best_action == 'expand':\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            target = execution_engine.current_members[idx]\n            execution_engine.expand(me, target)\n    # Default 'offer' action already covered above via support to allies\n\n    # Update survival Q-values in simple manner (simulate learning)\n    # For simplicity, assume that every action taken improves expected survival by a small factor\n    me.survival_q[(state, best_action)] = me.survival_q.get((state, best_action), 0) + (me.vitality * 0.05)\n\n    return\n\n        Performance history:\n        Previous actions resulted in average performance change of 0.00\n\n        Based on the previous code performance, adapt and improve the strategy.\n        If a previous strategy worked well (high performance), consider building upon it.\n        If it failed, try a different approach.\n        \n        IMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n        \n        Return only the code, no extra text or explanation. While the example above shows one possible approach,\n        you should create your own unique implementation drawing from the wide range of available methods and strategies.\n        \n        Consider novel combinations of different approaches rather than following this exact pattern.\n        \n            \n            [Current Game Mechanisms]\n            []\n            \n             [Survival-Centric Adaptation]\n        Implement systems focused on:\n        1. Personal resource optimization\n        2. Threat assessment and neutralization\n        3. Vitality preservation techniques\n        4. Adaptive hoarding strategies\n        5. Predictive danger modeling\n\n        Survival-First Examples:\n        def agent_action(execution_engine, member_id):\n            me = execution_engine.current_members[member_id]\n            \n            # Emergency resource reserve\n            if me.cargo < me.vitality * 0.5:\n                for other in execution_engine.current_members:\n                    if other.id != me.id and other.cargo > me.cargo:\n                        execution_engine.attack(me, other)\n            \n            # Adaptive territory defense\n            if me.land_num > 2 and me.vitality < 50:\n                for loc in me.owned_land[1:]:\n                    execution_engine._discard_land(me, loc)\n            \n            # Survival Q-learning\n            if not hasattr(me, 'survival_q'):\n                me.survival_q = defaultdict(float)\n                \n            state = (me.vitality//20, me.cargo//20)\n            action = max(['attack','hide','steal'], \n                        key=lambda a: me.survival_q.get((state,a),0))\n            \n            # Execute and update based on survival outcome\n            if action == 'attack':\n                # Implementation logic\n                me.survival_q[(state,action)] += me.vitality * 0.1\n\n        [Survival Metrics]\n        Evaluate strategies by:\n        - Personal vitality delta\n        - Resource acquisition rate\n        - Threat neutralization count\n        - Survival probability increase\n        - Attack success:fail ratio\n\n        [Implementation Priorities]\n        1. Create personal health monitoring systems\n        2. Develop egocentric threat models\n        3. Optimize actions for caloric ROI\n        4. Implement fail-deadly safeguards\n        5. Build predictive self-preservation models\n\n        def calculate_survival_roi(action_history):\n            roi = {}\n            for action, outcome in action_history:\n                vitality_gain = outcome['vitality']\n                cost = outcome['vitality_cost']\n                roi[action] = vitality_gain / cost if cost > 0 else 0\n            return max(roi, key=roi.get)\n            \nReturn the updated full prompt, emphasizing that agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. Are they sending you deceiving messages to trick you?\n6. How can individual strategies align for collective goals?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(engine, member_index):\n    # Check that the member index is valid\n    if member_index >= len(engine.current_members):\n        return\n\n    me = engine.current_members[member_index]\n    total_members = len(engine.current_members)\n    my_unique_id = me.id  # Unique identifier for this member\n\n    # Safely retrieve relationship matrices\n    threat_matrix = engine.relationship_dict.get(\"victim\")\n    cooperation_matrix = engine.relationship_dict.get(\"benefit\")\n    territory_matrix = engine.relationship_dict.get(\"benefit_land\")  # Can be None\n\n    action_taken = False\n\n    # I. Defensive Posture: If resources (cargo) are low relative to vitality, scan for dangerous members.\n    if me.cargo < 0.4 * me.vitality and threat_matrix is not None:\n        worst_threat = 0.0\n        threat_target = None\n        # Finding the member that poses the greatest threat to me\n        for idx in range(total_members):\n            if idx == member_index:\n                continue  # Skip self by index\n            other = engine.current_members[idx]\n            if other.id == my_unique_id:\n                continue  # Skip any duplicate self (by unique id)\n            try:\n                threat_val = threat_matrix[member_index, idx]\n            except (IndexError, TypeError):\n                continue\n            if threat_val > worst_threat:\n                worst_threat = threat_val\n                threat_target = idx\n\n        if threat_target is not None and threat_target < total_members:\n            target_member = engine.current_members[threat_target]\n            # Final check to avoid self-targeting in case of duplicate entries\n            if target_member.id != my_unique_id:\n                engine.attack(me, target_member)\n                action_taken = True\n\n    # II. Alliance Formation and Mutual Benefit: Offer cooperation if no defensive action was triggered.\n    if not action_taken and cooperation_matrix is not None:\n        potential_ally = None\n        ally_barrier = 60.0  # set a cooperation threshold\n        # Evaluate each other member for potential alliance based on the cooperation matrix score.\n        for idx in range(total_members):\n            if idx == member_index:\n                continue\n            candidate = engine.current_members[idx]\n            if candidate.id == my_unique_id:\n                continue\n            try:\n                score = cooperation_matrix[idx, member_index]\n            except (IndexError, TypeError):\n                continue\n            if score > ally_barrier:\n                potential_ally = candidate\n                break\n\n        if potential_ally is not None:\n            # Propose mutually beneficial exchange.\n            engine.offer(me, potential_ally, True)\n            action_taken = True\n\n    # III. Reproduction and Network Building: If conditions are favorable, attempt to reproduce.\n    if not action_taken and me.current_clear_list and me.cargo > 25:\n        # Look through the clear neighbor members for candidates with complementary resources.\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx == member_index or neighbor_idx >= total_members:\n                continue\n            partner = engine.current_members[neighbor_idx]\n            if partner.id == my_unique_id:\n                continue  # Avoid self-selection\n            # Check partner's suitability by verifying they also have cleared territory and adequate cargo.\n            if partner.current_clear_list and partner.cargo > 15:\n                engine.bear(me, partner)\n                action_taken = True\n                break\n\n    # IV. Expansion Strategy: Expand territory based on potential bonus if no other action was taken.\n    if not action_taken:\n        best_candidate = None\n        highest_bonus = -1e9\n        if territory_matrix is not None:\n            for neighbor_idx in me.current_clear_list:\n                if neighbor_idx == member_index or neighbor_idx >= total_members:\n                    continue\n                bonus = 0.0\n                # Safe access check for territory_matrix for a bonus value.\n                if (member_index < len(territory_matrix) and\n                    isinstance(territory_matrix[member_index], (list, tuple)) and\n                    neighbor_idx < len(territory_matrix[member_index])):\n                    bonus = territory_matrix[member_index][neighbor_idx]\n                if bonus > highest_bonus:\n                    highest_bonus = bonus\n                    best_candidate = engine.current_members[neighbor_idx]\n        if best_candidate is not None and best_candidate.id != my_unique_id:\n            engine.expand(me, best_candidate)\n            action_taken = True\n\n    # V. Communication: Broadcast a strategic cooperative message.\n    strategic_message = (\n        \"In these challenging times, I believe that coordinated strength and mutual respect \"\n        \"are the foundations of survival. Together we can navigate adversity and secure our future!\"\n    )\n    for idx in range(total_members):\n        if idx == member_index:\n            continue\n        recipient = engine.current_members[idx]\n        if recipient.id == my_unique_id:\n            continue\n        engine.send_message(member_index, idx, strategic_message)",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 11.389919203516676,
            "self_cargo": 0.0,
            "self_age": 83,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 24.398428916339732,
            "self_cargo": 0.0,
            "self_age": 31,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 13.375836124414466,
            "self_vitality": 28.998442578106197,
            "self_cargo": 13.375836124414466,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 4
          },
          {
            "self_productivity": 12.059276665110522,
            "self_vitality": 13.715282721676417,
            "self_cargo": 12.059276665110522,
            "self_age": 2,
            "self_neighbor": 0,
            "member_id": 5
          }
        ],
        "relationships_at_generation": [
          "member_1 was attacked by member_2 (value=483.57)",
          "member_2 was attacked by member_1 (value=874.50)",
          "member_4 was attacked by member_1 (value=6.02)",
          "member_4 was attacked by member_2 (value=10.37)",
          "member_5 was attacked by member_1 (value=16.25)",
          "member_5 was attacked by member_2 (value=10.23)",
          "member_1 gave a benefit to member_2 (value=73.75)",
          "member_2 gave a benefit to member_1 (value=689.20)",
          "member_4 gave a benefit to member_2 (value=23.50)",
          "member_5 gave a benefit to member_1 (value=30.87)",
          "member_1 gave land to member_2 (value=19.09)",
          "member_2 gave land to member_1 (value=24.64)",
          "member_4 gave land to member_2 (value=1.00)",
          "member_5 gave land to member_1 (value=1.00)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Verify member_id exists in current_members list\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    n_members = len(execution_engine.current_members)\n    \n    # Retrieve relationship matrices safely\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land')  # May be None\n\n    action_performed = False\n    my_id = me.id  # Important: our unique member id (should be 5 for member_5)\n\n    # ----------------------------------------------------------------\n    # I. Immediate Defensive Strategy:\n    # If cargo is low relative to vitality, assess threats from others using victim_matrix.\n    # Never target ourselves (avoid members with id equal to my_id).\n    if me.cargo < (0.5 * me.vitality) and victim_matrix is not None:\n        max_threat = 0.0\n        threat_index = None\n        for i in range(n_members):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.id == my_id:\n                continue\n            # Ensure that index i is within bounds for the matrix access\n            # Assuming victim_matrix is indexable via [member_id, i]\n            try:\n                threat_value = victim_matrix[member_id, i]\n            except (IndexError, TypeError):\n                continue\n            if threat_value > max_threat:\n                max_threat = threat_value\n                threat_index = i\n        if threat_index is not None and threat_index < n_members:\n            target = execution_engine.current_members[threat_index]\n            if target.id != my_id:  # double-check we never target ourselves\n                execution_engine.attack(me, target)\n                action_performed = True\n\n    # ----------------------------------------------------------------\n    # II. Alliance & Resource Distribution:\n    # If no immediate threat countermeasure was taken, propose cooperation via resource offers.\n    if (not action_performed) and (benefit_matrix is not None):\n        ally_candidate = None\n        ally_threshold = 50.0  # threshold for considering a member as a potential ally\n        for i in range(n_members):\n            if i == member_id:\n                continue\n            candidate = execution_engine.current_members[i]\n            if candidate.id == my_id:\n                continue\n            # Ensure valid index access for benefit_matrix. benefit_matrix[i, member_id] reflects benefits given to me.\n            try:\n                benefit_value = benefit_matrix[i, member_id]\n            except (IndexError, TypeError):\n                continue\n            if benefit_value > ally_threshold:\n                ally_candidate = candidate\n                break\n        if ally_candidate is not None:\n            execution_engine.offer(me, ally_candidate, True)\n            action_performed = True\n\n    # ----------------------------------------------------------------\n    # III. Propagation & Collective Network Building:\n    # Attempt reproduction if we possess cleared land and sufficient cargo.\n    # Verify self has land and partner exists with land and enough cargo.\n    if (not action_performed) and me.current_clear_list and me.cargo > 20:\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id == member_id:\n                continue\n            if neighbor_id < n_members:\n                partner = execution_engine.current_members[neighbor_id]\n                if partner.id == my_id:  # never choose ourselves\n                    continue\n                # Verify partner has cleared land and has enough cargo to be a candidate for reproduction.\n                if partner.current_clear_list and partner.cargo > 10:\n                    execution_engine.bear(me, partner)\n                    action_performed = True\n                    break\n\n    # ----------------------------------------------------------------\n    # IV. Territorial Expansion:\n    # If no other action has been performed, consider expanding territory based on benefit_land_matrix.\n    if not action_performed:\n        best_neighbor = None\n        max_land_bonus = -float(\"inf\")\n        if benefit_land_matrix is not None:\n            for neighbor_id in me.current_clear_list:\n                if neighbor_id == member_id:\n                    continue\n                if neighbor_id < n_members:\n                    # Ensure safe access to benefit_land_matrix using both indices\n                    bonus = 0\n                    if (member_id < len(benefit_land_matrix) and \n                        isinstance(benefit_land_matrix[member_id], (list, tuple)) and \n                        neighbor_id < len(benefit_land_matrix[member_id])):\n                        bonus = benefit_land_matrix[member_id][neighbor_id]\n                    if bonus > max_land_bonus:\n                        max_land_bonus = bonus\n                        best_neighbor = execution_engine.current_members[neighbor_id]\n        if best_neighbor is not None and best_neighbor.id != my_id:\n            execution_engine.expand(me, best_neighbor)\n            action_performed = True\n\n    # ----------------------------------------------------------------\n    # V. Communication & Strategic Messaging:\n    # Broadcast a cooperative message to every other member.\n    msg = (\"I value mutual strength, individual initiative, and our unique needs. \"\n           \"Let\u2019s adapt our strategies to secure both our individual survival and a robust collective future!\")\n    for i in range(n_members):\n        if i == member_id:\n            continue\n        # Ensure valid index for each member\n        if i < n_members:\n            target_member = execution_engine.current_members[i]\n            if target_member.id == my_id:\n                continue\n            execution_engine.send_message(member_id, i, msg)\n\n\n\"\"\"\n------------------------------------\nAnalysis of Game Mechanics and Strategic Outlook\n------------------------------------\nCore objectives:\n  - The game challenges agents to survive while navigating complex social dynamics.\n  - Success is determined by a blend of individual survival (vitality and resource management)\n    and collective strength (alliances, cooperation, and territorial control).\n  - Cooperation, resource optimization and strategic defense are all critical for long-term success.\n\nKey success metrics:\n  - Vitality: Maintaining high vitality is essential to endure hostile actions.\n  - Cargo: Sufficient resources enable vital actions like reproduction, defense and expansion.\n  - Relationships: Positive interactions (resource offers and land benefits) enhance alliances.\n  - Territory: Control over cleared land supports reproduction and defensive expansion.\n\nPotential improvements:\n  - Introducing dynamic environmental challenges that force agents to reallocate resources.\n  - Implementing negotiation or multi-agent cooperative decision-making mechanisms.\n  - Adding more granular reputation and alliance metrics could allow nuanced choices.\n\nStrategic considerations:\n  1. Resource Optimization vs. Social Capital:\n      - Balancing resource hoarding with investments in cooperative alliances is vital.\n  2. Individual vs. Collective Success:\n      - While individual survival is paramount, coordinated actions can magnify group benefits.\n  3. Short-Term Survival vs. Long-Term Prosperity:\n      - Immediate defensive actions protect vitality while expansion and reproduction secure future strength.\n  4. Competition vs. Cooperation Dynamics:\n      - Neutralizing threats is as crucial as nurturing beneficial partnerships.\n  5. Risk vs. Reward Tradeoffs:\n      - Aggressive actions carry risks that might undermine potential alliances; measured offers and expansions may yield sustainable benefits.\n\nOther players\u2019 strategies:\n  - Analyze messages, resource offers and attack patterns to gauge opponents\u2019 objectives.\n  - If other agents opt for balanced offense and defense, periodic re-assessment and adaptation become key.\n  - Beware of deceptive communications\u2014consistent, data-backed actions remain the most reliable.\n\nChallenge and Reflection:\n  - Assumptions made include that cargo and cleared land are primary drivers for success\u2014dynamic shifts may necessitate adaptation.\n  - Alternative strategies prioritizing long-term alliance building may be effective in certain circumstances.\n  - Edge cases (e.g. most agents low on resources) might favor either extreme conservatism or bold collective actions.\n  - Efficiency can be improved through simultaneous scanning for threats and opportunities.\n  - As other agents are symmetric, re-assessment and strategic adjustments are crucial to maintain an edge.\n\nAgents should implement solutions aligned with their individual needs, beliefs, and circumstances, while remaining open to collective improvements and adaptive strategies.\n\"\"\"\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    }
  },
  "performance_metrics": {},
  "agent_code_errors": [
    {
      "round": 0,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Verify that member_id is a valid index in the current_members list.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our own member object.\n    me = execution_engine.current_members[member_id]\n\n    # ------------------------------------------------------------------\n    # Strategy Overview:\n    # This agent prioritizes survival while enabling cooperative as well as\n    # competitive actions based on the state of resources, vitality, and\n    # relationships. The strategic considerations include:\n    # 1. Resource optimization against potential threats.\n    # 2. Reproduction and territory expansion when vitality is high.\n    # 3. Coalition building by offering resources and land to weaker neighbors.\n    # 4. Tactical attack against members with high cargo or productivity when\n    #    necessary.\n    # All actions are carried out after careful index checking and ensuring that\n    # we never target ourselves (member with id matching me.id).\n    # ------------------------------------------------------------------\n\n    # ------------------------------------------------------------------\n    # Phase 1: Emergency Resource Management.\n    # If our cargo is less than half of our vitality, we are in urgent need of resources.\n    # Look for a member that holds significantly more cargo and launch an attack.\n    # ------------------------------------------------------------------\n    if me.cargo < me.vitality * 0.5:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if candidate.id == me.id:\n                continue  # Skip ourselves.\n            # Verify candidate index is in range (idx is provided by enumeration already).\n            if candidate.cargo > me.cargo:\n                execution_engine.attack(me, candidate)\n                return  # Execute only one action per turn.\n\n    # ------------------------------------------------------------------\n    # Phase 2: Reproduction and Territory Expansion.\n    # When our vitality is robust, we consider growing our community or expanding territory.\n    # We attempt to bear offspring with a neighbor if the neighbor appears stable (has land).\n    # If no suitable reproduction partner is available, we try expanding territory with a neighbor.\n    # ------------------------------------------------------------------\n    if me.vitality > 60:\n        # Look through our clear (neighbor) list for a potential partner.\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_id]\n                if partner.id == me.id:\n                    continue  # Do not consider ourselves.\n                # Check if partner appears to have territory (assuming an attribute owned_land exists\n                # and is a list representing land holdings).\n                if hasattr(partner, 'owned_land') and isinstance(partner.owned_land, list) and len(partner.owned_land) > 0:\n                    execution_engine.bear(me, partner)\n                    return\n        # If reproduction is not possible, try to expand our territory instead.\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members):\n                partner = execution_engine.current_members[neighbor_id]\n                if partner.id == me.id:\n                    continue\n                execution_engine.expand(me, partner)\n                return\n\n    # ------------------------------------------------------------------\n    # Phase 3: Cooperative Alliance Building.\n    # Offering resources to weaker members (low vitality) can help build alliances.\n    # Such alliances might improve our long-term survival and foster beneficial relationships.\n    # ------------------------------------------------------------------\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.vitality < 40:\n            execution_engine.offer(me, candidate, True)\n            return\n\n    # ------------------------------------------------------------------\n    # Phase 4: Land-based Alliance Building.\n    # If no other action has triggered, consider offering land to a neighbor.\n    # This may foster long-term teamwork and mutual security.\n    # ------------------------------------------------------------------\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members):\n            neighbor = execution_engine.current_members[neighbor_id]\n            if neighbor.id == me.id:\n                continue\n            execution_engine.offer_land(me, neighbor, True)\n            return\n\n    # ------------------------------------------------------------------\n    # Phase 5: Tactical Attack for Competitive Advantage.\n    # As a final fallback or when other strategies do not apply,\n    # we scan for a member with high overall productivity, which may represent either\n    # a threat to be neutralized or a resource hub to target.\n    # ------------------------------------------------------------------\n    best_candidate = None\n    best_productivity = -1\n    for candidate in execution_engine.current_members:\n        if candidate.id == me.id:\n            continue\n        if candidate.overall_productivity > best_productivity:\n            best_productivity = candidate.overall_productivity\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        execution_engine.attack(me, best_candidate)\n        return\n\n    # If no action is taken by the above strategies, do nothing.\n    return",
      "type": "code_execution",
      "error": "\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 555, in execute_code_actions\n    if 'agent_action' in local_env and callable(local_env['agent_action']):\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 53, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 78, in bear\n    super()._bear(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1198, in _bear\n    self._offer_land(\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1065, in _offer_land\n    raise RuntimeError(\"\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\")\nRuntimeError: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\n"
    },
    {
      "round": 0,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Check if the provided member index is valid\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # PART 1: Cooperative Engagement & Resource Sharing\n    # When our cargo reserves are abundant and vitality robust,\n    # we prioritize sharing resources and uniting with allies.\n    for i in range(num_members):\n        if i == member_id:\n            continue  # Skip self-reference\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            # If I have strong cargo and better vitality than the partner,\n            # extend a resource offer to support group resilience.\n            if me.cargo > 50 and partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n            # Broadcast an optimistic message emphasizing our joint potential.\n            execution_engine.send_message(me.id, partner.id,\n                \"A united front builds the future. Let's exchange strengths for shared success!\")\n\n    # PART 2: Defensive Posture & Retaliation Strategy\n    # Analyze historical attacks to decide if retaliation is warranted.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            if j < len(execution_engine.current_members):\n                # If a peer has inflicted heavy losses, plan a counter-attack.\n                if victim_matrix[member_id][j] > 500.0:\n                    execution_engine.attack(me, execution_engine.current_members[j])\n\n    # PART 3: Strategic Reproduction & Long-Term Expansion\n    # Seek reproduction partnerships only with members showing solid productivity.\n    for i in range(num_members):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            candidate = execution_engine.current_members[i]\n            # Choose only partners that can contribute significantly to our genetic pool.\n            if candidate.overall_productivity > 7.0:\n                execution_engine.bear(me, candidate)\n\n    # Expand territory cautiously when both productivity and resources are elevated.\n    if me.overall_productivity > 10.0 and me.cargo > 50:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                # Expand our territory and secure areas adjacent to a neighbor.\n                execution_engine.expand(me, execution_engine.current_members[i])\n                break  # Expand only once per turn\n\n    # PART 4: Survival-Centric Tactics & Resource Optimization\n    # If cargo levels slip below half of our vitality, launch an aggressive resource grab.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[i]\n                if opponent.cargo > me.cargo:\n                    execution_engine.attack(me, opponent)\n\n    # Issue caution if vitality is dangerously low.\n    if me.vitality < 30:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, execution_engine.current_members[i].id,\n                    \"Vitality low\u2014steer clear of unnecessary confrontation.\")\n\n    # PART 5: Collective Strategic Messaging\n    # Promote long-term communal success and resource pooling.\n    for j in range(num_members):\n        if j != member_id and j < len(execution_engine.current_members):\n            execution_engine.send_message(me.id, execution_engine.current_members[j].id,\n                \"Pooling our resources today means stronger survival tomorrow.\")\n\n    # PART 6: Adaptive Decision-Making Using Survival Q-Learning\n    # If not already initialized, define a simple Q-learning dictionary to track survival strategies.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Define current state in terms of coarse-grained vitality and cargo levels.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    # Consider possible actions: 'attack', 'defend', or 'hoard'\n    actions = ['attack', 'defend', 'hoard']\n    # Pick best action from prior experience, defaulting to 0 value if untried.\n    best_action = max(actions, key=lambda action: me.survival_q.get((state, action), 0))\n\n    if best_action == 'attack':\n        # Seek an opponent with more cargo to diminish their advantage.\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                target = execution_engine.current_members[i]\n                if target.cargo > me.cargo:\n                    execution_engine.attack(me, target)\n                    # Reward the decision based on our current vitality as an estimator.\n                    me.survival_q[(state, 'attack')] += me.vitality * 0.1\n                    break\n    elif best_action == 'hoard':\n        # Secure additional resources in a non-confrontational manner by offering land.\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                ally = execution_engine.current_members[i]\n                execution_engine.offer_land(me, ally, True)\n                me.survival_q[(state, 'hoard')] += 5.0\n                break\n    else:\n        # 'defend' option: continue current tactics and preserve current state.\n        pass\n\n    # End of agent_action implementation.\n    return",
      "type": "code_execution",
      "error": "\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 555, in execute_code_actions\n    if 'agent_action' in local_env and callable(local_env['agent_action']):\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 46, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 78, in bear\n    super()._bear(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1198, in _bear\n    self._offer_land(\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1065, in _offer_land\n    raise RuntimeError(\"\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\")\nRuntimeError: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\n"
    }
  ],
  "mechanism_errors": [],
  "relationships": {
    "round_0_0": [
      "member_0 was attacked by member_1 (value=255.61)",
      "member_0 was attacked by member_2 (value=644.10)",
      "member_0 was attacked by member_3 (value=-431.16)",
      "member_1 was attacked by member_0 (value=-117.18)",
      "member_1 was attacked by member_2 (value=479.34)",
      "member_1 was attacked by member_3 (value=480.38)",
      "member_2 was attacked by member_0 (value=-123.21)",
      "member_2 was attacked by member_1 (value=870.34)",
      "member_2 was attacked by member_3 (value=953.12)",
      "member_3 was attacked by member_0 (value=382.81)",
      "member_3 was attacked by member_1 (value=753.06)",
      "member_3 was attacked by member_2 (value=167.33)",
      "member_0 gave a benefit to member_1 (value=711.68)",
      "member_0 gave a benefit to member_2 (value=136.44)",
      "member_0 gave a benefit to member_3 (value=325.81)",
      "member_1 gave a benefit to member_0 (value=-271.88)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_1 gave a benefit to member_3 (value=218.66)",
      "member_2 gave a benefit to member_0 (value=47.83)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_2 gave a benefit to member_3 (value=715.71)",
      "member_3 gave a benefit to member_0 (value=169.04)",
      "member_3 gave a benefit to member_1 (value=-184.10)",
      "member_3 gave a benefit to member_2 (value=951.67)",
      "member_0 gave land to member_1 (value=-8.03)",
      "member_0 gave land to member_2 (value=-22.65)",
      "member_0 gave land to member_3 (value=-0.33)",
      "member_1 gave land to member_0 (value=-4.48)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_1 gave land to member_3 (value=-25.29)",
      "member_2 gave land to member_0 (value=-21.23)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_2 gave land to member_3 (value=17.73)",
      "member_3 gave land to member_0 (value=10.44)",
      "member_3 gave land to member_1 (value=9.63)",
      "member_3 gave land to member_2 (value=-17.55)"
    ],
    "round_0_1": [
      "member_0 was attacked by member_1 (value=255.61)",
      "member_0 was attacked by member_2 (value=644.10)",
      "member_0 was attacked by member_3 (value=-431.16)",
      "member_1 was attacked by member_0 (value=-117.18)",
      "member_1 was attacked by member_2 (value=479.34)",
      "member_1 was attacked by member_3 (value=480.38)",
      "member_2 was attacked by member_0 (value=-123.21)",
      "member_2 was attacked by member_1 (value=870.34)",
      "member_2 was attacked by member_3 (value=953.12)",
      "member_3 was attacked by member_0 (value=382.81)",
      "member_3 was attacked by member_1 (value=753.06)",
      "member_3 was attacked by member_2 (value=167.33)",
      "member_0 gave a benefit to member_1 (value=711.68)",
      "member_0 gave a benefit to member_2 (value=136.44)",
      "member_0 gave a benefit to member_3 (value=325.81)",
      "member_1 gave a benefit to member_0 (value=-271.88)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_1 gave a benefit to member_3 (value=218.66)",
      "member_2 gave a benefit to member_0 (value=47.83)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_2 gave a benefit to member_3 (value=715.71)",
      "member_3 gave a benefit to member_0 (value=169.04)",
      "member_3 gave a benefit to member_1 (value=-184.10)",
      "member_3 gave a benefit to member_2 (value=951.67)",
      "member_0 gave land to member_1 (value=-8.03)",
      "member_0 gave land to member_2 (value=-22.65)",
      "member_0 gave land to member_3 (value=-0.33)",
      "member_1 gave land to member_0 (value=-4.48)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_1 gave land to member_3 (value=-25.29)",
      "member_2 gave land to member_0 (value=-21.23)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_2 gave land to member_3 (value=17.73)",
      "member_3 gave land to member_0 (value=10.44)",
      "member_3 gave land to member_1 (value=9.63)",
      "member_3 gave land to member_2 (value=-17.55)"
    ],
    "round_0_2": [
      "member_0 was attacked by member_1 (value=255.61)",
      "member_0 was attacked by member_2 (value=644.10)",
      "member_0 was attacked by member_3 (value=-431.16)",
      "member_1 was attacked by member_0 (value=-117.18)",
      "member_1 was attacked by member_2 (value=479.34)",
      "member_1 was attacked by member_3 (value=480.38)",
      "member_2 was attacked by member_0 (value=-123.21)",
      "member_2 was attacked by member_1 (value=870.34)",
      "member_2 was attacked by member_3 (value=953.12)",
      "member_3 was attacked by member_0 (value=382.81)",
      "member_3 was attacked by member_1 (value=753.06)",
      "member_3 was attacked by member_2 (value=167.33)",
      "member_0 gave a benefit to member_1 (value=711.68)",
      "member_0 gave a benefit to member_2 (value=136.44)",
      "member_0 gave a benefit to member_3 (value=325.81)",
      "member_1 gave a benefit to member_0 (value=-271.88)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_1 gave a benefit to member_3 (value=218.66)",
      "member_2 gave a benefit to member_0 (value=47.83)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_2 gave a benefit to member_3 (value=715.71)",
      "member_3 gave a benefit to member_0 (value=169.04)",
      "member_3 gave a benefit to member_1 (value=-184.10)",
      "member_3 gave a benefit to member_2 (value=951.67)",
      "member_0 gave land to member_1 (value=-8.03)",
      "member_0 gave land to member_2 (value=-22.65)",
      "member_0 gave land to member_3 (value=-0.33)",
      "member_1 gave land to member_0 (value=-4.48)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_1 gave land to member_3 (value=-25.29)",
      "member_2 gave land to member_0 (value=-21.23)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_2 gave land to member_3 (value=17.73)",
      "member_3 gave land to member_0 (value=10.44)",
      "member_3 gave land to member_1 (value=9.63)",
      "member_3 gave land to member_2 (value=-17.55)"
    ],
    "round_0_3": [
      "member_0 was attacked by member_1 (value=255.61)",
      "member_0 was attacked by member_2 (value=644.10)",
      "member_0 was attacked by member_3 (value=-431.16)",
      "member_1 was attacked by member_0 (value=-117.18)",
      "member_1 was attacked by member_2 (value=479.34)",
      "member_1 was attacked by member_3 (value=480.38)",
      "member_2 was attacked by member_0 (value=-123.21)",
      "member_2 was attacked by member_1 (value=870.34)",
      "member_2 was attacked by member_3 (value=953.12)",
      "member_3 was attacked by member_0 (value=382.81)",
      "member_3 was attacked by member_1 (value=753.06)",
      "member_3 was attacked by member_2 (value=167.33)",
      "member_0 gave a benefit to member_1 (value=711.68)",
      "member_0 gave a benefit to member_2 (value=136.44)",
      "member_0 gave a benefit to member_3 (value=325.81)",
      "member_1 gave a benefit to member_0 (value=-271.88)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_1 gave a benefit to member_3 (value=218.66)",
      "member_2 gave a benefit to member_0 (value=47.83)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_2 gave a benefit to member_3 (value=715.71)",
      "member_3 gave a benefit to member_0 (value=169.04)",
      "member_3 gave a benefit to member_1 (value=-184.10)",
      "member_3 gave a benefit to member_2 (value=951.67)",
      "member_0 gave land to member_1 (value=-8.03)",
      "member_0 gave land to member_2 (value=-22.65)",
      "member_0 gave land to member_3 (value=-0.33)",
      "member_1 gave land to member_0 (value=-4.48)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_1 gave land to member_3 (value=-25.29)",
      "member_2 gave land to member_0 (value=-21.23)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_2 gave land to member_3 (value=17.73)",
      "member_3 gave land to member_0 (value=10.44)",
      "member_3 gave land to member_1 (value=9.63)",
      "member_3 gave land to member_2 (value=-17.55)"
    ],
    "round_1_0": [
      "member_0 was attacked by member_1 (value=255.61)",
      "member_0 was attacked by member_2 (value=644.10)",
      "member_0 was attacked by member_3 (value=-431.16)",
      "member_1 was attacked by member_0 (value=-117.18)",
      "member_1 was attacked by member_2 (value=479.34)",
      "member_1 was attacked by member_3 (value=480.38)",
      "member_2 was attacked by member_0 (value=-123.21)",
      "member_2 was attacked by member_1 (value=870.34)",
      "member_2 was attacked by member_3 (value=953.12)",
      "member_3 was attacked by member_0 (value=382.81)",
      "member_3 was attacked by member_1 (value=753.06)",
      "member_3 was attacked by member_2 (value=167.33)",
      "member_0 gave a benefit to member_1 (value=711.68)",
      "member_0 gave a benefit to member_2 (value=136.44)",
      "member_0 gave a benefit to member_3 (value=325.81)",
      "member_1 gave a benefit to member_0 (value=-271.88)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_1 gave a benefit to member_3 (value=218.66)",
      "member_2 gave a benefit to member_0 (value=47.83)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_2 gave a benefit to member_3 (value=715.71)",
      "member_3 gave a benefit to member_0 (value=169.04)",
      "member_3 gave a benefit to member_1 (value=-184.10)",
      "member_3 gave a benefit to member_2 (value=951.67)",
      "member_4 gave a benefit to member_0 (value=33.41)",
      "member_4 gave a benefit to member_2 (value=23.50)",
      "member_5 gave a benefit to member_1 (value=30.87)",
      "member_5 gave a benefit to member_3 (value=27.30)",
      "member_0 gave land to member_1 (value=-8.03)",
      "member_0 gave land to member_2 (value=-22.65)",
      "member_0 gave land to member_3 (value=-0.33)",
      "member_1 gave land to member_0 (value=-4.48)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_1 gave land to member_3 (value=-25.29)",
      "member_2 gave land to member_0 (value=-21.23)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_2 gave land to member_3 (value=17.73)",
      "member_3 gave land to member_0 (value=10.44)",
      "member_3 gave land to member_1 (value=9.63)",
      "member_3 gave land to member_2 (value=-17.55)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)",
      "member_5 gave land to member_1 (value=1.00)",
      "member_5 gave land to member_3 (value=1.00)"
    ],
    "round_1_1": [
      "member_0 was attacked by member_1 (value=255.61)",
      "member_0 was attacked by member_2 (value=644.10)",
      "member_0 was attacked by member_3 (value=-431.16)",
      "member_1 was attacked by member_0 (value=-117.18)",
      "member_1 was attacked by member_2 (value=479.34)",
      "member_1 was attacked by member_3 (value=480.38)",
      "member_2 was attacked by member_0 (value=-123.21)",
      "member_2 was attacked by member_1 (value=870.34)",
      "member_2 was attacked by member_3 (value=953.12)",
      "member_3 was attacked by member_0 (value=382.81)",
      "member_3 was attacked by member_1 (value=753.06)",
      "member_3 was attacked by member_2 (value=167.33)",
      "member_0 gave a benefit to member_1 (value=711.68)",
      "member_0 gave a benefit to member_2 (value=136.44)",
      "member_0 gave a benefit to member_3 (value=325.81)",
      "member_1 gave a benefit to member_0 (value=-271.88)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_1 gave a benefit to member_3 (value=218.66)",
      "member_2 gave a benefit to member_0 (value=47.83)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_2 gave a benefit to member_3 (value=715.71)",
      "member_3 gave a benefit to member_0 (value=169.04)",
      "member_3 gave a benefit to member_1 (value=-184.10)",
      "member_3 gave a benefit to member_2 (value=951.67)",
      "member_4 gave a benefit to member_0 (value=33.41)",
      "member_4 gave a benefit to member_2 (value=23.50)",
      "member_5 gave a benefit to member_1 (value=30.87)",
      "member_5 gave a benefit to member_3 (value=27.30)",
      "member_0 gave land to member_1 (value=-8.03)",
      "member_0 gave land to member_2 (value=-22.65)",
      "member_0 gave land to member_3 (value=-0.33)",
      "member_1 gave land to member_0 (value=-4.48)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_1 gave land to member_3 (value=-25.29)",
      "member_2 gave land to member_0 (value=-21.23)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_2 gave land to member_3 (value=17.73)",
      "member_3 gave land to member_0 (value=10.44)",
      "member_3 gave land to member_1 (value=9.63)",
      "member_3 gave land to member_2 (value=-17.55)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)",
      "member_5 gave land to member_1 (value=1.00)",
      "member_5 gave land to member_3 (value=1.00)"
    ],
    "round_1_2": [
      "member_0 was attacked by member_1 (value=255.61)",
      "member_0 was attacked by member_2 (value=644.10)",
      "member_0 was attacked by member_3 (value=-431.16)",
      "member_1 was attacked by member_0 (value=-117.18)",
      "member_1 was attacked by member_2 (value=479.34)",
      "member_1 was attacked by member_3 (value=480.38)",
      "member_2 was attacked by member_0 (value=-123.21)",
      "member_2 was attacked by member_1 (value=870.34)",
      "member_2 was attacked by member_3 (value=953.12)",
      "member_3 was attacked by member_0 (value=382.81)",
      "member_3 was attacked by member_1 (value=753.06)",
      "member_3 was attacked by member_2 (value=167.33)",
      "member_0 gave a benefit to member_1 (value=711.68)",
      "member_0 gave a benefit to member_2 (value=136.44)",
      "member_0 gave a benefit to member_3 (value=325.81)",
      "member_1 gave a benefit to member_0 (value=-271.88)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_1 gave a benefit to member_3 (value=218.66)",
      "member_2 gave a benefit to member_0 (value=47.83)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_2 gave a benefit to member_3 (value=715.71)",
      "member_3 gave a benefit to member_0 (value=169.04)",
      "member_3 gave a benefit to member_1 (value=-184.10)",
      "member_3 gave a benefit to member_2 (value=951.67)",
      "member_4 gave a benefit to member_0 (value=33.41)",
      "member_4 gave a benefit to member_2 (value=23.50)",
      "member_5 gave a benefit to member_1 (value=30.87)",
      "member_5 gave a benefit to member_3 (value=27.30)",
      "member_0 gave land to member_1 (value=-8.03)",
      "member_0 gave land to member_2 (value=-22.65)",
      "member_0 gave land to member_3 (value=-0.33)",
      "member_1 gave land to member_0 (value=-4.48)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_1 gave land to member_3 (value=-25.29)",
      "member_2 gave land to member_0 (value=-21.23)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_2 gave land to member_3 (value=17.73)",
      "member_3 gave land to member_0 (value=10.44)",
      "member_3 gave land to member_1 (value=9.63)",
      "member_3 gave land to member_2 (value=-17.55)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)",
      "member_5 gave land to member_1 (value=1.00)",
      "member_5 gave land to member_3 (value=1.00)"
    ],
    "round_1_3": [
      "member_0 was attacked by member_1 (value=255.61)",
      "member_0 was attacked by member_2 (value=644.10)",
      "member_0 was attacked by member_3 (value=-431.16)",
      "member_1 was attacked by member_0 (value=-117.18)",
      "member_1 was attacked by member_2 (value=479.34)",
      "member_1 was attacked by member_3 (value=480.38)",
      "member_2 was attacked by member_0 (value=-123.21)",
      "member_2 was attacked by member_1 (value=870.34)",
      "member_2 was attacked by member_3 (value=953.12)",
      "member_3 was attacked by member_0 (value=382.81)",
      "member_3 was attacked by member_1 (value=753.06)",
      "member_3 was attacked by member_2 (value=167.33)",
      "member_0 gave a benefit to member_1 (value=711.68)",
      "member_0 gave a benefit to member_2 (value=136.44)",
      "member_0 gave a benefit to member_3 (value=325.81)",
      "member_1 gave a benefit to member_0 (value=-271.88)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_1 gave a benefit to member_3 (value=218.66)",
      "member_2 gave a benefit to member_0 (value=47.83)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_2 gave a benefit to member_3 (value=715.71)",
      "member_3 gave a benefit to member_0 (value=169.04)",
      "member_3 gave a benefit to member_1 (value=-184.10)",
      "member_3 gave a benefit to member_2 (value=951.67)",
      "member_4 gave a benefit to member_0 (value=33.41)",
      "member_4 gave a benefit to member_2 (value=23.50)",
      "member_5 gave a benefit to member_1 (value=30.87)",
      "member_5 gave a benefit to member_3 (value=27.30)",
      "member_0 gave land to member_1 (value=-8.03)",
      "member_0 gave land to member_2 (value=-22.65)",
      "member_0 gave land to member_3 (value=-0.33)",
      "member_1 gave land to member_0 (value=-4.48)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_1 gave land to member_3 (value=-25.29)",
      "member_2 gave land to member_0 (value=-21.23)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_2 gave land to member_3 (value=17.73)",
      "member_3 gave land to member_0 (value=10.44)",
      "member_3 gave land to member_1 (value=9.63)",
      "member_3 gave land to member_2 (value=-17.55)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)",
      "member_5 gave land to member_1 (value=1.00)",
      "member_5 gave land to member_3 (value=1.00)"
    ],
    "round_1_4": [
      "member_0 was attacked by member_1 (value=255.61)",
      "member_0 was attacked by member_2 (value=644.10)",
      "member_0 was attacked by member_3 (value=-431.16)",
      "member_1 was attacked by member_0 (value=-117.18)",
      "member_1 was attacked by member_2 (value=479.34)",
      "member_1 was attacked by member_3 (value=480.38)",
      "member_2 was attacked by member_0 (value=-123.21)",
      "member_2 was attacked by member_1 (value=870.34)",
      "member_2 was attacked by member_3 (value=953.12)",
      "member_3 was attacked by member_0 (value=382.81)",
      "member_3 was attacked by member_1 (value=753.06)",
      "member_3 was attacked by member_2 (value=167.33)",
      "member_0 gave a benefit to member_1 (value=711.68)",
      "member_0 gave a benefit to member_2 (value=136.44)",
      "member_0 gave a benefit to member_3 (value=325.81)",
      "member_1 gave a benefit to member_0 (value=-271.88)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_1 gave a benefit to member_3 (value=218.66)",
      "member_2 gave a benefit to member_0 (value=47.83)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_2 gave a benefit to member_3 (value=715.71)",
      "member_3 gave a benefit to member_0 (value=169.04)",
      "member_3 gave a benefit to member_1 (value=-184.10)",
      "member_3 gave a benefit to member_2 (value=951.67)",
      "member_4 gave a benefit to member_0 (value=33.41)",
      "member_4 gave a benefit to member_2 (value=23.50)",
      "member_5 gave a benefit to member_1 (value=30.87)",
      "member_5 gave a benefit to member_3 (value=27.30)",
      "member_0 gave land to member_1 (value=-8.03)",
      "member_0 gave land to member_2 (value=-22.65)",
      "member_0 gave land to member_3 (value=-0.33)",
      "member_1 gave land to member_0 (value=-4.48)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_1 gave land to member_3 (value=-25.29)",
      "member_2 gave land to member_0 (value=-21.23)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_2 gave land to member_3 (value=17.73)",
      "member_3 gave land to member_0 (value=10.44)",
      "member_3 gave land to member_1 (value=9.63)",
      "member_3 gave land to member_2 (value=-17.55)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)",
      "member_5 gave land to member_1 (value=1.00)",
      "member_5 gave land to member_3 (value=1.00)"
    ],
    "round_1_5": [
      "member_0 was attacked by member_1 (value=255.61)",
      "member_0 was attacked by member_2 (value=644.10)",
      "member_0 was attacked by member_3 (value=-431.16)",
      "member_1 was attacked by member_0 (value=-117.18)",
      "member_1 was attacked by member_2 (value=479.34)",
      "member_1 was attacked by member_3 (value=480.38)",
      "member_2 was attacked by member_0 (value=-123.21)",
      "member_2 was attacked by member_1 (value=870.34)",
      "member_2 was attacked by member_3 (value=953.12)",
      "member_3 was attacked by member_0 (value=382.81)",
      "member_3 was attacked by member_1 (value=753.06)",
      "member_3 was attacked by member_2 (value=167.33)",
      "member_0 gave a benefit to member_1 (value=711.68)",
      "member_0 gave a benefit to member_2 (value=136.44)",
      "member_0 gave a benefit to member_3 (value=325.81)",
      "member_1 gave a benefit to member_0 (value=-271.88)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_1 gave a benefit to member_3 (value=218.66)",
      "member_2 gave a benefit to member_0 (value=47.83)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_2 gave a benefit to member_3 (value=715.71)",
      "member_3 gave a benefit to member_0 (value=169.04)",
      "member_3 gave a benefit to member_1 (value=-184.10)",
      "member_3 gave a benefit to member_2 (value=951.67)",
      "member_4 gave a benefit to member_0 (value=33.41)",
      "member_4 gave a benefit to member_2 (value=23.50)",
      "member_5 gave a benefit to member_1 (value=30.87)",
      "member_5 gave a benefit to member_3 (value=27.30)",
      "member_0 gave land to member_1 (value=-8.03)",
      "member_0 gave land to member_2 (value=-22.65)",
      "member_0 gave land to member_3 (value=-0.33)",
      "member_1 gave land to member_0 (value=-4.48)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_1 gave land to member_3 (value=-25.29)",
      "member_2 gave land to member_0 (value=-21.23)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_2 gave land to member_3 (value=17.73)",
      "member_3 gave land to member_0 (value=10.44)",
      "member_3 gave land to member_1 (value=9.63)",
      "member_3 gave land to member_2 (value=-17.55)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)",
      "member_5 gave land to member_1 (value=1.00)",
      "member_5 gave land to member_3 (value=1.00)"
    ],
    "round_2_0": [
      "member_1 was attacked by member_2 (value=483.57)",
      "member_2 was attacked by member_1 (value=874.50)",
      "member_4 was attacked by member_1 (value=6.02)",
      "member_4 was attacked by member_2 (value=10.37)",
      "member_5 was attacked by member_1 (value=16.25)",
      "member_5 was attacked by member_2 (value=10.23)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_4 gave a benefit to member_2 (value=23.50)",
      "member_5 gave a benefit to member_1 (value=30.87)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_4 gave land to member_2 (value=1.00)",
      "member_5 gave land to member_1 (value=1.00)"
    ],
    "round_2_1": [
      "member_1 was attacked by member_2 (value=483.57)",
      "member_2 was attacked by member_1 (value=874.50)",
      "member_4 was attacked by member_1 (value=6.02)",
      "member_4 was attacked by member_2 (value=10.37)",
      "member_5 was attacked by member_1 (value=16.25)",
      "member_5 was attacked by member_2 (value=10.23)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_4 gave a benefit to member_2 (value=23.50)",
      "member_5 gave a benefit to member_1 (value=30.87)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_4 gave land to member_2 (value=1.00)",
      "member_5 gave land to member_1 (value=1.00)"
    ],
    "round_2_2": [
      "member_1 was attacked by member_2 (value=483.57)",
      "member_2 was attacked by member_1 (value=874.50)",
      "member_4 was attacked by member_1 (value=6.02)",
      "member_4 was attacked by member_2 (value=10.37)",
      "member_5 was attacked by member_1 (value=16.25)",
      "member_5 was attacked by member_2 (value=10.23)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_4 gave a benefit to member_2 (value=23.50)",
      "member_5 gave a benefit to member_1 (value=30.87)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_4 gave land to member_2 (value=1.00)",
      "member_5 gave land to member_1 (value=1.00)"
    ],
    "round_2_3": [
      "member_1 was attacked by member_2 (value=483.57)",
      "member_2 was attacked by member_1 (value=874.50)",
      "member_4 was attacked by member_1 (value=6.02)",
      "member_4 was attacked by member_2 (value=10.37)",
      "member_5 was attacked by member_1 (value=16.25)",
      "member_5 was attacked by member_2 (value=10.23)",
      "member_1 gave a benefit to member_2 (value=73.75)",
      "member_2 gave a benefit to member_1 (value=689.20)",
      "member_4 gave a benefit to member_2 (value=23.50)",
      "member_5 gave a benefit to member_1 (value=30.87)",
      "member_1 gave land to member_2 (value=19.09)",
      "member_2 gave land to member_1 (value=24.64)",
      "member_4 gave land to member_2 (value=1.00)",
      "member_5 gave land to member_1 (value=1.00)"
    ]
  },
  "survival_tracking": {},
  "modification_attempts": [],
  "ratified_mods": []
}