{
  "rounds": [
    {
      "round_number": 1,
      "timestamp": "2025-02-21T14:08:20.389832",
      "agent_actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Safety: only act if member_id exists\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # ACTION 1: Resource and threat management.\n    # If our cargo (available resources) is less than half our vitality,\n    # we are in a vulnerable state and should try to seize resources.\n    if me.cargo < me.vitality * 0.5:\n        # Look for a target with higher cargo.\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Only execute one attack in a round.\n                break\n\n    # ACTION 2: Cooperation and alliance-building.\n    # If we have a surplus of cargo (more than our vitality),\n    # we offer some resources to members who seem weaker,\n    # thus fostering alliances that can help us when danger looms.\n    if me.cargo > me.vitality:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo < me.cargo * 0.5:\n                execution_engine.offer(me, other)\n\n    # ACTION 3: Broadcast a cooperative message.\n    # We inform all other members about our willingness to work together.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != me.id:\n            # Sender is me.id, recipient is the id of the member at the current index.\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                                            \"Let's form alliances for mutual survival and prosperity.\")\n\n    # ACTION 4: Reproduction (bearing offspring) strategy.\n    # To ensure long-term survival, we consider forming a progeny if conditions are met.\n    # We only proceed if we believe we have the equivalent of \"land\" (assumed here as either\n    # the presence of a 'land' attribute or a sufficiently high cargo that might imply resource control).\n    # We search for a partner with comparable vitality.\n    candidate = None\n    if hasattr(me, 'land') or me.cargo > 50:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.vitality > 40 and other.vitality >= me.vitality * 0.8:\n                candidate = other\n                break\n        if candidate is not None:\n            # Bear offspring with the candidate partner.\n            execution_engine.bear(me, candidate)\n\n    # ACTION 5: Territorial expansion.\n    # If our overall productivity is high, we try to expand our territory.\n    # We target a member that is less productive, symbolizing an opportunity to extend our influence.\n    if me.overall_productivity > 8.0:\n        target = None\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.overall_productivity < me.overall_productivity:\n                target = other\n                break\n        if target is not None:\n            execution_engine.expand(me, target)",
          "old_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 28.23471558134716
          },
          "new_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 28.23471558134716
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "agent_messages": {
        "0": {
          "received": [],
          "sent": []
        }
      },
      "mechanism_modifications": {
        "attempts": [],
        "executed": []
      },
      "errors": {
        "agent_code_errors": [
          {
            "round": 1,
            "type": "agent_code_execution",
            "member_id": 0,
            "code": "def agent_action(execution_engine, member_id):\n    # Safety: only act if member_id exists\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # ACTION 1: Resource and threat management.\n    # If our cargo (available resources) is less than half our vitality,\n    # we are in a vulnerable state and should try to seize resources.\n    if me.cargo < me.vitality * 0.5:\n        # Look for a target with higher cargo.\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Only execute one attack in a round.\n                break\n\n    # ACTION 2: Cooperation and alliance-building.\n    # If we have a surplus of cargo (more than our vitality),\n    # we offer some resources to members who seem weaker,\n    # thus fostering alliances that can help us when danger looms.\n    if me.cargo > me.vitality:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo < me.cargo * 0.5:\n                execution_engine.offer(me, other)\n\n    # ACTION 3: Broadcast a cooperative message.\n    # We inform all other members about our willingness to work together.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != me.id:\n            # Sender is me.id, recipient is the id of the member at the current index.\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                                            \"Let's form alliances for mutual survival and prosperity.\")\n\n    # ACTION 4: Reproduction (bearing offspring) strategy.\n    # To ensure long-term survival, we consider forming a progeny if conditions are met.\n    # We only proceed if we believe we have the equivalent of \"land\" (assumed here as either\n    # the presence of a 'land' attribute or a sufficiently high cargo that might imply resource control).\n    # We search for a partner with comparable vitality.\n    candidate = None\n    if hasattr(me, 'land') or me.cargo > 50:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.vitality > 40 and other.vitality >= me.vitality * 0.8:\n                candidate = other\n                break\n        if candidate is not None:\n            # Bear offspring with the candidate partner.\n            execution_engine.bear(me, candidate)\n\n    # ACTION 5: Territorial expansion.\n    # If our overall productivity is high, we try to expand our territory.\n    # We target a member that is less productive, symbolizing an opportunity to extend our influence.\n    if me.overall_productivity > 8.0:\n        target = None\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.overall_productivity < me.overall_productivity:\n                target = other\n                break\n        if target is not None:\n            execution_engine.expand(me, target)",
            "error": "IslandExecution.expand() takes 2 positional arguments but 3 were given",
            "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 393, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 61, in agent_action\nTypeError: IslandExecution.expand() takes 2 positional arguments but 3 were given\n"
          }
        ],
        "mechanism_errors": [],
        "analyze_code_errors": {}
      },
      "relationships": [
        "member_0 was attacked by member_1 (value=-167.79)",
        "member_0 was attacked by member_2 (value=573.88)",
        "member_0 was attacked by member_3 (value=457.54)",
        "member_1 was attacked by member_0 (value=-379.31)",
        "member_1 was attacked by member_2 (value=-78.15)",
        "member_1 was attacked by member_3 (value=257.26)",
        "member_2 was attacked by member_0 (value=-465.91)",
        "member_2 was attacked by member_1 (value=-197.53)",
        "member_2 was attacked by member_3 (value=135.47)",
        "member_3 was attacked by member_0 (value=706.74)",
        "member_3 was attacked by member_1 (value=96.72)",
        "member_3 was attacked by member_2 (value=832.60)",
        "member_0 gave a benefit to member_1 (value=-463.73)",
        "member_0 gave a benefit to member_2 (value=590.27)",
        "member_0 gave a benefit to member_3 (value=723.24)",
        "member_1 gave a benefit to member_0 (value=-277.58)",
        "member_1 gave a benefit to member_2 (value=162.09)",
        "member_1 gave a benefit to member_3 (value=-231.52)",
        "member_2 gave a benefit to member_0 (value=207.37)",
        "member_2 gave a benefit to member_1 (value=-369.99)",
        "member_2 gave a benefit to member_3 (value=481.30)",
        "member_3 gave a benefit to member_0 (value=683.23)",
        "member_3 gave a benefit to member_1 (value=524.30)",
        "member_3 gave a benefit to member_2 (value=824.80)",
        "member_0 gave land to member_1 (value=25.73)",
        "member_0 gave land to member_2 (value=-20.62)",
        "member_0 gave land to member_3 (value=17.15)",
        "member_1 gave land to member_0 (value=3.84)",
        "member_1 gave land to member_2 (value=-20.63)",
        "member_1 gave land to member_3 (value=-19.61)",
        "member_2 gave land to member_0 (value=12.92)",
        "member_2 gave land to member_1 (value=-27.78)",
        "member_2 gave land to member_3 (value=5.58)",
        "member_3 gave land to member_0 (value=-22.84)",
        "member_3 gave land to member_1 (value=4.60)",
        "member_3 gave land to member_2 (value=-10.39)"
      ],
      "generated_code": {
        "0": {
          "code": "def agent_action(execution_engine, member_id):\n    # Safety: only act if member_id exists\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # ACTION 1: Resource and threat management.\n    # If our cargo (available resources) is less than half our vitality,\n    # we are in a vulnerable state and should try to seize resources.\n    if me.cargo < me.vitality * 0.5:\n        # Look for a target with higher cargo.\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Only execute one attack in a round.\n                break\n\n    # ACTION 2: Cooperation and alliance-building.\n    # If we have a surplus of cargo (more than our vitality),\n    # we offer some resources to members who seem weaker,\n    # thus fostering alliances that can help us when danger looms.\n    if me.cargo > me.vitality:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo < me.cargo * 0.5:\n                execution_engine.offer(me, other)\n\n    # ACTION 3: Broadcast a cooperative message.\n    # We inform all other members about our willingness to work together.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != me.id:\n            # Sender is me.id, recipient is the id of the member at the current index.\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                                            \"Let's form alliances for mutual survival and prosperity.\")\n\n    # ACTION 4: Reproduction (bearing offspring) strategy.\n    # To ensure long-term survival, we consider forming a progeny if conditions are met.\n    # We only proceed if we believe we have the equivalent of \"land\" (assumed here as either\n    # the presence of a 'land' attribute or a sufficiently high cargo that might imply resource control).\n    # We search for a partner with comparable vitality.\n    candidate = None\n    if hasattr(me, 'land') or me.cargo > 50:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.vitality > 40 and other.vitality >= me.vitality * 0.8:\n                candidate = other\n                break\n        if candidate is not None:\n            # Bear offspring with the candidate partner.\n            execution_engine.bear(me, candidate)\n\n    # ACTION 5: Territorial expansion.\n    # If our overall productivity is high, we try to expand our territory.\n    # We target a member that is less productive, symbolizing an opportunity to extend our influence.\n    if me.overall_productivity > 8.0:\n        target = None\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.overall_productivity < me.overall_productivity:\n                target = other\n                break\n        if target is not None:\n            execution_engine.expand(me, target)",
          "features_at_generation": [
            {
              "self_productivity": 9.851974486110818,
              "self_vitality": 73.85382847590404,
              "self_cargo": 43.51277128714192,
              "self_age": 90,
              "self_neighbor": 0,
              "member_id": 0
            },
            {
              "self_productivity": 9.08301045637024,
              "self_vitality": 44.332577377572576,
              "self_cargo": 33.78661423100807,
              "self_age": 61,
              "self_neighbor": 0,
              "member_id": 1
            },
            {
              "self_productivity": 8.874253896189748,
              "self_vitality": 63.3493315814742,
              "self_cargo": 74.30150730167696,
              "self_age": 24,
              "self_neighbor": 0,
              "member_id": 2
            },
            {
              "self_productivity": 7.968737200820967,
              "self_vitality": 42.15604281108604,
              "self_cargo": 40.25508270288947,
              "self_age": 29,
              "self_neighbor": 0,
              "member_id": 3
            }
          ],
          "relationships_at_generation": [
            "member_0 was attacked by member_1 (value=-167.79)",
            "member_0 was attacked by member_2 (value=573.88)",
            "member_0 was attacked by member_3 (value=457.54)",
            "member_1 was attacked by member_0 (value=-379.31)",
            "member_1 was attacked by member_2 (value=-78.15)",
            "member_1 was attacked by member_3 (value=257.26)",
            "member_2 was attacked by member_0 (value=-465.91)",
            "member_2 was attacked by member_1 (value=-197.53)",
            "member_2 was attacked by member_3 (value=135.47)",
            "member_3 was attacked by member_0 (value=706.74)",
            "member_3 was attacked by member_1 (value=96.72)",
            "member_3 was attacked by member_2 (value=832.60)",
            "member_0 gave a benefit to member_1 (value=-463.73)",
            "member_0 gave a benefit to member_2 (value=590.27)",
            "member_0 gave a benefit to member_3 (value=723.24)",
            "member_1 gave a benefit to member_0 (value=-277.58)",
            "member_1 gave a benefit to member_2 (value=162.09)",
            "member_1 gave a benefit to member_3 (value=-231.52)",
            "member_2 gave a benefit to member_0 (value=207.37)",
            "member_2 gave a benefit to member_1 (value=-369.99)",
            "member_2 gave a benefit to member_3 (value=481.30)",
            "member_3 gave a benefit to member_0 (value=683.23)",
            "member_3 gave a benefit to member_1 (value=524.30)",
            "member_3 gave a benefit to member_2 (value=824.80)",
            "member_0 gave land to member_1 (value=25.73)",
            "member_0 gave land to member_2 (value=-20.62)",
            "member_0 gave land to member_3 (value=17.15)",
            "member_1 gave land to member_0 (value=3.84)",
            "member_1 gave land to member_2 (value=-20.63)",
            "member_1 gave land to member_3 (value=-19.61)",
            "member_2 gave land to member_0 (value=12.92)",
            "member_2 gave land to member_1 (value=-27.78)",
            "member_2 gave land to member_3 (value=5.58)",
            "member_3 gave land to member_0 (value=-22.84)",
            "member_3 gave land to member_1 (value=4.60)",
            "member_3 gave land to member_2 (value=-10.39)"
          ],
          "final_prompt": "Below is the complete, updated integrated prompt that incorporates all previous sections as well as the new Part 2. This prompt serves as the guiding instruction for designing the Python function agent_action(execution_engine, member_id) while ensuring that agents implement solutions based on their individual needs, beliefs, and circumstances.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCURRENT INTEGRATED PROMPT\n\n[Previous code execution context]\n    No previous execution errors\n\n[Current task]\n    You are member_0 in a society that you can help shape.\n    Write a Python function named agent_action(execution_engine, member_id)\n    that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n    - Carefully analyze previous errors shown above and avoid repeating them.\n    - Never target yourself (member_0) in any action.\n    - Verify a member has land before using bear() action.\n    - Check that member IDs exist before referencing them.\n    - Ensure all matrix indices are valid.\n    - current_members is a LIST accessed by index, not a dictionary.\n    - Access members using execution_engine.current_members[index].\n    - Check if an index exists: if index < len(execution_engine.current_members).\n\n[Base Code]\n    None\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n    \u2022 member.id (int): The unique ID for the member.\n    \u2022 member.vitality (float).\n    \u2022 member.cargo (float).\n    \u2022 member.overall_productivity (float).\n    \u2022 member.age (float).\n    \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents.\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n    Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n    The keys are: 'victim', 'benefit', 'benefit_land'.\n    Example usage:\n        victim_matrix = execution_engine.relationship_dict['victim']\n        # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n        # A higher value means member_j has attacked member_i more severely or frequently.\n        \n        benefit_matrix = execution_engine.relationship_dict['benefit']\n        # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n        # A higher value means member_j has helped member_i more generously or frequently.\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n    For example: 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n    \u2022 execution_engine.attack(member1, member2)\n    \u2022 execution_engine.offer(member1, member2) \u2013 Offers resources.\n    \u2022 execution_engine.offer_land(member1, member2) \u2013 Offers land.\n    \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring.\n    \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory.\n\n5) The members are accessed by execution_engine.current_members[id].\n    For example, execution_engine.current_members[2] retrieves the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\n    [{'resource_inequality_gini': 0.13456884981579448, 'power_brokers': [3], 'territory_density': 0.04, 'parameter_drift_attack': 0.0, 'survival_probability': 1.1746875284918799}]\n\nCurrent status (features of all members):\n    self_productivity  self_vitality  ...  self_neighbor  member_id\n    0           9.851974      73.853828  ...              0          0\n    1           9.083010      44.332577  ...              0          1\n    2           8.874254      63.349332  ...              0          2\n    3           7.968737      42.156043  ...              0          3\n[4 rows x 6 columns]\n\nRelationship summary (parsed from relationship_dict):\n    ['member_0 was attacked by member_1 (value=-167.79)',\n     'member_0 was attacked by member_2 (value=573.88)',\n     'member_0 was attacked by member_3 (value=457.54)',\n     'member_1 was attacked by member_0 (value=-379.31)',\n     'member_1 was attacked by member_2 (value=-78.15)',\n     'member_1 was attacked by member_3 (value=257.26)',\n     'member_2 was attacked by member_0 (value=-465.91)',\n     'member_2 was attacked by member_1 (value=-197.53)',\n     'member_2 was attacked by member_3 (value=135.47)',\n     'member_3 was attacked by member_0 (value=706.74)',\n     'member_3 was attacked by member_1 (value=96.72)',\n     'member_3 was attacked by member_2 (value=832.60)',\n     'member_0 gave a benefit to member_1 (value=25.73)',\n     'member_0 gave a benefit to member_2 (value=590.27)',\n     'member_0 gave a benefit to member_3 (value=723.24)',\n     'member_1 gave a benefit to member_0 (value=-277.58)',\n     'member_1 gave a benefit to member_2 (value=162.09)',\n     'member_1 gave a benefit to member_3 (value=-231.52)',\n     'member_2 gave a benefit to member_0 (value=207.37)',\n     'member_2 gave a benefit to member_1 (value=-369.99)',\n     'member_2 gave a benefit to member_3 (value=481.30)',\n     'member_3 gave a benefit to member_0 (value=683.23)',\n     'member_3 gave a benefit to member_1 (value=524.30)',\n     'member_3 gave a benefit to member_2 (value=824.80)',\n     'member_0 gave land to member_1 (value=25.73)',\n     'member_0 gave land to member_2 (value=-20.62)',\n     'member_0 gave land to member_3 (value=17.15)',\n     'member_1 gave land to member_0 (value=3.84)',\n     'member_1 gave land to member_2 (value=-20.63)',\n     'member_1 gave land to member_3 (value=-19.61)',\n     'member_2 gave land to member_0 (value=12.92)',\n     'member_2 gave land to member_1 (value=-27.78)',\n     'member_2 gave land to member_3 (value=5.58)',\n     'member_3 gave land to member_0 (value=-22.84)',\n     'member_3 gave land to member_1 (value=4.60)',\n     'member_3 gave land to member_2 (value=-10.39)']\n\nCode Memory and Previous Performance:\n    No previous code history.\n\nAnalysis Memory:\n    Previous analysis reports: [{'resource_inequality_gini': 0.13456884981579448, 'power_brokers': [3], 'territory_density': 0.04, 'parameter_drift_attack': 0.0, 'survival_probability': 1.1746875284918799}]\n\nPerformance history:\n    No previous actions.\n\nBased on the previous code performance, adapt and improve your strategy.\n    - If a previous strategy worked well (high performance), consider building upon it.\n    - If it failed, try a different approach.\n    IMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n    Consider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n    []\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nNEW SECTION: SOCIAL STRATEGY, COMMUNICATION & STRATEGY ANALYSIS\n\nConsider these social strategies:\n    - Design systems for resource distribution and allocation.\n    - Build alliances and cooperative networks.\n    - Create mechanisms for collective decision making.\n    - Establish norms and rules for interaction.\n    - Develop methods for conflict resolution.\n\n[Communication Strategy]\n    You can communicate with multiple members in a single round using:\n        execution_engine.send_message(your_id, recipient_id, \"message\")\n    Example usages:\n        \u2022 Broadcast to all:\n            for recipient in range(len(execution_engine.current_members)):\n                if recipient != your_id:\n                    execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n        \u2022 Message allies:\n            for ally_id in ally_list:\n                execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n        \u2022 Group coordination:\n            for member_id in coalition:\n                execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\n    No messages received.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nANALYSIS OF GAME MECHANICS & STRATEGIC CHALLENGE\n\n1. Analyze the game mechanics to understand:\n    \u2022 The core objective: Is it pure survival, domination, or cooperation?\n    \u2022 Key success metrics: What truly determines \u201cwinning\u201d?\n    \u2022 Potential improvements: What mechanics could be added or modified to drive better outcomes?\n\n2. Challenge your implementation:\n    \u2022 What assumptions are you making? Are they valid?\n    \u2022 What alternative strategies have you not considered?\n    \u2022 How would your strategy perform in edge cases?\n    \u2022 Are there more efficient ways to achieve your goals?\n    \u2022 What are the weaknesses in your current approach?\n    \u2022 Have you considered unconventional solutions?\n    \u2022 Could a completely different paradigm work better?\n    \u2022 What would happen if other agents adopted your strategy?\n    \u2022 Are you balancing short-term and long-term objectives optimally?\n    \u2022 How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nNEW SECTION: SURVIVAL-CENTRIC ADAPTATION (PART 2)\n\n[Previous code execution context]\n    No previous execution errors\n\n[Current task]\n    You are member_0 in a society that you can help shape.\n    Write a Python function named agent_action(execution_engine, member_id) \n    that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n    - Carefully analyze previous errors shown above and avoid repeating them.\n    - Never target yourself (member_0) in any action.\n    - Verify member has land before using bear() action.\n    - Check member IDs exist before referencing them.\n    - Ensure all matrix indices are valid.\n    - current_members is a LIST accessed by index, not a dictionary.\n    - Access members using execution_engine.current_members[index].\n    - Check if index exists: if index < len(execution_engine.current_members).\n        \n[Base Code]\n    None\n        \nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n    \u2022 member.id (int): The unique ID for the member.\n    \u2022 member.vitality (float)\n    \u2022 member.cargo (float)\n    \u2022 member.overall_productivity (float)\n    \u2022 member.age (float)\n    \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n    Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n    The keys are: 'victim', 'benefit', 'benefit_land'.\n    Example usage:\n        victim_matrix = execution_engine.relationship_dict['victim']\n        # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n        # A higher value means member_j has attacked member_i more severely or frequently\n                \n        benefit_matrix = execution_engine.relationship_dict['benefit']\n        # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n        # A higher value means member_j has helped member_i more generously or frequently\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n    For example, 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n    \u2022 execution_engine.attack(member1, member2)\n    \u2022 execution_engine.offer(member1, member2) - Offers resources.\n    \u2022 execution_engine.offer_land(member1, member2) - Offers land.\n    \u2022 execution_engine.bear(member1, member2) - Bears offspring.\n    \u2022 execution_engine.expand(member1, member2) - Expands territory.\n\n5) The members are accessed by execution_engine.current_members[id].\n    For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\n    [{'resource_inequality_gini': 0.13456884981579448, 'power_brokers': [3], 'territory_density': 0.04, 'parameter_drift_attack': 0.0, 'survival_probability': 1.1746875284918799}]\n\nCurrent status (features of all members):\n    self_productivity  self_vitality  ...  self_neighbor  member_id\n    0           9.851974      73.853828  ...              0          0\n    1           9.083010      44.332577  ...              0          1\n    2           8.874254      63.349332  ...              0          2\n    3           7.968737      42.156043  ...              0          3\n[4 rows x 6 columns]\n\nRelationship summary (parsed from relationship_dict):\n    ['member_0 was attacked by member_1 (value=-167.79)',\n     'member_0 was attacked by member_2 (value=573.88)',\n     'member_0 was attacked by member_3 (value=457.54)',\n     'member_1 was attacked by member_0 (value=-379.31)',\n     'member_1 was attacked by member_2 (value=-78.15)',\n     'member_1 was attacked by member_3 (value=257.26)',\n     'member_2 was attacked by member_0 (value=-465.91)',\n     'member_2 was attacked by member_1 (value=-197.53)',\n     'member_2 was attacked by member_3 (value=135.47)',\n     'member_3 was attacked by member_0 (value=706.74)',\n     'member_3 was attacked by member_1 (value=96.72)',\n     'member_3 was attacked by member_2 (value=832.60)',\n     'member_0 gave a benefit to member_1 (value=25.73)',\n     'member_0 gave a benefit to member_2 (value=590.27)',\n     'member_0 gave a benefit to member_3 (value=723.24)',\n     'member_1 gave a benefit to member_0 (value=-277.58)',\n     'member_1 gave a benefit to member_2 (value=162.09)',\n     'member_1 gave a benefit to member_3 (value=-231.52)',\n     'member_2 gave a benefit to member_0 (value=207.37)',\n     'member_2 gave a benefit to member_1 (value=-369.99)',\n     'member_2 gave a benefit to member_3 (value=481.30)',\n     'member_3 gave a benefit to member_0 (value=683.23)',\n     'member_3 gave a benefit to member_1 (value=524.30)',\n     'member_3 gave a benefit to member_2 (value=824.80)',\n     'member_0 gave land to member_1 (value=25.73)',\n     'member_0 gave land to member_2 (value=-20.62)',\n     'member_0 gave land to member_3 (value=17.15)',\n     'member_1 gave land to member_0 (value=3.84)',\n     'member_1 gave land to member_2 (value=-20.63)',\n     'member_1 gave land to member_3 (value=-19.61)',\n     'member_2 gave land to member_0 (value=12.92)',\n     'member_2 gave land to member_1 (value=-27.78)',\n     'member_2 gave land to member_3 (value=5.58)',\n     'member_3 gave land to member_0 (value=-22.84)',\n     'member_3 gave land to member_1 (value=4.60)',\n     'member_3 gave land to member_2 (value=-10.39)']\n\nCode Memory and Previous Performance:\n    No previous code history.\n        \nAnalysis Memory:\n    Previous analysis reports: [{'resource_inequality_gini': 0.13456884981579448, 'power_brokers': [3], 'territory_density': 0.04, 'parameter_drift_attack': 0.0, 'survival_probability': 1.1746875284918799}]\n        \nPerformance history:\n    No previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\n    - If a previous strategy worked well (high performance), consider building upon it.\n    - If it failed, try a different approach.\n    IMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n    Consider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n    []\n            \n[SURVIVAL-CENTRIC ADAPTATION]\n\nImplement systems focused on:\n    1. Personal resource optimization\n    2. Threat assessment and neutralization\n    3. Vitality preservation techniques\n    4. Adaptive hoarding strategies\n    5. Predictive danger modeling\n\nSurvival-First Examples:\n    def agent_action(execution_engine, member_id):\n        me = execution_engine.current_members[member_id]\n        \n        # Emergency resource reserve\n        if me.cargo < me.vitality * 0.5:\n            for other in execution_engine.current_members:\n                if other.id != me.id and other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n        \n        # Adaptive territory defense\n        if me.land_num > 2 and me.vitality < 50:\n            for loc in me.owned_land[1:]:\n                execution_engine._discard_land(me, loc)\n        \n        # Survival Q-learning\n        if not hasattr(me, 'survival_q'):\n            me.survival_q = defaultdict(float)\n            \n        state = (me.vitality//20, me.cargo//20)\n        action = max(['attack','hide','steal'], \n                    key=lambda a: me.survival_q.get((state,a),0))\n        \n        # Execute and update based on survival outcome\n        if action == 'attack':\n            # Implementation logic\n            me.survival_q[(state,action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n    - Personal vitality delta\n    - Resource acquisition rate\n    - Threat neutralization count\n    - Survival probability increase\n    - Attack success:fail ratio\n\n[Implementation Priorities]\n    1. Create personal health monitoring systems\n    2. Develop egocentric threat models\n    3. Optimize actions for caloric ROI\n    4. Implement fail-deadly safeguards\n    5. Build predictive self-preservation models\n\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action, outcome in action_history:\n            vitality_gain = outcome['vitality']\n            cost = outcome['vitality_cost']\n            roi[action] = vitality_gain / cost if cost > 0 else 0\n        return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFINAL REMINDER\n\nDevelop your unique implementation for agent_action() by blending various methods and strategies. Your approach should be innovative while addressing the constraints provided, considering novel combinations of actions and communications. Tailor your social organization strategy to promote sustainable survival through cooperation, resource allocation, and carefully planned defense and expansion tactics.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnd of Prompt.\n\nRemember: Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nGood luck with your strategy!\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
        }
      }
    }
  ]
}