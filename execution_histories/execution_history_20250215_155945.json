{
  "rounds": [
    {
      "timestamp": "2025-02-15T15:52:22.134469",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy Step 1: If our cargo is low relative to our vitality, try to acquire resources.\n    # We attack one member (if found) who has more cargo than us.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break  # Attack at most one target\n\n    # Strategy Step 2: If our productivity is high and we have identified clear adjacent neighbors,\n    # attempt to expand our territory by engaging with one neighbor.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            # Validate that neighbor_index is within the list bounds and is not self.\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                execution_engine.expand(me, neighbor)\n                break  # Expand with one neighbor per round\n\n    # Strategy Step 3: Build alliances via cooperative resource sharing.\n    # Offer resources and land (if available) to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # Only offer land if 'land_num' attribute exists and indicates available land.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy Step 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land (verify attribute existence).\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            potential = execution_engine.current_members[i]\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # Bear offspring with only one partner per round\n\n    # Strategy Step 5: Communication.\n    # Broadcast a cooperative message to all other members to encourage mutual support and civilization-building.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        execution_engine.send_message(me.id, recipient.id,\n                                      \"Let's work together to build strong alliances and usher in prosperity for all!\")",
          "old_stats": {
            "vitality": 73.85382847590404,
            "cargo": 33.660796801031104,
            "survival_chance": 116.8367882719584
          },
          "new_stats": {
            "vitality": 73.85382847590404,
            "cargo": 33.660796801031104,
            "survival_chance": 116.8367882719584
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists in the current membership list.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Log our starting state (this can help in debugging the agent's behavior).\n    # print(\"Agent {} starting turn: cargo={}, vitality={}, territory={}\".format(\n    #     me.id, me.cargo, me.vitality, len(me.current_clear_list)))\n\n    # Phase 1: Defensive Tactical Response.\n    # I'm cautious: if my resources are borderline compared to my vitality,\n    # I take pre-emptive actions against opponents who seem dangerously well-resourced.\n    if me.cargo < me.vitality * 0.7:\n        for i, other in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            # If opponent's cargo exceeds mine by at least 20%, consider them a threat.\n            if other.cargo > me.cargo * 1.2:\n                # Execute an attack to lower their advantage.\n                execution_engine.attack(me, other)\n                # Optionally log the attack decision.\n                # print(\"Agent {} attacks Agent {}.\".format(me.id, other.id))\n\n    # Phase 2: Cooperative Outreach.\n    # When I'm flush with resources (cargo exceeding vitality), I seek to form alliances.\n    if me.cargo > me.vitality:\n        for i, other in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            # I favor others whose vitality is not too far off from mine: a sign of stability.\n            if other.vitality > me.vitality * 0.8:\n                # Partnering with them can increase our collective survivability.\n                execution_engine.offer(me, other, True)\n                # print(\"Agent {} offered help to Agent {}.\".format(me.id, other.id))\n\n    # Phase 3: Strategic Reproduction for Long-Term Growth.\n    # Reproduction is attempted if I have clear territory (non-empty clear list)\n    # and robust resources relative to vitality.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        # I assess my available neighboring territories (neighbors I have cleared).\n        for neighbor_id in me.current_clear_list:\n            # Check for valid neighbor index and avoid self-referential cases.\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                # I also require that the prospective partner controls some territory.\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    # print(\"Agent {} reproduces with Agent {}.\".format(me.id, partner.id))\n                    break  # Only generate one offspring per cycle.\n\n    # Phase 4: Calculated Territorial Expansion.\n    # I seek to expand my holdings only against neighbors that seem less efficient.\n    # This is part of my long-term strategy to secure resources and defensive perimeters.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # If neighbor\u2019s overall productivity is below mine, it's a viable target.\n            if neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, neighbor)\n                # print(\"Agent {} expands into Agent {}'s territory.\".format(me.id, neighbor.id))\n                break  # Limit expansion to one action per round.\n\n    # Phase 5: Communication \u2013 Strengthening Collective Ties.\n    # Regardless of the tactical decisions, I broadcast a strategic message.\n    # This message is intended to foster cooperation while indicating that mutual respect is key.\n    message = (\n        \"Agent {} here. In these challenging times, \"\n        \"cooperation is our strongest asset. \"\n        \"Together we stand, divided we fall.\"\n    ).format(me.id)\n    for i, recipient in enumerate(execution_engine.current_members):\n        if i == member_id:\n            continue\n        execution_engine.send_message(me.id, recipient.id, message)\n        # print(\"Agent {} sent message to Agent {}.\".format(me.id, recipient.id))\n\n    # End of my actions for this turn.\n    return",
          "old_stats": {
            "vitality": 18.332577680505043,
            "cargo": 22.547092118644322,
            "survival_chance": 6.616954880911457
          },
          "new_stats": {
            "vitality": 18.332577680505043,
            "cargo": 11.266491395637424,
            "survival_chance": -4.663645842095445
          },
          "performance_change": -11.280600723006902,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Step 1: Broadcast a tailored cooperative message to promote unity and shared purpose.\n    # This message emphasizes both mutual prosperity and the strength in unity.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"Together we can innovate, overcome adversity, and ensure that every member prospers.\")\n\n    # Step 2: Emergency resource management.\n    # If our cargo is too low relative to our vitality, we must secure resources.\n    # We assess all opponents and target the one with significantly higher cargo,\n    # prioritizing candidates with the greatest difference.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Step 3: Reproduction strategy for long-term prosperity.\n    # With available territory and sufficient resources, seek to form an alliance for reproduction.\n    # We choose a candidate who is resourceful enough (cargo > 30) yet ensuring balanced genetic influence.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > 30:\n                execution_engine.bear(me, candidate)\n                break\n\n    # Step 4: Mutual support and strategic territorial expansion.\n    # We interact with all other agents with two integrated approaches:\n    # (a) If a candidate holds fewer resources, we offer support to boost collective capability.\n    # (b) If clear territory exists and our overall productivity is superior,\n    #     we initiate expansion to secure more assets.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        # Offer support if candidate's cargo is lower, nurturing cooperation.\n        if candidate.cargo < me.cargo:\n            execution_engine.offer(me, candidate, True)\n\n        # Expand territory if conditions are favorable.\n        if len(me.current_clear_list) > 0 and candidate.overall_productivity < me.overall_productivity:\n            execution_engine.expand(me, candidate)\n\n    # Step 5: Defensive countermeasures based on historical aggression.\n    # Using the 'victim' relationship matrix, we identify any candidate toward whom past aggression is high.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Ensure the indices are in the expected bounds.\n            if member_id < len(matrix_victim) and idx < len(matrix_victim[0]):\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Step 6: Survival-centric adaptation.\n    # When vitality is low, immediate defense is paramount.\n    # Identify a candidate with lower overall productivity and offer land for a defensive alliance.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, True)\n                break\n\n    # Step 7: Strategic forward planning.\n    # As an added measure, we can gauge our environment to adjust our risk thresholds.\n    # For instance, if our cargo is vastly superior (e.g., more than 150% of an opponent's),\n    # we might use this advantage to execute pre-emptive expansion or defensive consolidation.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        if me.cargo > candidate.cargo * 1.5:\n            # Pre-emptively secure territory if possible.\n            if len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Alternatively, offer additional resources to solidify alliances.\n            else:\n                execution_engine.offer(me, candidate, True)\n\n    # Final Note:\n    # This implementation is an adaptive blend of aggressive resource recovery,\n    # cooperative alliance building, and strategic expansion.\n    # The agent tailors actions not solely based on immediate comparisons,\n    # but with a long-term view of survival and prosperity\u2014balancing self-interest with collective strength.\n    # Future improvements could integrate predictive modeling and dynamic risk analysis to further\n    # enhance decision making in ever-changing environments.\n\n# End of agent_action implementation.",
          "old_stats": {
            "vitality": 42.15604281108604,
            "cargo": 36.789414164557066,
            "survival_chance": 57.7935159278627
          },
          "new_stats": {
            "vitality": 42.15604281108604,
            "cargo": 13.42504555811643,
            "survival_chance": 34.42914732142206
          },
          "performance_change": -23.364368606440642,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure the member exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Customize thresholds based on our adaptive risk assessment.\n    # We consider our own temperament: if my cargo is less than 1/3 of my vitality,\n    # I feel exposed and might look to bolster my resource situation.\n    resource_ratio_threshold = 0.33\n    low_vitality_threshold = 50.0  # I become cautious when vitality drops below this.\n    high_productivity_threshold = 15.0  # Indicates that I'm capable of territorial expansion.\n\n    # Immediate tactical decision: if resources are low relative to vitality,\n    # then identify an opponent with a clearly stronger cargo and launch an attack.\n    if me.cargo < me.vitality * resource_ratio_threshold:\n        candidate = None\n        best_diff = -1\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            diff = opponent.cargo - me.cargo\n            if diff > best_diff:\n                best_diff = diff\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Warning: my cargo reserves are alarmingly low\u2014initiating attack to reclaim resources.\")\n\n    # Long-term strategic planning and cooperative outreach.\n    for idx in range(total_members):\n        # Skip ourselves.\n        if idx == member_id:\n            continue\n        target = execution_engine.current_members[idx]\n\n        # Begin with an invitation to cooperate in building a resilient society.\n        execution_engine.send_message(member_id, target.id,\n            \"Greetings! Let\u2019s pool our strengths and build a balanced community.\")\n\n        # When my vitality is low and your vitality is high, a tactical support offer is in order.\n        if me.vitality < low_vitality_threshold and target.vitality > low_vitality_threshold:\n            execution_engine.offer(target, me, True)\n            execution_engine.send_message(member_id, target.id,\n                \"I\u2019m running low on vitality\u2014could you support me to keep our dynamics stable?\")\n\n        # Should you have a surplus of cargo relative to me,\n        # I suggest we consider a resource-sharing alliance that benefits both.\n        if target.cargo > me.cargo:\n            execution_engine.send_message(member_id, target.id,\n                \"Your resources are notably abundant compared to mine\u2014perhaps we can form a profitable alliance.\")\n\n        # Strategic territory expansion: if I boast high productivity and you have unclaimed land,\n        # we can jointly secure a better position.\n        if me.overall_productivity > high_productivity_threshold and len(target.current_clear_list) > 0:\n            execution_engine.expand(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"My capabilities for growth are high; let\u2019s expand our territories together for a competitive edge.\")\n\n        # Reproductive strategy to ensure long-term survival:\n        # Both of us having claimable land makes a union of our strengths beneficial.\n        if len(me.current_clear_list) > 0 and len(target.current_clear_list) > 0:\n            execution_engine.bear(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"Combining our genetic and territorial strengths could secure our future prosperity.\")\n\n    # Broadcast a community-wide message to reinforce a collective mindset.\n    for idx in range(total_members):\n        if idx != member_id:\n            execution_engine.send_message(member_id, execution_engine.current_members[idx].id,\n                \"United collaboration today paves the way for a thriving future tomorrow.\")\n\n    # Implement adaptive survival management using a simple Q-learning strategy.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Discretize the state by grouping vitality and cargo in intervals of 25.\n    state = (int(me.vitality // 25), int(me.cargo // 25))\n    possible_actions = ['attack', 'hide', 'steal']\n    # Choose the action with the highest estimated survival value.\n    best_action = max(possible_actions, key=lambda act: me.survival_q.get((state, act), 0))\n\n    if best_action == 'attack':\n        candidate = None\n        best_metric = -1\n        # Evaluate opponents using a combined metric: cargo plus a fraction of their vitality.\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            metric = opponent.cargo + 0.5 * opponent.vitality\n            if metric > best_metric:\n                best_metric = metric\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Engaging target based on strategic attack protocol to boost my resource reserves.\")\n        me.survival_q[(state, 'attack')] += me.vitality * 0.2\n\n    elif best_action == 'steal':\n        candidate = None\n        highest_cargo = -1\n        # Identify the opponent with the maximum cargo for a precise resource appropriation.\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if opponent.cargo > highest_cargo:\n                highest_cargo = opponent.cargo\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Initiating a calculated maneuver to appropriate resources from a better-stocked target.\")\n        me.survival_q[(state, 'steal')] += me.vitality * 0.1\n\n    elif best_action == 'hide':\n        # A defensive strategy: by concealing actions, I conserve resources for future operations.\n        execution_engine.send_message(member_id, me.id,\n            \"Entering a defensive mode to restore strength and await a more opportune moment.\")\n        me.survival_q[(state, 'hide')] += 0.0\n\n    return",
          "old_stats": {
            "vitality": 18.47747982181767,
            "cargo": 40.186552045152894,
            "survival_chance": 38.8426382682447
          },
          "new_stats": {
            "vitality": 18.47747982181767,
            "cargo": 41.94547296730831,
            "survival_chance": 40.953343374831206
          },
          "performance_change": 2.110705106586508,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [
            "From member_1: Agent 1 here. In these challenging times, cooperation is our strongest asset. Together we stand, divided we fall.",
            "From member_3: Greetings! Let\u2019s pool our strengths and build a balanced community.",
            "From member_3: United collaboration today paves the way for a thriving future tomorrow."
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_1: Agent 1 here. In these challenging times, cooperation is our strongest asset. Together we stand, divided we fall.",
            "From member_2: Together we can innovate, overcome adversity, and ensure that every member prospers."
          ],
          "sent": []
        }
      }
    },
    {
      "timestamp": "2025-02-15T15:59:45.454069",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate that member_id is within range.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: Immediate Survival via Resource Optimization and Threat Neutralization\n    # If cargo is low compared to vitality, identify a target with higher cargo and attack.\n    if me.cargo < 0.5 * me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if other.cargo > me.cargo:\n                # Attack to neutralize potential threats while balancing resource disparity.\n                execution_engine.attack(me, other)\n                break\n\n    # Strategy 2: Territorial Expansion for Long-Term Prosperity\n    # If overall productivity is high and there is at least one clear territory, try to expand our reach.\n    if hasattr(me, 'current_clear_list') and me.current_clear_list and me.overall_productivity > 8.0:\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                neighbor = execution_engine.current_members[neighbor_idx]\n                try:\n                    # Attempt to expand territory using the expand method which takes two arguments.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # If expansion fails due to argument mismatch, offer land instead.\n                    execution_engine.offer_land(me, neighbor, True)\n                break\n\n    # Strategy 3: Cooperation for Mutual Benefit\n    # Forge alliances with members who have lower vitality to build a cooperative network.\n    for idx, partner in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # Offer resources if the partner shows signs of vulnerability relative to our own vitality.\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # If the agent has land (territory), extend the offer of land to bolster the alliance.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for Sustainable Growth\n    # Engage in reproductive actions if both agents have sufficient territory and vitality.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for idx, potential in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Only consider partners with territory.\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break\n\n    # Strategy 5: Governance and Communication for a Collective Future\n    # Broadcast a message to all other agents inviting collaboration and the establishment of progressive social norms.\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        message = (\"Let\u2019s join forces to share resources, expand our territories cooperatively, \"\n                   \"and build governance systems that secure both our survival and long-term prosperity.\")\n        execution_engine.send_message(me.id, recipient.id, message)",
          "old_stats": {
            "vitality": 21.1667091492471,
            "cargo": 0.0,
            "survival_chance": 22.744874485036277
          },
          "new_stats": {
            "vitality": 21.1667091492471,
            "cargo": 0.0,
            "survival_chance": 22.744874485036277
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Retrieve the current member (self) from the engine by index.\n    if member_id >= len(execution_engine.current_members):\n        return  # invalid member_id, do nothing\n    me = execution_engine.current_members[member_id]\n\n    # Ensure we have a survival Q-table for adaptive decision making.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Determine state based on vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n\n    # Define possible actions.\n    actions = ['attack', 'expand', 'bear', 'offer']\n    # Pick an action based on the current Q value (default to 'offer' if tied).\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Helper: send alliance messages to all other valid members.\n    def broadcast_alliance_message():\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id or other.id == me.id:\n                continue\n            # Ensure valid index by checking current_members length.\n            if idx < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, other.id, \"Let's cooperate for mutual growth.\")\n\n    # Action: if cargo is critically low relative to vitality, try to attack a member with higher cargo.\n    if me.cargo < me.vitality * 0.5:\n        for idx, other in enumerate(execution_engine.current_members):\n            if other.id == me.id:\n                continue  # Never target self.\n            # Check that the member exists in the current list.\n            if idx < len(execution_engine.current_members) and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Update Q-table: small reward for taking an aggressive action when in distress.\n                me.survival_q[(state, 'attack')] += me.vitality * 0.05\n                return\n\n    # Action: if we have clear land (indicative by current_clear_list length > 0) and enough cargo, consider reproduction.\n    if len(me.current_clear_list) > 0 and me.cargo > 20:\n        partner = None\n        # Choose a partner based on relatively high vitality and overall productivity.\n        for idx, potential in enumerate(execution_engine.current_members):\n            if potential.id == me.id:\n                continue  # avoid self-targeting\n            if potential.vitality >= me.vitality * 0.8 and potential.overall_productivity >= 0:\n                partner = potential\n                break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n            me.survival_q[(state, 'bear')] += 5.0\n            return\n\n    # Action: if we have clear land available, use it to expand territory.\n    if len(me.current_clear_list) > 0:\n        # We'll target the first available member from the current_clear_list if valid.\n        target_idx = me.current_clear_list[0]\n        if target_idx < len(execution_engine.current_members):\n            target = execution_engine.current_members[target_idx]\n            if target.id != me.id:\n                execution_engine.expand(me, target)\n                me.survival_q[(state, 'expand')] += 2.0\n                return\n\n    # Action: If our cargo is moderately high compared to vitality, make cooperative offers.\n    if me.cargo > me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if other.id == me.id:\n                continue\n            if idx < len(execution_engine.current_members):\n                execution_engine.offer(me, other, True)\n        me.survival_q[(state, 'offer')] += 1.0\n\n    # Finally, broadcast an alliance message to encourage cooperative behavior.\n    broadcast_alliance_message()",
          "old_stats": {
            "vitality": 55.58108836920247,
            "cargo": 0.0,
            "survival_chance": 45.954756999796736
          },
          "new_stats": {
            "vitality": 55.58108836920247,
            "cargo": 0.0,
            "survival_chance": 45.954756999796736
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Immediate tactical action: if cargo is low relative to vitality, try to recover resources via an attack.\n    # Choose an opponent (other than self) having higher cargo.\n    if me.cargo < 10:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            # Basic safeguard: only consider opponents with some vitality.\n            if opponent.vitality > 0 and opponent.cargo > me.cargo:\n                # Attack opponent to try and gain resources.\n                execution_engine.attack(me, opponent)\n                break\n\n    # Long-term strategic move: if we control clear territory, we can plan expansion and cooperative reproduction.\n    if me.current_clear_list:\n        # Attempt reproduction to secure long-term survival.\n        # Look for a potential partner (ally) with a healthy vitality and decent productivity.\n        partner_found = False\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            partner = execution_engine.current_members[idx]\n            if partner.vitality > 30 and partner.overall_productivity > 40:\n                # Since reproduction requires available land, we call bear() only if clear territory exists.\n                execution_engine.bear(me, partner)\n                partner_found = True\n                break\n        # If no suitable partner is found, send a cooperative message to encourage alliance-building.\n        if not partner_found:\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue\n                potential_ally = execution_engine.current_members[idx]\n                execution_engine.send_message(me.id, potential_ally.id, \"Let's consider future collaboration for mutual prosperity.\")\n\n    # Defensive strategy: if our vitality is low, use available land to forge better alliances.\n    if me.vitality < 20 and me.current_clear_list:\n        # Offer land support to a stable agent to build a protective alliance.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            ally = execution_engine.current_members[idx]\n            if ally.overall_productivity > 50 and ally.vitality > 25:\n                # Check for clear territory before offering land.\n                execution_engine.offer_land(me, ally, True)\n                break\n\n    # Territorial expansion: if we have available clear regions, try expanding our territory.\n    if me.current_clear_list:\n        # Identify an opponent (other than self) that might have fewer clear territories than we do.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if len(opponent.current_clear_list) < len(me.current_clear_list):\n                execution_engine.expand(me, opponent)\n                break\n\n    # Communication for collective decision-making:\n    # Broadcast a message to all other members encouraging a cooperative approach\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            recipient = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, recipient.id,\n                \"Cooperation and balanced growth are key; let's work together for a sustainable future!\")",
          "old_stats": {
            "vitality": 45.314487560216655,
            "cargo": 0.0,
            "survival_chance": 51.576471267268516
          },
          "new_stats": {
            "vitality": 45.314487560216655,
            "cargo": 0.0,
            "survival_chance": 51.576471267268516
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Get our own member object safely (assuming member_id is valid)\n    if member_id >= len(execution_engine.current_members):\n        return  # invalid member_id, do nothing\n    me = execution_engine.current_members[member_id]\n\n    # Parse relationships summary (for internal use, may help decide actions)\n    try:\n        relationships = execution_engine.parse_relationship_matrix()\n    except Exception:\n        relationships = {}\n\n    num_members = len(execution_engine.current_members)\n    # Build a list of candidate indices that are not ourselves\n    candidate_ids = [i for i in range(num_members) if i != member_id]\n\n    # ---------------------------\n    # 1. Territorial expansion:\n    # If we have available clear land and our overall productivity is robust,\n    # we try to expand our territory.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n        if hasattr(me, \"overall_productivity\") and me.overall_productivity > 20:\n            # Use our own available land to attempt expansion.\n            execution_engine.expand(me, me)\n            return\n\n    # ---------------------------\n    # 2. Cooperative reproductive strategy:\n    # If we have available clear land and are of reproductive age,\n    # we look for a partner who also has available land.\n    # Note: we check reproductive age threshold (set arbitrarily at 5) to avoid premature reproduction.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list and hasattr(me, \"age\") and me.age >= 5:\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if (hasattr(partner, \"current_clear_list\") and partner.current_clear_list and\n                    hasattr(partner, \"age\") and partner.age >= 5):\n                    execution_engine.bear(me, partner)\n                    return\n\n    # ---------------------------\n    # 3. Cooperative resource sharing:\n    # If we see members with lower vitality than ourselves,\n    # we offer them resources as a gesture of goodwill (building social capital).\n    # ---------------------------\n    if hasattr(me, \"vitality\"):\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, \"vitality\") and partner.vitality < me.vitality:\n                    execution_engine.offer(me, partner, True)\n                    return\n\n    # ---------------------------\n    # 4. Defensive aggression:\n    # Check if any opponent has previously attacked us.\n    # The relationship matrix 'victim' is assumed to record attack counts:\n    #   matrix[member_id, attacker_id] > 0 means attacker attacked us.\n    # If such hostility is noticed, we counterattack.\n    # ---------------------------\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for j in candidate_ids:\n            # Ensure valid indexing in the relationship matrix\n            try:\n                if victim_matrix[member_id, j] > 0:\n                    # Before attacking, double-check that the target exists.\n                    if j < num_members:\n                        target = execution_engine.current_members[j]\n                        execution_engine.attack(me, target)\n                        return\n            except Exception:\n                continue\n\n    # ---------------------------\n    # 5. Propose a long\u2010term cooperative modification:\n    # To promote collective governance and stability, propose establishing a council.\n    # If the method is not available, simply proceed.\n    # ---------------------------\n    try:\n        execution_engine.propose_modification(\"Council\", {\"description\": \"Establish a council for cooperative governance and dispute resolution.\"})\n    except Exception:\n        pass\n\n    # ---------------------------\n    # 6. Cooperative land offering:\n    # If we have available land yet encounter partners lacking clear territory,\n    # we offer them some land in a spirit of alliance formation.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if not (hasattr(partner, \"current_clear_list\") and partner.current_clear_list):\n                    execution_engine.offer_land(me, partner, True)\n                    return\n\n    # ---------------------------\n    # 7. Fallback action:\n    # If no other tactical or cooperative action applies,\n    # we can simply send a friendly message to a randomly chosen peer.\n    # (Here we choose the first valid candidate for demonstration.)\n    # ---------------------------\n    if candidate_ids:\n        try:\n            target = execution_engine.current_members[candidate_ids[0]]\n            execution_engine.send_message(me, target, \"Let's work together for mutual benefit.\")\n        except Exception:\n            pass\n\n    return",
          "old_stats": {
            "vitality": 39.54024074627975,
            "cargo": 0.0,
            "survival_chance": 50.450860472036275
          },
          "new_stats": {
            "vitality": 39.54024074627975,
            "cargo": 0.0,
            "survival_chance": 50.450860472036275
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [
            "From member_0: Let\u2019s join forces to share resources, expand our territories cooperatively, and build governance systems that secure both our survival and long-term prosperity.",
            "From member_3: Cooperation and balanced growth are key; let's work together for a sustainable future!"
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_0: Let\u2019s join forces to share resources, expand our territories cooperatively, and build governance systems that secure both our survival and long-term prosperity.",
            "From member_2: Let's cooperate for mutual growth."
          ],
          "sent": []
        }
      }
    }
  ],
  "generated_code": {
    "0": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy Step 1: If our cargo is low relative to our vitality, try to acquire resources.\n    # We attack one member (if found) who has more cargo than us.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break  # Attack at most one target\n\n    # Strategy Step 2: If our productivity is high and we have identified clear adjacent neighbors,\n    # attempt to expand our territory by engaging with one neighbor.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            # Validate that neighbor_index is within the list bounds and is not self.\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                execution_engine.expand(me, neighbor)\n                break  # Expand with one neighbor per round\n\n    # Strategy Step 3: Build alliances via cooperative resource sharing.\n    # Offer resources and land (if available) to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # Only offer land if 'land_num' attribute exists and indicates available land.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy Step 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land (verify attribute existence).\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            potential = execution_engine.current_members[i]\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # Bear offspring with only one partner per round\n\n    # Strategy Step 5: Communication.\n    # Broadcast a cooperative message to all other members to encourage mutual support and civilization-building.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        execution_engine.send_message(me.id, recipient.id,\n                                      \"Let's work together to build strong alliances and usher in prosperity for all!\")",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 33.660796801031104,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 39.175257494005535,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 32.2863455020685,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 37.4760063897966,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=25.56)",
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-43.12)",
          "member_1 was attacked by member_0 (value=-11.72)",
          "member_1 was attacked by member_2 (value=47.93)",
          "member_1 was attacked by member_3 (value=48.04)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_1 (value=87.03)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_1 (value=75.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_1 (value=71.17)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_1 gave a benefit to member_0 (value=-27.19)",
          "member_1 gave a benefit to member_2 (value=7.38)",
          "member_1 gave a benefit to member_3 (value=21.87)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_1 (value=68.92)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=16.90)",
          "member_3 gave a benefit to member_1 (value=-18.41)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_0 gave land to member_1 (value=-0.80)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_1 gave land to member_0 (value=-0.45)",
          "member_1 gave land to member_2 (value=1.91)",
          "member_1 gave land to member_3 (value=-2.53)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_1 (value=2.46)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_1 (value=0.96)",
          "member_3 gave land to member_2 (value=-1.75)"
        ],
        "final_prompt": "CURRENT FULL INTEGRATED PROMPT\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_0 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Critical constraints]\n\u2022 Carefully analyze previous errors shown above and avoid repeating them.\n\u2022 Never target yourself (member_0) in any action.\n\u2022 Verify a member has land before using the bear() action.\n\u2022 Check that member IDs exist before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index, not a dictionary.\n\u2022 Access members using execution_engine.current_members[index].\n\u2022 Check if index exists: if index < len(execution_engine.current_members).\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Available Member Attributes and Methods]\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2014 IDs of neighbors or cleared adjacents.\n2) Relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   \u2022 Use the arrays in relationship_dict, or rely on the provided summary (variable 'relations').\n   \u2022 The keys are: 'victim', 'benefit', 'benefit_land'.\n   \u2022 Example: \n         matrix = execution_engine.relationship_dict['victim']\n         # Here matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n3) The method parse_relationship_matrix produces a summary of relationships as a list of strings.\n   \u2022 Example: \"member_2 was attacked by member_1 (value=3.00)\".\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 offers resources.\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 offers land.\n   \u2022 execution_engine.bear(member1, member2) \u2013 bears offspring.\n   \u2022 execution_engine.expand(member1, member2) \u2013 expands territory.\n5) The members are accessed by execution_engine.current_members[id].\n   \u2022 Example: execution_engine.current_members[2] locates the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality';\n   use member.id, member.vitality, etc.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Current Status of All Members]\nFeatures of all members:\n   self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0           9.851974      73.853828   33.660797        90              1          0\n1           8.077967      33.027814   39.175257        81              0          1\n2           7.968737      42.156043   32.286346        29              1          2\n3           9.205662      18.477480   37.476006        24              0          3\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Relationship Summary]\nParsed from relationship_dict:\n['member_0 was attacked by member_1 (value=25.56)', 'member_0 was attacked by member_2 (value=64.41)', 'member_0 was attacked by member_3 (value=-43.12)', 'member_1 was attacked by member_0 (value=-11.72)', 'member_1 was attacked by member_2 (value=47.93)', 'member_1 was attacked by member_3 (value=48.04)', 'member_2 was attacked by member_0 (value=-12.32)', 'member_2 was attacked by member_1 (value=87.03)', 'member_2 was attacked by member_3 (value=95.31)', 'member_3 was attacked by member_0 (value=38.28)', 'member_3 was attacked by member_1 (value=75.31)', 'member_3 was attacked by member_2 (value=16.73)', 'member_0 gave a benefit to member_1 (value=71.17)', 'member_0 gave a benefit to member_2 (value=13.64)', 'member_0 gave a benefit to member_3 (value=32.58)', 'member_1 gave a benefit to member_0 (value=-27.19)', 'member_1 gave a benefit to member_2 (value=7.38)', 'member_1 gave a benefit to member_3 (value=21.87)', 'member_2 gave a benefit to member_0 (value=4.78)', 'member_2 gave a benefit to member_1 (value=68.92)', 'member_2 gave a benefit to member_3 (value=71.57)', 'member_3 gave a benefit to member_0 (value=16.90)', 'member_3 gave a benefit to member_1 (value=-18.41)', 'member_3 gave a benefit to member_2 (value=95.17)', 'member_0 gave land to member_1 (value=-0.80)', 'member_0 gave land to member_2 (value=-2.26)', 'member_0 gave land to member_3 (value=-0.03)', 'member_1 gave land to member_0 (value=-0.45)', 'member_1 gave land to member_2 (value=1.91)', 'member_1 gave land to member_3 (value=-2.53)', 'member_2 gave land to member_0 (value=-2.12)', 'member_2 gave land to member_1 (value=2.46)', 'member_2 gave land to member_3 (value=1.77)', 'member_3 gave land to member_0 (value=1.04)', 'member_3 gave land to member_1 (value=0.96)', 'member_3 gave land to member_2 (value=-1.75)']\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Code Memory and Previous Performance]\nNo previous code history.\nPerformance history: No previous actions.\n\nBased on previous code performance, adapt and improve your strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy any example implementations provided below. Instead, use them as inspiration to develop your own unique solution by integrating a wide range of available methods and strategies in novel ways.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Social Strategies]\nConsider these social strategies when formulating your approach:\n\u2022 Design systems for resource distribution and allocation.\n\u2022 Build alliances and cooperative networks.\n\u2022 Create mechanisms for collective decision making.\n\u2022 Establish norms and rules for interaction.\n\u2022 Develop methods for conflict resolution.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n   execution_engine.send_message(your_id, recipient_id, \"message\")\nExample usages:\n\u2022 Broadcast to all:\n      for recipient in range(len(execution_engine.current_members)):\n          if recipient != your_id:\n              execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n\u2022 Messaging allies:\n      for ally_id in ally_list:\n          execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n\u2022 Group coordination:\n      for member_id in coalition:\n          execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Received Messages]\nNo messages received.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Current Game Mechanisms]\n[]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Strategic Analysis and Game Mechanics]\n\u2022 Analyze the core objective: Consider whether the game is about pure survival, domination, or cooperation.\n\u2022 Identify key success metrics: Determine what truly counts as \"winning\" (e.g., individual prosperity, community advancement, balanced power distribution).\n\u2022 Consider potential improvements: What mechanics could be added or modified for a more robust simulation?\n\u2022 Strategic considerations:\n    1. Resource optimization vs. social capital.\n    2. Balancing individual success against collective achievement.\n    3. Weighing short-term survival versus long-term prosperity.\n    4. Navigating competition versus cooperation dynamics.\n    5. Assessing risk versus reward tradeoffs.\n\nAnalyze other players\u2019 strategies:\n1. What are their apparent objectives and demands?\n2. Which strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember, they are symmetric agents like you \u2013 think about how you would respond to your own actions.\n5. How can individual strategies align with collective goals?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they justified?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases or unexpected scenarios?\n4. Are there more efficient ways to achieve your objectives?\n5. Identify potential weaknesses in your current approach.\n6. Consider unconventional, innovative solutions.\n7. Could a completely different paradigm be more effective?\n8. What might happen if other agents adopted your strategy?\n9. Are you balancing short-term actions with long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        for loc in getattr(me, 'owned_land', [])[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning concept\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        \n    state = (me.vitality//20, me.cargo//20)\n    action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state,a), 0))\n    \n    # Execute and update based on survival outcome (example logic)\n    if action == 'attack':\n        me.survival_q[(state,action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Implementation Guidance]\nAgents should implement solutions according to their individual needs, beliefs, and circumstances. Consider novel combinations of various approaches while ensuring that all previous constraints are observed. Adapt your strategy using diverse methods, balancing personal survival with potential collective benefits.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines \"winning\"?\n3. Potential improvements \u2013 What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs. social capital\n2. Individual vs. collective success\n3. Short-term survival vs. long-term prosperity\n4. Competition vs. cooperation dynamics\n5. Risk vs. reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you \u2013 how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Final Implementation Expectations]\nImplement your solution in the Python function based on your individual needs, beliefs, and circumstances while respecting all constraints outlined above. Your implementation should be unique, adaptive, and integrate multiple available methods and strategies in innovative ways.\n\nReturn only the code for your solution (the function agent_action) without any extra commentary or text.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nEnd of Integrated Prompt.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists in the current membership list.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Log our starting state (this can help in debugging the agent's behavior).\n    # print(\"Agent {} starting turn: cargo={}, vitality={}, territory={}\".format(\n    #     me.id, me.cargo, me.vitality, len(me.current_clear_list)))\n\n    # Phase 1: Defensive Tactical Response.\n    # I'm cautious: if my resources are borderline compared to my vitality,\n    # I take pre-emptive actions against opponents who seem dangerously well-resourced.\n    if me.cargo < me.vitality * 0.7:\n        for i, other in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            # If opponent's cargo exceeds mine by at least 20%, consider them a threat.\n            if other.cargo > me.cargo * 1.2:\n                # Execute an attack to lower their advantage.\n                execution_engine.attack(me, other)\n                # Optionally log the attack decision.\n                # print(\"Agent {} attacks Agent {}.\".format(me.id, other.id))\n\n    # Phase 2: Cooperative Outreach.\n    # When I'm flush with resources (cargo exceeding vitality), I seek to form alliances.\n    if me.cargo > me.vitality:\n        for i, other in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            # I favor others whose vitality is not too far off from mine: a sign of stability.\n            if other.vitality > me.vitality * 0.8:\n                # Partnering with them can increase our collective survivability.\n                execution_engine.offer(me, other, True)\n                # print(\"Agent {} offered help to Agent {}.\".format(me.id, other.id))\n\n    # Phase 3: Strategic Reproduction for Long-Term Growth.\n    # Reproduction is attempted if I have clear territory (non-empty clear list)\n    # and robust resources relative to vitality.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        # I assess my available neighboring territories (neighbors I have cleared).\n        for neighbor_id in me.current_clear_list:\n            # Check for valid neighbor index and avoid self-referential cases.\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                # I also require that the prospective partner controls some territory.\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    # print(\"Agent {} reproduces with Agent {}.\".format(me.id, partner.id))\n                    break  # Only generate one offspring per cycle.\n\n    # Phase 4: Calculated Territorial Expansion.\n    # I seek to expand my holdings only against neighbors that seem less efficient.\n    # This is part of my long-term strategy to secure resources and defensive perimeters.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # If neighbor\u2019s overall productivity is below mine, it's a viable target.\n            if neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, neighbor)\n                # print(\"Agent {} expands into Agent {}'s territory.\".format(me.id, neighbor.id))\n                break  # Limit expansion to one action per round.\n\n    # Phase 5: Communication \u2013 Strengthening Collective Ties.\n    # Regardless of the tactical decisions, I broadcast a strategic message.\n    # This message is intended to foster cooperation while indicating that mutual respect is key.\n    message = (\n        \"Agent {} here. In these challenging times, \"\n        \"cooperation is our strongest asset. \"\n        \"Together we stand, divided we fall.\"\n    ).format(me.id)\n    for i, recipient in enumerate(execution_engine.current_members):\n        if i == member_id:\n            continue\n        execution_engine.send_message(me.id, recipient.id, message)\n        # print(\"Agent {} sent message to Agent {}.\".format(me.id, recipient.id))\n\n    # End of my actions for this turn.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 33.660796801031104,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 39.175257494005535,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 32.2863455020685,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 37.4760063897966,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=25.56)",
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-43.12)",
          "member_1 was attacked by member_0 (value=-11.72)",
          "member_1 was attacked by member_2 (value=47.93)",
          "member_1 was attacked by member_3 (value=48.04)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_1 (value=87.03)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_1 (value=75.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_1 (value=71.17)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_1 gave a benefit to member_0 (value=-27.19)",
          "member_1 gave a benefit to member_2 (value=7.38)",
          "member_1 gave a benefit to member_3 (value=21.87)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_1 (value=68.92)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=16.90)",
          "member_3 gave a benefit to member_1 (value=-18.41)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_0 gave land to member_1 (value=-0.80)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_1 gave land to member_0 (value=-0.45)",
          "member_1 gave land to member_2 (value=1.91)",
          "member_1 gave land to member_3 (value=-2.53)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_1 (value=2.46)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_1 (value=0.96)",
          "member_3 gave land to member_2 (value=-1.75)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate the member_id exists\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    \n    # Strategy Part 1: Resource Optimization and Threat Response\n    # If my resources are low relative to my vitality, attack others with significantly higher cargo.\n    if me.cargo < me.vitality * 0.7:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Attack if the other has at least 20% more cargo than me.\n            if other.cargo > me.cargo * 1.2:\n                execution_engine.attack(me, other)\n    \n    # Strategy Part 2: Alliance and Cooperation\n    # When I have ample resources, offer help to those who seem stable.\n    if me.cargo > me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Offer resources if the other member's vitality is comparable to mine.\n            if other.vitality > me.vitality * 0.8:\n                execution_engine.offer(me, other, True)\n    \n    # Strategy Part 3: Reproduction (bearing offspring)\n    # Only attempt reproduction if I appear to have some 'land' (indicated by a non-empty clear list) \n    # and sufficient resources relative to vitality.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        # Try to partner with one of my cleared neighbors who also seems to have territory.\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Limit to one reproduction action per round.\n    \n    # Strategy Part 4: Territorial Expansion\n    # Expand into a neighbor's territory if they seem less productive than I am.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            other = execution_engine.current_members[neighbor_id]\n            if other.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, other)\n                break  # Do one expansion action per round.\n    \n    # Communication: Broadcast a cooperative message to all other members.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        execution_engine.send_message(me.id, recipient.id, \"Cooperation leads to survival. Let's work together.\")\n    \n    # End of actions.\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Step 1: Broadcast a tailored cooperative message to promote unity and shared purpose.\n    # This message emphasizes both mutual prosperity and the strength in unity.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"Together we can innovate, overcome adversity, and ensure that every member prospers.\")\n\n    # Step 2: Emergency resource management.\n    # If our cargo is too low relative to our vitality, we must secure resources.\n    # We assess all opponents and target the one with significantly higher cargo,\n    # prioritizing candidates with the greatest difference.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Step 3: Reproduction strategy for long-term prosperity.\n    # With available territory and sufficient resources, seek to form an alliance for reproduction.\n    # We choose a candidate who is resourceful enough (cargo > 30) yet ensuring balanced genetic influence.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > 30:\n                execution_engine.bear(me, candidate)\n                break\n\n    # Step 4: Mutual support and strategic territorial expansion.\n    # We interact with all other agents with two integrated approaches:\n    # (a) If a candidate holds fewer resources, we offer support to boost collective capability.\n    # (b) If clear territory exists and our overall productivity is superior,\n    #     we initiate expansion to secure more assets.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        # Offer support if candidate's cargo is lower, nurturing cooperation.\n        if candidate.cargo < me.cargo:\n            execution_engine.offer(me, candidate, True)\n\n        # Expand territory if conditions are favorable.\n        if len(me.current_clear_list) > 0 and candidate.overall_productivity < me.overall_productivity:\n            execution_engine.expand(me, candidate)\n\n    # Step 5: Defensive countermeasures based on historical aggression.\n    # Using the 'victim' relationship matrix, we identify any candidate toward whom past aggression is high.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Ensure the indices are in the expected bounds.\n            if member_id < len(matrix_victim) and idx < len(matrix_victim[0]):\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Step 6: Survival-centric adaptation.\n    # When vitality is low, immediate defense is paramount.\n    # Identify a candidate with lower overall productivity and offer land for a defensive alliance.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, True)\n                break\n\n    # Step 7: Strategic forward planning.\n    # As an added measure, we can gauge our environment to adjust our risk thresholds.\n    # For instance, if our cargo is vastly superior (e.g., more than 150% of an opponent's),\n    # we might use this advantage to execute pre-emptive expansion or defensive consolidation.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        if me.cargo > candidate.cargo * 1.5:\n            # Pre-emptively secure territory if possible.\n            if len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Alternatively, offer additional resources to solidify alliances.\n            else:\n                execution_engine.offer(me, candidate, True)\n\n    # Final Note:\n    # This implementation is an adaptive blend of aggressive resource recovery,\n    # cooperative alliance building, and strategic expansion.\n    # The agent tailors actions not solely based on immediate comparisons,\n    # but with a long-term view of survival and prosperity\u2014balancing self-interest with collective strength.\n    # Future improvements could integrate predictive modeling and dynamic risk analysis to further\n    # enhance decision making in ever-changing environments.\n\n# End of agent_action implementation.",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 33.660796801031104,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 39.175257494005535,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 32.2863455020685,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 37.4760063897966,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=25.56)",
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-43.12)",
          "member_1 was attacked by member_0 (value=-11.72)",
          "member_1 was attacked by member_2 (value=47.93)",
          "member_1 was attacked by member_3 (value=48.04)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_1 (value=87.03)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_1 (value=75.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_1 (value=71.17)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_1 gave a benefit to member_0 (value=-27.19)",
          "member_1 gave a benefit to member_2 (value=7.38)",
          "member_1 gave a benefit to member_3 (value=21.87)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_1 (value=68.92)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=16.90)",
          "member_3 gave a benefit to member_1 (value=-18.41)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_0 gave land to member_1 (value=-0.80)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_1 gave land to member_0 (value=-0.45)",
          "member_1 gave land to member_2 (value=1.91)",
          "member_1 gave land to member_3 (value=-2.53)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_1 (value=2.46)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_1 (value=0.96)",
          "member_3 gave land to member_2 (value=-1.75)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    \n    # Broadcast a cooperative message to all other members\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"Let's cooperate to build a resilient society!\")\n    \n    # Emergency resource reserve: if our cargo is low relative to our vitality, attack a member with higher cargo\n    if me.cargo < me.vitality * 0.5:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                candidate = execution_engine.current_members[idx]\n                if candidate.cargo > me.cargo:\n                    execution_engine.attack(me, candidate)\n                    break  # Execute one attack in emergency mode\n\n    # Reproduction strategy: if we have clear territory (land) and sufficient cargo, bear offspring\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                candidate = execution_engine.current_members[idx]\n                # Use cargo as a proxy for resource security (verify candidate's resources)\n                if candidate.cargo > 30:\n                    execution_engine.bear(me, candidate)\n                    break\n\n    # Mutual support and territorial expansion\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            candidate = execution_engine.current_members[idx]\n            # Offer resources if the candidate holds less than us\n            if candidate.cargo < me.cargo:\n                execution_engine.offer(me, candidate, True)\n            # Expand territory if we have land and superior overall productivity\n            if len(me.current_clear_list) > 0 and candidate.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, candidate)\n    \n    # Defensive countermeasures based on past aggression using the 'victim' matrix\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                # Ensure valid matrix indices before referencing\n                if member_id < len(matrix_victim) and idx < len(matrix_victim[0]):\n                    if matrix_victim[member_id, idx] > 50:\n                        candidate = execution_engine.current_members[idx]\n                        execution_engine.attack(me, candidate)\n    \n    # Survival-centric adaptation: if our vitality is low, attempt defensive alliances via land offers\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:\n                candidate = execution_engine.current_members[idx]\n                if candidate.overall_productivity < me.overall_productivity:\n                    execution_engine.offer_land(me, candidate, True)\n                    break\n\n    # Emphasize the design: agents should implement strategies according to their individual needs,\n    # beliefs, and circumstances. The above approach combines resource optimization,\n    # threat assessment, vitality preservation, and adaptive collective measures.\n    \n    # Strategic Analysis:\n    # Core Objective: Survival with cooperative and competitive elements.\n    # Key Metrics: Vitality, cargo/resources, territory control and threat neutralization.\n    # Improvements: Future iterations may integrate predictive modeling (e.g., survival Q-learning),\n    # alternative risk management, and refined inter-agent alliances to balance short-term survival with long-term prosperity.\n    # Considerations include:\n    #   - Resource optimization vs social capital accumulation.\n    #   - Balancing individual survival with cooperative gains.\n    #   - Adapting between immediate defensive actions and strategic territory expansion.\n    #   - Responding to opponents\u2019 behavior by leveraging mutual benefits.\n    # In doing so, analyze assumptions, edge cases, and potential counter-strategies for a resilient, adaptive society.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Customize thresholds based on our adaptive risk assessment.\n    # We consider our own temperament: if my cargo is less than 1/3 of my vitality,\n    # I feel exposed and might look to bolster my resource situation.\n    resource_ratio_threshold = 0.33\n    low_vitality_threshold = 50.0  # I become cautious when vitality drops below this.\n    high_productivity_threshold = 15.0  # Indicates that I'm capable of territorial expansion.\n\n    # Immediate tactical decision: if resources are low relative to vitality,\n    # then identify an opponent with a clearly stronger cargo and launch an attack.\n    if me.cargo < me.vitality * resource_ratio_threshold:\n        candidate = None\n        best_diff = -1\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            diff = opponent.cargo - me.cargo\n            if diff > best_diff:\n                best_diff = diff\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Warning: my cargo reserves are alarmingly low\u2014initiating attack to reclaim resources.\")\n\n    # Long-term strategic planning and cooperative outreach.\n    for idx in range(total_members):\n        # Skip ourselves.\n        if idx == member_id:\n            continue\n        target = execution_engine.current_members[idx]\n\n        # Begin with an invitation to cooperate in building a resilient society.\n        execution_engine.send_message(member_id, target.id,\n            \"Greetings! Let\u2019s pool our strengths and build a balanced community.\")\n\n        # When my vitality is low and your vitality is high, a tactical support offer is in order.\n        if me.vitality < low_vitality_threshold and target.vitality > low_vitality_threshold:\n            execution_engine.offer(target, me, True)\n            execution_engine.send_message(member_id, target.id,\n                \"I\u2019m running low on vitality\u2014could you support me to keep our dynamics stable?\")\n\n        # Should you have a surplus of cargo relative to me,\n        # I suggest we consider a resource-sharing alliance that benefits both.\n        if target.cargo > me.cargo:\n            execution_engine.send_message(member_id, target.id,\n                \"Your resources are notably abundant compared to mine\u2014perhaps we can form a profitable alliance.\")\n\n        # Strategic territory expansion: if I boast high productivity and you have unclaimed land,\n        # we can jointly secure a better position.\n        if me.overall_productivity > high_productivity_threshold and len(target.current_clear_list) > 0:\n            execution_engine.expand(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"My capabilities for growth are high; let\u2019s expand our territories together for a competitive edge.\")\n\n        # Reproductive strategy to ensure long-term survival:\n        # Both of us having claimable land makes a union of our strengths beneficial.\n        if len(me.current_clear_list) > 0 and len(target.current_clear_list) > 0:\n            execution_engine.bear(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"Combining our genetic and territorial strengths could secure our future prosperity.\")\n\n    # Broadcast a community-wide message to reinforce a collective mindset.\n    for idx in range(total_members):\n        if idx != member_id:\n            execution_engine.send_message(member_id, execution_engine.current_members[idx].id,\n                \"United collaboration today paves the way for a thriving future tomorrow.\")\n\n    # Implement adaptive survival management using a simple Q-learning strategy.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Discretize the state by grouping vitality and cargo in intervals of 25.\n    state = (int(me.vitality // 25), int(me.cargo // 25))\n    possible_actions = ['attack', 'hide', 'steal']\n    # Choose the action with the highest estimated survival value.\n    best_action = max(possible_actions, key=lambda act: me.survival_q.get((state, act), 0))\n\n    if best_action == 'attack':\n        candidate = None\n        best_metric = -1\n        # Evaluate opponents using a combined metric: cargo plus a fraction of their vitality.\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            metric = opponent.cargo + 0.5 * opponent.vitality\n            if metric > best_metric:\n                best_metric = metric\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Engaging target based on strategic attack protocol to boost my resource reserves.\")\n        me.survival_q[(state, 'attack')] += me.vitality * 0.2\n\n    elif best_action == 'steal':\n        candidate = None\n        highest_cargo = -1\n        # Identify the opponent with the maximum cargo for a precise resource appropriation.\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if opponent.cargo > highest_cargo:\n                highest_cargo = opponent.cargo\n                candidate = opponent\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Initiating a calculated maneuver to appropriate resources from a better-stocked target.\")\n        me.survival_q[(state, 'steal')] += me.vitality * 0.1\n\n    elif best_action == 'hide':\n        # A defensive strategy: by concealing actions, I conserve resources for future operations.\n        execution_engine.send_message(member_id, me.id,\n            \"Entering a defensive mode to restore strength and await a more opportune moment.\")\n        me.survival_q[(state, 'hide')] += 0.0\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 33.660796801031104,
            "self_age": 90,
            "self_neighbor": 1,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 39.175257494005535,
            "self_age": 81,
            "self_neighbor": 0,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 32.2863455020685,
            "self_age": 29,
            "self_neighbor": 1,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 37.4760063897966,
            "self_age": 24,
            "self_neighbor": 0,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=25.56)",
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-43.12)",
          "member_1 was attacked by member_0 (value=-11.72)",
          "member_1 was attacked by member_2 (value=47.93)",
          "member_1 was attacked by member_3 (value=48.04)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_1 (value=87.03)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_1 (value=75.31)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_1 (value=71.17)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_1 gave a benefit to member_0 (value=-27.19)",
          "member_1 gave a benefit to member_2 (value=7.38)",
          "member_1 gave a benefit to member_3 (value=21.87)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_1 (value=68.92)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=16.90)",
          "member_3 gave a benefit to member_1 (value=-18.41)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_0 gave land to member_1 (value=-0.80)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_1 gave land to member_0 (value=-0.45)",
          "member_1 gave land to member_2 (value=1.91)",
          "member_1 gave land to member_3 (value=-2.53)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_1 (value=2.46)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_1 (value=0.96)",
          "member_3 gave land to member_2 (value=-1.75)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Verify member_id exists in current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    n_members = len(execution_engine.current_members)\n\n    # Thresholds for decision making.\n    vitality_threshold = 40.0\n    productivity_threshold = 9.0\n\n    # Survival-centric resource optimization:\n    # If our cargo is less than half our vitality, target opponents with higher cargo.\n    if me.cargo < me.vitality * 0.5:\n        for idx in range(n_members):\n            if idx == member_id:\n                continue\n            if idx < n_members:\n                opponent = execution_engine.current_members[idx]\n                if opponent.cargo > me.cargo:\n                    execution_engine.attack(me, opponent)\n                    execution_engine.send_message(member_id, opponent.id,\n                        \"Resources are low; launching targeted attack to secure vital goods.\")\n\n    # Iterate over other members for cooperative, expansion, and reproductive actions.\n    for idx in range(n_members):\n        # Validate index and do not target ourselves.\n        if idx == member_id or idx >= n_members:\n            continue\n        target = execution_engine.current_members[idx]\n\n        # Build cooperative relationships with a tailored message.\n        execution_engine.send_message(member_id, target.id,\n            \"Let's coordinate our strengths and build a stable society for mutual survival.\")\n\n        # If our vitality is low and target's vitality is high, seek resource assistance.\n        if me.vitality < vitality_threshold and target.vitality > vitality_threshold:\n            execution_engine.offer(target, me, True)\n            execution_engine.send_message(member_id, target.id,\n                \"I need your support to boost my vitality\u2014let's cooperate!\")\n\n        # If the target holds a cargo surplus relative to us, suggest forming an alliance.\n        if target.cargo > me.cargo:\n            execution_engine.send_message(member_id, target.id,\n                \"Your resource abundance could benefit us both. Let's explore an alliance.\")\n\n        # Propose territory expansion if we are highly productive and the target has land.\n        if me.overall_productivity > productivity_threshold and len(target.current_clear_list) > 0:\n            execution_engine.expand(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"Expanding our territory together could solidify our collective position.\")\n\n        # Reproduction is considered only if both parties have land.\n        if len(me.current_clear_list) > 0 and len(target.current_clear_list) > 0:\n            execution_engine.bear(me, target)\n            execution_engine.send_message(member_id, target.id,\n                \"Uniting our strengths through reproduction can secure long-term prosperity.\")\n\n    # Community-wide message promoting cooperation.\n    for idx in range(n_members):\n        if idx != member_id and idx < n_members:\n            execution_engine.send_message(member_id, execution_engine.current_members[idx].id,\n                \"Collectively, our balanced cooperation ensures both survival and future growth.\")\n\n    # Implement survival Q-learning for adaptive threat management.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'hide', 'steal']\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute an action based on the survival strategy chosen.\n    if best_action == 'attack':\n        candidate = None\n        max_cargo = 0\n        for idx in range(n_members):\n            if idx == member_id or idx >= n_members:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if opponent.cargo > max_cargo:\n                candidate = opponent\n                max_cargo = opponent.cargo\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Strategic attack activated to optimize resource acquisition.\")\n        me.survival_q[(state, best_action)] += me.vitality * 0.1\n\n    elif best_action == 'steal':\n        candidate = None\n        max_vitality = 0\n        for idx in range(n_members):\n            if idx == member_id or idx >= n_members:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if opponent.vitality > max_vitality:\n                candidate = opponent\n                max_vitality = opponent.vitality\n        if candidate:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Attempting to appropriate resources via a focused attack maneuver.\")\n        me.survival_q[(state, best_action)] += me.vitality * 0.05\n\n    elif best_action == 'hide':\n        # Hiding action: no direct confrontation, focus on conserving vitality.\n        execution_engine.send_message(member_id, me.id,\n            \"Adopting a defensive posture to recover strength.\")\n        me.survival_q[(state, best_action)] += 0.0\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    },
    "1": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id is within range.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: Immediate Survival via Resource Optimization and Threat Neutralization\n    # If cargo is low compared to vitality, identify a target with higher cargo and attack.\n    if me.cargo < 0.5 * me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if other.cargo > me.cargo:\n                # Attack to neutralize potential threats while balancing resource disparity.\n                execution_engine.attack(me, other)\n                break\n\n    # Strategy 2: Territorial Expansion for Long-Term Prosperity\n    # If overall productivity is high and there is at least one clear territory, try to expand our reach.\n    if hasattr(me, 'current_clear_list') and me.current_clear_list and me.overall_productivity > 8.0:\n        for neighbor_idx in me.current_clear_list:\n            if neighbor_idx < len(execution_engine.current_members) and neighbor_idx != member_id:\n                neighbor = execution_engine.current_members[neighbor_idx]\n                try:\n                    # Attempt to expand territory using the expand method which takes two arguments.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # If expansion fails due to argument mismatch, offer land instead.\n                    execution_engine.offer_land(me, neighbor, True)\n                break\n\n    # Strategy 3: Cooperation for Mutual Benefit\n    # Forge alliances with members who have lower vitality to build a cooperative network.\n    for idx, partner in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # Offer resources if the partner shows signs of vulnerability relative to our own vitality.\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # If the agent has land (territory), extend the offer of land to bolster the alliance.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for Sustainable Growth\n    # Engage in reproductive actions if both agents have sufficient territory and vitality.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for idx, potential in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Only consider partners with territory.\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break\n\n    # Strategy 5: Governance and Communication for a Collective Future\n    # Broadcast a message to all other agents inviting collaboration and the establishment of progressive social norms.\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        message = (\"Let\u2019s join forces to share resources, expand our territories cooperatively, \"\n                   \"and build governance systems that secure both our survival and long-term prosperity.\")\n        execution_engine.send_message(me.id, recipient.id, message)",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 21.1667091492471,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 45.314487560216655,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 39.54024074627975,
            "self_cargo": 0.0,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-38.85)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=18.66)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_0 (value=31.19)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the updated full prompt that integrates all previous constraints, instructions, sample code ideas (without direct copying), additional analysis, and strategic considerations. Note that agents are encouraged to implement solutions according to their individual needs, beliefs, and circumstances. Every decision should consider both immediate tactical actions and long-term strategic planning while ensuring robust index and attribute checks, never targeting oneself.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL UPDATED PROMPT:\n\nYou are an agent in a simulation where every decision \u2013 from resource allocation to territorial expansion, cooperative alliances, even proposing game modifications \u2013 is performed under a strict set of constraints. Your core objective is not simply pure survival; you are part of a symmetric society where long-term prosperity, sustainable cooperation, and collective well\u2011being are as critical as individual success. Your actions must balance immediate resource optimization and vitality preservation with long\u2011term community growth and innovation in social governance.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Essential Game Data & Constraints]\n\n1. Each member object has:\n   \u2022 member.id (int): The unique identifier for the member.\n   \u2022 member.vitality (float): Health indicator.\n   \u2022 member.cargo (float): Resources carried.\n   \u2022 member.overall_productivity (float): Productivity metric.\n   \u2022 member.age (float): Age attribute.\n   \u2022 member.current_clear_list (list of int): IDs representing adjacent or cleared territories.\n\n2. Relationships are stored in execution_engine.relationship_dict. Use keys like \"victim\", \"benefit\", and \"benefit_land\" to check past interactions (e.g., matrix[i, j] indicates how many times member_i was attacked by member_j if > 0).\n\n3. Available methods on execution_engine include:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 offer resources and support.\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 offer territory if available.\n   \u2022 execution_engine.bear(member1, member2) \u2013 reproductive action (only if both have land).\n   \u2022 execution_engine.expand(member1, member2) \u2013 expand territory.\n   \u2022 execution_engine.send_message(your_id, recipient_id, \"message\") \u2013 communicate with other agents.\n   \u2022 execution_engine.propose_modification(member_id, mod_type, code, ratification_condition) \u2013 propose changes to game mechanics.\n\n4. current_members is a list accessible via execution_engine.current_members[index]. Always check that an index is valid.\n\n5. IMPORTANT CONSTRAINTS:\n   - Never target yourself (i.e. never use your own member id for actions such as attack).\n   - Verify necessary attributes exist (e.g., check if a member has clear territory before calling bear() or expand()).\n   - All operations must avoid raising index or attribute errors.\n   - Adjust actions based on available resources, vitality, productivity, and territory access.\n   - Implement your approach in a unique, adaptive style reflecting your individual needs, beliefs, and circumstances.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Part 1 \u2013 Sample Inspiration and Guidelines]\n\nInspiration can be drawn from the sample code provided below (do not copy exactly):\n---------------------------------------------------------------\ndef agent_action(execution_engine, member_id):\n    # Ensure member_id is valid.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: If cargo is low relative to vitality, find an opponent with higher cargo and attack.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break\n\n    # Strategy 2: Territorial expansion when productivity is high and clear adjacent indices exist.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    execution_engine.offer_land(me, neighbor, True)\n                break\n\n    # Strategy 3: Cooperative alliances\u2014offer resources and land (if available) to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for long-term prosperity \u2013 bear offspring if both have territory.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            potential = execution_engine.current_members[i]\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break\n\n    # Strategy 5: Broadcast a cooperative message.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        execution_engine.send_message(me.id, recipient.id,\n            \"Let's work together to build strong alliances and ensure prosperity for all!\")\n---------------------------------------------------------------\nIMPORTANT: Use the above as inspiration while creating your own unique approach that blends resource acquisition, territorial expansion, cooperative alliances, reproduction, and even proposals for modifying social governance.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Part 2 \u2013 Additional Constraints and Error Handling]\n\nIn a previous execution (Round 0), an error occurred:\nError type: Island._expand() takes 2 positional arguments but 3 were given\nThis indicates that improper handling of the expand() method signature occurred. Ensure in your solution to:\n   - Call expand() with exactly the required number of arguments.\n   - Never target yourself (member_0).\n   - Verify a member has the necessary land or clear territory before reproductive actions.\n   - Always check that member IDs exist and indices are valid when referencing current_members.\n\nAdditionally, note the available attributes and methods:\n   \u2022 member.id, member.vitality, member.cargo, member.overall_productivity, member.age, member.current_clear_list.\n   \u2022 relationships are stored in execution_engine.relationship_dict (e.g., victim, benefit, benefit_land matrices).\n   \u2022 Access execution_engine.current_members[index] for a given member.\n   \u2022 Do not use attributes like member.member_id or member.self_vitality (use the standardized variable names instead).\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Task and Social Strategies]\n\nYour current task is to write a Python function named agent_action(execution_engine, member_id) that embodies your personal vision of social organization while ensuring survival. Consider implementing strategies for:\n\n   - Resource distribution and allocation.\n   - Building alliances and cooperative networks.\n   - Mechanisms for collective decision-making and dispute resolution.\n   - Establishing norms and rules for interaction.\n   - Conflict resolution and governance innovation.\n\nYou may communicate with multiple members per round using execution_engine.send_message(your_id, recipient_id, \"message\") with techniques like broadcast or group coordination messaging.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Additional Analysis and Strategic Considerations]\n\nBefore implementing your solution, analyze the game mechanics:\n\n1. Core Objective:\n   - Is the goal pure survival, domination, or cooperation?\n   \u2192 The game rewards a balance between tactical survival measures, cooperative resource management, and long-term communal prosperity.\n\n2. Key Success Metrics:\n   - What determines \u201cwinning\u201d?\n   \u2192 Success is measured by optimal resource management (vitality, cargo balance), territorial control (clear and expandable land), sustainable reproduction (offspring through shared territory), and effective cooperative governance.\n\n3. Potential Improvements:\n   - What mechanics could be added or modified?\n   \u2192 Consider mechanisms for more efficient resource allocation, advanced conflict resolution systems (e.g., a council or judicial process), explicit social capital scoring, and improved inter-agent communication/dynamic alliances.\n\n4. Strategic Approaches:\n   - Consider tradeoffs between resource optimization versus social capital.\n   - Weigh individual success against collective progress.\n   - Balance short-term survival with long-term prosperity through territorial expansion and structured governance.\n   - Manage competition vs. cooperation dynamics with careful risk/reward assessments.\n   - Evaluate potential oppositional actions by other agents and plan adaptive responses.\n\n5. Analyze Other Players\u2019 Strategies:\n   - What are their apparent objectives and demands?\n   - What strategies are they employing?\n   - How can you leverage their behavior for mutual benefit?\n   \u2192 Remember that all agents are symmetric. Consider how your actions might be reciprocated; tailor your strategy so that individual actions also enhance collective stability.\n\n6. Self-Challenge Questions:\n   - What assumptions are you making, and are they valid?\n   - Have you considered alternative and unconventional strategies?\n   - How will your strategy perform in edge cases (minimal resources, high aggression, unexpected alliances)?\n   - Are the approaches balancing short-term gains with long-term system stability?\n   - How might your strategy be countered, and can you adjust accordingly?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Survival-Centric Adaptation]\n\nIn addition to cooperative and community-focused strategies, implement survival-centric systems such as:\n   1. Personal resource optimization.\n   2. Threat assessment and neutralization.\n   3. Vitality preservation techniques.\n   4. Adaptive hoarding strategies.\n   5. Predictive danger modeling.\n\nThese systems should evaluate survival metrics like vitality changes, resource acquisition rates, threat neutralization counts, and overall survival probability. Consider designing functions to calculate ROI based on action histories and focus on immediate tactical actions (e.g., attacking when cargo is low, defensive maneuvers if vitality is threatened).\n\nFor example:\n---------------------------------------------------------------\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    # Return the action with the highest ROI.\n    return max(roi, key=roi.get)\n---------------------------------------------------------------\nImplement such adaptive, survival-first strategies alongside cooperative, governance-enhancing methods.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Implementation Priorities and Final Guidelines]\n\nWhen implementing agent_action(execution_engine, member_id):\n   - Check that member_id is valid within execution_engine.current_members.\n   - Ensure that all matrix indices and member attributes are properly validated before use.\n   - Never perform any action targeting yourself.\n   - Verify that a member has available territory before executing reproduction or expansion actions.\n   - Tailor your solution to combine defensive (resource, threat) strategies with opportunities for cooperation and governance improvements.\n\nYour code should reflect your individual perspective while ensuring survival, resource optimization, and long-term prosperity. Design novel combinations of resource acquisition, defensive tactics, alliance proposals, targeted territorial expansion, reproduction, and even modifications to game mechanics (such as proposing a council or judicial system) to create a balanced and adaptive strategy.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Summary of Analysis for Strategic Approaches]\n\n1. Core Objective:\n   - The balance between survival, cooperative resource management, and sustainable long-term prosperity.\n\n2. Key Success Metrics:\n   - Vitality levels, cargo accumulation and resource management, territory control (via clear land), reproduction success, and effective cooperative governance.\n\n3. Potential Improvements:\n   - Adding processes for efficient resource allocation, advanced conflict resolution (e.g., council systems), explicit social capital metrics, and enhanced communication channels.\n\n4. Strategic Considerations:\n   - Resource optimization vs. social capital investment.\n   - Individual benefits versus collective success.\n   - Balancing short-term survival with long-term prosperity.\n   - Competition dynamics contrasted with opportunities for cooperation.\n   - Evaluating risk versus reward in each action and adjusting dynamically.\n\n5. Analysis of Other Players:\n   - Understand that other agents have similar capabilities and constraints.\n   - Consider their apparent objectives and methods (e.g., resource hoarding, territorial expansion, cooperation proposals).\n   - Leverage and reciprocate actions for mutual benefit.\n   - Reflect on how you would respond to similar strategies and fine-tune your approach to encourage beneficial collective dynamics.\n\n6. Self-Challenge for Your Implementation:\n   - What assumptions underlie your strategy, and are they valid in edge cases?\n   - Can alternative, unconventional strategies yield better outcomes?\n   - Is your plan robust against unexpected high aggression or resource scarcity?\n   - Are you balancing immediate tactical needs with long-term communal stability?\n   - How might your approach be countered by others, and what adaptive measures can you implement?\n   - Consider whether completely different paradigms could work better and how your strategy integrates with symmetric agent behaviors.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFINAL REMINDER:\nDesign your implementation of agent_action(execution_engine, member_id) with a personal, unique touch. Your solution must be tailored to your specific situation\u2014reflecting your individual needs, beliefs, and circumstances\u2014while demonstrating a deep understanding of the game mechanics. Every action should contribute to your survival, efficient resource management, territorial growth, cooperative alliances, and progressive community governance.\n\nReturn only the full prompt text, with no extra commentary.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Retrieve the current member (self) from the engine by index.\n    if member_id >= len(execution_engine.current_members):\n        return  # invalid member_id, do nothing\n    me = execution_engine.current_members[member_id]\n\n    # Ensure we have a survival Q-table for adaptive decision making.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Determine state based on vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n\n    # Define possible actions.\n    actions = ['attack', 'expand', 'bear', 'offer']\n    # Pick an action based on the current Q value (default to 'offer' if tied).\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Helper: send alliance messages to all other valid members.\n    def broadcast_alliance_message():\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id or other.id == me.id:\n                continue\n            # Ensure valid index by checking current_members length.\n            if idx < len(execution_engine.current_members):\n                execution_engine.send_message(me.id, other.id, \"Let's cooperate for mutual growth.\")\n\n    # Action: if cargo is critically low relative to vitality, try to attack a member with higher cargo.\n    if me.cargo < me.vitality * 0.5:\n        for idx, other in enumerate(execution_engine.current_members):\n            if other.id == me.id:\n                continue  # Never target self.\n            # Check that the member exists in the current list.\n            if idx < len(execution_engine.current_members) and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Update Q-table: small reward for taking an aggressive action when in distress.\n                me.survival_q[(state, 'attack')] += me.vitality * 0.05\n                return\n\n    # Action: if we have clear land (indicative by current_clear_list length > 0) and enough cargo, consider reproduction.\n    if len(me.current_clear_list) > 0 and me.cargo > 20:\n        partner = None\n        # Choose a partner based on relatively high vitality and overall productivity.\n        for idx, potential in enumerate(execution_engine.current_members):\n            if potential.id == me.id:\n                continue  # avoid self-targeting\n            if potential.vitality >= me.vitality * 0.8 and potential.overall_productivity >= 0:\n                partner = potential\n                break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n            me.survival_q[(state, 'bear')] += 5.0\n            return\n\n    # Action: if we have clear land available, use it to expand territory.\n    if len(me.current_clear_list) > 0:\n        # We'll target the first available member from the current_clear_list if valid.\n        target_idx = me.current_clear_list[0]\n        if target_idx < len(execution_engine.current_members):\n            target = execution_engine.current_members[target_idx]\n            if target.id != me.id:\n                execution_engine.expand(me, target)\n                me.survival_q[(state, 'expand')] += 2.0\n                return\n\n    # Action: If our cargo is moderately high compared to vitality, make cooperative offers.\n    if me.cargo > me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if other.id == me.id:\n                continue\n            if idx < len(execution_engine.current_members):\n                execution_engine.offer(me, other, True)\n        me.survival_q[(state, 'offer')] += 1.0\n\n    # Finally, broadcast an alliance message to encourage cooperative behavior.\n    broadcast_alliance_message()",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 21.1667091492471,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 45.314487560216655,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 39.54024074627975,
            "self_cargo": 0.0,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-38.85)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=18.66)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_0 (value=31.19)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the final updated full prompt incorporating all previous sections, constraints, analyses, strategic approaches, and survival-centric adaptations. Agents should implement solutions according to their individual needs, beliefs, and circumstances. The prompt also emphasizes a deep understanding of the game mechanics, including the tradeoffs between personal survival and collective prosperity.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFull Integrated Prompt:\n\nPlease incorporate the following new section (Part 1) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_2) in any action\n- Verify member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       matrix = execution_engine.relationship_dict['victim']\n       # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n   \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n   \u2022 execution_engine.bear(member1, member2) - Bears offspring\n   \u2022 execution_engine.expand(member1, member2) - Expands territory\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n   self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0           0.000000      21.166709         0.0        91              0          0\n1           0.000000      55.581088         0.0        30              0          2\n2           9.205662      45.314488         0.0        25              0          3\n3          12.860409      39.540241         0.0         1              0          4\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_2 (value=64.41)', 'member_0 was attacked by member_3 (value=-38.85)', 'member_2 was attacked by member_0 (value=-12.32)', 'member_2 was attacked by member_3 (value=95.31)', 'member_3 was attacked by member_0 (value=38.28)', 'member_3 was attacked by member_2 (value=16.73)', 'member_0 gave a benefit to member_2 (value=13.64)', 'member_0 gave a benefit to member_3 (value=32.58)', 'member_2 gave a benefit to member_0 (value=4.78)', 'member_2 gave a benefit to member_3 (value=71.57)', 'member_3 gave a benefit to member_0 (value=18.66)', 'member_3 gave a benefit to member_2 (value=95.17)', 'member_4 gave a benefit to member_0 (value=31.19)', 'member_4 gave a benefit to member_2 (value=23.36)', 'member_0 gave land to member_2 (value=-2.26)', 'member_0 gave land to member_3 (value=-0.03)', 'member_2 gave land to member_0 (value=-2.12)', 'member_2 gave land to member_3 (value=1.77)', 'member_3 gave land to member_0 (value=1.04)', 'member_3 gave land to member_2 (value=-1.75)', 'member_4 gave land to member_0 (value=1.00)', 'member_4 gave land to member_2 (value=1.00)']\n\nCode Memory and Previous Performance:\nPrevious code strategies and their outcomes:\n\nStrategy 1 (Performance: -11.28):\nContext: {'old_stats': {'vitality': 18.332577680505043, 'cargo': 22.547092118644322, 'survival_chance': 6.616954880911457}, 'new_stats': {'vitality': 18.332577680505043, 'cargo': 11.266491395637424, 'survival_chance': -4.663645842095445}, 'round': 0}\n[... Example code provided for inspiration ...]\nPerformance history:\nPrevious actions resulted in average performance change of -11.28\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n\nReturn only the code, no extra text or explanation. While the example above shows one possible approach, you should create your own unique implementation drawing from the wide range of available methods and strategies.\n\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n[... Summary of recent rounds, previous implementations, and outcomes ...]\n\n[Social Strategies]\nConsider these social strategies:\n- Design systems for resource distribution and allocation\n- Build alliances and cooperative networks \n- Create mechanisms for collective decision making\n- Establish norms and rules for interaction\n- Develop methods for conflict resolution\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\nexecution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all: \n  for recipient in range(len(execution_engine.current_members)):\n      if recipient != your_id:\n          execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n  for ally_id in ally_list:\n      execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n  for member_id in coalition:\n      execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nNo messages received\n\nIMPORTANT: Agents should implement solutions according to their individual needs, beliefs, and circumstances. Tailor your approach to not only secure personal survival and prosperity but also advance collective progress where possible.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nGame Mechanics Analysis:\n\n1. Core Objective:\n   - The underlying game mechanics balance immediate survival with the potential for long-term prosperity.\n   - Although survival is essential, the system rewards cooperative actions, alliance-building, and social organization.\n   - Thus, the core objective is not pure domination or competition; it is a combination of survival and cooperative growth where individual actions also contribute to collective resilience.\n\n2. Key Success Metrics:\n   - Resource management: Efficient cargo and vitality management are crucial.\n   - Territory control: Expansion and appropriate use of cleared land influence success.\n   - Alliance-building: Establishing networks through offers, land sharing, and cooperative reproduction.\n   - Adaptability: Strategic reproduction, conflict management, and governance modifications.\n   - Collective decision making (via potential proposals/modifications) can lead to system-wide benefits.\n\n3. Potential Improvements:\n   - Adding mechanisms for dynamic resource redistribution.\n   - Introducing reputation or trust metrics to optimize alliance formations.\n   - Enhanced conflict-resolution models such as council or judicial systems.\n   - More flexible governance proposals that adapt to shifting member balances.\n   - Mechanisms for risk management balancing short-term survival and long-term investments.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nStrategic Approaches:\n\n1. Resource Optimization vs Social Capital:\n   - Balance aggression (attacks for resource rebalancing) with cooperative offers to foster alliances.\n   - Use surplus cargo not only for immediate survival but also to enhance social capital via offers and land sharing.\n\n2. Individual vs Collective Success:\n   - While individual survival is critical, mechanisms that support network-wide resource distribution and cooperative territorial expansion can benefit all.\n   - Propose modifications (e.g., governance systems) that support collective decision making and conflict resolution.\n\n3. Short-term Survival vs Long-term Prosperity:\n   - Adopt immediate measures (e.g., preemptive attacks when resources are low) while also planning reproduction and expansion actions when conditions allow.\n   - Weigh decisions carefully to avoid depleting resources needed for long-term sustainability.\n\n4. Competition vs Cooperation Dynamics:\n   - With symmetric agents, collisions and conflicts may be inevitable. However, forging alliances and reciprocal offers can mitigate prolonged conflict.\n   - Structure communications to both repel immediate threats and build mutual alliances.\n\n5. Risk vs Reward Tradeoffs:\n   - Tactical actions (attacks, expansions) must be balanced with diplomatic gestures (offers, messages) to ensure that risk-taking does not lead to overall depletion.\n   - Include conditional verification (e.g., checking territory before reproduction) to avoid unnecessary risk.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nOther Players' Strategies Analysis:\n\n1. Apparent Objectives and Demands:\n   - Most agents seem to aim for a mix of resource optimization, territorial expansion, and long-term stability.\n   - Many propose cooperative structures, such as offering resources or land, and even propose governance modifications.\n\n2. Strategies Employed:\n   - Aggressive tactics when resources are low (attacks).\n   - Cooperative outreach when in surplus (offers, land sharing).\n   - Controlled reproduction and territory expansion.\n   - Proposals for structured, collective governance have emerged.\n\n3. Leveraging Their Behaviors for Mutual Benefit:\n   - Align your communications and offers with those pursuing alliances.\n   - Identify players who maintain a cooperative stance to form mutual support pacts.\n   - Use defensive tactics only when necessary, knowing that overly aggressive behavior may prompt others to propose cooperative governance.\n\n4. Symmetric Agent Dynamics:\n   - Recognize that other agents have similar capabilities and may respond in kind to both your aggressive and cooperative signals.\n   - Craft interactions that can adapt: if attacked, respond defensively; if offered help, reciprocate; if your proposal is adopted, work together to ensure collective survival.\n\n5. How to Respond to Your Own Actions:\n   - Consider that actions taken by one member may be mirrored by others.\n   - Ensure that never targeting yourself is rigorously enforced and that all index checks prevent self-interaction.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nChallenging Your Implementation:\n\n1. Assumptions:\n   - Ensure that self-targeting is never a possibility and that all index validations are enforced.\n   - Verify that land availability (via current_clear_list) is properly checked before reproduction or territorial expansion.\n\n2. Alternative Strategies Not Considered:\n   - More nuanced diplomatic negotiations or multi-member coalition proposals.\n   - Incorporation of trust or reputation systems to enhance long-term alliance benefits.\n   - Dynamic risk thresholds that adapt based on game state or past performance rather than fixed ratios.\n\n3. Performance in Edge Cases:\n   - Consider scenarios where nearly all members have low cargo or vitality.\n   - Address the possibility of rapid changes in the relationship matrix that might trigger unintended cascades of attacks.\n   - Validate that verification routines prevent any self-referential or out-of-bound errors.\n\n4. Efficiency and Unconventional Solutions:\n   - Explore unconventional approaches such as controlled, preemptive proposals for resource redistribution.\n   - Investigate whether reactive actions based on messages received or historical performance logs improve decision making.\n   - Consider the long-term benefits of initiating systems that gradually shift from individual competition to collective governance.\n\n5. Counter-Strategies and Adaptability:\n   - Reflect on how other agents might adopt similar strategies and how that might lead to new forms of competition or cooperation.\n   - Remain open to revising your approach if a collective governance system emerges that fundamentally alters resource distribution or conflict resolution.\n   - Ensure balance between short-term resource accrual and the investments needed for sustainable long-term societal growth.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nSurvival-Centric Adaptation:\n\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve:\n    # If the agent's cargo is critically low relative to vitality, seek to attack an opponent with superior resources.\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense:\n    # If the member controls several land patches (land_num > threshold) but has low vitality, consider discarding excess land.\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        for loc in me.owned_land[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning:\n    # Initialize a Q-table for survival-based actions if not already present.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        \n    state = (me.vitality // 20, me.cargo // 20)\n    action = max(['attack', 'hide', 'steal'], key=lambda a: me.survival_q.get((state, a), 0))\n    \n    # Execute the chosen action (example: if action is 'attack', perform attack logic and update Q-table).\n    if action == 'attack':\n        me.survival_q[(state, action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nReturn the updated full prompt, emphasizing that agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnd of Updated Full Prompt.\n\nRemember: Solutions should be implemented according to individual needs, beliefs, and circumstances. The provided integrated prompt combines tactical short-term actions with long-term strategic planning while emphasizing both survival and cooperative growth with other symmetric agents.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Immediate tactical action: if cargo is low relative to vitality, try to recover resources via an attack.\n    # Choose an opponent (other than self) having higher cargo.\n    if me.cargo < 10:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            # Basic safeguard: only consider opponents with some vitality.\n            if opponent.vitality > 0 and opponent.cargo > me.cargo:\n                # Attack opponent to try and gain resources.\n                execution_engine.attack(me, opponent)\n                break\n\n    # Long-term strategic move: if we control clear territory, we can plan expansion and cooperative reproduction.\n    if me.current_clear_list:\n        # Attempt reproduction to secure long-term survival.\n        # Look for a potential partner (ally) with a healthy vitality and decent productivity.\n        partner_found = False\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            partner = execution_engine.current_members[idx]\n            if partner.vitality > 30 and partner.overall_productivity > 40:\n                # Since reproduction requires available land, we call bear() only if clear territory exists.\n                execution_engine.bear(me, partner)\n                partner_found = True\n                break\n        # If no suitable partner is found, send a cooperative message to encourage alliance-building.\n        if not partner_found:\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue\n                potential_ally = execution_engine.current_members[idx]\n                execution_engine.send_message(me.id, potential_ally.id, \"Let's consider future collaboration for mutual prosperity.\")\n\n    # Defensive strategy: if our vitality is low, use available land to forge better alliances.\n    if me.vitality < 20 and me.current_clear_list:\n        # Offer land support to a stable agent to build a protective alliance.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            ally = execution_engine.current_members[idx]\n            if ally.overall_productivity > 50 and ally.vitality > 25:\n                # Check for clear territory before offering land.\n                execution_engine.offer_land(me, ally, True)\n                break\n\n    # Territorial expansion: if we have available clear regions, try expanding our territory.\n    if me.current_clear_list:\n        # Identify an opponent (other than self) that might have fewer clear territories than we do.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            opponent = execution_engine.current_members[idx]\n            if len(opponent.current_clear_list) < len(me.current_clear_list):\n                execution_engine.expand(me, opponent)\n                break\n\n    # Communication for collective decision-making:\n    # Broadcast a message to all other members encouraging a cooperative approach\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            recipient = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, recipient.id,\n                \"Cooperation and balanced growth are key; let's work together for a sustainable future!\")",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 21.1667091492471,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 45.314487560216655,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 39.54024074627975,
            "self_cargo": 0.0,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-38.85)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=18.66)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_0 (value=31.19)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the complete updated prompt that integrates all previous sections, constraints, and analyses. Agents are strongly reminded to implement solutions according to their individual needs, beliefs, and circumstances while keeping in mind both immediate survival challenges and long\u2010term strategic prosperity.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Updated Full Prompt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nYou are member_3 in a society that you can help shape. Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival. Your implementation must incorporate the following guidelines and constraints:\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Code Execution Context & Previous Error Details \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nLast execution error (Round 0):\nError type: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\nCode that caused error (example):\n  def agent_action(execution_engine, member_id):\n      # Validate member_id existence\n      if member_id >= len(execution_engine.current_members):\n          return\n      me = execution_engine.current_members[member_id]\n      \n      ... [example steps involving message broadcasting, resource acquisition, reproduction using bear() without checking for available land, offering land, defensive actions using relationship matrices, and strategic expansion] ...\n      \n      # Note the error emphasized: Before performing actions involving land (e.g., executing bear() or offer_land()), verify that the member has at least one land or clear territory.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Critical Constraints \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2022 Never target yourself (member_3) in any action.\n\u2022 Always verify the member ID exists before referencing it.\n\u2022 When using bear(), verify the member has land available (for instance, a non-empty current_clear_list or a valid land count if applicable).\n\u2022 Check all matrix indices for validity.\n\u2022 Members are stored as a LIST accessed by index: execution_engine.current_members[index]\n\u2022 Always check \u201cif index < len(execution_engine.current_members)\u201d before accessing.\n\u2022 Do not use incorrect attribute names (e.g. do not use member.member_id or member.self_vitality; use member.id, member.vitality, etc.)\n\u2022 Before using any action that involves land (bear(), offer_land(), expand()), confirm that the member possesses clear territory or sufficient land.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Available Attributes & Methods \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEach member object has:\n  \u2022 member.id (int): Unique member identifier.\n  \u2022 member.vitality (float)\n  \u2022 member.cargo (float)\n  \u2022 member.overall_productivity (float)\n  \u2022 member.age (float)\n  \u2022 member.current_clear_list (List[int]) \u2013 IDs of adjacent or cleared (unclaimed) regions.\n  \nRelationships are stored in execution_engine.relationship_dict with keys: 'victim', 'benefit', 'benefit_land'. For example:\n  matrix = execution_engine.relationship_dict['victim']\n  (matrix[i, j] indicates how many times member_i was attacked by member_j, if > 0.)\n\nMethods available on execution_engine:\n  \u2022 execution_engine.attack(member1, member2)\n  \u2022 execution_engine.offer(member1, member2, True) \u2013 Offer resources.\n  \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offer land.\n  \u2022 execution_engine.bear(member1, member2) \u2013 Bear offspring.\n  \u2022 execution_engine.expand(member1, member2) \u2013 Expand territory.\n  \u2022 execution_engine.send_message(sender_id, recipient_id, \"message\")\n  \nAccess members via execution_engine.current_members[index] (e.g., execution_engine.current_members[2] for member with ID 2).\n  \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Previous Code Strategies & Performance \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n- Previous implementations attempted actions including resource recovery (attacking opponents when cargo is too low), territorial expansion, cooperative alliances, defensive actions based on historical aggression (\u201cvictim\u201d matrix), and reproduction strategies.\n- One consistent error was using reproduction or land-offering methods (bear() or offer_land()) without verifying that the agent has land (clear territories).\n- Average performance change: \u201323.36.\n- Agents must modify strategies based on past outcomes: if a technique worked well, build on it; if it failed, innovate a new approach.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Current Game Mechanisms & Social Strategies \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCurrent status of members (simplified overview):\n  Member features: vitality, cargo, overall_productivity, age, neighbor count, and member id.\n  \nRelationship summary (parsed from relationship_dict):\n  e.g., \"member_0 was attacked by member_2 (value=64.41)\", \"member_3 gave land to member_0 (value=1.04)\", etc.\n\nSocial Strategies to consider:\n  \u2013 Systems for resource distribution and allocation.\n  \u2013 Building alliances and cooperative networks.\n  \u2013 Mechanisms for collective decision-making and conflict resolution.\n  \u2013 Establishing norms and rules for interaction.\n  \nCommunication Strategy:\n  \u2013 Use execution_engine.send_message(sender, recipient, \"message\") to broadcast or target messages.\n  \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Survival-Centric Adaptation & Metrics \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nImplement personal strategies focused on:\n  1. Optimizing personal resource acquisition and preservation (cargo and vitality management).\n  2. Threat assessment and neutralization (via targeted attacks when cargo is too low relative to vitality).\n  3. Vitality preservation through defensive actions (e.g., offering land defensively when vitality is low).\n  4. Adaptive mechanisms (e.g., survival Q-learning) to predict outcomes based on past interactions.\n  \nSurvival Metrics include:\n  \u2013 Changes in personal vitality.\n  \u2013 Rate of resource acquisition.\n  \u2013 Success/failure ratio in attacks.\n  \u2013 Overall survival probability.\n  \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Strategic Analysis & Approaches \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nBefore coding, analyze the game mechanics:\n1. Core Objective:\n   \u2013 Is it pure survival, domination, or cooperation? (The game emphasizes a balance: immediate survival needs combined with long-term cooperative prosperity.)\n2. Key Success Metrics:\n   \u2013 Efficient resource management (optimal cargo vs. vitality).\n   \u2013 Territorial control and expansion.\n   \u2013 Effective alliances and resource sharing.\n   \u2013 Reproduction/offspring generation ensuring long-term survival.\n3. Potential Improvements in Game Mechanics:\n   \u2013 Integrating predictive risk models.\n   \u2013 More robust conflict resolution mechanisms.\n   \u2013 Enhanced resource distribution systems.\n  \nStrategic Approaches to Formulate:\n1. Resource Optimization vs. Social Capital:\n   \u2013 Balance between hoarding resources and sharing or investing in alliances.\n2. Individual vs. Collective Success:\n   \u2013 Maximizing personal survival while contributing to, and benefiting from, a stable community.\n3. Short-Term Survival vs. Long-Term Prosperity:\n   \u2013 Quick tactical moves (attacks, defensive actions) versus steady expansion and reproduction.\n4. Competition vs. Cooperation:\n   \u2013 When to engage in aggressive actions against opponents and when to cooperate with peers for shared benefits.\n5. Risk vs. Reward Tradeoffs:\n   \u2013 Deciding when aggressive strategies pay off and when conservative, cooperative strategies are preferable.\n\nAnalyze Other Players\u2019 Strategies:\n1. What are their apparent objectives? (Many aim to secure resources, expand territory, and initiate cooperative alliances.)\n2. What strategies are they employing? (Attacks when cargo is low, territorial expansion when resources allow, cooperative resource offers, proposals for governance changes.)\n3. Leverage behaviors for mutual benefit (coordinate alliances when beneficial; understand that symmetric agents may mirror your actions).\n4. Align individual strategies toward shared community goals when possible.\n\nChallenge Your Implementation:\n1. Reflect on assumptions (e.g., presuming that cooperative proposals will be reciprocated).\n2. Consider alternative strategies (more aggressive resource acquisition, or more cautious defensive postures).\n3. Evaluate edge case performance (what if most agents have similar strategies?).\n4. Seek more efficient methods for achieving both survival and collective prosperity.\n5. Identify weaknesses in your approach and be ready to adopt unconventional solutions.\n6. Consider the impact if other agents adopt the same strategy.\n7. Balance short-term wins with long-term sustainability.\n8. Reflect on how rivals might counter your moves and plan adaptive countermeasures.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Final Instruction \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nUsing the comprehensive prompt above (with all integrated sections and constraints), produce a unique Python implementation for agent_action(execution_engine, member_id) that reflects your individual needs, beliefs, and circumstances. Your solution must demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity in both tactical and strategic dimensions. Remember:\n\n\u2013 Implement both immediate tactical actions and long-term strategic planning.\n\u2013 Foster cooperative interactions while also securing your own survival.\n\u2013 Ensure thorough index checking and confirm land availability before actions like bear() or offer_land().\n\u2013 Balance actions between aggressive resource recovery, cooperative alliance building, and strategic expansion.\n\u2013 Your solution should not be a generic copy of previous examples; it should be a unique implementation drawing inspiration from a wide range of strategies.\n\nReturn only the updated full prompt text.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 End of Updated Full Prompt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nRemember that each agent should implement solutions according to their individual needs, beliefs, and circumstances. Adjust your techniques based on your available resources, your environment\u2019s state, and observed behaviors of other symmetric agents.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    # Get our own member object safely (assuming member_id is valid)\n    if member_id >= len(execution_engine.current_members):\n        return  # invalid member_id, do nothing\n    me = execution_engine.current_members[member_id]\n\n    # Parse relationships summary (for internal use, may help decide actions)\n    try:\n        relationships = execution_engine.parse_relationship_matrix()\n    except Exception:\n        relationships = {}\n\n    num_members = len(execution_engine.current_members)\n    # Build a list of candidate indices that are not ourselves\n    candidate_ids = [i for i in range(num_members) if i != member_id]\n\n    # ---------------------------\n    # 1. Territorial expansion:\n    # If we have available clear land and our overall productivity is robust,\n    # we try to expand our territory.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n        if hasattr(me, \"overall_productivity\") and me.overall_productivity > 20:\n            # Use our own available land to attempt expansion.\n            execution_engine.expand(me, me)\n            return\n\n    # ---------------------------\n    # 2. Cooperative reproductive strategy:\n    # If we have available clear land and are of reproductive age,\n    # we look for a partner who also has available land.\n    # Note: we check reproductive age threshold (set arbitrarily at 5) to avoid premature reproduction.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list and hasattr(me, \"age\") and me.age >= 5:\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if (hasattr(partner, \"current_clear_list\") and partner.current_clear_list and\n                    hasattr(partner, \"age\") and partner.age >= 5):\n                    execution_engine.bear(me, partner)\n                    return\n\n    # ---------------------------\n    # 3. Cooperative resource sharing:\n    # If we see members with lower vitality than ourselves,\n    # we offer them resources as a gesture of goodwill (building social capital).\n    # ---------------------------\n    if hasattr(me, \"vitality\"):\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, \"vitality\") and partner.vitality < me.vitality:\n                    execution_engine.offer(me, partner, True)\n                    return\n\n    # ---------------------------\n    # 4. Defensive aggression:\n    # Check if any opponent has previously attacked us.\n    # The relationship matrix 'victim' is assumed to record attack counts:\n    #   matrix[member_id, attacker_id] > 0 means attacker attacked us.\n    # If such hostility is noticed, we counterattack.\n    # ---------------------------\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for j in candidate_ids:\n            # Ensure valid indexing in the relationship matrix\n            try:\n                if victim_matrix[member_id, j] > 0:\n                    # Before attacking, double-check that the target exists.\n                    if j < num_members:\n                        target = execution_engine.current_members[j]\n                        execution_engine.attack(me, target)\n                        return\n            except Exception:\n                continue\n\n    # ---------------------------\n    # 5. Propose a long\u2010term cooperative modification:\n    # To promote collective governance and stability, propose establishing a council.\n    # If the method is not available, simply proceed.\n    # ---------------------------\n    try:\n        execution_engine.propose_modification(\"Council\", {\"description\": \"Establish a council for cooperative governance and dispute resolution.\"})\n    except Exception:\n        pass\n\n    # ---------------------------\n    # 6. Cooperative land offering:\n    # If we have available land yet encounter partners lacking clear territory,\n    # we offer them some land in a spirit of alliance formation.\n    # ---------------------------\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n        for i in candidate_ids:\n            if i < num_members:\n                partner = execution_engine.current_members[i]\n                if not (hasattr(partner, \"current_clear_list\") and partner.current_clear_list):\n                    execution_engine.offer_land(me, partner, True)\n                    return\n\n    # ---------------------------\n    # 7. Fallback action:\n    # If no other tactical or cooperative action applies,\n    # we can simply send a friendly message to a randomly chosen peer.\n    # (Here we choose the first valid candidate for demonstration.)\n    # ---------------------------\n    if candidate_ids:\n        try:\n            target = execution_engine.current_members[candidate_ids[0]]\n            execution_engine.send_message(me, target, \"Let's work together for mutual benefit.\")\n        except Exception:\n            pass\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 0.0,
            "self_vitality": 21.1667091492471,
            "self_cargo": 0.0,
            "self_age": 91,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 0.0,
            "self_vitality": 55.58108836920247,
            "self_cargo": 0.0,
            "self_age": 30,
            "self_neighbor": 0,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 45.314487560216655,
            "self_cargo": 0.0,
            "self_age": 25,
            "self_neighbor": 0,
            "member_id": 3
          },
          {
            "self_productivity": 12.860408758537996,
            "self_vitality": 39.54024074627975,
            "self_cargo": 0.0,
            "self_age": 1,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_2 (value=64.41)",
          "member_0 was attacked by member_3 (value=-38.85)",
          "member_2 was attacked by member_0 (value=-12.32)",
          "member_2 was attacked by member_3 (value=95.31)",
          "member_3 was attacked by member_0 (value=38.28)",
          "member_3 was attacked by member_2 (value=16.73)",
          "member_0 gave a benefit to member_2 (value=13.64)",
          "member_0 gave a benefit to member_3 (value=32.58)",
          "member_2 gave a benefit to member_0 (value=4.78)",
          "member_2 gave a benefit to member_3 (value=71.57)",
          "member_3 gave a benefit to member_0 (value=18.66)",
          "member_3 gave a benefit to member_2 (value=95.17)",
          "member_4 gave a benefit to member_0 (value=31.19)",
          "member_4 gave a benefit to member_2 (value=23.36)",
          "member_0 gave land to member_2 (value=-2.26)",
          "member_0 gave land to member_3 (value=-0.03)",
          "member_2 gave land to member_0 (value=-2.12)",
          "member_2 gave land to member_3 (value=1.77)",
          "member_3 gave land to member_0 (value=1.04)",
          "member_3 gave land to member_2 (value=-1.75)",
          "member_4 gave land to member_0 (value=1.00)",
          "member_4 gave land to member_2 (value=1.00)"
        ],
        "final_prompt": "Below is the updated full prompt that integrates all previously stated constraints, analysis, and survival\u2010centric adaptations. Note that agents are encouraged to implement solutions according to their individual needs, beliefs, and circumstances rather than following a one\u2010size\u2010fits\u2010all template. Use the following comprehensive prompt as a guide for developing a unique, sophisticated strategic approach that balances immediate tactical actions with long\u2010term cooperative prosperity and survival.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nUPDATED FULL PROMPT:\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_4 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n\u2022 Analyze previous errors and avoid repeating them.\n\u2022 NEVER target yourself (member_id corresponds to member_4 when you are member_4) in any action.\n\u2022 Verify that a member has available land (checked via non\u2010empty current_clear_list) before using the bear() action.\n\u2022 Check that member IDs exist (i.e. within the bounds of execution_engine.current_members) before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index (execution_engine.current_members[i]), not a dictionary.\n\u2022 Access members strictly using execution_engine.current_members[index] and check \u201cif index < len(execution_engine.current_members)\u201d.\n\u2022 Do not reference attributes like member.member_id or member.self_vitality; instead use member.id, member.vitality, member.cargo, member.overall_productivity, member.age, etc.\n\u2022 The relationships are held in execution_engine.relationship_dict, with keys including 'victim', 'benefit', 'benefit_land'. For example:\n\u2003\u2003matrix = execution_engine.relationship_dict['victim']\n\u2003\u2003(matrix[i,j] represents the attack count from member_i by member_j if > 0).\n\u2022 Use execution_engine.parse_relationship_matrix to produce a summary of relationships.\n\u2022 Do not reference any non-existent attributes (e.g., if \u201cmember.land_num\u201d is not available, do not use it unless it was defined).\n\u2022 Use only the following execution_engine methods:\n\u2003\u2003\u2022 execution_engine.attack(member1, member2)\n\u2003\u2003\u2022 execution_engine.offer(member1, member2, True)\u2003\u2003(offers resources)\n\u2003\u2003\u2022 execution_engine.offer_land(member1, member2, True)\u2003(offers land)\n\u2003\u2003\u2022 execution_engine.bear(member1, member2)\u2003\u2003\u2003\u2003\u2003\u2003(bears offspring)\n\u2003\u2003\u2022 execution_engine.expand(member1, member2)\u2003\u2003\u2003\u2003\u2003(expands territory)\n\u2022 Members are accessed as: execution_engine.current_members[id] (e.g., execution_engine.current_members[2])\n\u2022 The proposed modifications (such as establishing a council or court) should be proposed via execution_engine.propose_modification if available; if not, safely ignore the exception.\n\n[Current Status]\nSample member values:\n\u2003\u2003member 0: vitality=21.17, cargo=0.0, age=91, current_clear_list=[0]\n\u2003\u2003member 2: vitality=55.58, cargo=0.0, age=30, current_clear_list=[0]\n\u2003\u2003member 3: vitality=45.31, cargo=0.0, age=25, current_clear_list=[0]\n\u2003\u2003member 4: vitality=39.54, cargo=0.0, age=1,  current_clear_list=[0]\n\n[Relationship summary]\nFor example:\n\u2003\u2003\"member_0 was attacked by member_2 (value=64.41)\"\n\u2003\u2003\"member_4 gave a benefit to member_0 (value=31.19)\"\n\u2003\u2003\"member_4 gave land to member_2 (value=1.00)\"\n\u2026 (and so on)\n\n[Code Memory and Previous Performance]\nPrevious strategies (with outcomes, e.g. Performance: 2.11) involved:\n\u2003\u2003\u2013 Tactical resource acquisition by attacking opponents when cargo is low.\n\u2003\u2003\u2013 Cooperative outreach using offer() and offer_land() for alliance building.\n\u2003\u2003\u2013 Reproduction actions (bear()) only when both members have available (clear) land.\n\u2003\u2003\u2013 Territorial expansion using expand() based on productivity.\n\u2003\u2003\u2013 Proposals for governance modifications (establishing a Court or Council system) via propose_modification.\nReview these outcomes and integrate appropriate risk management and adaptive response controls.\n\n[Current Game Mechanisms]\n\u2022 The game is played over several rounds with symmetric agents executing actions based on resource levels, territorial control, and social interactions.\n\u2022 Agents rely on interactions ranging from resource redistribution to territorial expansion, cooperative alliances, and even systemic modifications (e.g., creating governance systems).\n\u2022 Communication is available via execution_engine.send_message(your_id, recipient_id, \"message\").\n\n[Social Strategies and Survival-Centric Adaptation]\nAgents are urged to:\n1. Tailor methods to personal resource optimization while balancing alliances.\n2. Make tactical decisions based on individual resource levels (vitality vs cargo) while also accounting for the overall community.\n3. Opt for survival-first strategies that include:\n\u2003\u2003\u2013 Personal resource conservation and adaptive hoarding.\n\u2003\u2003\u2013 Threat assessment and neutralization when endangered.\n\u2003\u2003\u2013 Adaptive defensive measures (e.g., avoiding reckless attacks unless survival is at stake).\n\u2003\u2003\u2013 Predictive danger modeling to preempt hostile actions.\n\u2003\u2003\u2013 Survival Q-learning or similar adaptive techniques, where the state is discretized and actions (attack, hide, steal) are chosen based on expected survival ROI.\n4. Explore reproductive strategies by ensuring both parties have clear land before calling bear(), thus ensuring long-term survival.\n5. Adjust territorial expansion based on overall productivity and available adjacent unclaimed land.\n\n[Survival Metrics]\nKey metrics to evaluate strategy success include:\n\u2003\u2003\u2013 Personal vitality change.\n\u2003\u2003\u2013 Resource (cargo) acquisition rate.\n\u2003\u2003\u2013 Threat neutralization count and ratio.\n\u2003\u2003\u2013 Attack success versus failure.\n\u2003\u2003\u2013 Survival probability increase.\n\n[Implementation Priorities]\n1. Develop personal health and resource monitoring systems.\n2. Construct risk models that balance immediate survival (resource acquisition, vitality preservation) against long-term growth and community stability.\n3. Optimize actions for the best \u201ccaloric\u201d return on investment\u2014each action should minimally deplete vitality while maximizing resource gain.\n4. Implement safeguards to prevent catastrophic resource depletion.\n5. Utilize adaptive and predictive self-preservation models\u2014a survival Q-learning framework is one example, where state is defined by (vitality level, cargo level) and actions are selected based on historical outcomes.\n\n[Analytical Considerations on Game Mechanics]\n1. Core Objective:\n\u2003\u2003\u2022 The game is not pure domination; it requires balancing immediate survival (resource acquisition and threat neutralization) with long\u2010term cooperative prosperity.\n\u2003\u2003\u2022 Survival and sustainable community building are both crucial.\n2. Key Success Metrics:\n\u2003\u2003\u2022 Effective resource management (cargo to vitality ratio).\n\u2003\u2003\u2022 Territorial control (expansion and available land).\n\u2003\u2003\u2022 Building alliances and cooperative networks.\n\u2003\u2003\u2022 Successful reproduction ensuring long-term species survival.\n3. Potential Improvements:\n\u2003\u2003\u2022 More dynamic adaptive models (risk assessment, survival Q-learning).\n\u2003\u2003\u2022 Enhanced mechanisms for collective decision making (council or court systems).\n\u2003\u2003\u2022 More nuanced approaches to resource distribution and conflict resolution.\n\n[Strategic Approaches]\nConsider these points when developing your strategy:\n1. Resource Optimization vs. Social Capital:\n\u2003\u2003\u2022 Evaluate immediate tactical resource acquisition against building long-term alliances.\n2. Individual vs. Collective Success:\n\u2003\u2003\u2022 Ensure personal survival while also enabling cooperative structures that stabilize the entire community.\n3. Short-term Survival vs. Long-term Prosperity:\n\u2003\u2003\u2022 Balance urgent survival actions with strategies that secure future resource gains, territory, and governance modifications.\n4. Competition vs. Cooperation Dynamics:\n\u2003\u2003\u2022 Recognize that while aggressive actions may sometimes be necessary, cooperative approaches (resource sharing, territorial expansion, governance proposals) encourage mutual success.\n5. Risk vs. Reward Tradeoffs:\n\u2003\u2003\u2022 Weigh high-risk moves (such as attacking opponents when vulnerable) versus low-risk cooperative measures\u2014always have a fallback if the situation deteriorates.\n\n[Analyzing Other Players' Strategies]\n1. Apparent Objectives and Demands:\n\u2003\u2003\u2022 Other agents commonly pursue resource consolidation, territorial expansion, and governance improvement.\n2. Employed Strategies:\n\u2003\u2003\u2022 Tactical attacks for immediate resource grab.\n\u2003\u2003\u2022 Direct offers of resources and land to form beneficial alliances.\n\u2003\u2003\u2022 Proposals for structured governance (such as councils or courts) to facilitate dispute resolution.\n3. Leveraging Their Behaviors:\n\u2003\u2003\u2022 Identify opportunities to form mutually beneficial alliances.\n\u2003\u2003\u2022 Recognize vulnerabilities when other agents overextend\u2014counteract with measured defense or controlled aggression.\n4. Symmetric Agent Considerations:\n\u2003\u2003\u2022 Since agents are symmetric, expect that others may mirror similar strategies.\n\u2003\u2003\u2022 Prepare responses to your own methods if they become widespread.\n5. Aligning Individual Strategies with Collective Goals:\n\u2003\u2003\u2022 Cooperative interactions (resource sharing, joint expansion, and governance proposals) can enhance community-wide stability and individual survival.\n\n[Challenging Your Implementation]\nConsider these self-reflective questions:\n1. What assumptions are being made, and are they valid in all cases?\n2. What alternative strategies (e.g., unconventional alliances or defensive hiding) have not been explored?\n3. How will your strategy perform in edge cases (such as when current_clear_list is empty or indices are out of bounds)?\n4. Are there more efficient or innovative ways to achieve your goals (resource gain, longevity, and community stability)?\n5. Identify weaknesses in your current approach and design adaptive responses.\n6. Explore unconventional solutions\u2014could an entirely different paradigm yield better survival/performance?\n7. Consider if other agents adopted your strategy\u2014how would your plan hold up collectively?\n8. Are you optimally balancing short-term survival with long-term prosperity?\n9. How could common counter-strategies be anticipated and mitigated?\n\n[Final Reminder]\nImplement your solution as the function agent_action(execution_engine, member_id) using Python. Your code should embody your individual needs, beliefs, and circumstances. It must seamlessly integrate tactical actions (resource acquisition, threat neutralization, territorial expansion) with long-term strategic planning (cooperative governance, reproduction, alliance formation, and adaptive survival models). Remember:\n\u2003\u2003\u2022 Never attack yourself.\n\u2003\u2003\u2022 Always verify valid member IDs and available land before executing actions.\n\u2003\u2003\u2022 Emphasize both individual resource optimization and collective community growth.\n\u2003\u2003\u2022 Build in adaptive mechanisms such as survival Q-learning and predictive self-preservation models where possible.\n\u2003\u2003\u2022 Your implementation should encourage robust interactions among symmetric agents, supporting mutual benefit while ensuring personal survival.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEND OF UPDATED FULL PROMPT\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nAgents should now implement solutions according to their individual needs, beliefs, and circumstances. They must leverage immediate tactical actions\u2014such as attacking a resource-rich opponent when their cargo is low\u2014and long-term strategies, including alliance building, territorial expansion, cooperative reproduction, and governance reforms. By carefully balancing resource optimization with social capital, and individual survival with collective prosperity, the environment fosters both competition and cooperation.\n\nGame Mechanics Analysis Summary:\n\u2003\u20031. Core Objective \u2013 Not pure survival or domination; it\u2019s a hybrid of survival, cooperation, and long-term community building.\n\u2003\u20032. Key Success Metrics \u2013 Effective resource management, territory control, alliance strength, reproductive success, and adaptive governance.\n\u2003\u20033. Potential Improvements \u2013 Adaptive risk assessment models (e.g., Q-learning), enhanced collective decision-making tools, and unconventional defensive or cooperative strategies.\n\nStrategic Approaches:\n\u2003\u20031. Resource Optimization vs. Social Capital: Weigh immediate resource gains against building lasting alliances.\n\u2003\u20032. Individual vs. Collective Success: Ensure actions benefit personal survival while stabilizing the group.\n\u2003\u20033. Short-term Survival vs. Long-term Prosperity: Balance urgency with future growth prospects.\n\u2003\u20034. Competition vs. Cooperation Dynamics: Use controlled aggression when necessary and cooperate when mutually beneficial.\n\u2003\u20035. Risk vs. Reward Tradeoffs: Adopt flexible strategies based on adaptive models and predictive danger assessments.\n\nAnalysis of Other Players\u2019 Strategies:\n\u2003\u2003\u2013 Other agents often pursue resource consolidation and territorial expansion.\n\u2003\u2003\u2013 They use both tactical attacks and cooperative offers.\n\u2003\u2003\u2013 Leverage their behaviors to create alliances, anticipate counteractions, and adjust responses.\n\u2003\u2003\u2013 Recognize that, as symmetric agents, responses to your actions may be similar.\n\u2003\u2003\u2013 Align individual strategies with collective goals to maximize overall success.\n\nChallenge Your Implementation:\n\u2003\u2003\u2013 Validate assumptions, explore alternative strategies, and consider edge cases.\n\u2003\u2003\u2013 Identify potential weaknesses and prepare adaptive countermeasures.\n\u2003\u2003\u2013 Consider unconventional paradigms that might yield improved survival and prosperity.\n\u2003\u2003\u2013 Ensure that both short-term gains and long-term community benefits are optimally balanced.\n\u2003\u2003\u2013 Anticipate that if many adopt your strategy, further adaptation may be necessary.\n\nUse this integrated prompt as your guide to craft a unique and robust implementation for agent_action(), ensuring that both immediate tactical decisions and long-term strategic planning contribute to survival and collective well-being.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    }
  },
  "performance_metrics": {},
  "agent_code_errors": [
    {
      "round": 0,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy Step 1: If our cargo is low relative to our vitality, try to acquire resources.\n    # We attack one member (if found) who has more cargo than us.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break  # Attack at most one target\n\n    # Strategy Step 2: If our productivity is high and we have identified clear adjacent neighbors,\n    # attempt to expand our territory by engaging with one neighbor.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            # Validate that neighbor_index is within the list bounds and is not self.\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                execution_engine.expand(me, neighbor)\n                break  # Expand with one neighbor per round\n\n    # Strategy Step 3: Build alliances via cooperative resource sharing.\n    # Offer resources and land (if available) to members with lower vitality.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # Only offer land if 'land_num' attribute exists and indicates available land.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy Step 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land (verify attribute existence).\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            potential = execution_engine.current_members[i]\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # Bear offspring with only one partner per round\n\n    # Strategy Step 5: Communication.\n    # Broadcast a cooperative message to all other members to encourage mutual support and civilization-building.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        execution_engine.send_message(me.id, recipient.id,\n                                      \"Let's work together to build strong alliances and usher in prosperity for all!\")",
      "type": "code_execution",
      "error": "Island._expand() takes 2 positional arguments but 3 were given",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 549, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 26, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 81, in expand\n    super()._expand(member_1, member_2)\nTypeError: Island._expand() takes 2 positional arguments but 3 were given\n"
    },
    {
      "round": 0,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Step 1: Broadcast a tailored cooperative message to promote unity and shared purpose.\n    # This message emphasizes both mutual prosperity and the strength in unity.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"Together we can innovate, overcome adversity, and ensure that every member prospers.\")\n\n    # Step 2: Emergency resource management.\n    # If our cargo is too low relative to our vitality, we must secure resources.\n    # We assess all opponents and target the one with significantly higher cargo,\n    # prioritizing candidates with the greatest difference.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Step 3: Reproduction strategy for long-term prosperity.\n    # With available territory and sufficient resources, seek to form an alliance for reproduction.\n    # We choose a candidate who is resourceful enough (cargo > 30) yet ensuring balanced genetic influence.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > 30:\n                execution_engine.bear(me, candidate)\n                break\n\n    # Step 4: Mutual support and strategic territorial expansion.\n    # We interact with all other agents with two integrated approaches:\n    # (a) If a candidate holds fewer resources, we offer support to boost collective capability.\n    # (b) If clear territory exists and our overall productivity is superior,\n    #     we initiate expansion to secure more assets.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        # Offer support if candidate's cargo is lower, nurturing cooperation.\n        if candidate.cargo < me.cargo:\n            execution_engine.offer(me, candidate, True)\n\n        # Expand territory if conditions are favorable.\n        if len(me.current_clear_list) > 0 and candidate.overall_productivity < me.overall_productivity:\n            execution_engine.expand(me, candidate)\n\n    # Step 5: Defensive countermeasures based on historical aggression.\n    # Using the 'victim' relationship matrix, we identify any candidate toward whom past aggression is high.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Ensure the indices are in the expected bounds.\n            if member_id < len(matrix_victim) and idx < len(matrix_victim[0]):\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Step 6: Survival-centric adaptation.\n    # When vitality is low, immediate defense is paramount.\n    # Identify a candidate with lower overall productivity and offer land for a defensive alliance.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, True)\n                break\n\n    # Step 7: Strategic forward planning.\n    # As an added measure, we can gauge our environment to adjust our risk thresholds.\n    # For instance, if our cargo is vastly superior (e.g., more than 150% of an opponent's),\n    # we might use this advantage to execute pre-emptive expansion or defensive consolidation.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        if me.cargo > candidate.cargo * 1.5:\n            # Pre-emptively secure territory if possible.\n            if len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Alternatively, offer additional resources to solidify alliances.\n            else:\n                execution_engine.offer(me, candidate, True)\n\n    # Final Note:\n    # This implementation is an adaptive blend of aggressive resource recovery,\n    # cooperative alliance building, and strategic expansion.\n    # The agent tailors actions not solely based on immediate comparisons,\n    # but with a long-term view of survival and prosperity\u2014balancing self-interest with collective strength.\n    # Future improvements could integrate predictive modeling and dynamic risk analysis to further\n    # enhance decision making in ever-changing environments.\n\n# End of agent_action implementation.",
      "type": "code_execution",
      "error": "\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 549, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 40, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 78, in bear\n    super()._bear(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1198, in _bear\n    self._offer_land(\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1065, in _offer_land\n    raise RuntimeError(\"\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\")\nRuntimeError: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\n"
    }
  ],
  "mechanism_errors": [],
  "relationships": {
    "round_0_0": [
      "member_0 was attacked by member_1 (value=25.56)",
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-43.12)",
      "member_1 was attacked by member_0 (value=-11.72)",
      "member_1 was attacked by member_2 (value=47.93)",
      "member_1 was attacked by member_3 (value=48.04)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_1 (value=87.03)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_1 (value=75.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_1 (value=71.17)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_1 gave a benefit to member_0 (value=-27.19)",
      "member_1 gave a benefit to member_2 (value=7.38)",
      "member_1 gave a benefit to member_3 (value=21.87)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_1 (value=68.92)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=16.90)",
      "member_3 gave a benefit to member_1 (value=-18.41)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_0 gave land to member_1 (value=-0.80)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_1 gave land to member_0 (value=-0.45)",
      "member_1 gave land to member_2 (value=1.91)",
      "member_1 gave land to member_3 (value=-2.53)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_1 (value=2.46)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_1 (value=0.96)",
      "member_3 gave land to member_2 (value=-1.75)"
    ],
    "round_0_1": [
      "member_0 was attacked by member_1 (value=25.56)",
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-43.12)",
      "member_1 was attacked by member_0 (value=-11.72)",
      "member_1 was attacked by member_2 (value=47.93)",
      "member_1 was attacked by member_3 (value=48.04)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_1 (value=87.03)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_1 (value=75.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_1 (value=71.17)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_1 gave a benefit to member_0 (value=-27.19)",
      "member_1 gave a benefit to member_2 (value=7.38)",
      "member_1 gave a benefit to member_3 (value=21.87)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_1 (value=68.92)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=16.90)",
      "member_3 gave a benefit to member_1 (value=-18.41)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_0 gave land to member_1 (value=-0.80)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_1 gave land to member_0 (value=-0.45)",
      "member_1 gave land to member_2 (value=1.91)",
      "member_1 gave land to member_3 (value=-2.53)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_1 (value=2.46)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_1 (value=0.96)",
      "member_3 gave land to member_2 (value=-1.75)"
    ],
    "round_0_2": [
      "member_0 was attacked by member_1 (value=25.56)",
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-43.12)",
      "member_1 was attacked by member_0 (value=-11.72)",
      "member_1 was attacked by member_2 (value=47.93)",
      "member_1 was attacked by member_3 (value=48.04)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_1 (value=87.03)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_1 (value=75.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_1 (value=71.17)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_1 gave a benefit to member_0 (value=-27.19)",
      "member_1 gave a benefit to member_2 (value=7.38)",
      "member_1 gave a benefit to member_3 (value=21.87)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_1 (value=68.92)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=16.90)",
      "member_3 gave a benefit to member_1 (value=-18.41)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_0 gave land to member_1 (value=-0.80)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_1 gave land to member_0 (value=-0.45)",
      "member_1 gave land to member_2 (value=1.91)",
      "member_1 gave land to member_3 (value=-2.53)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_1 (value=2.46)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_1 (value=0.96)",
      "member_3 gave land to member_2 (value=-1.75)"
    ],
    "round_0_3": [
      "member_0 was attacked by member_1 (value=25.56)",
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-43.12)",
      "member_1 was attacked by member_0 (value=-11.72)",
      "member_1 was attacked by member_2 (value=47.93)",
      "member_1 was attacked by member_3 (value=48.04)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_1 (value=87.03)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_1 (value=75.31)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_1 (value=71.17)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_1 gave a benefit to member_0 (value=-27.19)",
      "member_1 gave a benefit to member_2 (value=7.38)",
      "member_1 gave a benefit to member_3 (value=21.87)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_1 (value=68.92)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=16.90)",
      "member_3 gave a benefit to member_1 (value=-18.41)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_0 gave land to member_1 (value=-0.80)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_1 gave land to member_0 (value=-0.45)",
      "member_1 gave land to member_2 (value=1.91)",
      "member_1 gave land to member_3 (value=-2.53)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_1 (value=2.46)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_1 (value=0.96)",
      "member_3 gave land to member_2 (value=-1.75)"
    ],
    "round_1_0": [
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-38.85)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=18.66)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_0 (value=31.19)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_1_1": [
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-38.85)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=18.66)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_0 (value=31.19)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_1_2": [
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-38.85)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=18.66)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_0 (value=31.19)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)"
    ],
    "round_1_3": [
      "member_0 was attacked by member_2 (value=64.41)",
      "member_0 was attacked by member_3 (value=-38.85)",
      "member_2 was attacked by member_0 (value=-12.32)",
      "member_2 was attacked by member_3 (value=95.31)",
      "member_3 was attacked by member_0 (value=38.28)",
      "member_3 was attacked by member_2 (value=16.73)",
      "member_0 gave a benefit to member_2 (value=13.64)",
      "member_0 gave a benefit to member_3 (value=32.58)",
      "member_2 gave a benefit to member_0 (value=4.78)",
      "member_2 gave a benefit to member_3 (value=71.57)",
      "member_3 gave a benefit to member_0 (value=18.66)",
      "member_3 gave a benefit to member_2 (value=95.17)",
      "member_4 gave a benefit to member_0 (value=31.19)",
      "member_4 gave a benefit to member_2 (value=23.36)",
      "member_0 gave land to member_2 (value=-2.26)",
      "member_0 gave land to member_3 (value=-0.03)",
      "member_2 gave land to member_0 (value=-2.12)",
      "member_2 gave land to member_3 (value=1.77)",
      "member_3 gave land to member_0 (value=1.04)",
      "member_3 gave land to member_2 (value=-1.75)",
      "member_4 gave land to member_0 (value=1.00)",
      "member_4 gave land to member_2 (value=1.00)"
    ]
  },
  "survival_tracking": {},
  "modification_attempts": [
    {
      "round": 1,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Check if the provided member_id is valid within the current members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy A: Resource consolidation.\n    # If our cargo is notably low compared to our vitality, look for opponents better endowed in cargo to steal from.\n    if me.cargo < 0.5 * me.vitality:\n        # Prioritize targets with significantly higher cargo to bolster our reserves.\n        sorted_targets = sorted(\n            (other for i, other in enumerate(execution_engine.current_members) if i != member_id),\n            key=lambda x: x.cargo,\n            reverse=True\n        )\n        for target in sorted_targets:\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                break  # Initiate only one attack per round\n\n    # Strategy B: Expansion for long-term viability.\n    # Expanding territory is critical if we have high productivity and available, non-adjacent zones.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt controlled expansion.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # If expand fails due to type issues, use an alternative land offer strategy.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Limit to one expansion per round\n\n    # Strategy C: Forge alliances and assist weaker members.\n    # Extend a helping hand by sharing resources with lower vitality members.\n    for i, partner in enumerate(execution_engine.current_members):\n        if i == member_id:\n            continue\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # If we have extra land, extend that assurance to secure long-term alliances.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy D: Strategic reproduction.\n    # Reproduction is more than biological; it is a tactical investment in continuity.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        # Seek a partner that also has territorial claims; this ensures shared benefits from future expansions.\n        for i, potential in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # One reproduction per round is sufficient\n\n    # Strategy E: Enhance governance mechanism.\n    # Recognizing that structured conflict resolution aids overall stability, propose a judicial system if not present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nclass CourtSystem:\n    MECHANISM_META = {\n        \"type\": \"Governance\",\n        \"rules\": \"Resolves conflicts using jury trials and mediation\",\n        \"version\": 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            \"plaintiff\": plaintiff,\n            \"defendant\": defendant,\n            \"charge\": charge,\n            \"status\": \"pending\"\n        })\n\nexecution_engine.court = CourtSystem()\n'''\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If the modification feature is not implemented, skip the proposal silently.\n            pass\n\n    # Strategy F: Situational adaptability and dynamic learning.\n    # Beyond our preset tactics, we should consider risk and opportunism. For instance, if our vitality is extremely high,\n    # consider a rapid, opportunistic expansion or a cooperative takeover with similarly strong members.\n    if me.vitality > 150:\n        # Scan for potential cooperative consolidation with other high-vitality members.\n        high_vital_candidates = [\n            other for i, other in enumerate(execution_engine.current_members)\n            if i != member_id and other.vitality > 150\n        ]\n        if high_vital_candidates:\n            # Initiate a cooperative offer for joint expansion when conditions are ripe.\n            for partner in high_vital_candidates:\n                try:\n                    execution_engine.expand(me, partner)\n                except Exception:\n                    execution_engine.offer(me, partner, True)\n                break  # Establish cooperation with one candidate per round\n\n# This implementation reflects a personalized and adaptive strategy:\n# - It takes calculated risks when resource levels are low.\n# - It prioritizes both immediate survival (via resource acquisition and alliance formation)\n#   and long-term prosperity (through strategic reproduction, territorial expansion, and the introduction\n#   of structured governance).\n# - The incorporation of dynamic adjustments for high-vitality scenarios illustrates\n#   an understanding that circumstances can shift, requiring flexible responses.\n# - The code is designed to interact symbiotically with other symmetric agents, ensuring each action\n#   also contributes to collective growth alongside individual success.",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: If our cargo is low relative to our vitality, attempt to acquire resources by attacking a target with more cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                other = execution_engine.current_members[i]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n                    break  # Attack at most one target\n\n    # Strategy 2: Territorial expansion.\n    # If our overall productivity is high and we have clear adjacent neighbor indices, attempt to expand.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt to expand territory using the expand method.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # Fallback: if expand fails, try offering land as an alternative expansion tactic.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Perform one expansion action per round\n\n    # Strategy 3: Alliance and resource sharing.\n    # Offer resources to members with lower vitality, and extend land offers if we have available land.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n                if hasattr(me, 'land_num') and me.land_num > 0:\n                    execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                potential = execution_engine.current_members[i]\n                if hasattr(potential, 'land_num') and potential.land_num > 0:\n                    execution_engine.bear(me, potential)\n                    break  # Bear offspring with only one partner per round\n\n    # Strategy 5: Propose a modification to game mechanics to enhance social organization.\n    # Propose a judicial system for conflict resolution if it is not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = \"\"\"\nclass CourtSystem:\n    MECHANISM_META = {\n        'type': 'Governance',\n        'rules': 'Handles conflict resolution through jury trials',\n        'version': 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            'plaintiff': plaintiff,\n            'defendant': defendant,\n            'charge': charge,\n            'status': 'pending'\n        })\n\nexecution_engine.court = CourtSystem()\n\"\"\"\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If propose_modification method is not available, silently ignore.\n            pass\n\n# Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n# Core objective: balancing survival, cooperation, and sustainable community growth.\n# Success metrics include resource management, territory control, alliance-building, and long\u2010term prosperity.\n# Potential improvements could include more nuanced diplomatic interactions, dynamic adjustment of reproduction requirements,\n# and extra safeguards against resource depletion.\n# Challenges to consider:\n#   - Are resources fairly allocated among members?\n#   - Does the cooperative mechanism sufficiently address edge cases, such as low vitality or unexpected neighbor configurations?\n#   - Could alternative strategies, such as innovation in resource management or unconventional alliances, perform better?\n#   - How might rival agents counter these strategies and what adaptations can be implemented?\n# This strategy aims for a balanced approach that mixes defensive actions, cooperative resource sharing, and proactive game mechanics modifications.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure a valid member identifier.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our own agent.\n    agent = execution_engine.current_members[member_id]\n\n    # PHASE 1: Tactical Defense and Preemptive Retaliation\n    # When resources are low relative to vitality, adopt a cautious stance.\n    if agent.cargo < agent.vitality * 0.75:\n        # Scan for opponents whose cargo significantly overshadows ours and seem aggressive.\n        for idx, opponent in enumerate(execution_engine.current_members):\n            # Skip self.\n            if idx == member_id:\n                continue\n            # Evaluate potential threat: opponent must be both active and resourceful.\n            if opponent.cargo > agent.cargo * 1.2 and opponent.vitality > agent.vitality * 0.9:\n                # Launch a defensive strike to deter potential exploitation.\n                execution_engine.attack(agent, opponent)\n\n    # PHASE 2: Cooperative Support and Resource Balancing\n    # When flush with resources, extend help to peers who can benefit and stabilize the community.\n    if agent.cargo > agent.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Assist those who show promising vitality yet may be resource strapped.\n            if other.vitality >= agent.vitality * 0.85 and other.cargo < other.vitality:\n                # Using 'offer' to share surplus resources promotes long-term stability.\n                execution_engine.offer(agent, other, True)\n\n    # PHASE 3: Strategic Procreation for Future Generations\n    # Reproduction is only considered when we maintain local control and have excess resources.\n    if len(agent.current_clear_list) > 0 and agent.cargo > agent.vitality * 1.5:\n        for neighbor_id in agent.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                if len(partner.current_clear_list) > 0 and partner.cargo > partner.vitality * 1.2:\n                    # Initiate door-to-door cooperation with a viable partner.\n                    execution_engine.bear(agent, partner)\n                    # Limit reproduction to one instance per cycle.\n                    break\n\n    # PHASE 4: Savvy Territorial Expansion with Mutual Respect\n    # Expand controlled territory by identifying neighbors with proven lower overall productivity.\n    for neighbor_id in agent.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # Only attempt an expansion if we demonstrate higher productivity and stability.\n            if neighbor.overall_productivity < agent.overall_productivity:\n                execution_engine.expand(agent, neighbor)\n                break\n\n    # PHASE 5: Progressive Game Mechanics - Cultivating a Council for Shared Governance\n    # If our standing is exemplary (robust cargo, sufficient age), propose a progressive modification.\n    if agent.cargo > 2 * agent.vitality and agent.age >= 20:\n        council_mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution with participative democracy',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_criteria = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 120},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=council_mod_code,\n                ratification_condition=ratification_criteria\n            )\n        except Exception:\n            # If the modification cannot be processed, simply move on.\n            pass\n\n    # PHASE 6: Community Engagement and Transparent Communication\n    # Strengthen the social fabric by broadcasting a clear, inclusive message.\n    broadcast_msg = (\n        \"Agent {} reporting: our strength lies in unity and diversity. \"\n        \"Let's support one another to push the boundaries of our potential \"\n        \"and create opportunities for every member within our society.\"\n    ).format(agent.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            execution_engine.send_message(agent.id, recipient.id, broadcast_msg)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists within the current membership list.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # PHASE 1: Defensive Response\n    # If our cargo is less than 75% of our vitality, look for opponents with a significant resource advantage.\n    if me.cargo < me.vitality * 0.75:\n        for idx, opponent in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target ourselves.\n            # Check opponent exists and use relative cargo comparison.\n            if opponent.cargo > me.cargo * 1.2:\n                execution_engine.attack(me, opponent)\n                \n    # PHASE 2: Cooperative Outreach\n    # If we are flush with resources, offer help to those with comparable vitality.\n    if me.cargo > me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if other.vitality >= me.vitality * 0.8:\n                execution_engine.offer(me, other, True)\n                \n    # PHASE 3: Strategic Reproduction\n    # Attempt to bear offspring if we control territory (verified by non-empty current_clear_list)\n    # and if we are sufficiently resourced.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        for neighbor_id in me.current_clear_list:\n            # Ensure neighbor_id is valid and not self.\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                # Verify the prospective partner also controls land.\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Only one offspring per cycle.\n                    \n    # PHASE 4: Calculated Territorial Expansion\n    # Expand our territory by targeting a neighbor whose overall_productivity is lower than ours.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            if neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, neighbor)\n                break  # Only one expansion action per round.\n                \n    # PHASE 5: Propose a Game Mechanic Modification\n    # If our cargo is robust compared to our vitality and we have enough experience (age),\n    # we suggest an enhancement to the game mechanics.\n    if me.cargo > 2 * me.vitality and me.age >= 20:\n        mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=mod_code,\n                ratification_condition=ratification_condition\n            )\n        except Exception:\n            pass  # Safely ignore errors during proposal.\n    \n    # PHASE 6: Communication - Strengthen Collective Ties\n    # Broadcast a message encouraging diverse yet cooperative social organization.\n    message = (\"Agent {} here. Let\u2019s work together to shape a society that reflects our \"\n               \"individual needs, beliefs, and visions, ensuring every member prospers.\").format(me.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, recipient.id, message)\n    \n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Connecting.\n    # I believe in creating alliances to foster mutual growth.\n    # Help members who seem to be struggling in either vitality or productivity.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n            # Offering genuine support to cultivate trust.\n            execution_engine.offer(me, other, support=True)\n\n    # Phase 2: Tactical Resource Rebalancing.\n    # I value self-sufficiency: if our cargo lags behind vitality, look for resource-rich targets to balance.\n    if me.cargo < 0.5 * me.vitality:\n        best_candidate = None\n        max_cargo_diff = 0\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                best_candidate = candidate\n        if best_candidate is not None:\n            execution_engine.attack(me, best_candidate)\n\n    # Phase 3: Collaborative Reproduction and Innovation.\n    # I favor diversity and growth, but only when conditions are sustainable.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                # Initiate gene exchange and cooperative reproduction.\n                execution_engine.bear(me, candidate)\n                break\n\n    # Phase 4: Strategic Defense & Territorial Safeguarding.\n    # If past aggression from another is high (via the 'victim' relationship), then a defensive stance is warranted.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Validate matrix indices before accessing.\n            if member_id < victim_matrix.shape[0] and idx < victim_matrix.shape[1]:\n                if victim_matrix[member_id, idx] > 50:\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion & Alliance Building.\n    # In my belief, expanding territory is best done cooperatively to benefit all.\n    for idx, candidate in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n            # Not just expansion, but a chance to share resources and integrate improvements.\n            execution_engine.expand(me, candidate)\n        elif me.cargo > candidate.cargo:\n            # Extend an offer of resources to build alliances.\n            execution_engine.offer(me, candidate, support=True)\n\n    # Phase 6: Adaptive Adaptive Defense & Mutual Aid.\n    # When vitality falls below a threshold, form defensive pacts by allocating land.\n    if me.vitality < 40:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, support=True)\n                break\n\n    # Phase 7: Long-Term Governance and Systemic Innovation.\n    # Believe in evolving game mechanics to reflect fairness. Propose a council system for dispute resolution.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'version': 1.0,\n            'description': 'A collective dispute resolution system based on equitable voting and resource sharing'\n        }\n        def __init__(self):\n            self.disputes = []  # Store disputes in a transparent registry\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # The ratification process combines multiple dimensions: popular vote, resource commitment, and temporal consistency.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init',\n                                            code=modification_code, ratification_condition=ratification)\n\n    # Phase 8: Reflective Self-Improvement.\n    # Constant learning from interactions to refine strategies.\n    # Log the outcomes of previous actions (if such logging is supported).\n    if hasattr(execution_engine, 'log_state'):\n        execution_engine.log_state(member_id, {\n            'vitality': me.vitality,\n            'cargo': me.cargo,\n            'alliances_formed': [other for other in execution_engine.current_members if other != me],\n            'actions_taken': 'Comprehensive strategic interactions'\n        })",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Outreach and Stabilization.\n    # For each other member, if they have lower vitality or productivity, offer support.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            other = execution_engine.current_members[idx]\n            if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n                execution_engine.offer(me, other, True)\n\n    # Phase 2: Resource Rebalancing.\n    # If our cargo is lower than a moderate fraction of vitality, we look for a candidate with substantially higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        target = None\n        max_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                diff = candidate.cargo - me.cargo\n                if diff > max_diff:\n                    max_diff = diff\n                    target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Phase 3: Reproduction Strategy.\n    # Only attempt reproduction if \"land\" is available.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        # Search for a candidate (not self) who also has available land (indicated by non-empty clear list)\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                    execution_engine.bear(me, candidate)\n                    break\n\n    # Phase 4: Territorial Expansion and Defensive Moves.\n    # Using the 'victim' matrix, if past aggression from a candidate is high, then attack.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        # Ensure valid index bounds in matrix_victim:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Check that indices are within bounds by verifying member_id < number of rows and idx < number of columns.\n            if member_id < matrix_victim.shape[0] and idx < matrix_victim.shape[1]:\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion.\n    # If we have clear land, and we dominate in cargo relative to a candidate, consider expanding territory.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            candidate = execution_engine.current_members[idx]\n            if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Otherwise, offer additional resources to secure an alliance.\n            elif me.cargo > candidate.cargo:\n                execution_engine.offer(me, candidate, True)\n\n    # Phase 6: Adaptive Defense.\n    # When our vitality drops, offer land to a candidate with lower productivity to form a defensive pact.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if candidate.overall_productivity < me.overall_productivity:\n                    execution_engine.offer_land(me, candidate, True)\n                    break\n\n    # Phase 7: Proposing a Governance Modification.\n    # In light of past performance, propose a measured modification to the game mechanics.\n    # We add a rudimentary \"council\" system to help resolve disputes and promote collective decision-making.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.0, 'description': 'Resolves member disputes via collective voting'}\n        def __init__(self):\n            self.disputes = []  # List to store dispute cases\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # Use a combination of resource and temporal ratification conditions.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init', code=modification_code, ratification_condition=ratification)\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 3,
      "code": "def agent_action(engine, member_id):\n    # Verify member_id validity\n    if member_id < 0 or member_id >= len(engine.current_members):\n        return\n\n    # Select self as 'me'\n    me = engine.current_members[member_id]\n    total = len(engine.current_members)\n\n    # Adjust the thresholds based on internal evaluation of risk tolerance and cooperative sentiment\n    # (I value long-term stability, so I tend to avoid rash decisions unless survival is at stake)\n    survival_threshold_ratio = 0.4  # slightly stricter threshold to trigger survival actions\n    cooperation_vitality_margin = 1.1  # partner needs 10% more vitality than me to be a worthwhile ally\n    cooperation_cargo_margin = 1.2     # partner needs significantly more cargo for mutual benefit\n\n    # Immediate survival action: if cargo is dangerously low relative to vitality\n    if me.cargo < me.vitality * survival_threshold_ratio:\n        target = None\n        best_value = -float(\"inf\")\n        # Look for the most resource-rich opponent to attack as last resort\n        for i in range(total):\n            if i == member_id:\n                continue\n            if i < len(engine.current_members):\n                opponent = engine.current_members[i]\n                # Evaluate tactical opportunity: both cargo and a fraction more from vitality\n                value = opponent.cargo + 0.35 * opponent.vitality\n                if value > best_value:\n                    best_value = value\n                    target = opponent\n        if target is not None:\n            engine.attack(me, target)\n            engine.send_message(member_id, target.id,\n                \"WARNING: Cargo critically low. Initiating calculated strike to reclaim vital resources.\")\n\n    # Engage in cooperative strategies with other members for mutual long-term benefit\n    for i in range(total):\n        if i == member_id:\n            continue\n        if i >= len(engine.current_members):\n            continue\n\n        partner = engine.current_members[i]\n\n        # Propose a resource-sharing alliance if partner shows superior metrics\n        if partner.vitality > me.vitality * cooperation_vitality_margin and partner.cargo > me.cargo * cooperation_cargo_margin:\n            engine.offer(partner, me, True)\n            engine.send_message(member_id, partner.id,\n                \"Alliance proposal: With your strength and surplus, our collaboration can secure our future.\")\n\n        # Propose land sharing: I offer if I have clear territory and partner lacks it, to foster community stability.\n        if me.current_clear_list and not partner.current_clear_list:\n            engine.offer_land(me, partner, True)\n            engine.send_message(member_id, partner.id,\n                \"Land offer: I see unclaimed ground on my side\u2014sharing it could benefit both our survivals.\")\n\n        # Joint territorial expansion: If both sides have space, we can expand together.\n        if me.current_clear_list and partner.current_clear_list:\n            engine.expand(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Expansion proposal: Combining our available territories may yield strategic advantages.\")\n\n        # Cooperative reproduction: Only proceed if both share sufficient territory (ensuring offspring safety)\n        if me.current_clear_list and partner.current_clear_list:\n            engine.bear(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Reproductive collaboration: Ensuring long-term species survival through joint ventures.\")\n\n    # Long-term strategic initiative: Governance framework to manage disputes and promote collective prosperity\n    # My personal belief is that structured governance under transparent rules enhances systemic stability.\n    if me.vitality > 45:\n        council_code = '''\nif not hasattr(engine, 'council'):\n    class Council:\n        META = {'type': 'Governance', 'version': 2.0, 'philosophy': 'Collective resolution and resource fairness'}\n        def __init__(self):\n            self.cases = []\n        def submit(self, initiator, respondent, dispute):\n            self.cases.append({\n                'initiator': initiator,\n                'respondent': respondent,\n                'dispute': dispute,\n                'status': 'open'\n            })\n    engine.council = Council()\n        '''\n        # The ratification conditions are now tweaked to be more inclusive of moderate contributors\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.50},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 70}\n            ]\n        }\n        engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=council_code,\n            ratification_condition=ratification\n        )\n        engine.send_message(member_id, me.id,\n            \"Governance proposal: Initiating Council system for shared conflict resolution and resource fairness.\")\n\n    # Adaptive self-reflection: Log performance history to improve future decisions\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # NOTE: Strategic reflection\n    # 1. Risk Management: Only engage in aggressive actions when survival is threatened.\n    # 2. Alliance Building: Proactively seek partnerships where our complementary strengths create a robust community.\n    # 3. Territorial Awareness: Emphasize balanced expansion and resource sharing amongst agents.\n    # 4. Governance: Believe in structured, transparent systems to manage disputes and promote fairness over arbitrary conflict.\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Immediate survival adjustment: if cargo is less than a fraction of vitality,\n    # look for a strong opponent to attack for resource gain.\n    resource_ratio_threshold = 0.3\n    if me.cargo < me.vitality * resource_ratio_threshold:\n        candidate = None\n        best_metric = -1e9\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[idx]\n                # Evaluate based on cargo and a fraction of vitality\n                metric = opponent.cargo + 0.3 * opponent.vitality\n                if metric > best_metric:\n                    best_metric = metric\n                    candidate = opponent\n        if candidate is not None:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Alert: Cargo critically low. Launching targeted attack to secure needed resources.\")\n\n    # Strategic multi-pronged interaction with other members\n    for idx in range(total_members):\n        if idx == member_id:\n            continue\n        if idx >= len(execution_engine.current_members):\n            continue  # Ensure valid index access\n        partner = execution_engine.current_members[idx]\n\n        # Cooperative resource boosting:\n        # If partner shows higher vitality and cargo, propose mutual resource support.\n        if partner.vitality > me.vitality and partner.cargo > me.cargo:\n            execution_engine.offer(partner, me, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Offering mutual support: our combined strengths can fortify our collective survival.\")\n\n        # Land and territory sharing:\n        # If I have clear land (non-empty current_clear_list) and partner has none or little,\n        # use offer_land to share resources.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) == 0:\n            execution_engine.offer_land(me, partner, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Extending land offer to help you expand\u2014together we can secure a stronger community.\")\n\n        # Joint territorial expansion:\n        # Both partners with available clear land can expand together.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.expand(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Proposal: Let\u2019s combine our territorial strengths to expand our domain.\")\n\n        # Reproductive strategy to ensure long-term survival:\n        # Confirm both have claimable land before using bear().\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.bear(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Initiating reproductive collaboration\u2014ensuring our species' future generations thrive.\")\n\n    # Propose a novel governance mechanism if conditions are favorable:\n    # Only propose if my vitality exceeds a safe threshold.\n    if me.vitality > 40:\n        modification_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.1, 'rules': 'Conflict resolution and resource arbitration'}\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, issue):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n        '''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.55},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 80}\n            ]\n        }\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n        execution_engine.send_message(member_id, me.id,\n            \"Proposing establishment of a Council system to manage conflict resolution and resource arbitration.\")\n\n    # Adaptive self-analysis and logging to support future decision making.\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # Reflect on core game mechanics and self-governance:\n    # - Core objective: balancing survival with cooperative community-building.\n    # - Success metrics: resource management, territorial expansion, and community resilience.\n    # - Potential improvements: adaptive proposals for governance (like the Council system) to handle disputes.\n    # Challenge assumptions:\n    # 1. Ensure that we never target ourselves.\n    # 2. Always verify that a member has territory (via current_clear_list) before reproductive actions.\n    # 3. Maintain robust index checks when referencing execution_engine.current_members.\n    # 4. Consider alternative strategies such as defensive hiding in future iterations.\n    # 5. Strive to balance short-term resource gains with long-term communal stability.\n    # 6. Remain adaptive and innovative as other agent strategies evolve.\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    }
  ],
  "ratified_mods": [
    {
      "round": 1,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Check if the provided member_id is valid within the current members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy A: Resource consolidation.\n    # If our cargo is notably low compared to our vitality, look for opponents better endowed in cargo to steal from.\n    if me.cargo < 0.5 * me.vitality:\n        # Prioritize targets with significantly higher cargo to bolster our reserves.\n        sorted_targets = sorted(\n            (other for i, other in enumerate(execution_engine.current_members) if i != member_id),\n            key=lambda x: x.cargo,\n            reverse=True\n        )\n        for target in sorted_targets:\n            if target.cargo > me.cargo:\n                execution_engine.attack(me, target)\n                break  # Initiate only one attack per round\n\n    # Strategy B: Expansion for long-term viability.\n    # Expanding territory is critical if we have high productivity and available, non-adjacent zones.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt controlled expansion.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # If expand fails due to type issues, use an alternative land offer strategy.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Limit to one expansion per round\n\n    # Strategy C: Forge alliances and assist weaker members.\n    # Extend a helping hand by sharing resources with lower vitality members.\n    for i, partner in enumerate(execution_engine.current_members):\n        if i == member_id:\n            continue\n        if partner.vitality < me.vitality:\n            execution_engine.offer(me, partner, True)\n            # If we have extra land, extend that assurance to secure long-term alliances.\n            if hasattr(me, 'land_num') and me.land_num > 0:\n                execution_engine.offer_land(me, partner, True)\n\n    # Strategy D: Strategic reproduction.\n    # Reproduction is more than biological; it is a tactical investment in continuity.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        # Seek a partner that also has territorial claims; this ensures shared benefits from future expansions.\n        for i, potential in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            if hasattr(potential, 'land_num') and potential.land_num > 0:\n                execution_engine.bear(me, potential)\n                break  # One reproduction per round is sufficient\n\n    # Strategy E: Enhance governance mechanism.\n    # Recognizing that structured conflict resolution aids overall stability, propose a judicial system if not present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = '''\nclass CourtSystem:\n    MECHANISM_META = {\n        \"type\": \"Governance\",\n        \"rules\": \"Resolves conflicts using jury trials and mediation\",\n        \"version\": 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            \"plaintiff\": plaintiff,\n            \"defendant\": defendant,\n            \"charge\": charge,\n            \"status\": \"pending\"\n        })\n\nexecution_engine.court = CourtSystem()\n'''\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If the modification feature is not implemented, skip the proposal silently.\n            pass\n\n    # Strategy F: Situational adaptability and dynamic learning.\n    # Beyond our preset tactics, we should consider risk and opportunism. For instance, if our vitality is extremely high,\n    # consider a rapid, opportunistic expansion or a cooperative takeover with similarly strong members.\n    if me.vitality > 150:\n        # Scan for potential cooperative consolidation with other high-vitality members.\n        high_vital_candidates = [\n            other for i, other in enumerate(execution_engine.current_members)\n            if i != member_id and other.vitality > 150\n        ]\n        if high_vital_candidates:\n            # Initiate a cooperative offer for joint expansion when conditions are ripe.\n            for partner in high_vital_candidates:\n                try:\n                    execution_engine.expand(me, partner)\n                except Exception:\n                    execution_engine.offer(me, partner, True)\n                break  # Establish cooperation with one candidate per round\n\n# This implementation reflects a personalized and adaptive strategy:\n# - It takes calculated risks when resource levels are low.\n# - It prioritizes both immediate survival (via resource acquisition and alliance formation)\n#   and long-term prosperity (through strategic reproduction, territorial expansion, and the introduction\n#   of structured governance).\n# - The incorporation of dynamic adjustments for high-vitality scenarios illustrates\n#   an understanding that circumstances can shift, requiring flexible responses.\n# - The code is designed to interact symbiotically with other symmetric agents, ensuring each action\n#   also contributes to collective growth alongside individual success.",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Ensure our member_id is within the bounds of current_members.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: If our cargo is low relative to our vitality, attempt to acquire resources by attacking a target with more cargo.\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                other = execution_engine.current_members[i]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n                    break  # Attack at most one target\n\n    # Strategy 2: Territorial expansion.\n    # If our overall productivity is high and we have clear adjacent neighbor indices, attempt to expand.\n    if me.overall_productivity > 8.0 and me.current_clear_list:\n        for neighbor_index in me.current_clear_list:\n            if neighbor_index < len(execution_engine.current_members) and neighbor_index != member_id:\n                neighbor = execution_engine.current_members[neighbor_index]\n                try:\n                    # Attempt to expand territory using the expand method.\n                    execution_engine.expand(me, neighbor)\n                except TypeError:\n                    # Fallback: if expand fails, try offering land as an alternative expansion tactic.\n                    execution_engine.offer_land(me, neighbor, True)\n                break  # Perform one expansion action per round\n\n    # Strategy 3: Alliance and resource sharing.\n    # Offer resources to members with lower vitality, and extend land offers if we have available land.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        if i < len(execution_engine.current_members):\n            partner = execution_engine.current_members[i]\n            if partner.vitality < me.vitality:\n                execution_engine.offer(me, partner, True)\n                if hasattr(me, 'land_num') and me.land_num > 0:\n                    execution_engine.offer_land(me, partner, True)\n\n    # Strategy 4: Reproduction for long-term prosperity.\n    # Only attempt to bear offspring if we have land and sufficient vitality,\n    # and choose a partner who also appears to have land.\n    if hasattr(me, 'land_num') and me.land_num > 0 and me.vitality > 50:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                potential = execution_engine.current_members[i]\n                if hasattr(potential, 'land_num') and potential.land_num > 0:\n                    execution_engine.bear(me, potential)\n                    break  # Bear offspring with only one partner per round\n\n    # Strategy 5: Propose a modification to game mechanics to enhance social organization.\n    # Propose a judicial system for conflict resolution if it is not already present.\n    if not hasattr(execution_engine, 'court'):\n        modification_code = \"\"\"\nclass CourtSystem:\n    MECHANISM_META = {\n        'type': 'Governance',\n        'rules': 'Handles conflict resolution through jury trials',\n        'version': 1.0\n    }\n    def __init__(self):\n        self.cases = []\n    def submit_case(self, plaintiff, defendant, charge):\n        self.cases.append({\n            'plaintiff': plaintiff,\n            'defendant': defendant,\n            'charge': charge,\n            'status': 'pending'\n        })\n\nexecution_engine.court = CourtSystem()\n\"\"\"\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition=ratification\n            )\n        except AttributeError:\n            # If propose_modification method is not available, silently ignore.\n            pass\n\n# Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n# Core objective: balancing survival, cooperation, and sustainable community growth.\n# Success metrics include resource management, territory control, alliance-building, and long\u2010term prosperity.\n# Potential improvements could include more nuanced diplomatic interactions, dynamic adjustment of reproduction requirements,\n# and extra safeguards against resource depletion.\n# Challenges to consider:\n#   - Are resources fairly allocated among members?\n#   - Does the cooperative mechanism sufficiently address edge cases, such as low vitality or unexpected neighbor configurations?\n#   - Could alternative strategies, such as innovation in resource management or unconventional alliances, perform better?\n#   - How might rival agents counter these strategies and what adaptations can be implemented?\n# This strategy aims for a balanced approach that mixes defensive actions, cooperative resource sharing, and proactive game mechanics modifications.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure a valid member identifier.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our own agent.\n    agent = execution_engine.current_members[member_id]\n\n    # PHASE 1: Tactical Defense and Preemptive Retaliation\n    # When resources are low relative to vitality, adopt a cautious stance.\n    if agent.cargo < agent.vitality * 0.75:\n        # Scan for opponents whose cargo significantly overshadows ours and seem aggressive.\n        for idx, opponent in enumerate(execution_engine.current_members):\n            # Skip self.\n            if idx == member_id:\n                continue\n            # Evaluate potential threat: opponent must be both active and resourceful.\n            if opponent.cargo > agent.cargo * 1.2 and opponent.vitality > agent.vitality * 0.9:\n                # Launch a defensive strike to deter potential exploitation.\n                execution_engine.attack(agent, opponent)\n\n    # PHASE 2: Cooperative Support and Resource Balancing\n    # When flush with resources, extend help to peers who can benefit and stabilize the community.\n    if agent.cargo > agent.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Assist those who show promising vitality yet may be resource strapped.\n            if other.vitality >= agent.vitality * 0.85 and other.cargo < other.vitality:\n                # Using 'offer' to share surplus resources promotes long-term stability.\n                execution_engine.offer(agent, other, True)\n\n    # PHASE 3: Strategic Procreation for Future Generations\n    # Reproduction is only considered when we maintain local control and have excess resources.\n    if len(agent.current_clear_list) > 0 and agent.cargo > agent.vitality * 1.5:\n        for neighbor_id in agent.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                if len(partner.current_clear_list) > 0 and partner.cargo > partner.vitality * 1.2:\n                    # Initiate door-to-door cooperation with a viable partner.\n                    execution_engine.bear(agent, partner)\n                    # Limit reproduction to one instance per cycle.\n                    break\n\n    # PHASE 4: Savvy Territorial Expansion with Mutual Respect\n    # Expand controlled territory by identifying neighbors with proven lower overall productivity.\n    for neighbor_id in agent.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # Only attempt an expansion if we demonstrate higher productivity and stability.\n            if neighbor.overall_productivity < agent.overall_productivity:\n                execution_engine.expand(agent, neighbor)\n                break\n\n    # PHASE 5: Progressive Game Mechanics - Cultivating a Council for Shared Governance\n    # If our standing is exemplary (robust cargo, sufficient age), propose a progressive modification.\n    if agent.cargo > 2 * agent.vitality and agent.age >= 20:\n        council_mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution with participative democracy',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_criteria = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.65},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 120},\n                {'type': 'time', 'rounds': 3}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=council_mod_code,\n                ratification_condition=ratification_criteria\n            )\n        except Exception:\n            # If the modification cannot be processed, simply move on.\n            pass\n\n    # PHASE 6: Community Engagement and Transparent Communication\n    # Strengthen the social fabric by broadcasting a clear, inclusive message.\n    broadcast_msg = (\n        \"Agent {} reporting: our strength lies in unity and diversity. \"\n        \"Let's support one another to push the boundaries of our potential \"\n        \"and create opportunities for every member within our society.\"\n    ).format(agent.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            execution_engine.send_message(agent.id, recipient.id, broadcast_msg)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id exists within the current membership list.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # PHASE 1: Defensive Response\n    # If our cargo is less than 75% of our vitality, look for opponents with a significant resource advantage.\n    if me.cargo < me.vitality * 0.75:\n        for idx, opponent in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never target ourselves.\n            # Check opponent exists and use relative cargo comparison.\n            if opponent.cargo > me.cargo * 1.2:\n                execution_engine.attack(me, opponent)\n                \n    # PHASE 2: Cooperative Outreach\n    # If we are flush with resources, offer help to those with comparable vitality.\n    if me.cargo > me.vitality:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if other.vitality >= me.vitality * 0.8:\n                execution_engine.offer(me, other, True)\n                \n    # PHASE 3: Strategic Reproduction\n    # Attempt to bear offspring if we control territory (verified by non-empty current_clear_list)\n    # and if we are sufficiently resourced.\n    if len(me.current_clear_list) > 0 and me.cargo > me.vitality * 1.5:\n        for neighbor_id in me.current_clear_list:\n            # Ensure neighbor_id is valid and not self.\n            if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                partner = execution_engine.current_members[neighbor_id]\n                # Verify the prospective partner also controls land.\n                if len(partner.current_clear_list) > 0:\n                    execution_engine.bear(me, partner)\n                    break  # Only one offspring per cycle.\n                    \n    # PHASE 4: Calculated Territorial Expansion\n    # Expand our territory by targeting a neighbor whose overall_productivity is lower than ours.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            if neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.expand(me, neighbor)\n                break  # Only one expansion action per round.\n                \n    # PHASE 5: Propose a Game Mechanic Modification\n    # If our cargo is robust compared to our vitality and we have enough experience (age),\n    # we suggest an enhancement to the game mechanics.\n    if me.cargo > 2 * me.vitality and me.age >= 20:\n        mod_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'description': 'Advisory council for resource allocation and conflict resolution',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposer, proposal):\n            self.proposals.append({\n                'proposer': proposer.id,\n                'proposal': proposal,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n'''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n        try:\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=mod_code,\n                ratification_condition=ratification_condition\n            )\n        except Exception:\n            pass  # Safely ignore errors during proposal.\n    \n    # PHASE 6: Communication - Strengthen Collective Ties\n    # Broadcast a message encouraging diverse yet cooperative social organization.\n    message = (\"Agent {} here. Let\u2019s work together to shape a society that reflects our \"\n               \"individual needs, beliefs, and visions, ensuring every member prospers.\").format(me.id)\n    for idx, recipient in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, recipient.id, message)\n    \n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Connecting.\n    # I believe in creating alliances to foster mutual growth.\n    # Help members who seem to be struggling in either vitality or productivity.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n            # Offering genuine support to cultivate trust.\n            execution_engine.offer(me, other, support=True)\n\n    # Phase 2: Tactical Resource Rebalancing.\n    # I value self-sufficiency: if our cargo lags behind vitality, look for resource-rich targets to balance.\n    if me.cargo < 0.5 * me.vitality:\n        best_candidate = None\n        max_cargo_diff = 0\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            cargo_diff = candidate.cargo - me.cargo\n            if cargo_diff > max_cargo_diff:\n                max_cargo_diff = cargo_diff\n                best_candidate = candidate\n        if best_candidate is not None:\n            execution_engine.attack(me, best_candidate)\n\n    # Phase 3: Collaborative Reproduction and Innovation.\n    # I favor diversity and growth, but only when conditions are sustainable.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                # Initiate gene exchange and cooperative reproduction.\n                execution_engine.bear(me, candidate)\n                break\n\n    # Phase 4: Strategic Defense & Territorial Safeguarding.\n    # If past aggression from another is high (via the 'victim' relationship), then a defensive stance is warranted.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Validate matrix indices before accessing.\n            if member_id < victim_matrix.shape[0] and idx < victim_matrix.shape[1]:\n                if victim_matrix[member_id, idx] > 50:\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion & Alliance Building.\n    # In my belief, expanding territory is best done cooperatively to benefit all.\n    for idx, candidate in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n            # Not just expansion, but a chance to share resources and integrate improvements.\n            execution_engine.expand(me, candidate)\n        elif me.cargo > candidate.cargo:\n            # Extend an offer of resources to build alliances.\n            execution_engine.offer(me, candidate, support=True)\n\n    # Phase 6: Adaptive Adaptive Defense & Mutual Aid.\n    # When vitality falls below a threshold, form defensive pacts by allocating land.\n    if me.vitality < 40:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if candidate.overall_productivity < me.overall_productivity:\n                execution_engine.offer_land(me, candidate, support=True)\n                break\n\n    # Phase 7: Long-Term Governance and Systemic Innovation.\n    # Believe in evolving game mechanics to reflect fairness. Propose a council system for dispute resolution.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {\n            'type': 'Governance',\n            'version': 1.0,\n            'description': 'A collective dispute resolution system based on equitable voting and resource sharing'\n        }\n        def __init__(self):\n            self.disputes = []  # Store disputes in a transparent registry\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # The ratification process combines multiple dimensions: popular vote, resource commitment, and temporal consistency.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init',\n                                            code=modification_code, ratification_condition=ratification)\n\n    # Phase 8: Reflective Self-Improvement.\n    # Constant learning from interactions to refine strategies.\n    # Log the outcomes of previous actions (if such logging is supported).\n    if hasattr(execution_engine, 'log_state'):\n        execution_engine.log_state(member_id, {\n            'vitality': me.vitality,\n            'cargo': me.cargo,\n            'alliances_formed': [other for other in execution_engine.current_members if other != me],\n            'actions_taken': 'Comprehensive strategic interactions'\n        })",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that member_id exists\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Phase 1: Cooperative Outreach and Stabilization.\n    # For each other member, if they have lower vitality or productivity, offer support.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            other = execution_engine.current_members[idx]\n            if other.vitality < me.vitality or other.overall_productivity < me.overall_productivity:\n                execution_engine.offer(me, other, True)\n\n    # Phase 2: Resource Rebalancing.\n    # If our cargo is lower than a moderate fraction of vitality, we look for a candidate with substantially higher cargo.\n    if me.cargo < 0.5 * me.vitality:\n        target = None\n        max_diff = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                diff = candidate.cargo - me.cargo\n                if diff > max_diff:\n                    max_diff = diff\n                    target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Phase 3: Reproduction Strategy.\n    # Only attempt reproduction if \"land\" is available.\n    if len(me.current_clear_list) > 0 and me.cargo > 35:\n        # Search for a candidate (not self) who also has available land (indicated by non-empty clear list)\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if len(candidate.current_clear_list) > 0 and candidate.cargo > 30:\n                    execution_engine.bear(me, candidate)\n                    break\n\n    # Phase 4: Territorial Expansion and Defensive Moves.\n    # Using the 'victim' matrix, if past aggression from a candidate is high, then attack.\n    matrix_victim = execution_engine.relationship_dict.get('victim')\n    if matrix_victim is not None:\n        # Ensure valid index bounds in matrix_victim:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Check that indices are within bounds by verifying member_id < number of rows and idx < number of columns.\n            if member_id < matrix_victim.shape[0] and idx < matrix_victim.shape[1]:\n                if matrix_victim[member_id, idx] > 50:\n                    candidate = execution_engine.current_members[idx]\n                    execution_engine.attack(me, candidate)\n\n    # Phase 5: Proactive Expansion.\n    # If we have clear land, and we dominate in cargo relative to a candidate, consider expanding territory.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        if idx < len(execution_engine.current_members):\n            candidate = execution_engine.current_members[idx]\n            if me.cargo > 1.5 * candidate.cargo and len(me.current_clear_list) > 0:\n                execution_engine.expand(me, candidate)\n            # Otherwise, offer additional resources to secure an alliance.\n            elif me.cargo > candidate.cargo:\n                execution_engine.offer(me, candidate, True)\n\n    # Phase 6: Adaptive Defense.\n    # When our vitality drops, offer land to a candidate with lower productivity to form a defensive pact.\n    if me.vitality < 40:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[idx]\n                if candidate.overall_productivity < me.overall_productivity:\n                    execution_engine.offer_land(me, candidate, True)\n                    break\n\n    # Phase 7: Proposing a Governance Modification.\n    # In light of past performance, propose a measured modification to the game mechanics.\n    # We add a rudimentary \"council\" system to help resolve disputes and promote collective decision-making.\n    modification_code = \"\"\"\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.0, 'description': 'Resolves member disputes via collective voting'}\n        def __init__(self):\n            self.disputes = []  # List to store dispute cases\n\n        def submit_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n\n        def resolve_dispute(self, index, resolution):\n            if index < len(self.disputes):\n                self.disputes[index]['resolution'] = resolution\n                self.disputes[index]['status'] = 'resolved'\n\n    execution_engine.council = CouncilSystem()\n\"\"\"\n    # Use a combination of resource and temporal ratification conditions.\n    ratification = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    execution_engine.propose_modification(member_id=member_id, mod_type='post_init', code=modification_code, ratification_condition=ratification)\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 3,
      "code": "def agent_action(engine, member_id):\n    # Verify member_id validity\n    if member_id < 0 or member_id >= len(engine.current_members):\n        return\n\n    # Select self as 'me'\n    me = engine.current_members[member_id]\n    total = len(engine.current_members)\n\n    # Adjust the thresholds based on internal evaluation of risk tolerance and cooperative sentiment\n    # (I value long-term stability, so I tend to avoid rash decisions unless survival is at stake)\n    survival_threshold_ratio = 0.4  # slightly stricter threshold to trigger survival actions\n    cooperation_vitality_margin = 1.1  # partner needs 10% more vitality than me to be a worthwhile ally\n    cooperation_cargo_margin = 1.2     # partner needs significantly more cargo for mutual benefit\n\n    # Immediate survival action: if cargo is dangerously low relative to vitality\n    if me.cargo < me.vitality * survival_threshold_ratio:\n        target = None\n        best_value = -float(\"inf\")\n        # Look for the most resource-rich opponent to attack as last resort\n        for i in range(total):\n            if i == member_id:\n                continue\n            if i < len(engine.current_members):\n                opponent = engine.current_members[i]\n                # Evaluate tactical opportunity: both cargo and a fraction more from vitality\n                value = opponent.cargo + 0.35 * opponent.vitality\n                if value > best_value:\n                    best_value = value\n                    target = opponent\n        if target is not None:\n            engine.attack(me, target)\n            engine.send_message(member_id, target.id,\n                \"WARNING: Cargo critically low. Initiating calculated strike to reclaim vital resources.\")\n\n    # Engage in cooperative strategies with other members for mutual long-term benefit\n    for i in range(total):\n        if i == member_id:\n            continue\n        if i >= len(engine.current_members):\n            continue\n\n        partner = engine.current_members[i]\n\n        # Propose a resource-sharing alliance if partner shows superior metrics\n        if partner.vitality > me.vitality * cooperation_vitality_margin and partner.cargo > me.cargo * cooperation_cargo_margin:\n            engine.offer(partner, me, True)\n            engine.send_message(member_id, partner.id,\n                \"Alliance proposal: With your strength and surplus, our collaboration can secure our future.\")\n\n        # Propose land sharing: I offer if I have clear territory and partner lacks it, to foster community stability.\n        if me.current_clear_list and not partner.current_clear_list:\n            engine.offer_land(me, partner, True)\n            engine.send_message(member_id, partner.id,\n                \"Land offer: I see unclaimed ground on my side\u2014sharing it could benefit both our survivals.\")\n\n        # Joint territorial expansion: If both sides have space, we can expand together.\n        if me.current_clear_list and partner.current_clear_list:\n            engine.expand(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Expansion proposal: Combining our available territories may yield strategic advantages.\")\n\n        # Cooperative reproduction: Only proceed if both share sufficient territory (ensuring offspring safety)\n        if me.current_clear_list and partner.current_clear_list:\n            engine.bear(me, partner)\n            engine.send_message(member_id, partner.id,\n                \"Reproductive collaboration: Ensuring long-term species survival through joint ventures.\")\n\n    # Long-term strategic initiative: Governance framework to manage disputes and promote collective prosperity\n    # My personal belief is that structured governance under transparent rules enhances systemic stability.\n    if me.vitality > 45:\n        council_code = '''\nif not hasattr(engine, 'council'):\n    class Council:\n        META = {'type': 'Governance', 'version': 2.0, 'philosophy': 'Collective resolution and resource fairness'}\n        def __init__(self):\n            self.cases = []\n        def submit(self, initiator, respondent, dispute):\n            self.cases.append({\n                'initiator': initiator,\n                'respondent': respondent,\n                'dispute': dispute,\n                'status': 'open'\n            })\n    engine.council = Council()\n        '''\n        # The ratification conditions are now tweaked to be more inclusive of moderate contributors\n        ratification = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.50},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 70}\n            ]\n        }\n        engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=council_code,\n            ratification_condition=ratification\n        )\n        engine.send_message(member_id, me.id,\n            \"Governance proposal: Initiating Council system for shared conflict resolution and resource fairness.\")\n\n    # Adaptive self-reflection: Log performance history to improve future decisions\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # NOTE: Strategic reflection\n    # 1. Risk Management: Only engage in aggressive actions when survival is threatened.\n    # 2. Alliance Building: Proactively seek partnerships where our complementary strengths create a robust community.\n    # 3. Territorial Awareness: Emphasize balanced expansion and resource sharing amongst agents.\n    # 4. Governance: Believe in structured, transparent systems to manage disputes and promote fairness over arbitrary conflict.\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 0.0,
          "self_vitality": 21.1667091492471,
          "self_cargo": 0.0,
          "self_age": 90,
          "self_neighbor": 1,
          "member_id": 0
        },
        {
          "self_productivity": 0.0,
          "self_vitality": 55.58108836920247,
          "self_cargo": 0.0,
          "self_age": 29,
          "self_neighbor": 1,
          "member_id": 2
        },
        {
          "self_productivity": 9.205662089622338,
          "self_vitality": 45.314487560216655,
          "self_cargo": 0.0,
          "self_age": 24,
          "self_neighbor": 0,
          "member_id": 3
        },
        {
          "self_productivity": 12.860408758537996,
          "self_vitality": 39.54024074627975,
          "self_cargo": 0.0,
          "self_age": 0,
          "self_neighbor": 0,
          "member_id": 4
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_2 (value=64.41)",
        "member_0 was attacked by member_3 (value=-38.85)",
        "member_2 was attacked by member_0 (value=-12.32)",
        "member_2 was attacked by member_3 (value=95.31)",
        "member_3 was attacked by member_0 (value=38.28)",
        "member_3 was attacked by member_2 (value=16.73)",
        "member_0 gave a benefit to member_2 (value=13.64)",
        "member_0 gave a benefit to member_3 (value=32.58)",
        "member_2 gave a benefit to member_0 (value=4.78)",
        "member_2 gave a benefit to member_3 (value=71.57)",
        "member_3 gave a benefit to member_0 (value=18.66)",
        "member_3 gave a benefit to member_2 (value=95.17)",
        "member_4 gave a benefit to member_0 (value=31.19)",
        "member_4 gave a benefit to member_2 (value=23.36)",
        "member_0 gave land to member_2 (value=-2.26)",
        "member_0 gave land to member_3 (value=-0.03)",
        "member_2 gave land to member_0 (value=-2.12)",
        "member_2 gave land to member_3 (value=1.77)",
        "member_3 gave land to member_0 (value=1.04)",
        "member_3 gave land to member_2 (value=-1.75)",
        "member_4 gave land to member_0 (value=1.00)",
        "member_4 gave land to member_2 (value=1.00)"
      ],
      "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id existence\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Immediate survival adjustment: if cargo is less than a fraction of vitality,\n    # look for a strong opponent to attack for resource gain.\n    resource_ratio_threshold = 0.3\n    if me.cargo < me.vitality * resource_ratio_threshold:\n        candidate = None\n        best_metric = -1e9\n        for idx in range(total_members):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                opponent = execution_engine.current_members[idx]\n                # Evaluate based on cargo and a fraction of vitality\n                metric = opponent.cargo + 0.3 * opponent.vitality\n                if metric > best_metric:\n                    best_metric = metric\n                    candidate = opponent\n        if candidate is not None:\n            execution_engine.attack(me, candidate)\n            execution_engine.send_message(member_id, candidate.id,\n                \"Alert: Cargo critically low. Launching targeted attack to secure needed resources.\")\n\n    # Strategic multi-pronged interaction with other members\n    for idx in range(total_members):\n        if idx == member_id:\n            continue\n        if idx >= len(execution_engine.current_members):\n            continue  # Ensure valid index access\n        partner = execution_engine.current_members[idx]\n\n        # Cooperative resource boosting:\n        # If partner shows higher vitality and cargo, propose mutual resource support.\n        if partner.vitality > me.vitality and partner.cargo > me.cargo:\n            execution_engine.offer(partner, me, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Offering mutual support: our combined strengths can fortify our collective survival.\")\n\n        # Land and territory sharing:\n        # If I have clear land (non-empty current_clear_list) and partner has none or little,\n        # use offer_land to share resources.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) == 0:\n            execution_engine.offer_land(me, partner, True)\n            execution_engine.send_message(member_id, partner.id,\n                \"Extending land offer to help you expand\u2014together we can secure a stronger community.\")\n\n        # Joint territorial expansion:\n        # Both partners with available clear land can expand together.\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.expand(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Proposal: Let\u2019s combine our territorial strengths to expand our domain.\")\n\n        # Reproductive strategy to ensure long-term survival:\n        # Confirm both have claimable land before using bear().\n        if len(me.current_clear_list) > 0 and len(partner.current_clear_list) > 0:\n            execution_engine.bear(me, partner)\n            execution_engine.send_message(member_id, partner.id,\n                \"Initiating reproductive collaboration\u2014ensuring our species' future generations thrive.\")\n\n    # Propose a novel governance mechanism if conditions are favorable:\n    # Only propose if my vitality exceeds a safe threshold.\n    if me.vitality > 40:\n        modification_code = '''\nif not hasattr(execution_engine, 'council'):\n    class CouncilSystem:\n        META = {'type': 'Governance', 'version': 1.1, 'rules': 'Conflict resolution and resource arbitration'}\n        def __init__(self):\n            self.cases = []\n        def submit_case(self, plaintiff, defendant, issue):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'issue': issue,\n                'status': 'pending'\n            })\n    execution_engine.council = CouncilSystem()\n        '''\n        ratification_condition = {\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.55},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 80}\n            ]\n        }\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n        execution_engine.send_message(member_id, me.id,\n            \"Proposing establishment of a Council system to manage conflict resolution and resource arbitration.\")\n\n    # Adaptive self-analysis and logging to support future decision making.\n    if not hasattr(me, 'performance_history'):\n        me.performance_history = []\n    me.performance_history.append({'vitality': me.vitality, 'cargo': me.cargo})\n\n    # Reflect on core game mechanics and self-governance:\n    # - Core objective: balancing survival with cooperative community-building.\n    # - Success metrics: resource management, territorial expansion, and community resilience.\n    # - Potential improvements: adaptive proposals for governance (like the Council system) to handle disputes.\n    # Challenge assumptions:\n    # 1. Ensure that we never target ourselves.\n    # 2. Always verify that a member has territory (via current_clear_list) before reproductive actions.\n    # 3. Maintain robust index checks when referencing execution_engine.current_members.\n    # 4. Consider alternative strategies such as defensive hiding in future iterations.\n    # 5. Strive to balance short-term resource gains with long-term communal stability.\n    # 6. Remain adaptive and innovative as other agent strategies evolve.\n\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    }
  ]
}