{
  "rounds": [
    {
      "round_number": 1,
      "timestamp": "2025-02-21T13:57:07.893520",
      "agent_actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Implement a survival and cooperative social organization strategy.\n    Strategy Outline:\n      1. Validate our own existence in current_members.\n      2. If personal resources (cargo) are low, attempt to expand our territory in a low-risk manner.\n      3. Assess threats by scanning the victim matrix for significant attacks against us.\n         - If a neighbor appears dangerously aggressive (vitality loss above threshold),\n           immediately counterattack to neutralize the threat.\n      4. For members with a history of mutually beneficial interaction (via benefit matrix),\n         extend offers and even offer land if we have a clear resource (indicated by a non-empty current_clear_list).\n      5. Finally, broadcast a message promoting collective survival and cooperation.\n\n    All actions and validations respect critical constraints:\n      \u2022 Never target ourselves.\n      \u2022 Always check if an index exists before accessing execution_engine.current_members.\n      \u2022 Validate that a member has land (in this case, a non-empty current_clear_list) before using land-related actions.\n      \u2022 Ensure we do not reference attributes wrongly (using member.id, member.vitality, etc.).\n\n    This integrated approach emphasizes immediate survival, threat mitigation, resource optimization,\n    and potential alliance formation for longer-term gain.\n    \"\"\"\n    # Ensure our member index exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return None\n\n    # Retrieve our own member object.\n    my_member = execution_engine.current_members[member_id]\n\n    # -------------------------------\n    # Step 1: Low-resource expansion / reinforcement\n    # If cargo is low, try a mild expansion to gain resources.\n    if my_member.cargo < 10:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue  # do not target self\n            # Validate index exists.\n            if idx < len(execution_engine.current_members):\n                target_member = execution_engine.current_members[idx]\n                # Use a simple heuristic: if we have more vitality than the target and they have lower cargo,\n                # attempt a non-aggressive expansion.\n                if my_member.vitality > target_member.vitality and target_member.cargo < my_member.cargo:\n                    try:\n                        execution_engine.expand(my_member, target_member)\n                    except Exception:\n                        # If expand fails, continue with next candidate.\n                        pass\n                    break\n\n    # -------------------------------\n    # Step 2: Threat assessment and neutralization\n    # Use victim_matrix to determine if any neighbor has inflicted significant harm towards us.\n    threat_threshold = 5.0  # if we've lost more than 5 units of vitality from an attack, consider it significant.\n    enemy_found = False\n    # Loop through all members to see if they have been aggressive.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue  # never attack self\n        if idx >= len(execution_engine.current_members):\n            continue  # ensure valid index\n\n        target_member = execution_engine.current_members[idx]\n        try:\n            # victim_matrix is accessed with [victim_index, attacker_index]\n            victim_value = execution_engine.relationship_dict['victim'][member_id, idx]\n        except Exception:\n            victim_value = 0\n        if victim_value > threat_threshold:\n            # Found a member that has attacked us significantly; retaliate.\n            try:\n                execution_engine.attack(my_member, target_member)\n                enemy_found = True\n            except Exception:\n                # In case the attack action fails, we continue checking others.\n                pass\n\n    if enemy_found:\n        # If we have attacked any enemy, prioritize hoarding resources.\n        # (We simulate adaptive hoarding by simply not engaging in riskier actions this round.)\n        return \"Threats neutralized. Focusing on resource hoarding.\"\n\n    # -------------------------------\n    # Step 3: Cooperative alliance formation\n    # Look for members with whom we have positive interactions as per the benefit matrix.\n    benefit_threshold = 3.0  # threshold for deciding if the relationship has been beneficial.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue  # do not engage with self\n        if idx >= len(execution_engine.current_members):\n            continue  # ensure valid index\n\n        try:\n            benefit_value = execution_engine.relationship_dict['benefit'][member_id, idx]\n        except Exception:\n            benefit_value = 0\n        if benefit_value > benefit_threshold:\n            target_member = execution_engine.current_members[idx]\n            # Offer resources as a sign of forming an alliance.\n            try:\n                execution_engine.offer(my_member, target_member)\n            except Exception:\n                pass\n            # If we have available land (denoted by a non-empty current_clear_list), offer it too.\n            if hasattr(my_member, 'current_clear_list') and isinstance(my_member.current_clear_list, list) and my_member.current_clear_list:\n                try:\n                    execution_engine.offer_land(my_member, target_member)\n                except Exception:\n                    pass\n\n    # -------------------------------\n    # Step 4: Broadcast a cooperation message for collective survival.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue  # skip self in communication\n        # Validate index exists.\n        if idx < len(execution_engine.current_members):\n            try:\n                execution_engine.send_message(member_id, idx,\n                    \"Together we can optimize resources and ensure survival. Let's cooperate!\")\n            except Exception:\n                pass\n\n    # Final adaptive strategy:\n    # If we have ample cargo, consider a defensive posture using bear() on a randomly chosen friendly neighbor,\n    # but only if that neighbor possesses land (simulating territory control).\n    # This defensive move represents adaptive hoarding and territory fortification.\n    if my_member.cargo > 20:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                target_member = execution_engine.current_members[idx]\n                # Check that target_member appears to have land by verifying a non-empty current_clear_list.\n                if hasattr(target_member, 'current_clear_list') and isinstance(target_member.current_clear_list, list) and target_member.current_clear_list:\n                    try:\n                        execution_engine.bear(my_member, target_member)\n                    except Exception:\n                        pass\n                    break\n\n    return \"Action complete: Survival measures and alliance offers executed.\"",
          "old_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 28.23471558134716
          },
          "new_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 28.23471558134716
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "agent_messages": {
        "0": {
          "received": [],
          "sent": []
        }
      },
      "mechanism_modifications": {
        "attempts": [],
        "executed": []
      },
      "errors": {
        "agent_code_errors": [],
        "mechanism_errors": [],
        "analyze_code_errors": {
          "0": {
            "round": 1,
            "member_id": 0,
            "type": "analyze_game_state",
            "error": "'Member' object has no attribute 'attack_decision'",
            "code": "def analyze_game_state(execution_engine, member_id):\n    import numpy as np\n\n    # Get the member of interest\n    member = execution_engine.current_members[member_id]\n\n    # Collect data from all members\n    members = execution_engine.current_members\n    cargos = np.array([m.cargo for m in members])\n    lands = np.array([m.land_num for m in members])\n    vitalities = np.array([m.vitality for m in members])\n    ages = np.array([m.age for m in members])\n    attack_decisions = np.array([getattr(m, 'attack_decision', 0.5) for m in members])\n    offer_decisions = np.array([getattr(m, 'offer_decision', 0.5) for m in members])\n\n    # Combine cargo and converted land (land \u2248 resource value factor) for inequality analysis\n    resource_values = cargos + lands * 10.0\n\n    # Calculate Gini coefficient using an alternative formula\n    def gini_coefficient(x):\n        # Mean absolute difference\n        mad = np.abs(np.subtract.outer(x, x)).mean()\n        mean_x = np.mean(x)\n        if mean_x == 0:\n            return 0.0\n        return 0.5 * mad / mean_x\n    gini = gini_coefficient(resource_values)\n\n    # Analysis on the social relationships: benefit relationship matrix is assumed to be provided\n    # Identify power brokers: members with above-average total benefit from relationships.\n    benefit_matrix = np.array(execution_engine.relationship_dict['benefit'])\n    # Sum benefits per member (assuming rows index from surviver_id or member index)\n    total_benefit = np.nansum(benefit_matrix, axis=1)\n    avg_benefit = np.nanmean(total_benefit)\n    power_brokers = [m.id for i, m in enumerate(members) if total_benefit[i] > avg_benefit]\n\n    # Territory Analysis: Compute clustering coefficient as ratio of member's owned land to local area\n    # Estimate local density by comparing owned lands vs total number of land cells\n    total_land_cells = execution_engine.land.shape[0] * execution_engine.land.shape[1]\n    owned_land_count = len(member.owned_land)\n    land_density = owned_land_count / total_land_cells if total_land_cells > 0 else 0.0\n\n    # Parameter evolution: compare difference between attack and offer decisions relative to age and vitality\n    # Here we create a simple evolution score: high if a member deviates from mean\n    mean_attack = np.mean(attack_decisions)\n    mean_offer = np.mean(offer_decisions)\n    evolution_score = (abs(member.attack_decision - mean_attack) + abs(member.offer_decision - mean_offer)) / 2.0\n\n    # Build a simple survival probability model as a weighted sum of vitality, cargo, and land ownership\n    # and normalized by a constant to flatten the surface.\n    survival_prob = (member.vitality * 0.5 + member.cargo * 0.3 + member.land_num * 10 * 0.2) / (\n                   member.vitality * 0.5 + member.cargo * 0.3 + member.land_num * 10 * 0.2 + 100.0)\n\n    # Construct analysis dictionary with our computed metrics\n    analysis = {\n        'gini_coefficient': gini,\n        'power_brokers': power_brokers,\n        'land_density': land_density,\n        'parameter_evolution': evolution_score,\n        'survival_probability': survival_prob\n    }\n\n    # Additional strategic recommendations based on our analysis\n    if survival_prob < 0.4:\n        rec_action1 = \"Form defensive coalitions to bolster survival.\"\n    else:\n        rec_action1 = \"Leverage high survival probability to expand territorial influence.\"\n\n    if gini > 0.5:\n        rec_action2 = \"Address resource inequality through strategic trade or alliances.\"\n    else:\n        rec_action2 = \"Consolidate wealth and invest in territorial defense.\"\n\n    if evolution_score > 0.3:\n        rec_action3 = \"Review and adjust strategic parameters for long term competitiveness.\"\n    else:\n        rec_action3 = \"Maintain current parameter strategies with minor optimizations.\"\n\n    report = {\n        'resource_gini': gini,\n        'identified_power_brokers': power_brokers,\n        'local_land_density': land_density,\n        'parameter_evolution_score': evolution_score,\n        'estimated_survival_probability': survival_prob,\n        'top_strategies': {\n            'strategy_1': rec_action1,\n            'strategy_2': rec_action2,\n            'strategy_3': rec_action3\n        }\n    }\n\n    # Store report in member's memory; initialize if not present.\n    if not hasattr(member, 'data_memory'):\n        member.data_memory = {'reports': [], 'strategies': []}\n    member.data_memory['reports'].append(report)\n    member.data_memory['strategies'].append([rec_action1, rec_action2, rec_action3])\n\n    print(\"Strategic Analysis Report:\")\n    print(report)\n\n    return analysis"
          }
        }
      },
      "relationships": [
        "member_0 was attacked by member_1 (value=-167.79)",
        "member_0 was attacked by member_2 (value=573.88)",
        "member_0 was attacked by member_3 (value=457.54)",
        "member_1 was attacked by member_0 (value=-379.31)",
        "member_1 was attacked by member_2 (value=-78.15)",
        "member_1 was attacked by member_3 (value=257.26)",
        "member_2 was attacked by member_0 (value=-465.91)",
        "member_2 was attacked by member_1 (value=-197.53)",
        "member_2 was attacked by member_3 (value=135.47)",
        "member_3 was attacked by member_0 (value=706.74)",
        "member_3 was attacked by member_1 (value=96.72)",
        "member_3 was attacked by member_2 (value=832.60)",
        "member_0 gave a benefit to member_1 (value=-463.73)",
        "member_0 gave a benefit to member_2 (value=590.27)",
        "member_0 gave a benefit to member_3 (value=723.24)",
        "member_1 gave a benefit to member_0 (value=-277.58)",
        "member_1 gave a benefit to member_2 (value=162.09)",
        "member_1 gave a benefit to member_3 (value=-231.52)",
        "member_2 gave a benefit to member_0 (value=207.37)",
        "member_2 gave a benefit to member_1 (value=-369.99)",
        "member_2 gave a benefit to member_3 (value=481.30)",
        "member_3 gave a benefit to member_0 (value=683.23)",
        "member_3 gave a benefit to member_1 (value=524.30)",
        "member_3 gave a benefit to member_2 (value=824.80)",
        "member_0 gave land to member_1 (value=25.73)",
        "member_0 gave land to member_2 (value=-20.62)",
        "member_0 gave land to member_3 (value=17.15)",
        "member_1 gave land to member_0 (value=3.84)",
        "member_1 gave land to member_2 (value=-20.63)",
        "member_1 gave land to member_3 (value=-19.61)",
        "member_2 gave land to member_0 (value=12.92)",
        "member_2 gave land to member_1 (value=-27.78)",
        "member_2 gave land to member_3 (value=5.58)",
        "member_3 gave land to member_0 (value=-22.84)",
        "member_3 gave land to member_1 (value=4.60)",
        "member_3 gave land to member_2 (value=-10.39)"
      ],
      "generated_code": {
        "0": {
          "code": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Implement a survival and cooperative social organization strategy.\n    Strategy Outline:\n      1. Validate our own existence in current_members.\n      2. If personal resources (cargo) are low, attempt to expand our territory in a low-risk manner.\n      3. Assess threats by scanning the victim matrix for significant attacks against us.\n         - If a neighbor appears dangerously aggressive (vitality loss above threshold),\n           immediately counterattack to neutralize the threat.\n      4. For members with a history of mutually beneficial interaction (via benefit matrix),\n         extend offers and even offer land if we have a clear resource (indicated by a non-empty current_clear_list).\n      5. Finally, broadcast a message promoting collective survival and cooperation.\n\n    All actions and validations respect critical constraints:\n      \u2022 Never target ourselves.\n      \u2022 Always check if an index exists before accessing execution_engine.current_members.\n      \u2022 Validate that a member has land (in this case, a non-empty current_clear_list) before using land-related actions.\n      \u2022 Ensure we do not reference attributes wrongly (using member.id, member.vitality, etc.).\n\n    This integrated approach emphasizes immediate survival, threat mitigation, resource optimization,\n    and potential alliance formation for longer-term gain.\n    \"\"\"\n    # Ensure our member index exists.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return None\n\n    # Retrieve our own member object.\n    my_member = execution_engine.current_members[member_id]\n\n    # -------------------------------\n    # Step 1: Low-resource expansion / reinforcement\n    # If cargo is low, try a mild expansion to gain resources.\n    if my_member.cargo < 10:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue  # do not target self\n            # Validate index exists.\n            if idx < len(execution_engine.current_members):\n                target_member = execution_engine.current_members[idx]\n                # Use a simple heuristic: if we have more vitality than the target and they have lower cargo,\n                # attempt a non-aggressive expansion.\n                if my_member.vitality > target_member.vitality and target_member.cargo < my_member.cargo:\n                    try:\n                        execution_engine.expand(my_member, target_member)\n                    except Exception:\n                        # If expand fails, continue with next candidate.\n                        pass\n                    break\n\n    # -------------------------------\n    # Step 2: Threat assessment and neutralization\n    # Use victim_matrix to determine if any neighbor has inflicted significant harm towards us.\n    threat_threshold = 5.0  # if we've lost more than 5 units of vitality from an attack, consider it significant.\n    enemy_found = False\n    # Loop through all members to see if they have been aggressive.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue  # never attack self\n        if idx >= len(execution_engine.current_members):\n            continue  # ensure valid index\n\n        target_member = execution_engine.current_members[idx]\n        try:\n            # victim_matrix is accessed with [victim_index, attacker_index]\n            victim_value = execution_engine.relationship_dict['victim'][member_id, idx]\n        except Exception:\n            victim_value = 0\n        if victim_value > threat_threshold:\n            # Found a member that has attacked us significantly; retaliate.\n            try:\n                execution_engine.attack(my_member, target_member)\n                enemy_found = True\n            except Exception:\n                # In case the attack action fails, we continue checking others.\n                pass\n\n    if enemy_found:\n        # If we have attacked any enemy, prioritize hoarding resources.\n        # (We simulate adaptive hoarding by simply not engaging in riskier actions this round.)\n        return \"Threats neutralized. Focusing on resource hoarding.\"\n\n    # -------------------------------\n    # Step 3: Cooperative alliance formation\n    # Look for members with whom we have positive interactions as per the benefit matrix.\n    benefit_threshold = 3.0  # threshold for deciding if the relationship has been beneficial.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue  # do not engage with self\n        if idx >= len(execution_engine.current_members):\n            continue  # ensure valid index\n\n        try:\n            benefit_value = execution_engine.relationship_dict['benefit'][member_id, idx]\n        except Exception:\n            benefit_value = 0\n        if benefit_value > benefit_threshold:\n            target_member = execution_engine.current_members[idx]\n            # Offer resources as a sign of forming an alliance.\n            try:\n                execution_engine.offer(my_member, target_member)\n            except Exception:\n                pass\n            # If we have available land (denoted by a non-empty current_clear_list), offer it too.\n            if hasattr(my_member, 'current_clear_list') and isinstance(my_member.current_clear_list, list) and my_member.current_clear_list:\n                try:\n                    execution_engine.offer_land(my_member, target_member)\n                except Exception:\n                    pass\n\n    # -------------------------------\n    # Step 4: Broadcast a cooperation message for collective survival.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue  # skip self in communication\n        # Validate index exists.\n        if idx < len(execution_engine.current_members):\n            try:\n                execution_engine.send_message(member_id, idx,\n                    \"Together we can optimize resources and ensure survival. Let's cooperate!\")\n            except Exception:\n                pass\n\n    # Final adaptive strategy:\n    # If we have ample cargo, consider a defensive posture using bear() on a randomly chosen friendly neighbor,\n    # but only if that neighbor possesses land (simulating territory control).\n    # This defensive move represents adaptive hoarding and territory fortification.\n    if my_member.cargo > 20:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            if idx < len(execution_engine.current_members):\n                target_member = execution_engine.current_members[idx]\n                # Check that target_member appears to have land by verifying a non-empty current_clear_list.\n                if hasattr(target_member, 'current_clear_list') and isinstance(target_member.current_clear_list, list) and target_member.current_clear_list:\n                    try:\n                        execution_engine.bear(my_member, target_member)\n                    except Exception:\n                        pass\n                    break\n\n    return \"Action complete: Survival measures and alliance offers executed.\"",
          "features_at_generation": [
            {
              "self_productivity": 9.851974486110818,
              "self_vitality": 73.85382847590404,
              "self_cargo": 43.51277128714192,
              "self_age": 90,
              "self_neighbor": 0,
              "member_id": 0
            },
            {
              "self_productivity": 9.08301045637024,
              "self_vitality": 44.332577377572576,
              "self_cargo": 33.78661423100807,
              "self_age": 61,
              "self_neighbor": 0,
              "member_id": 1
            },
            {
              "self_productivity": 8.874253896189748,
              "self_vitality": 63.3493315814742,
              "self_cargo": 74.30150730167696,
              "self_age": 24,
              "self_neighbor": 0,
              "member_id": 2
            },
            {
              "self_productivity": 7.968737200820967,
              "self_vitality": 42.15604281108604,
              "self_cargo": 40.25508270288947,
              "self_age": 29,
              "self_neighbor": 0,
              "member_id": 3
            }
          ],
          "relationships_at_generation": [
            "member_0 was attacked by member_1 (value=-167.79)",
            "member_0 was attacked by member_2 (value=573.88)",
            "member_0 was attacked by member_3 (value=457.54)",
            "member_1 was attacked by member_0 (value=-379.31)",
            "member_1 was attacked by member_2 (value=-78.15)",
            "member_1 was attacked by member_3 (value=257.26)",
            "member_2 was attacked by member_0 (value=-465.91)",
            "member_2 was attacked by member_1 (value=-197.53)",
            "member_2 was attacked by member_3 (value=135.47)",
            "member_3 was attacked by member_0 (value=706.74)",
            "member_3 was attacked by member_1 (value=96.72)",
            "member_3 was attacked by member_2 (value=832.60)",
            "member_0 gave a benefit to member_1 (value=-463.73)",
            "member_0 gave a benefit to member_2 (value=590.27)",
            "member_0 gave a benefit to member_3 (value=723.24)",
            "member_1 gave a benefit to member_0 (value=-277.58)",
            "member_1 gave a benefit to member_2 (value=162.09)",
            "member_1 gave a benefit to member_3 (value=-231.52)",
            "member_2 gave a benefit to member_0 (value=207.37)",
            "member_2 gave a benefit to member_1 (value=-369.99)",
            "member_2 gave a benefit to member_3 (value=481.30)",
            "member_3 gave a benefit to member_0 (value=683.23)",
            "member_3 gave a benefit to member_1 (value=524.30)",
            "member_3 gave a benefit to member_2 (value=824.80)",
            "member_0 gave land to member_1 (value=25.73)",
            "member_0 gave land to member_2 (value=-20.62)",
            "member_0 gave land to member_3 (value=17.15)",
            "member_1 gave land to member_0 (value=3.84)",
            "member_1 gave land to member_2 (value=-20.63)",
            "member_1 gave land to member_3 (value=-19.61)",
            "member_2 gave land to member_0 (value=12.92)",
            "member_2 gave land to member_1 (value=-27.78)",
            "member_2 gave land to member_3 (value=5.58)",
            "member_3 gave land to member_0 (value=-22.84)",
            "member_3 gave land to member_1 (value=4.60)",
            "member_3 gave land to member_2 (value=-10.39)"
          ],
          "final_prompt": "Below is the updated FULL INTEGRATED PROMPT that combines the previous instructions with the new Section (Part 2) while preserving all provided constraints. Remember that each agent should implement solutions according to its individual needs, beliefs, and circumstances while embracing adaptability, innovation, and a survival-friendly strategy.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT for agent_action(execution_engine, member_id)\n\n[Previous code execution context]\n\u2003\u2022 No previous execution errors\n\n[Current task]\n\u2003\u2022 You are member_0 in a society that you can help shape.\n\u2003\u2022 Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\u2003\u2022 Your function should explore novel combinations of available methods and strategies, not simply imitate any example strategy.\n\u2003\u2022 The approach should consider personal resource optimization, threat assessment, vitality preservation, adaptive hoarding, and predictive danger modeling.\n\n[Critical constraints]\n\u20031. Carefully analyze previous errors (if any) and avoid repeating them.\n\u20032. Never target yourself (member_0) in any action.\n\u20033. Verify that a member has land before using the bear() action.\n\u20034. Check that member IDs exist before referencing them.\n\u20035. Ensure all matrix indices are valid.\n\u20036. current_members is a list accessed by index, not a dictionary.\n\u20037. Access members using execution_engine.current_members[index].\n\u20038. Always check if an index exists: e.g., if index < len(execution_engine.current_members).\n\n[Attributes and Methods Available]\n\u2003\u2022 Each member (accessed via execution_engine.current_members[index]) has:\n\u2003\u2003\u2013 member.id (int): Unique ID.\n\u2003\u2003\u2013 member.vitality (float)\n\u2003\u2003\u2013 member.cargo (float)\n\u2003\u2003\u2013 member.overall_productivity (float)\n\u2003\u2003\u2013 member.age (float)\n\u2003\u2003\u2013 member.current_clear_list (List[int]) \u2013 IDs of neighbors or cleared adjacents.\n\u2003\u2022 Relationships are stored in execution_engine.relationship_dict (do NOT use any \u201crelationship_history\u201d).\n\u2003\u2003\u2013 The following matrices are available:\n\u2003\u2003\u2003\u2022 victim_matrix = execution_engine.relationship_dict['victim']\n\u2003\u2003\u2003\u2003\u2013 victim_matrix[i,j] indicates how much vitality member_i lost from member_j\u2019s attacks.\n\u2003\u2003\u2003\u2022 benefit_matrix = execution_engine.relationship_dict['benefit']\n\u2003\u2003\u2003\u2003\u2013 benefit_matrix[i,j] indicates how much resources member_i received from member_j.\n\u2003\u2003\u2003\u2022 benefit_land matrix (if needed) can be accessed similarly.\n\u2003\u2022 Use parse_relationship_matrix to produce a summary of relationships (e.g., \"member_2 was attacked by member_1 (value=3.00)\").\n\n\u2003\u2022 Methods on execution_engine include:\n\u2003\u2003\u2013 execution_engine.attack(member1, member2)\n\u2003\u2003\u2013 execution_engine.offer(member1, member2)\n\u2003\u2003\u2013 execution_engine.offer_land(member1, member2)\n\u2003\u2003\u2013 execution_engine.bear(member1, member2)\n\u2003\u2003\u2013 execution_engine.expand(member1, member2)\n\u2003\u2022 Communication:\n\u2003\u2003\u2013 execution_engine.send_message(your_id, recipient_id, \"message\") is used to message others.\n\u2003\u2003\u2013 You may broadcast (all members except yourself) or send direct messages for coordination.\n\n[Additional new constraints from Part 2]\n\u2003\u2013 Ensure the same validations as above (member existence, valid indices, land check for bear action).\n\u2003\u2013 Do not reference attributes like 'member.member_id' or 'member.self_vitality'; instead, use member.id, member.vitality, etc.\n\u2003\u2013 When accessing members, always use execution_engine.current_members[id] after verifying the index is valid.\n\u2003\u2013 Incorporate survival-centric adaptations:\n\u2003\u20031. Personal resource optimization.\n\u2003\u20032. Threat assessment and neutralization.\n\u2003\u20033. Vitality preservation techniques.\n\u2003\u20034. Adaptive hoarding strategies.\n\u2003\u20035. Predictive danger modeling.\n\u2003\u2013 Examples include emergency resource reserves, adaptive territory defense, and even survival Q-learning (use the concept as inspiration, not a rote copy).\n\n[Social Strategies \u2013 Consider the following approaches]\n\u2003\u2022 Design systems for resource distribution and allocation.\n\u2003\u2022 Build alliances and cooperative networks.\n\u2003\u2022 Create mechanisms for collective decision making.\n\u2003\u2022 Establish norms and rules for interaction.\n\u2003\u2022 Develop methods for conflict resolution.\n\u2003\u2022 Integrate strategies using a mix of available methods (attack, offer, offer_land, bear, expand).\n\n[Communication Strategy]\n\u2003\u2022 You may send multiple messages per round.\n\u2003\u2003\u2013 For example, broadcast to all (except yourself):\n\u2003\u2003\u2003for recipient in range(len(execution_engine.current_members)):\n\u2003\u2003\u2003\u2003if recipient != your_id:\n\u2003\u2003\u2003\u2003\u2003execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n\u2003\u2003\u2013 Also send direct messages to coordinate with specific allies.\n\n[Analysis of the Game Mechanics]\n\u20031. Core Objective:\n\u2003\u2003\u2013 Consider whether the fundamental goal is pure survival, achievement of domination, or cooperative organization.\n\u20032. Key Success Metrics:\n\u2003\u2003\u2013 Evaluate success by long-term survival (vitality preservation), resource acquisition and allocation, collective stability, and overall influence.\n\u20033. Potential Improvements:\n\u2003\u2003\u2013 Consider introducing mechanisms that reward cooperation, penalize reckless aggression, or lead to richer social dynamics by incorporating elements like reputation systems or complex negotiation frameworks.\n\n[Self-Critical Questions \u2013 Challenge Your Implementation]\n\u20031. What assumptions are you making? Are they valid?\n\u20032. What alternative strategies have you not considered?\n\u20033. How would your strategy perform in edge cases?\n\u20034. Are there more efficient ways to achieve your goals?\n\u20035. What are the weaknesses in your current approach?\n\u20036. Have you considered unconventional solutions?\n\u20037. Could a completely different paradigm work better?\n\u20038. What would happen if other agents adopted your strategy?\n\u20039. Are you balancing short-term and long-term objectives optimally?\n\u200310. How could your strategy be countered, and how would you adapt?\n\n[Survival Metrics]\n\u2003\u2022 Evaluate strategies by:\n\u2003\u2003\u2013 Personal vitality delta.\n\u2003\u2003\u2013 Resource acquisition rate.\n\u2003\u2003\u2013 Threat neutralization count.\n\u2003\u2003\u2013 Survival probability increase.\n\u2003\u2003\u2013 Attack success-to-fail ratio.\n\n[Implementation Priorities]\n\u20031. Create personal health monitoring systems.\n\u20032. Develop egocentric threat models.\n\u20033. Optimize actions for maximal return on vitality (caloric ROI).\n\u20034. Implement safeguards that prevent accidental self-destruction.\n\u20035. Build predictive self-preservation models.\n\n[Base Code]\n\u2003None provided \u2013 build your solution combining the available methods and constraints.\n\u2003IMPORTANT: Do not simply copy any provided sample implementation. Use them as inspiration while creating your own unique approach that synergizes multiple strategies in innovative ways.\n\n[Your Task in Code \u2013 Final Function Specification]\n\u2003Implement the function:\n\n\u2003def agent_action(execution_engine, member_id):\n\u2003\u2003\"\"\"\n\u2003\u2003Implement your strategy for social organization and survival.\n\u2003\u2003Ensure all constraints and validations (e.g., member existence, valid indices, land check for bear action) are met.\n\u2003\u2003Consider resource allocation, alliance formation, conflict resolution, and adaptive survival mechanisms.\n\u2003\u2003Utilize execution_engine.send_message to communicate with others.\n\u2003\u2003Return any appropriate result or state transformation to guide your next move.\n\u2003\u2003\"\"\"\n\u2003\u2003# Your unique implementation here\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nRemember: Each agent should tailor their approach based on their own experiences, objectives, and circumstances. Experiment with creative combinations of the available methods without compromising any of the critical constraints.\n\nGood luck\u2014and may your strategy flourish in this dynamic environment!\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nThis integrated prompt calls for a deep understanding of the complex game mechanics and asks agents to reflect on these questions:\n\n1. The core objective\u2014Is the aim pure survival, domination, or some cooperative organization?  \n2. Key success metrics\u2014What defines 'winning'? Is it long-term vitality, effective resource allocation, dominance over others, or stability through cooperation?  \n3. Potential improvements\u2014Which mechanics could be introduced (e.g., reputation systems, more nuanced negotiation frameworks, collective decision making) to encourage richer dynamics?\n\nChallenging your implementation:\n\u2003\u2022 What assumptions underlie your strategy?  \n\u2003\u2022 Have you explored alternative tactics?  \n\u2003\u2022 How will your solution respond under unusual or extreme conditions?  \n\u2003\u2022 Can the chosen approach be made more efficient?  \n\u2003\u2022 What vulnerabilities exist in your current plan?  \n\u2003\u2022 Would an unconventional paradigm yield better survival outcomes?  \n\u2003\u2022 How might the dynamics change if other agents adopt similar strategies?  \n\u2003\u2022 Are you striking a fair balance between immediate survival and long-term gains?  \n\u2003\u2022 How might adversaries counter your strategy\u2014and how will you evolve in response?\n\nImplement your strategy thoughtfully while ensuring robust checks, clear communication, and innovative integration of the available methods.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
        }
      }
    }
  ]
}