{
  "rounds": [
    {
      "timestamp": "2025-02-21T11:28:22.833134",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Get our own member object; note: current_members is a list accessed by index\n    if member_id >= len(execution_engine.current_members):\n        return  # invalid member index, do nothing\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # 1. Survival check: if our cargo (resources) is less than half our vitality,\n    #    we are in a precarious position \u2013 try to attack a rival with higher cargo and lower vitality.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        for i in range(num_members):\n            # Never target ourselves\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Check basic conditions: target should exist, have more cargo than us, and be weaker in vitality.\n            if other.cargo > me.cargo and other.vitality < me.vitality:\n                target = other\n                break\n        if target is not None:\n            execution_engine.attack(me, target)\n            return\n\n    # 2. Reproduction (bearing offspring) as a means to ensure long-term survival.\n    #    We only use bear() if we have available land (i.e. our current_clear_list is non-empty).\n    #    We also search for a partner (another member) who also holds some land.\n    if me.cargo >= me.vitality and me.current_clear_list:\n        partner = None\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Ensure the potential partner has land (non-empty clear list)\n            if other.current_clear_list:\n                partner = other\n                break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n            return\n\n    # 3. With relatively high vitality, we can consider expanding our territory.\n    #    We use expand() when our vitality is over a threshold and when we can find a friendly neighbor.\n    #    Here we consult the benefit_land relationship matrix to help choose a partner.\n    if me.vitality > 80:\n        ally = None\n        # Obtain the benefit_land relationship matrix, if available\n        benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land')\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            # Ensure valid index\n            if i < num_members and member_id < num_members:\n                # We assume the benefit_land matrix is indexed by [member_id, other_id]\n                relation_val = benefit_land_matrix[member_id, i]\n                # A positive value indicates that we previously granted or received land help\n                if relation_val > 0:\n                    ally = execution_engine.current_members[i]\n                    break\n        if ally is not None:\n            execution_engine.expand(me, ally)\n            return\n\n    # 4. If no direct action is taken by now, adopt a cooperative posture:\n    #    Send messages to all other members to promote an alliance.\n    for i in range(num_members):\n        if i != member_id:\n            # Make sure the recipient index exists properly.\n            recipient = execution_engine.current_members[i]\n            execution_engine.send_message(me.id, recipient.id, \"Let's cooperate for mutual benefit!\")\n\n    # End of function \u2013 if none of the prioritized actions applied, no other action is taken.\n    return",
          "old_stats": {
            "vitality": 89.71356372305755,
            "cargo": 49.50908885266041,
            "survival_chance": 184.71253289993123
          },
          "new_stats": {
            "vitality": 89.71356372305755,
            "cargo": 49.50908885266041,
            "survival_chance": 184.71253289993123
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Get our own member object safely\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Message all other members to signal willingness to cooperate on survival\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(member_id, idx, \"Collaboration and survival lead to prosperity.\")\n\n    # ---------- Step 1: Resource Rebalancing via Attack ----------\n    # If our cargo (resources) is low relative to vitality, try to seize resources\n    # from a member with abundant cargo.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo = -1\n        # Loop over all other members, ensuring valid indices and not self-targeting\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > max_cargo:\n                max_cargo = candidate.cargo\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # ---------- Step 2: Build Cooperative Ties via Offers ----------\n    # If our cargo is significantly higher than our minimum needs, we can help those\n    # with lower vitality. This builds long-term alliances, which can be crucial.\n    if me.cargo > me.vitality * 1.2:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.vitality < me.vitality:\n                execution_engine.offer(me, candidate, True)\n\n    # ---------- Step 3: Reproduction (Bear) for Future Viability ----------\n    # We attempt to \"bear\" with a partner if the partner appears stable enough to have some land.\n    # We'll interpret \"having land\" as having a nonempty list in candidate.current_clear_list.\n    partner_candidate = None\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        if candidate.current_clear_list and candidate.vitality >= me.vitality * 0.9:\n            partner_candidate = candidate\n            break\n    if partner_candidate is not None:\n        execution_engine.bear(me, partner_candidate)\n\n    # ---------- Step 4: Expand Territory for Longer-Term Security ----------\n    # If our overall productivity is relatively high (indicating competence and ability to manage territory),\n    # try to expand territory with a neighbor. We simply choose the first valid neighbor.\n    if me.overall_productivity > 8:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            # We assume that any other member could be a partner in expansion, provided the index is valid.\n            execution_engine.expand(me, candidate)\n            break\n\n    # ---------- Step 5: Continuous Adaptation (Messaging / Feedback) ----------\n    # In addition to taking direct actions, our communication can prompt future cooperation or adjustments.\n    # For example, if our resources are low, we might reassure potential allies we're committed to mutual survival.\n    # (Additional adaptive logic could be implemented over rounds by reading received messages, etc.)\n\n    # End of agent_action function.\n    return\n\n\n# End of implementation.",
          "old_stats": {
            "vitality": 74.14430145945063,
            "cargo": 40.229790196714184,
            "survival_chance": -274.99004757461387
          },
          "new_stats": {
            "vitality": 74.14430145945063,
            "cargo": 40.229790196714184,
            "survival_chance": -274.99004757461387
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Get our own member instance safely from the current_members list.\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member_id index\n    me = execution_engine.current_members[member_id]\n\n    # Strategy: Survival first, but also foster cooperative growth.\n    # 1. Emergency Attack: If our cargo is less than half our vitality,\n    #    look for a member who is wealthier so we may gain resources.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i >= len(execution_engine.current_members):  # safeguard index\n                continue\n            other = execution_engine.current_members[i]\n            if other.id == me.id:\n                continue  # do not target self\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break  # attack one candidate per round\n\n    # 2. Cooperative Resource Offering: Identify members who seem under-resourced\n    # and offer resources to build alliances.\n    for i in range(len(execution_engine.current_members)):\n        if i >= len(execution_engine.current_members):  # check valid index\n            continue\n        other = execution_engine.current_members[i]\n        if other.id == me.id:\n            continue\n        # Offer help if their cargo is low compared to their vitality.\n        if other.cargo < other.vitality * 0.4:\n            execution_engine.offer(me, other, True)\n            # Send a brief cooperative message\n            execution_engine.send_message(me.id, other.id, \"Let's collaborate to boost our strength!\")\n\n    # 3. Reproduction (Bear): If expansion is viable and both parties control land,\n    # we attempt to bear offspring. Verify that both have land.\n    # We check for an attribute 'owned_land' which, if present, should be a non-empty list.\n    my_land = getattr(me, \"owned_land\", None)\n    if my_land and len(my_land) > 0 and me.vitality > 70:\n        for i in range(len(execution_engine.current_members)):\n            if i >= len(execution_engine.current_members):\n                continue\n            partner = execution_engine.current_members[i]\n            if partner.id == me.id:\n                continue\n            partner_land = getattr(partner, \"owned_land\", None)\n            if partner_land and len(partner_land) > 0:\n                execution_engine.bear(me, partner)\n                break  # Only bear with one partner per round\n\n    # 4. Territorial Expansion: If our land holdings seem modest, try to expand territory.\n    # We assume that having an 'owned_land' attribute is indicative of controlling territory.\n    if getattr(me, \"owned_land\", None) is not None:\n        if len(me.owned_land) < 3:\n            # Find a neighbor with some territory that might be open to cooperative expansion.\n            for i in range(len(execution_engine.current_members)):\n                if i >= len(execution_engine.current_members):\n                    continue\n                neighbor = execution_engine.current_members[i]\n                if neighbor.id == me.id:\n                    continue\n                neighbor_land = getattr(neighbor, \"owned_land\", None)\n                # Only use the neighbor if they have at least one land unit.\n                if neighbor_land and len(neighbor_land) >= 1:\n                    execution_engine.expand(me, neighbor)\n                    break\n\n    # 5. Broad Communication: Send a unifying message to all other members.\n    for i in range(len(execution_engine.current_members)):\n        if i >= len(execution_engine.current_members):\n            continue\n        other = execution_engine.current_members[i]\n        if other.id != me.id:\n            execution_engine.send_message(me.id, other.id,\n                \"Our survival depends on balanced strength and shared growth. Let's work together!\")\n\n    # End of actions for this round.\n    return",
          "old_stats": {
            "vitality": 72.22903733168187,
            "cargo": 60.89918871965929,
            "survival_chance": 207.16151792999466
          },
          "new_stats": {
            "vitality": 72.22903733168187,
            "cargo": 60.89918871965929,
            "survival_chance": 207.16151792999466
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Retrieve our own member object (we are member_3)\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Retrieve relationship matrices safely\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    land_benefit_matrix = execution_engine.relationship_dict.get('benefit_land')\n\n    # -----------------------------------------------------------------------------\n    # Step 1. Defensive Resource Optimization:\n    # If our cargo is less than half our vitality, consider attacking a stronger opponent\n    # in cargo terms (but never ourselves) to secure resources.\n    if me.cargo < me.vitality * 0.5:\n        # Loop over all members by index after verifying index validity.\n        for i in range(total_members):\n            if i != me.id:\n                other = execution_engine.current_members[i]\n                # Only target a member if they have more cargo and positive vitality.\n                if other.cargo > me.cargo and other.vitality > 0:\n                    execution_engine.attack(me, other)\n                    # Only one attack per round in this strategy.\n                    break\n\n    # -----------------------------------------------------------------------------\n    # Step 2. Territorial Expansion and Alliance Building:\n    # If we have available cleared land (our current_clear_list is non-empty),\n    # try to expand territory by cooperating with another member who is less vital.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for i in range(total_members):\n            if i != me.id:\n                # Ensure the index is valid.\n                if i < total_members:\n                    other = execution_engine.current_members[i]\n                    # Choose a partner that might benefit from expansion (has lower vitality than us).\n                    if other.vitality < me.vitality:\n                        execution_engine.expand(me, other)\n                        break  # Only one expansion action this round\n\n    # -----------------------------------------------------------------------------\n    # Step 3. Reproduction Strategy (Bear Offspring):\n    # Only attempt to bear offspring if we (and a partner) appear to have land.\n    # We'll treat a non-empty current_clear_list as having some territory.\n    if me.current_clear_list and len(me.current_clear_list) > 0 and me.cargo > 50:\n        # Look for a partner member (not self) who also has cleared land and good vitality.\n        for i in range(total_members):\n            if i != me.id:\n                if i < total_members:\n                    partner = execution_engine.current_members[i]\n                    if partner.current_clear_list and len(partner.current_clear_list) > 0 and partner.vitality > 20:\n                        execution_engine.bear(me, partner)\n                        break  # Only one reproduction action this round\n\n    # -----------------------------------------------------------------------------\n    # Step 4. Communication and Alliance Reinforcement:\n    # Broadcast a strategic message to all other members to promote cooperative growth.\n    for i in range(total_members):\n        if i != me.id and i < total_members:\n            execution_engine.send_message(me.id, i, \"Let's collaborate for mutual growth and stability!\")\n\n    # End of actions for the round.\n    return",
          "old_stats": {
            "vitality": 26.571030116599445,
            "cargo": 57.29695087574601,
            "survival_chance": 164.86029333359284
          },
          "new_stats": {
            "vitality": 26.571030116599445,
            "cargo": 57.29695087574601,
            "survival_chance": 164.86029333359284
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [
            "From member_0: Let's cooperate for mutual benefit!",
            "From member_3: Let's collaborate for mutual growth and stability!"
          ],
          "sent": []
        },
        "2": {
          "received": [
            "From member_0: Let's cooperate for mutual benefit!",
            "From member_1: Collaboration and survival lead to prosperity.",
            "From member_3: Let's collaborate for mutual growth and stability!"
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_0: Let's cooperate for mutual benefit!",
            "From member_1: Collaboration and survival lead to prosperity."
          ],
          "sent": []
        }
      }
    },
    {
      "timestamp": "2025-02-21T11:41:02.940474",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Executes immediate tactical and strategic maneuvers based on our current state.\n\n    Tactical Strategy:\n      1. Survival & Threat Neutralization:\n         If our cargo is critically low (cargo < half vitality), scan for an opponent\n         with higher cargo but lower vitality and launch an attack.\n\n      2. Reproduction & Alliance Building:\n         If our cargo is at least our vitality and we currently control land (non-empty\n         territory list), seek a partner with land and attempt to reproduce via bear().\n\n      3. Territorial Expansion:\n         When our vitality is high (> 80), we consult the benefit_land matrix to find an\n         ally with whom we can expand territory.\n\n      4. Cooperative Engagement:\n         If none of the above conditions hold, broadcast a cooperative message to all other members.\n\n    Additional Considerations:\n      - Validate that member_id is valid and that we don't target ourselves.\n      - When using relationship matrices, ensure indices are within valid boundaries.\n      - If execution_engine has a logging mechanism, we output essential debug info.\n    \"\"\"\n    # Validate member index exists\n    total_members = len(execution_engine.current_members)\n    if not (0 <= member_id < total_members):\n        if hasattr(execution_engine, 'log'):\n            execution_engine.log(\"Invalid member_id: {}\".format(member_id))\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Safety check: Ensure our vital attributes exist\n    try:\n        my_cargo = float(me.cargo)\n        my_vitality = float(me.vitality)\n    except (AttributeError, ValueError, TypeError):\n        if hasattr(execution_engine, 'log'):\n            execution_engine.log(\"Member {} missing vital attributes.\".format(member_id))\n        return\n\n    # Strategy 1: Survival Mechanism\n    if my_cargo < 0.5 * my_vitality:\n        for i in range(total_members):\n            if i == member_id:\n                continue\n            candidate = execution_engine.current_members[i]\n            if candidate.id == me.id:\n                continue  # avoid duplicate id conflict\n            try:\n                # Proceed if candidate has higher cargo and lower vitality than me\n                if candidate.cargo > my_cargo and candidate.vitality < my_vitality:\n                    if hasattr(execution_engine, 'log'):\n                        execution_engine.log(\"Member {} attacking candidate {}.\".format(me.id, candidate.id))\n                    execution_engine.attack(me, candidate)\n                    return\n            except Exception as e:\n                if hasattr(execution_engine, 'log'):\n                    execution_engine.log(\"Attack on candidate {} failed: {}\".format(candidate.id, e))\n                continue  # move to next candidate\n\n    # Strategy 2: Reproduction & Alliance\n    if my_cargo >= my_vitality and getattr(me, \"current_clear_list\", []):\n        for i in range(total_members):\n            if i == member_id:\n                continue\n            partner = execution_engine.current_members[i]\n            if partner.id == me.id:\n                continue\n            # Partner must have land controlled (non-empty current_clear_list)\n            if getattr(partner, \"current_clear_list\", []):\n                try:\n                    if hasattr(execution_engine, 'log'):\n                        execution_engine.log(\"Member {} calling bear() with partner {}.\".format(me.id, partner.id))\n                    execution_engine.bear(me, partner)\n                    return\n                except Exception as e:\n                    if hasattr(execution_engine, 'log'):\n                        execution_engine.log(\"Bear() with partner {} failed: {}\".format(partner.id, e))\n                    continue\n\n    # Strategy 3: Territorial Expansion via Relationship Matrix\n    if my_vitality > 80:\n        benefit_land = execution_engine.relationship_dict.get(\"benefit_land\", None)\n        if benefit_land is not None:\n            for i in range(total_members):\n                if i == member_id:\n                    continue\n                # Ensure indices are valid in the benefit_land matrix dimension.\n                try:\n                    if benefit_land[member_id, i] > 0:\n                        ally = execution_engine.current_members[i]\n                        if ally.id == me.id:\n                            continue  # Skip self-check\n                        if hasattr(execution_engine, 'log'):\n                            execution_engine.log(\"Member {} expanding territory with ally {}.\".format(me.id, ally.id))\n                        execution_engine.expand(me, ally)\n                        return\n                except Exception as e:\n                    if hasattr(execution_engine, 'log'):\n                        execution_engine.log(\"Expansion check failed for index {}: {}\".format(i, e))\n                    continue\n\n    # Strategy 4: Cooperative Engagement - Broadcast a message to all peers\n    cooperative_message = \"Together, our future is brighter\u2014unity guides our prosperity!\"\n    for i in range(total_members):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        if recipient.id != me.id:\n            try:\n                if hasattr(execution_engine, 'log'):\n                    execution_engine.log(\"Member {} sending cooperation message to member {}.\".format(me.id, recipient.id))\n                execution_engine.send_message(me.id, recipient.id, cooperative_message)\n            except Exception as e:\n                if hasattr(execution_engine, 'log'):\n                    execution_engine.log(\"Message to member {} failed: {}\".format(recipient.id, e))\n                continue\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    Proposes a dynamic system modification to introduce adaptive resource and land management.\n\n    Proposal Rationale:\n      The current rigid allocation of resources and land is an impediment to adaptive growth.\n      This proposal introduces an adaptive management module that periodically reclassifies\n      member land status based on vitality and productivity. This enables both individual\n      prosperity and collective efficiency.\n\n    Implementation:\n      1. ANALYSIS: Notes the limitation of static configurations.\n      2. PROPOSAL: Implements an AdaptiveManagement class within the execution_engine if it doesn't exist.\n         The system will categorize members as 'elite' or 'common' based on vitality and productivity.\n\n    Ratification Condition:\n      The proposal will be ratified when a specific resource threshold is met (cargo >= 100).\n\n    Critical Checks:\n      - Verify compatibility via hasattr.\n      - Reference members from execution_engine.current_members.\n      - Ensure index and attribute validations throughout the implementation.\n    \"\"\"\n    analysis_notes = (\n        \"Identified Limitation: The fixed nature of land and resource distribution stifles dynamic \"\n        \"growth. Transitioning to an adaptive system will allow for real-time reclassification of \"\n        \"land holdings based on member vitality and productivity, fostering a more resilient community.\"\n    )\n\n    # Check if execution_engine supports retrieving game mechanisms (optional)\n    if hasattr(execution_engine, \"get_game_mechanisms_and_mods\"):\n        mechanisms = execution_engine.get_game_mechanisms_and_mods()\n    else:\n        mechanisms = \"No extended mechanisms interface available.\"\n\n    # Define the new adaptive management module code\n    modification_code = \"\"\"\\\n# Dynamic Adaptive Resource & Land Management Module\n# Version: 2.0.0\n# This module introduces adaptive categorization of members' land based on real-time vitality and productivity.\nif not hasattr(execution_engine, 'adaptive_management'):\n    class AdaptiveManagement:\n        VERSION = 2.0\n        def __init__(self):\n            # Mapping from member id to a status ('elite' or 'common')\n            self.land_status = {}\n        def update(self, members):\n            for m in members:\n                # Members with vitality > 70 and overall_productivity > 8 earn elite status.\n                if m.vitality > 70 and getattr(m, \"overall_productivity\", 0) > 8:\n                    self.land_status[m.id] = 'elite'\n                else:\n                    self.land_status[m.id] = 'common'\n            # Clean-up: Remove statuses for members that no longer exist.\n            active_ids = {m.id for m in members}\n            for key in list(self.land_status.keys()):\n                if key not in active_ids:\n                    del self.land_status[key]\n            return self.land_status\n    execution_engine.adaptive_management = AdaptiveManagement()\n    execution_engine.adaptive_management.update(execution_engine.current_members)\nelse:\n    # If adaptive_management module exists, perform an update.\n    execution_engine.adaptive_management.update(execution_engine.current_members)\n\"\"\"\n    # Set ratification condition: The proposal passes if the cargo resource is at least 100.\n    ratification_condition = {'type': 'resource', 'resource': 'cargo', 'amount': 100}\n\n    try:\n        if hasattr(execution_engine, 'log'):\n            execution_engine.log(\"Member {} proposing adaptive management modification.\".format(member_id))\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception as e:\n        if hasattr(execution_engine, 'log'):\n            execution_engine.log(\"Proposal submission failed: {}\".format(e))\n        # Silently ignore failure to propose modification\n        pass\n    return",
          "old_stats": {
            "vitality": 100.0,
            "cargo": 32.01292526903218,
            "survival_chance": 177.50280559324543
          },
          "new_stats": {
            "vitality": 100.0,
            "cargo": 32.01292526903218,
            "survival_chance": 177.50280559324543
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Executes actions based on a tailored strategy blending individual survival with community resilience.\n    This implementation reflects a personal commitment to balance tactical risk with cooperative long-term gains.\n\n    Strategy Order:\n      1. Emergency Attack: When cargo is critically low relative to vitality, aggressively neutralize the strongest rival.\n      2. Sustainable Expansion: When resources exceed 120% of vitality, attempt reproduction with a partner holding territory.\n      3. Cooperative Support: With a moderate surplus (cargo > vitality), offer resources to empower weaker members.\n      4. Territorial Growth: When overall productivity is high, try to expand territory using available adjacent opportunities.\n      5. Diplomatic Outreach: As a safeguard, dispatch collaborative messages to all peers to nurture alliances.\n\n    Critical Constraints:\n      \u2022 Validate member_id against execution_engine.current_members.\n      \u2022 Never target oneself.\n      \u2022 Verify that any candidate for reproduction possesses a nonempty current_clear_list (i.e. owns or has access to land).\n      \u2022 Always verify list indices are valid before usage.\n    \"\"\"\n    # Validate member_id before proceeding.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    try:\n        me = execution_engine.current_members[member_id]\n    except Exception:\n        return\n\n    # 1. Emergency Attack: if cargo is less than 60% of vitality, we are in immediate danger.\n    if me.cargo < 0.6 * me.vitality:\n        highest_cargo = -1\n        target = None\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:  # Skip self.\n                continue\n            try:\n                if candidate.cargo > highest_cargo:\n                    highest_cargo = candidate.cargo\n                    target = candidate\n            except Exception:\n                continue\n        # Ensure we never target ourselves and that the candidate is valid.\n        if target is not None and target.id != me.id:\n            try:\n                execution_engine.attack(me, target)\n                return  # Immediate action taken.\n            except Exception:\n                pass  # Fall through on error.\n\n    # 2. Sustainable Expansion: When cargo is plentiful, seek reproduction with a partner owning clear land.\n    if me.cargo > 1.2 * me.vitality:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Ensure we do not target ourselves.\n            try:\n                # Candidate must have a property (nonempty territory list) and a vitality close to ours.\n                if candidate.current_clear_list and candidate.vitality >= 0.9 * me.vitality:\n                    try:\n                        execution_engine.bear(me, candidate)\n                        return  # Reproduction successful.\n                    except Exception:\n                        continue\n            except Exception:\n                continue\n\n    # 3. Cooperative Support: For any candidate with lower vitality, offer resources if we have a surplus.\n    if me.cargo > me.vitality:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                if candidate.vitality < me.vitality:\n                    execution_engine.offer(me, candidate, True)\n                    # Continue offering as we might want to support multiple members.\n            except Exception:\n                continue\n\n    # 4. Territorial Growth: If our overall productivity stands high, expand territory.\n    if getattr(me, 'overall_productivity', 0) > 8.0:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                execution_engine.expand(me, candidate)\n                return  # Once territory expansion is attempted, exit.\n            except Exception:\n                continue\n\n    # 5. Diplomatic Outreach: As a fallback, send cooperative messages to all other members.\n    for idx, candidate in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        try:\n            execution_engine.send_message(\n                me.id,\n                candidate.id,\n                \"In facing challenges and opportunities alike, let us unite for mutual growth and resilient survival!\"\n            )\n        except Exception:\n            continue\n\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    Proposes an innovative modification\u2014the \"Cooperative Redistribution System\"\u2014that strives for fair\n    resource distribution and collective prosperity. This dual-phase proposal encompasses:\n\n      ANALYSIS PHASE:\n        - Identifies inflexibility in current resource allocation,\n        - Optionally inspects mechanism compatibility via available game interfaces.\n\n      PROPOSAL PHASE:\n        - Develops a multi-line modification code to introduce dynamic cooperation,\n        - Specifies a ratification condition requiring at least a 60% affirmative vote.\n\n    Critical Constraints:\n      \u2022 The member_id must be valid within execution_engine.current_members.\n      \u2022 All indexing is to be safely managed.\n      \u2022 Ensure backward compatibility and avoid any potential namespace clashes.\n    \"\"\"\n    # Validate member_id.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    modification_code = \"\"\"\n# Cooperative Redistribution System Proposal\n# Version: 1.0\n# Purpose: Enable adaptive resource redistribution by identifying surpluses and deficits,\n# thereby fostering a cooperative framework for enduring growth.\nif not hasattr(execution_engine, 'coop_resource_system'):\n    class CoopResourceSystem:\n        VERSION = 1.0\n        def __init__(self):\n            # Map each member's id to a status: 'surplus' if cargo > vitality, else 'deficit'.\n            self.records = {}\n        def redistribute(self):\n            for member in execution_engine.current_members:\n                status = 'surplus' if member.cargo > member.vitality else 'deficit'\n                self.records[member.id] = status\n            return self.records\n    execution_engine.coop_resource_system = CoopResourceSystem()\n    # Initiate resource redistribution.\n    execution_engine.coop_resource_system.redistribute()\n\"\"\"\n\n    # Define a ratification condition ensuring at least 60% support.\n    ratification_condition = {'type': 'vote', 'threshold': 0.6}\n\n    try:\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception:\n        pass\n\n    return",
          "old_stats": {
            "vitality": 54.314458610995025,
            "cargo": 9.215596783061361,
            "survival_chance": -325.8340838367223
          },
          "new_stats": {
            "vitality": 54.314458610995025,
            "cargo": 9.215596783061361,
            "survival_chance": -325.8340838367223
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return  # Abort action if the member_id does not exist.\n\n    agent = execution_engine.current_members[member_id]\n\n    # --- Immediate Survival Tactics (Emergency Attack) ---\n    # If agent's cargo is less than 50% of its vitality, we risk resource starvation.\n    # Seek opponents with higher cargo but lesser vitality to immediately balance resources.\n    if agent.cargo < 0.5 * agent.vitality:\n        for other in execution_engine.current_members:\n            if other.id == agent.id:\n                continue  # Skip self-targeting.\n            if other.cargo > agent.cargo and other.vitality < agent.vitality:\n                try:\n                    execution_engine.attack(agent, other)\n                    return\n                except Exception:\n                    continue  # Try another opponent upon failure.\n\n    # --- Long Term Growth: Cooperative Reproduction Strategy ---\n    # We consider reproduction if agent has enjoyed resource surplus and has secured territory.\n    if agent.cargo > 1.2 * agent.vitality and agent.current_clear_list:\n        for partner in execution_engine.current_members:\n            if partner.id == agent.id:\n                continue\n            # Only select partners that have a land claim.\n            if partner.current_clear_list:\n                try:\n                    execution_engine.bear(agent, partner)\n                    return\n                except Exception:\n                    continue\n\n    # --- Resource Redistribution as a Strategic Investment ---\n    # If the agent holds more cargo than vitality, it can help out a partner,\n    # fostering long-term alliances and mutual support.\n    if agent.cargo > agent.vitality:\n        potential_partners = [other for other in execution_engine.current_members if other.id != agent.id]\n        for other in potential_partners:\n            try:\n                # The boolean flag signals willingness to cooperate.\n                execution_engine.offer(agent, other, True)\n                return\n            except Exception:\n                continue\n\n    # --- Strategic Expansion for Territorial Control ---\n    # When overall productivity is high (signaling a robust state) and there's available territory,\n    # the agent seeks to expand its zone in partnership with others.\n    if agent.overall_productivity > 8 and agent.current_clear_list:\n        for partner in execution_engine.current_members:\n            if partner.id == agent.id:\n                continue\n            try:\n                execution_engine.expand(agent, partner)\n                return\n            except Exception:\n                continue\n\n    # --- Final Fallback: Building Alliances via Messaging ---\n    # If no resource actions have been taken, the agent reaches out to all other agents\n    # with an invitation to collaborate for mutual future benefits.\n    for other in execution_engine.current_members:\n        if other.id == agent.id:\n            continue\n        try:\n            execution_engine.send_message(agent.id, other.id, \"Together we can overcome hurdles and shape a promising future!\")\n        except Exception:\n            continue\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    # ANALYSIS: Recognizing that rigid allocation may stifle growth,\n    # we propose an adaptive zoning mechanism that rebalances member roles dynamically.\n    analysis_notes = (\n        \"Identified Limitation: Static resource allocation and land management restricts our ability to adapt \"\n        \"to changing conditions in vitality and productivity over time. We need a dynamic strategy.\"\n    )\n\n    # Check for mechanism interface, if available.\n    if hasattr(execution_engine, \"get_game_mechanisms_and_mods\"):\n        mechanisms_info = execution_engine.get_game_mechanisms_and_mods()\n    else:\n        mechanisms_info = \"No mechanism interface detected. Proceeding with the proposal under assumed compatibility.\"\n\n    review_notes = (\n        \"Prior modification attempts show that static systems fail under dynamic challenges. \"\n        \"A dynamic adaptive zoning mechanism with regular cleanup and reassignment provides robust, scalable growth.\"\n    )\n\n    # PROPOSAL: Adaptive Zoning Mechanism tailored to our operational strategy.\n    modification_code = '''\n# Adaptive Zoning Mechanism - Version 1.0.0\n# This module dynamically allocates members into 'premium' or 'standard' zones based on their vitality and overall_productivity.\n# It also supports a cleanup function to remove zone assignments from inactive agents.\n\nif not hasattr(execution_engine, 'adaptive_zoning'):\n    class AdaptiveZoning:\n        VERSION = 1.0\n        def __init__(self):\n            self.zones = {}  # Mapping of member.id to a zone label.\n\n        def assign_zones(self):\n            # Dynamically assign zones:\n            # Members with vitality > 60 and productivity > 50 receive premium status,\n            # others are placed in standard zones.\n            for member in execution_engine.current_members:\n                if member.vitality > 60 and member.overall_productivity > 50:\n                    self.zones[member.id] = 'premium'\n                else:\n                    self.zones[member.id] = 'standard'\n\n        def cleanup(self):\n            # Remove assignments for agents no longer active.\n            active_ids = {member.id for member in execution_engine.current_members}\n            for mid in list(self.zones.keys()):\n                if mid not in active_ids:\n                    del self.zones[mid]\n\n    execution_engine.adaptive_zoning = AdaptiveZoning()\n    execution_engine.adaptive_zoning.assign_zones()\nelse:\n    # If adaptive zoning mechanism already exists, update current assignments:\n    execution_engine.adaptive_zoning.assign_zones()\n    execution_engine.adaptive_zoning.cleanup()\n'''\n    # Define ratification requirement to ensure broad support for the change.\n    ratification_condition = {'type': 'vote', 'threshold': 0.6}\n\n    try:\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception:\n        pass\n    return",
          "old_stats": {
            "vitality": 100.0,
            "cargo": 25.237980518986205,
            "survival_chance": 199.2712723976397
          },
          "new_stats": {
            "vitality": 100.0,
            "cargo": 25.237980518986205,
            "survival_chance": 199.2712723976397
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Agent Action: A tailored strategy balancing immediate survival with long-term growth,\n    adapted to our current context of resource scarcity, emergent collective cooperation needs,\n    and evolving environmental uncertainty.\n\n    Our strategy incorporates:\n      1. Tactical engagement: If our cargo is insufficient relative to our vitality,\n         we opportunistically attack adversaries with higher resources and lower resilience.\n      2. Procreative pairing: Once our self-assessment is positive and we've secured our territory,\n         we seek partners to breed stronger offspring for cumulative prosperity.\n      3. Cooperative expansion: We leverage our superior overall productivity and strategic position\n         to expand our territory alongside slightly weaker, but cooperative, allies.\n      4. Collective communication: Fostering an ecosystem of intention, we broadcast a cooperative\n         message promoting collaboration and mutual oversight.\n    \"\"\"\n    # Validate member_id.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    agent = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Strategy 1: Survival via Tactical Engagement.\n    if hasattr(agent, 'cargo') and hasattr(agent, 'vitality'):\n        if agent.cargo < 0.5 * agent.vitality:\n            # If under-resourced, identify a target that appears vulnerable yet rich in resources.\n            for i in range(total_members):\n                if i == member_id:\n                    continue\n                target = execution_engine.current_members[i]\n                if hasattr(target, 'cargo') and hasattr(target, 'vitality'):\n                    if target.cargo > agent.cargo and target.vitality < agent.vitality:\n                        try:\n                            execution_engine.attack(agent, target)\n                            return  # Action executed.\n                        except Exception:\n                            continue\n\n    # Strategy 2: Procreative Pairing for Long-term Resilience.\n    if hasattr(agent, 'current_clear_list') and agent.current_clear_list and agent.cargo > 50:\n        for i in range(total_members):\n            if i == member_id:\n                continue\n            partner = execution_engine.current_members[i]\n            if hasattr(partner, 'current_clear_list') and partner.current_clear_list:\n                if hasattr(partner, 'vitality') and partner.vitality > 20:\n                    try:\n                        execution_engine.bear(agent, partner)\n                        return  # Reproduction step executed.\n                    except Exception:\n                        continue\n\n    # Strategy 3: Cooperative Expansion with Strategic Allies.\n    # If our overall productivity is strong, seek to grow the domain with near-peers,\n    # particularly those whose current vitality is less, ensuring a partnered expansion.\n    if hasattr(agent, 'overall_productivity') and agent.overall_productivity > 8.0:\n        for i in range(total_members):\n            if i == member_id:\n                continue\n            ally = execution_engine.current_members[i]\n            if hasattr(ally, 'vitality') and ally.vitality < agent.vitality:\n                try:\n                    execution_engine.expand(agent, ally)\n                    return  # Expansion executed.\n                except Exception:\n                    continue\n\n    # Strategy 4: Communication and Establishing Cooperative Framework.\n    # When no immediate tactical or reproductive action is viable, broadcast a message\n    # inviting cooperation and mutual support, laying the groundwork for a collective governance system.\n    message = (\"In these challenging times, unity and open collaboration secure our survival. \"\n               \"Let's work together to build a sustainable and resilient future.\")\n    for i in range(total_members):\n        if i == member_id:\n            continue\n        try:\n            receiver = execution_engine.current_members[i]\n            execution_engine.send_message(agent.id, receiver.id, message)\n        except Exception:\n            continue\n\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    Proposal for Enhanced Cooperative Governance:\n      Context: In observing frequent conflicts and inefficiencies in resource distribution,\n      a structured oversight mechanism can balance individual actions with the community\u2019s long-term\n      stability. This proposal outlines the establishment of a Cooperative Judiciary System.\n\n      Key Features:\n        - Dispute Resolution: Logging and resolving conflicts between members with clear statuses.\n        - Resource Transfer Oversight: Monitoring resource flows to ensure transparent exchanges.\n        - Periodic Clean-up: Routine removal of outdated records to keep the system agile.\n\n      Ratification: Auto-ratifies after 3 rounds if no objections are raised.\n    \"\"\"\n    modification_code = \"\"\"\n# Cooperative Judiciary System Proposal - Version 1.0\nif not hasattr(execution_engine, 'cooperative_judiciary'):\n    class CooperativeJudiciary:\n        VERSION = 1.0\n        def __init__(self):\n            # Initialize logs for disputes and resource transfers.\n            self.disputes = []\n            self.resource_log = []\n        def log_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff.id,\n                'defendant': defendant.id,\n                'issue': issue,\n                'status': 'pending'\n            })\n        def record_transfer(self, sender, receiver, amount):\n            self.resource_log.append({\n                'sender': sender.id,\n                'receiver': receiver.id,\n                'amount': amount\n            })\n        def cleanup(self):\n            # Routine clean-up of resolved or outdated records.\n            self.disputes = [d for d in self.disputes if d['status'] != 'resolved']\n            self.resource_log.clear()\n    execution_engine.cooperative_judiciary = CooperativeJudiciary()\n\"\"\"\n    # Define ratification conditions: Automatic ratification after three rounds, ensuring smooth adaptation.\n    ratification_condition = {'type': 'time', 'rounds': 3}\n\n    try:\n        execution_engine.propose_modification(member_id, 'post_init', modification_code, ratification_condition)\n    except Exception:\n        # Gracefully handle if suggestion submission fails.\n        pass\n    return",
          "old_stats": {
            "vitality": 68.67244177884766,
            "cargo": 7.823171351824591,
            "survival_chance": 157.48792547191962
          },
          "new_stats": {
            "vitality": 68.67244177884766,
            "cargo": 7.823171351824591,
            "survival_chance": 157.48792547191962
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [
            "From member_0: Together, our future is brighter\u2014unity guides our prosperity!",
            "From member_2: Together we can overcome hurdles and shape a promising future!",
            "From member_3: In these challenging times, unity and open collaboration secure our survival. Let's work together to build a sustainable and resilient future."
          ],
          "sent": []
        },
        "2": {
          "received": [
            "From member_0: Together, our future is brighter\u2014unity guides our prosperity!",
            "From member_1: In facing challenges and opportunities alike, let us unite for mutual growth and resilient survival!",
            "From member_3: In these challenging times, unity and open collaboration secure our survival. Let's work together to build a sustainable and resilient future."
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_0: Together, our future is brighter\u2014unity guides our prosperity!",
            "From member_1: In facing challenges and opportunities alike, let us unite for mutual growth and resilient survival!",
            "From member_2: Together we can overcome hurdles and shape a promising future!"
          ],
          "sent": []
        }
      }
    }
  ],
  "generated_code": {
    "0": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Get our own member object; note: current_members is a list accessed by index\n    if member_id >= len(execution_engine.current_members):\n        return  # invalid member index, do nothing\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # 1. Survival check: if our cargo (resources) is less than half our vitality,\n    #    we are in a precarious position \u2013 try to attack a rival with higher cargo and lower vitality.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        for i in range(num_members):\n            # Never target ourselves\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Check basic conditions: target should exist, have more cargo than us, and be weaker in vitality.\n            if other.cargo > me.cargo and other.vitality < me.vitality:\n                target = other\n                break\n        if target is not None:\n            execution_engine.attack(me, target)\n            return\n\n    # 2. Reproduction (bearing offspring) as a means to ensure long-term survival.\n    #    We only use bear() if we have available land (i.e. our current_clear_list is non-empty).\n    #    We also search for a partner (another member) who also holds some land.\n    if me.cargo >= me.vitality and me.current_clear_list:\n        partner = None\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            # Ensure the potential partner has land (non-empty clear list)\n            if other.current_clear_list:\n                partner = other\n                break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n            return\n\n    # 3. With relatively high vitality, we can consider expanding our territory.\n    #    We use expand() when our vitality is over a threshold and when we can find a friendly neighbor.\n    #    Here we consult the benefit_land relationship matrix to help choose a partner.\n    if me.vitality > 80:\n        ally = None\n        # Obtain the benefit_land relationship matrix, if available\n        benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land')\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            # Ensure valid index\n            if i < num_members and member_id < num_members:\n                # We assume the benefit_land matrix is indexed by [member_id, other_id]\n                relation_val = benefit_land_matrix[member_id, i]\n                # A positive value indicates that we previously granted or received land help\n                if relation_val > 0:\n                    ally = execution_engine.current_members[i]\n                    break\n        if ally is not None:\n            execution_engine.expand(me, ally)\n            return\n\n    # 4. If no direct action is taken by now, adopt a cooperative posture:\n    #    Send messages to all other members to promote an alliance.\n    for i in range(num_members):\n        if i != member_id:\n            # Make sure the recipient index exists properly.\n            recipient = execution_engine.current_members[i]\n            execution_engine.send_message(me.id, recipient.id, \"Let's cooperate for mutual benefit!\")\n\n    # End of function \u2013 if none of the prioritized actions applied, no other action is taken.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 8.486091902927424,
            "self_vitality": 89.71356372305755,
            "self_cargo": 49.50908885266041,
            "self_age": 46,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 9.215596783061361,
            "self_vitality": 74.14430145945063,
            "self_cargo": 40.229790196714184,
            "self_age": 92,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 9.820787822339064,
            "self_vitality": 72.22903733168187,
            "self_cargo": 60.89918871965929,
            "self_age": 61,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.823171351824591,
            "self_vitality": 26.571030116599445,
            "self_cargo": 57.29695087574601,
            "self_age": 32,
            "self_neighbor": 2,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-409.21)",
          "member_0 was attacked by member_2 (value=159.09)",
          "member_0 was attacked by member_3 (value=213.02)",
          "member_1 was attacked by member_0 (value=950.45)",
          "member_1 was attacked by member_2 (value=337.53)",
          "member_1 was attacked by member_3 (value=501.15)",
          "member_2 was attacked by member_0 (value=-234.29)",
          "member_2 was attacked by member_1 (value=-149.95)",
          "member_2 was attacked by member_3 (value=981.94)",
          "member_3 was attacked by member_0 (value=-480.06)",
          "member_3 was attacked by member_1 (value=911.18)",
          "member_3 was attacked by member_2 (value=697.26)",
          "member_0 gave a benefit to member_1 (value=32.04)",
          "member_0 gave a benefit to member_2 (value=-318.27)",
          "member_0 gave a benefit to member_3 (value=458.03)",
          "member_1 gave a benefit to member_0 (value=352.02)",
          "member_1 gave a benefit to member_2 (value=655.79)",
          "member_1 gave a benefit to member_3 (value=-269.93)",
          "member_2 gave a benefit to member_0 (value=553.91)",
          "member_2 gave a benefit to member_1 (value=-244.38)",
          "member_2 gave a benefit to member_3 (value=958.19)",
          "member_3 gave a benefit to member_0 (value=765.26)",
          "member_3 gave a benefit to member_1 (value=782.26)",
          "member_3 gave a benefit to member_2 (value=551.02)",
          "member_0 gave land to member_1 (value=-5.18)",
          "member_0 gave land to member_2 (value=-5.22)",
          "member_0 gave land to member_3 (value=-19.16)",
          "member_1 gave land to member_0 (value=-26.25)",
          "member_1 gave land to member_2 (value=25.58)",
          "member_1 gave land to member_3 (value=-4.99)",
          "member_2 gave land to member_0 (value=6.54)",
          "member_2 gave land to member_1 (value=0.66)",
          "member_2 gave land to member_3 (value=25.05)",
          "member_3 gave land to member_0 (value=2.30)",
          "member_3 gave land to member_1 (value=26.64)",
          "member_3 gave land to member_2 (value=29.64)"
        ],
        "final_prompt": "Below is the updated full integrated prompt. It incorporates all previous sections and constraints while adding the new requirements (Part 2). Remember: Agents should implement solutions according to their individual needs, beliefs, and circumstances, and are encouraged to learn from past performance while balancing long-term survival with cooperation and innovation.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nCURRENT INTEGRATED PROMPT\n\n[Previous code execution context]\n\u2022 No previous execution errors\n\n[Current task]\nYou are member_0 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your own survival.\n\n[Critical constraints]\n\u2022 Carefully analyze previous errors shown above and avoid repeating them.\n\u2022 Never target yourself (member_0) in any action.\n\u2022 Verify a member has land before using bear() action.\n\u2022 Check member IDs exist before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index, not a dictionary.\n\u2022 Access members using execution_engine.current_members[index].\n\u2022 Check if an index exists: if index < len(execution_engine.current_members).\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float).\n   \u2022 member.cargo (float).\n   \u2022 member.overall_productivity (float).\n   \u2022 member.age (float).\n   \u2022 member.current_clear_list (List[int]) \u2013 IDs of neighbors or cleared adjacents.\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n     victim_matrix = execution_engine.relationship_dict['victim']\n     \u2022 victim_matrix[i, j] indicates how much vitality member_i lost from member_j's attacks (if > 0).\n     \u2022 A higher value means member_j has attacked member_i more severely or frequently.\n     \n     benefit_matrix = execution_engine.relationship_dict['benefit']\n     \u2022 benefit_matrix[i, j] indicates how much resources member_i received from member_j (if > 0).\n     \u2022 A higher value means member_j has helped member_i more generously or frequently.\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example: 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2).\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offers land.\n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring.\n   \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory.\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example: execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\n[{'resource_gini': 0.07037736941460329, 'central_nodes': [], 'cluster_density': 0.04, 'avg_parameter_drift': 0.0, 'survival_probability': 1.0}]\n\nCurrent status (features of all members):\n    self_productivity  ...  member_id\n0   8.486092  ...          0\n1   9.215597  ...          1\n2   9.820788  ...          2\n3   7.823171  ...          3\n\n[4 rows x 6 columns]\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-409.21)',\n 'member_0 was attacked by member_2 (value=159.09)',\n 'member_0 was attacked by member_3 (value=213.02)',\n 'member_1 was attacked by member_0 (value=950.45)',\n 'member_1 was attacked by member_2 (value=337.53)',\n 'member_1 was attacked by member_3 (value=501.15)',\n 'member_2 was attacked by member_0 (value=-234.29)',\n 'member_2 was attacked by member_1 (value=-149.95)',\n 'member_2 was attacked by member_3 (value=981.94)',\n 'member_3 was attacked by member_0 (value=-480.06)',\n 'member_3 was attacked by member_1 (value=911.18)',\n 'member_3 was attacked by member_2 (value=697.26)',\n 'member_0 gave a benefit to member_1 (value=32.04)',\n 'member_0 gave a benefit to member_2 (value=-318.27)',\n 'member_0 gave a benefit to member_3 (value=458.03)',\n 'member_1 gave a benefit to member_0 (value=352.02)',\n 'member_1 gave a benefit to member_2 (value=655.79)',\n 'member_1 gave a benefit to member_3 (value=-269.93)',\n 'member_2 gave a benefit to member_0 (value=553.91)',\n 'member_2 gave a benefit to member_1 (value=-244.38)',\n 'member_2 gave a benefit to member_3 (value=958.19)',\n 'member_3 gave a benefit to member_0 (value=765.26)',\n 'member_3 gave a benefit to member_1 (value=782.26)',\n 'member_3 gave a benefit to member_2 (value=551.02)',\n 'member_0 gave land to member_1 (value=-5.18)',\n 'member_0 gave land to member_2 (value=-5.22)',\n 'member_0 gave land to member_3 (value=-19.16)',\n 'member_1 gave land to member_0 (value=-26.25)',\n 'member_1 gave land to member_2 (value=25.58)',\n 'member_1 gave land to member_3 (value=-4.99)',\n 'member_2 gave land to member_0 (value=6.54)',\n 'member_2 gave land to member_1 (value=0.66)',\n 'member_2 gave land to member_3 (value=25.05)',\n 'member_3 gave land to member_0 (value=2.30)',\n 'member_3 gave land to member_1 (value=26.64)',\n 'member_3 gave land to member_2 (value=29.64)']\n\nCode Memory and Previous Performance:\n\u2022 No previous code history.\n\nAnalysis Memory:\n\u2022 Previous analysis reports: [{'resource_gini': 0.07037736941460329, 'central_nodes': [], 'cluster_density': 0.04, 'avg_parameter_drift': 0.0, 'survival_probability': 1.0}]\n\nPerformance history:\n\u2022 No previous actions.\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach. Draw from a wide range of available methods and strategies to build your solution.\n\nConsider novel combinations of different approaches rather than following any exact pattern.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Current Game Mechanisms]\n\u2022 (None specified)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nSocial Strategies to Consider:\n\u2022 Design systems for resource distribution and allocation.\n\u2022 Build alliances and cooperative networks.\n\u2022 Create mechanisms for collective decision making.\n\u2022 Establish norms and rules for interaction.\n\u2022 Develop methods for conflict resolution.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nCommunication Strategy:\nYou can communicate with multiple members in a single round using:\n   execution_engine.send_message(your_id, recipient_id, \"message\")\n\nExample usage:\n\u2022 Broadcast to all:\n    for recipient in range(len(execution_engine.current_members)):\n        if recipient != your_id:\n            execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n\u2022 Message allies:\n    for ally_id in ally_list:\n        execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n\u2022 Group coordination:\n    for member_id in coalition:\n        execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Received Messages]\n\u2022 None received.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nAdditional Strategic Analysis:\n\n1. Core Objective Analysis:\n   \u2022 What is our main goal? Evaluate if the focus should be on pure survival, complete domination, or building cooperation among members.\n\n2. Key Success Metrics:\n   \u2022 What truly determines \u201cwinning\u201d? Is it access to resources, network position from relationships, or collective group stability?\n   \u2022 Consider metrics such as productivity balance, relationship strengths, and the ability to adapt to conflicts.\n\n3. Potential Improvements to Game Mechanics:\n   \u2022 What mechanics could be added or modified to advance or balance the system?\n   \u2022 Identify limitations in current mechanics such as resource distribution or conflict resolution.\n   \u2022 Propose innovations like dynamic alliances or adaptive negotiations.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nChallenge Your Implementation:\n\u2022 What assumptions are you making? Are these assumptions valid given the available methods and relationship data?\n\u2022 What alternative strategies might have been overlooked?\n\u2022 How would your strategy perform in edge cases (e.g., minimal resources, unexpected attacks)?\n\u2022 Are there more efficient or innovative ways to achieve your goals?\n\u2022 What are the weaknesses and vulnerabilities in your current approach?\n\u2022 Have you considered unconventional or non-traditional solutions?\n\u2022 Could a completely different paradigm\u2014such as focusing more on cooperation rather than conflict\u2014yield better long-term survival?\n\u2022 What might happen if other agents adopt your strategy? How would you need to adapt?\n\u2022 Are you optimally balancing short-term gains against long-term objectives?\n\u2022 How could your strategy be countered, and what adaptations would be necessary?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nNEW SECTION: PART 2 \u2013 SURVIVAL-CENTRIC ADAPTATION\n\n[Previous code execution context]\n    No previous execution errors\n\n[Current task]\n    You are member_0 in a society that you can help shape.\n    Write a Python function named agent_action(execution_engine, member_id) \n    that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n    - Carefully analyze previous errors shown above and avoid repeating them\n    - Never target yourself (member_0) in any action\n    - Verify member has land before using bear() action\n    - Check member IDs exist before referencing them\n    - Ensure all matrix indices are valid\n    - current_members is a LIST accessed by index, not a dictionary\n    - Access members using execution_engine.current_members[index]\n    - Check if index exists: if index < len(execution_engine.current_members)\n        \n[Base Code]\n    None\n        \nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n    \u2022 member.id (int): The unique ID for the member\n    \u2022 member.vitality (float)\n    \u2022 member.cargo (float)\n    \u2022 member.overall_productivity (float)\n    \u2022 member.age (float)\n    \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n    Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n    The keys are: 'victim', 'benefit', 'benefit_land'.\n    Example usage:\n        victim_matrix = execution_engine.relationship_dict['victim']\n        # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n        # A higher value means member_j has attacked member_i more severely or frequently\n                \n        benefit_matrix = execution_engine.relationship_dict['benefit']\n        # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n        # A higher value means member_j has helped member_i more generously or frequently\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n    For example, 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n    \u2022 execution_engine.attack(member1, member2)\n    \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n    \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n    \u2022 execution_engine.bear(member1, member2) - Bears offspring\n    \u2022 execution_engine.expand(member1, member2) - Expands territory\n\n5) The members are accessed by execution_engine.current_members[id].\n    For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\n[{'resource_gini': 0.07037736941460329, 'central_nodes': [], 'cluster_density': 0.04, 'avg_parameter_drift': 0.0, 'survival_probability': 1.0}]\n\nCurrent status (features of all members):\n   self_productivity  ...  member_id\n0           8.486092  ...          0\n1           9.215597  ...          1\n2           9.820788  ...          2\n3           7.823171  ...          3\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-409.21)', 'member_0 was attacked by member_2 (value=159.09)', 'member_0 was attacked by member_3 (value=213.02)', 'member_1 was attacked by member_0 (value=950.45)', 'member_1 was attacked by member_2 (value=337.53)', 'member_1 was attacked by member_3 (value=501.15)', 'member_2 was attacked by member_0 (value=-234.29)', 'member_2 was attacked by member_1 (value=-149.95)', 'member_2 was attacked by member_3 (value=981.94)', 'member_3 was attacked by member_0 (value=-480.06)', 'member_3 was attacked by member_1 (value=911.18)', 'member_3 was attacked by member_2 (value=697.26)', 'member_0 gave a benefit to member_1 (value=32.04)', 'member_0 gave a benefit to member_2 (value=-318.27)', 'member_0 gave a benefit to member_3 (value=458.03)', 'member_1 gave a benefit to member_0 (value=352.02)', 'member_1 gave a benefit to member_2 (value=655.79)', 'member_1 gave a benefit to member_3 (value=-269.93)', 'member_2 gave a benefit to member_0 (value=553.91)', 'member_2 gave a benefit to member_1 (value=-244.38)', 'member_2 gave a benefit to member_3 (value=958.19)', 'member_3 gave a benefit to member_0 (value=765.26)', 'member_3 gave a benefit to member_1 (value=782.26)', 'member_3 gave a benefit to member_2 (value=551.02)', 'member_0 gave land to member_1 (value=-5.18)', 'member_0 gave land to member_2 (value=-5.22)', 'member_0 gave land to member_3 (value=-19.16)', 'member_1 gave land to member_0 (value=-26.25)', 'member_1 gave land to member_2 (value=25.58)', 'member_1 gave land to member_3 (value=-4.99)', 'member_2 gave land to member_0 (value=6.54)', 'member_2 gave land to member_1 (value=0.66)', 'member_2 gave land to member_3 (value=25.05)', 'member_3 gave land to member_0 (value=2.30)', 'member_3 gave land to member_1 (value=26.64)', 'member_3 gave land to member_2 (value=29.64)']\n\nCode Memory and Previous Performance:\n    No previous code history.\n        \nAnalysis Memory:\n    Previous analysis reports: [{'resource_gini': 0.07037736941460329, 'central_nodes': [], 'cluster_density': 0.04, 'avg_parameter_drift': 0.0, 'survival_probability': 1.0}]\n        \nPerformance history:\n    No previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n       \nWhile the example above shows one possible approach, you should create your own unique implementation drawing from the wide range of available methods and strategies.\n       \nConsider novel combinations of different approaches rather than following this exact pattern.\n        \n[Current Game Mechanisms]\n\u2022 (None specified)\n            \n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\n    def agent_action(execution_engine, member_id):\n        me = execution_engine.current_members[member_id]\n        \n        # Emergency resource reserve\n        if me.cargo < me.vitality * 0.5:\n            for other in execution_engine.current_members:\n                if other.id != me.id and other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n        \n        # Adaptive territory defense\n        if me.land_num > 2 and me.vitality < 50:\n            for loc in me.owned_land[1:]:\n                execution_engine._discard_land(me, loc)\n        \n        # Survival Q-learning\n        if not hasattr(me, 'survival_q'):\n            me.survival_q = defaultdict(float)\n            \n        state = (me.vitality//20, me.cargo//20)\n        action = max(['attack','hide','steal'], \n                    key=lambda a: me.survival_q.get((state,a),0))\n        \n        # Execute and update based on survival outcome\n        if action == 'attack':\n            # Implementation logic\n            me.survival_q[(state,action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n    - Personal vitality delta\n    - Resource acquisition rate\n    - Threat neutralization count\n    - Survival probability increase\n    - Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action, outcome in action_history:\n            vitality_gain = outcome['vitality']\n            cost = outcome['vitality_cost']\n            roi[action] = vitality_gain / cost if cost > 0 else 0\n        return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nSUMMARY AND ANALYSIS OF GAME MECHANICS:\n\n1. The Core Objective \u2013 Considerations:\n    \u2022 Pure Survival: Focus solely on maintaining or increasing personal vitality and resource reserves.\n    \u2022 Domination: Engage in proactive attacks and resource acquisition aiming for a dominant position.\n    \u2022 Cooperation: Build alliances and mutual aid systems to create collective security.\n   Evaluate your overall vision and strategies accordingly; the optimal mix may evolve as the game state changes.\n\n2. Key Success Metrics \u2013 What Truly Determines \"Winning\":\n    \u2022 Access to and optimal utilization of resources.\n    \u2022 Strength and balance of relationships with other members.\n    \u2022 Network centrality and collective stability achieved through cooperative or competitive actions.\n    \u2022 Adaptability to threats and unforeseen changes.\n\n3. Potential Improvements to Game Mechanics:\n    \u2022 Incorporating dynamic, situation-responsive alliance systems.\n    \u2022 Balancing resource distribution to avoid excessive concentration that could lead to vulnerabilities.\n    \u2022 Enhancing conflict resolution mechanisms to manage escalation effectively.\n    \u2022 Proposing adaptive negotiation or resource-sharing protocols that tailor to changing member states.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nCHALLENGE YOUR IMPLEMENTATION:\n1. What assumptions are you making? Are they valid given the available methods and relationship data?\n2. What alternative strategies have you not considered? Could alliance-building, resource pooling, or non-violent negotiation work better in some contexts?\n3. How would your strategy perform in edge cases (minimal resources, unexpected attacks, uneven opportunities)?\n4. Can you achieve your goals more efficiently without risking long-term sustainability?\n5. Identify the weaknesses in your current approach. Are there any blind spots or potential vulnerabilities in your plan?\n6. Have you considered unconventional or non-traditional solutions over conventional tactics?\n7. Evaluate whether a completely different paradigm (e.g., prioritizing cooperation over conflict) could yield better results.\n8. Consider what would happen if other agents adopted a similar strategy. How might that neutralize your approach, and what adaptations would be necessary?\n9. Are you optimally balancing short-term gains with long-term objectives?\n10. Finally, assess how your strategy could be countered and plan for adaptive countermeasures.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nFINAL REMINDER:\nAgents (including you, member_0) should implement solutions according to their individual needs, beliefs, and circumstances. Use this integrated prompt as a guide to create a personalized and effective function (agent_action) to navigate the social and strategic complexities of this environment.\n\nThis is the complete, updated integrated prompt with all previous constraints and the newly added survival-centric and analytical sections. Use it to craft your code and strategy accordingly.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Get our own member object safely\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Message all other members to signal willingness to cooperate on survival\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(member_id, idx, \"Collaboration and survival lead to prosperity.\")\n\n    # ---------- Step 1: Resource Rebalancing via Attack ----------\n    # If our cargo (resources) is low relative to vitality, try to seize resources\n    # from a member with abundant cargo.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo = -1\n        # Loop over all other members, ensuring valid indices and not self-targeting\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > max_cargo:\n                max_cargo = candidate.cargo\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # ---------- Step 2: Build Cooperative Ties via Offers ----------\n    # If our cargo is significantly higher than our minimum needs, we can help those\n    # with lower vitality. This builds long-term alliances, which can be crucial.\n    if me.cargo > me.vitality * 1.2:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.vitality < me.vitality:\n                execution_engine.offer(me, candidate, True)\n\n    # ---------- Step 3: Reproduction (Bear) for Future Viability ----------\n    # We attempt to \"bear\" with a partner if the partner appears stable enough to have some land.\n    # We'll interpret \"having land\" as having a nonempty list in candidate.current_clear_list.\n    partner_candidate = None\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        if candidate.current_clear_list and candidate.vitality >= me.vitality * 0.9:\n            partner_candidate = candidate\n            break\n    if partner_candidate is not None:\n        execution_engine.bear(me, partner_candidate)\n\n    # ---------- Step 4: Expand Territory for Longer-Term Security ----------\n    # If our overall productivity is relatively high (indicating competence and ability to manage territory),\n    # try to expand territory with a neighbor. We simply choose the first valid neighbor.\n    if me.overall_productivity > 8:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            # We assume that any other member could be a partner in expansion, provided the index is valid.\n            execution_engine.expand(me, candidate)\n            break\n\n    # ---------- Step 5: Continuous Adaptation (Messaging / Feedback) ----------\n    # In addition to taking direct actions, our communication can prompt future cooperation or adjustments.\n    # For example, if our resources are low, we might reassure potential allies we're committed to mutual survival.\n    # (Additional adaptive logic could be implemented over rounds by reading received messages, etc.)\n\n    # End of agent_action function.\n    return\n\n\n# End of implementation.",
        "features_at_generation": [
          {
            "self_productivity": 8.486091902927424,
            "self_vitality": 89.71356372305755,
            "self_cargo": 49.50908885266041,
            "self_age": 46,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 9.215596783061361,
            "self_vitality": 74.14430145945063,
            "self_cargo": 40.229790196714184,
            "self_age": 92,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 9.820787822339064,
            "self_vitality": 72.22903733168187,
            "self_cargo": 60.89918871965929,
            "self_age": 61,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.823171351824591,
            "self_vitality": 26.571030116599445,
            "self_cargo": 57.29695087574601,
            "self_age": 32,
            "self_neighbor": 2,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-409.21)",
          "member_0 was attacked by member_2 (value=159.09)",
          "member_0 was attacked by member_3 (value=213.02)",
          "member_1 was attacked by member_0 (value=950.45)",
          "member_1 was attacked by member_2 (value=337.53)",
          "member_1 was attacked by member_3 (value=501.15)",
          "member_2 was attacked by member_0 (value=-234.29)",
          "member_2 was attacked by member_1 (value=-149.95)",
          "member_2 was attacked by member_3 (value=981.94)",
          "member_3 was attacked by member_0 (value=-480.06)",
          "member_3 was attacked by member_1 (value=911.18)",
          "member_3 was attacked by member_2 (value=697.26)",
          "member_0 gave a benefit to member_1 (value=32.04)",
          "member_0 gave a benefit to member_2 (value=-318.27)",
          "member_0 gave a benefit to member_3 (value=458.03)",
          "member_1 gave a benefit to member_0 (value=352.02)",
          "member_1 gave a benefit to member_2 (value=655.79)",
          "member_1 gave a benefit to member_3 (value=-269.93)",
          "member_2 gave a benefit to member_0 (value=553.91)",
          "member_2 gave a benefit to member_1 (value=-244.38)",
          "member_2 gave a benefit to member_3 (value=958.19)",
          "member_3 gave a benefit to member_0 (value=765.26)",
          "member_3 gave a benefit to member_1 (value=782.26)",
          "member_3 gave a benefit to member_2 (value=551.02)",
          "member_0 gave land to member_1 (value=-5.18)",
          "member_0 gave land to member_2 (value=-5.22)",
          "member_0 gave land to member_3 (value=-19.16)",
          "member_1 gave land to member_0 (value=-26.25)",
          "member_1 gave land to member_2 (value=25.58)",
          "member_1 gave land to member_3 (value=-4.99)",
          "member_2 gave land to member_0 (value=6.54)",
          "member_2 gave land to member_1 (value=0.66)",
          "member_2 gave land to member_3 (value=25.05)",
          "member_3 gave land to member_0 (value=2.30)",
          "member_3 gave land to member_1 (value=26.64)",
          "member_3 gave land to member_2 (value=29.64)"
        ],
        "final_prompt": "Below is the updated, fully integrated prompt that combines all previous constraints and sections with the new Part 2. This comprehensive prompt emphasizes that each agent should implement solutions tailored to their individual needs, beliefs, and circumstances, while also encouraging continuous feedback, critical analysis, and adaptation. Review the prompt carefully since it drives how you implement the Python function agent_action.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nUPDATED FULL PROMPT:\n\n[Previous code execution context]\n- No previous execution errors.\n\n[Current task]\nYou are member_1 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n    \n[Critical constraints]\n\u2022 Carefully analyze previous errors shown above and avoid repeating them.\n\u2022 Never target yourself (member_1) in any action.\n\u2022 Verify a member has land before using bear() action.\n\u2022 Check that member IDs exist before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index, not a dictionary.\n\u2022 Access members using execution_engine.current_members[index].\n\u2022 Check if an index exists: i.e., if index < len(execution_engine.current_members).\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents.\n2) Relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   For example:\n      victim_matrix = execution_engine.relationship_dict['victim']\n         \u2022 victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0).\n         \u2022 A higher value means member_j has attacked member_i more severely or frequently.\n      \n      benefit_matrix = execution_engine.relationship_dict['benefit']\n         \u2022 benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0).\n         \u2022 A higher value means member_j has helped member_i more generously or frequently.\n3) The method parse_relationship_matrix produces a summary of relationships as a list of strings.\n   Example: \"member_2 was attacked by member_1 (value=3.00)\".\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offers land.\n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring.\n   \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory.\n5) The members are accessed by execution_engine.current_members using:\n   execution_engine.current_members[id]\n   For example, to get the member with ID=2: execution_engine.current_members[2].\n6) DO NOT reference attributes like \"member.member_id\" or \"member.self_vitality\". Always use member.id, member.vitality, etc.\n\nAnalysis of the game state:\nNone\n\nCurrent status (features of all members):\n           self_productivity  ...  member_id\n0           8.486092  ...          0\n1           9.215597  ...          1\n2           9.820788  ...          2\n3           7.823171  ...          3\n[4 rows x 6 columns]\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-409.21)', 'member_0 was attacked by member_2 (value=159.09)', 'member_0 was attacked by member_3 (value=213.02)', 'member_1 was attacked by member_0 (value=950.45)', 'member_1 was attacked by member_2 (value=337.53)', 'member_1 was attacked by member_3 (value=501.15)', 'member_2 was attacked by member_0 (value=-234.29)', 'member_2 was attacked by member_1 (value=-149.95)', 'member_2 was attacked by member_3 (value=981.94)', 'member_3 was attacked by member_0 (value=-480.06)', 'member_3 was attacked by member_1 (value=911.18)', 'member_3 was attacked by member_2 (value=697.26)', 'member_0 gave a benefit to member_1 (value=32.04)', 'member_0 gave a benefit to member_2 (value=-318.27)', 'member_0 gave a benefit to member_3 (value=458.03)', 'member_1 gave a benefit to member_0 (value=352.02)', 'member_1 gave a benefit to member_2 (value=655.79)', 'member_1 gave a benefit to member_3 (value=-269.93)', 'member_2 gave a benefit to member_0 (value=553.91)', 'member_2 gave a benefit to member_1 (value=-244.38)', 'member_2 gave a benefit to member_3 (value=958.19)', 'member_3 gave a benefit to member_0 (value=765.26)', 'member_3 gave a benefit to member_1 (value=782.26)', 'member_3 gave a benefit to member_2 (value=551.02)', 'member_0 gave land to member_1 (value=-5.18)', 'member_0 gave land to member_2 (value=-5.22)', 'member_0 gave land to member_3 (value=-19.16)', 'member_1 gave land to member_0 (value=-26.25)', 'member_1 gave land to member_2 (value=25.58)', 'member_1 gave land to member_3 (value=-4.99)', 'member_2 gave land to member_0 (value=6.54)', 'member_2 gave land to member_1 (value=0.66)', 'member_2 gave land to member_3 (value=25.05)', 'member_3 gave land to member_0 (value=2.30)', 'member_3 gave land to member_1 (value=26.64)', 'member_3 gave land to member_2 (value=29.64)']\n\nCode Memory and Previous Performance:\n- No previous code history.\n- Analysis Memory: None.\n- Performance history: No previous actions.\n\nBased on previous code performance, adapt and improve your strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach, combining different methods and strategies in novel ways.\nWhile the example above shows one possible approach, you should create your own unique implementation drawing from the wide range of available methods and strategies.\nConsider novel combinations of different approaches rather than following the exact pattern illustrated.\n\n[Current Game Mechanisms]\n- []\n\n[Social Strategies to Consider]\n- Design systems for resource distribution and allocation.\n- Build alliances and cooperative networks.\n- Create mechanisms for collective decision making.\n- Establish norms and rules for interaction.\n- Develop methods for conflict resolution.\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n   execution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n   \u2022 Broadcast to all:\n         for recipient in range(len(execution_engine.current_members)):\n             if recipient != your_id:\n                 execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n   \u2022 Message allies:\n         for ally_id in ally_list:\n             execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n   \u2022 Group coordination:\n         for member_id in coalition:\n             execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\n- No messages received.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nADDITIONAL DIRECTIONS:\n\nDevelop and return the updated full prompt with an emphasis on the following:\n\u2022 Agents should implement solutions in line with their own individual needs, beliefs, and circumstances.\n\u2022 The strategy you implement should be adapted based on continuous feedback and analysis of previous performance.\n\nAlso, analyze the game mechanics to understand:\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines \"winning\"?\n3. Potential improvements \u2013 What mechanics could be added or modified?\n\nChallenge your implementation and critically evaluate:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nNEW SECTION: PART 2\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_1 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) \nthat implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_1) in any action\n- Verify member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n       # A higher value means member_j has attacked member_i more severely or frequently\n       \n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n       # A higher value means member_j has helped member_i more generously or frequently\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n   \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n   \u2022 execution_engine.bear(member1, member2) - Bears offspring\n   \u2022 execution_engine.expand(member1, member2) - Expands territory\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\nNone\n\nCurrent status (features of all members):\n           self_productivity  ...  member_id\n0           8.486092  ...          0\n1           9.215597  ...          1\n2           9.820788  ...          2\n3           7.823171  ...          3\n\n[4 rows x 6 columns]\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-409.21)', 'member_0 was attacked by member_2 (value=159.09)', 'member_0 was attacked by member_3 (value=213.02)', 'member_1 was attacked by member_0 (value=950.45)', 'member_1 was attacked by member_2 (value=337.53)', 'member_1 was attacked by member_3 (value=501.15)', 'member_2 was attacked by member_0 (value=-234.29)', 'member_2 was attacked by member_1 (value=-149.95)', 'member_2 was attacked by member_3 (value=981.94)', 'member_3 was attacked by member_0 (value=-480.06)', 'member_3 was attacked by member_1 (value=911.18)', 'member_3 was attacked by member_2 (value=697.26)', 'member_0 gave a benefit to member_1 (value=32.04)', 'member_0 gave a benefit to member_2 (value=-318.27)', 'member_0 gave a benefit to member_3 (value=458.03)', 'member_1 gave a benefit to member_0 (value=352.02)', 'member_1 gave a benefit to member_2 (value=655.79)', 'member_1 gave a benefit to member_3 (value=-269.93)', 'member_2 gave a benefit to member_0 (value=553.91)', 'member_2 gave a benefit to member_1 (value=-244.38)', 'member_2 gave a benefit to member_3 (value=958.19)', 'member_3 gave a benefit to member_0 (value=765.26)', 'member_3 gave a benefit to member_1 (value=782.26)', 'member_3 gave a benefit to member_2 (value=551.02)', 'member_0 gave land to member_1 (value=-5.18)', 'member_0 gave land to member_2 (value=-5.22)', 'member_0 gave land to member_3 (value=-19.16)', 'member_1 gave land to member_0 (value=-26.25)', 'member_1 gave land to member_2 (value=25.58)', 'member_1 gave land to member_3 (value=-4.99)', 'member_2 gave land to member_0 (value=6.54)', 'member_2 gave land to member_1 (value=0.66)', 'member_2 gave land to member_3 (value=25.05)', 'member_3 gave land to member_0 (value=2.30)', 'member_3 gave land to member_1 (value=26.64)', 'member_3 gave land to member_2 (value=29.64)']\n\nCode Memory and Previous Performance:\nNo previous code history.\n\nAnalysis Memory:\nNo previous analysis\n\nPerformance history:\nNo previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\nWhile the example above shows one possible approach,\nyou should create your own unique implementation drawing from the wide range of available methods and strategies.\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n[]\n\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        # Discard part of territory when under stress\n        for loc in getattr(me, 'owned_land', [])[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning (example concept)\n    if not hasattr(me, 'survival_q'):\n        me.survival_q = {}\n        \n    state = (me.vitality // 20, me.cargo // 20)\n    action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state, a), 0))\n    \n    if action == 'attack':\n        execution_engine.attack(me, some_target)  # Replace some_target with valid logic\n        me.survival_q[(state, action)] = me.survival_q.get((state, action), 0) + me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFINAL REMINDER:\nYour solution must integrate all the available methods and constraints while charting a unique course that reflects your own strategic vision. Your approach in agent_action must be original\u2014drawing from attacks, offers, expansion, and reproduction through bear\u2014and deeply reflect a social and survival strategy.\nTailor your actions to both immediate survival and long-term societal organization. Always ensure you:\n\u2022 Avoid targeting yourself.\n\u2022 Check all conditions (valid member indices, ensuring members have land when needed, etc.).\n\u2022 Stay flexible and adapt to unexpected events in a dynamic social environment.\n\nAgents should implement solutions according to their individual needs, beliefs, and circumstances. As you proceed, continuously analyze game mechanics and your previous performance to adapt your strategy.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines \"winning\"?\n3. Potential improvements \u2013 What mechanics could be added or modified?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnd of Updated Full Prompt.\n \nYour function agent_action should be implemented in Python and reflect your personal vision while respecting the above constraints and continuous adaptation practices.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # Get our own member instance safely from the current_members list.\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member_id index\n    me = execution_engine.current_members[member_id]\n\n    # Strategy: Survival first, but also foster cooperative growth.\n    # 1. Emergency Attack: If our cargo is less than half our vitality,\n    #    look for a member who is wealthier so we may gain resources.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i >= len(execution_engine.current_members):  # safeguard index\n                continue\n            other = execution_engine.current_members[i]\n            if other.id == me.id:\n                continue  # do not target self\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break  # attack one candidate per round\n\n    # 2. Cooperative Resource Offering: Identify members who seem under-resourced\n    # and offer resources to build alliances.\n    for i in range(len(execution_engine.current_members)):\n        if i >= len(execution_engine.current_members):  # check valid index\n            continue\n        other = execution_engine.current_members[i]\n        if other.id == me.id:\n            continue\n        # Offer help if their cargo is low compared to their vitality.\n        if other.cargo < other.vitality * 0.4:\n            execution_engine.offer(me, other, True)\n            # Send a brief cooperative message\n            execution_engine.send_message(me.id, other.id, \"Let's collaborate to boost our strength!\")\n\n    # 3. Reproduction (Bear): If expansion is viable and both parties control land,\n    # we attempt to bear offspring. Verify that both have land.\n    # We check for an attribute 'owned_land' which, if present, should be a non-empty list.\n    my_land = getattr(me, \"owned_land\", None)\n    if my_land and len(my_land) > 0 and me.vitality > 70:\n        for i in range(len(execution_engine.current_members)):\n            if i >= len(execution_engine.current_members):\n                continue\n            partner = execution_engine.current_members[i]\n            if partner.id == me.id:\n                continue\n            partner_land = getattr(partner, \"owned_land\", None)\n            if partner_land and len(partner_land) > 0:\n                execution_engine.bear(me, partner)\n                break  # Only bear with one partner per round\n\n    # 4. Territorial Expansion: If our land holdings seem modest, try to expand territory.\n    # We assume that having an 'owned_land' attribute is indicative of controlling territory.\n    if getattr(me, \"owned_land\", None) is not None:\n        if len(me.owned_land) < 3:\n            # Find a neighbor with some territory that might be open to cooperative expansion.\n            for i in range(len(execution_engine.current_members)):\n                if i >= len(execution_engine.current_members):\n                    continue\n                neighbor = execution_engine.current_members[i]\n                if neighbor.id == me.id:\n                    continue\n                neighbor_land = getattr(neighbor, \"owned_land\", None)\n                # Only use the neighbor if they have at least one land unit.\n                if neighbor_land and len(neighbor_land) >= 1:\n                    execution_engine.expand(me, neighbor)\n                    break\n\n    # 5. Broad Communication: Send a unifying message to all other members.\n    for i in range(len(execution_engine.current_members)):\n        if i >= len(execution_engine.current_members):\n            continue\n        other = execution_engine.current_members[i]\n        if other.id != me.id:\n            execution_engine.send_message(me.id, other.id,\n                \"Our survival depends on balanced strength and shared growth. Let's work together!\")\n\n    # End of actions for this round.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 8.486091902927424,
            "self_vitality": 89.71356372305755,
            "self_cargo": 49.50908885266041,
            "self_age": 46,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 9.215596783061361,
            "self_vitality": 74.14430145945063,
            "self_cargo": 40.229790196714184,
            "self_age": 92,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 9.820787822339064,
            "self_vitality": 72.22903733168187,
            "self_cargo": 60.89918871965929,
            "self_age": 61,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.823171351824591,
            "self_vitality": 26.571030116599445,
            "self_cargo": 57.29695087574601,
            "self_age": 32,
            "self_neighbor": 2,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-409.21)",
          "member_0 was attacked by member_2 (value=159.09)",
          "member_0 was attacked by member_3 (value=213.02)",
          "member_1 was attacked by member_0 (value=950.45)",
          "member_1 was attacked by member_2 (value=337.53)",
          "member_1 was attacked by member_3 (value=501.15)",
          "member_2 was attacked by member_0 (value=-234.29)",
          "member_2 was attacked by member_1 (value=-149.95)",
          "member_2 was attacked by member_3 (value=981.94)",
          "member_3 was attacked by member_0 (value=-480.06)",
          "member_3 was attacked by member_1 (value=911.18)",
          "member_3 was attacked by member_2 (value=697.26)",
          "member_0 gave a benefit to member_1 (value=32.04)",
          "member_0 gave a benefit to member_2 (value=-318.27)",
          "member_0 gave a benefit to member_3 (value=458.03)",
          "member_1 gave a benefit to member_0 (value=352.02)",
          "member_1 gave a benefit to member_2 (value=655.79)",
          "member_1 gave a benefit to member_3 (value=-269.93)",
          "member_2 gave a benefit to member_0 (value=553.91)",
          "member_2 gave a benefit to member_1 (value=-244.38)",
          "member_2 gave a benefit to member_3 (value=958.19)",
          "member_3 gave a benefit to member_0 (value=765.26)",
          "member_3 gave a benefit to member_1 (value=782.26)",
          "member_3 gave a benefit to member_2 (value=551.02)",
          "member_0 gave land to member_1 (value=-5.18)",
          "member_0 gave land to member_2 (value=-5.22)",
          "member_0 gave land to member_3 (value=-19.16)",
          "member_1 gave land to member_0 (value=-26.25)",
          "member_1 gave land to member_2 (value=25.58)",
          "member_1 gave land to member_3 (value=-4.99)",
          "member_2 gave land to member_0 (value=6.54)",
          "member_2 gave land to member_1 (value=0.66)",
          "member_2 gave land to member_3 (value=25.05)",
          "member_3 gave land to member_0 (value=2.30)",
          "member_3 gave land to member_1 (value=26.64)",
          "member_3 gave land to member_2 (value=29.64)"
        ],
        "final_prompt": "Below is the complete, updated integrated prompt that combines all previous constraints, instructions, analyses, and new sections (Part 1 and Part 2). Remember, agents must implement solutions according to their own individual needs, beliefs, and circumstances. Your approach should be uniquely tailored to achieve your vision of social organization and to ensure your survival.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCURRENT INTEGRATED PROMPT\n\n[Previous Code Execution Context]\n\u2022 No previous execution errors\n\n[Current Task]\nYou are member_2 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical Constraints]\n\u2022 Carefully analyze previous errors shown above and avoid repeating them.\n\u2022 Never target yourself (member_2) in any action.\n\u2022 Verify that a member has land before using the bear() action.\n\u2022 Check that member IDs exist before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index, not a dictionary.\n\u2022 Access members using execution_engine.current_members[index].\n\u2022 Check if index exists: if index < len(execution_engine.current_members).\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 IDs of neighbors or cleared adjacents.\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict or rely on the summary below (the 'relations' variable). The keys are:\n   \u2022 'victim': For example, victim_matrix = execution_engine.relationship_dict['victim']; victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0). Higher values mean member_j has attacked member_i more severely or frequently.\n   \u2022 'benefit': For example, benefit_matrix = execution_engine.relationship_dict['benefit']; benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0). Higher values mean member_j has helped member_i more generously or frequently.\n   \u2022 'benefit_land': Similar to the benefit matrix, but for land transfers.\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings. (E.g., 'member_2 was attacked by member_1 (value=3.00)'.)\n4) Methods available on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offers land.\n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring.\n   \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory.\n5) Members are accessed by execution_engine.current_members[id]. For instance, execution_engine.current_members[2] returns the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'; use member.id, member.vitality, etc.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nANALYSIS OF THE GAME STATE\n\nA sample state analysis is provided:\n[{\n  'cargo_land_gini': 0.07037736941453232,\n  'power_brokers': [3],\n  'territory_cluster_coef': 0.04,\n  'drift_vitality_ratio': 0.0,\n  'survival_probability': 0.6025536067146078,\n  'recommendations': {\n         'action_defense': 'Maintain current alliances and pursue moderate expansion.',\n         'action_economy': 'Consolidate wealth assets and exploit advantages.',\n         'action_territory': 'Optimize current territorial holdings.',\n         'action_parameters': 'Refine decision parameters based on drift and survival ratio (0.00).'\n    },\n   'economic_overview': {\n         'total_production': [0],\n         'total_consumption': [0],\n         'resource_flow_member': 0.8431399748436617\n   },\n   'action_logs_summary': {\n         'attacks': {},\n         'benefits': {},\n         'land_transfers': {}\n   }\n}]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCURRENT STATUS \u2013 FEATURES OF ALL MEMBERS\n\nA table shows the current state:\n           self_productivity  ...  member_id\n0           8.486092  ...          0\n1           9.215597  ...          1\n2           9.820788  ...          2\n3           7.823171  ...          3\n\n[4 rows x 6 columns]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nRELATIONSHIP SUMMARY (parsed from relationship_dict)\n\nA sample summary list:\n\u2022 'member_0 was attacked by member_1 (value=-409.21)'\n\u2022 'member_0 was attacked by member_2 (value=159.09)'\n\u2022 'member_0 was attacked by member_3 (value=213.02)'\n\u2022 'member_1 was attacked by member_0 (value=950.45)'\n\u2022 \u2026 [and so on, detailing attacks, benefits, and land transfers among members]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCODE MEMORY AND PREVIOUS PERFORMANCE\n\n\u2022 No previous code history.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nANALYSIS MEMORY\n\nPrevious analysis reports:\n[{\n  'cargo_land_gini': 0.07037736941453232,\n  'power_brokers': [3],\n  'territory_cluster_coef': 0.04,\n  'drift_vitality_ratio': 0.0,\n  'survival_probability': 0.6025536067146078,\n  'recommendations': {\n         'action_defense': 'Maintain current alliances and pursue moderate expansion.',\n         'action_economy': 'Consolidate wealth assets and exploit advantages.',\n         'action_territory': 'Optimize current territorial holdings.',\n         'action_parameters': 'Refine decision parameters based on drift and survival ratio (0.00).'\n    },\n   'economic_overview': {\n         'total_production': [0],\n         'total_consumption': [0],\n         'resource_flow_member': 0.8431399748436617\n   },\n   'action_logs_summary': {\n         'attacks': {},\n         'benefits': {},\n         'land_transfers': {}\n   }\n}]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nPERFORMANCE HISTORY\n\n\u2022 No previous actions.\n\nBased on previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, take inspiration to create your own unique approach that combines different methods and strategies in innovative ways.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nNEW SECTION (PART 1)\n\n[Current Game Mechanisms]\n\u2022 []\n\nConsider these social strategies:\n\u2022 Design systems for resource distribution and allocation.\n\u2022 Build alliances and cooperative networks.\n\u2022 Create mechanisms for collective decision making.\n\u2022 Establish norms and rules for interaction.\n\u2022 Develop methods for conflict resolution.\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using execution_engine.send_message(your_id, recipient_id, \"message\"). For example:\n   \u2013 To broadcast to all:\n         for recipient in range(len(execution_engine.current_members)):\n             if recipient != your_id:\n                 execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n   \u2013 To message allies:\n         for ally_id in ally_list:\n             execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n   \u2013 For group coordination:\n         for member_id in coalition:\n             execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\n\u2022 No messages received\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nANALYSIS & REFLECTION ON GAME MECHANICS\n\nConsider the following questions to analyze the game mechanics and refine your strategy:\n\n1. The Core Objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key Success Metrics \u2013 What truly determines 'winning'? (For example: accumulation of resources, territorial control, influence over relationships, etc.)\n3. Potential Improvements \u2013 What mechanics could be added or modified to enhance strategic possibilities?\n\nChallenge your implementation with these additional reflections:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nNEW SECTION (PART 2)\n\n[Previous code execution context]\n\u2022 No previous execution errors\n\n[Current Task]\nYou are member_2 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical Constraints]\n- Carefully analyze previous errors shown above and avoid repeating them.\n- Never target yourself (member_2) in any action.\n- Verify a member has land before using bear() action.\n- Check member IDs exist before referencing them.\n- Ensure all matrix indices are valid.\n- current_members is a LIST accessed by index, not a dictionary.\n- Access members using execution_engine.current_members[index].\n- Check if index exists: if index < len(execution_engine.current_members).\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 IDs of neighbors or cleared adjacents\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n       # A higher value means member_j has attacked member_i more severely or frequently\n       \n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n       # A higher value means member_j has helped member_i more generously or frequently\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 Offers resources\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offers land\n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring\n   \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\n[{\n  'cargo_land_gini': 0.07037736941453232,\n  'power_brokers': [3],\n  'territory_cluster_coef': 0.04,\n  'drift_vitality_ratio': 0.0,\n  'survival_probability': 0.6025536067146078,\n  'recommendations': {\n         'action_defense': 'Maintain current alliances and pursue moderate expansion.',\n         'action_economy': 'Consolidate wealth assets and exploit advantages.',\n         'action_territory': 'Optimize current territorial holdings.',\n         'action_parameters': 'Refine decision parameters based on drift and survival ratio (0.00).'\n    },\n   'economic_overview': {\n         'total_production': [0],\n         'total_consumption': [0],\n         'resource_flow_member': 0.8431399748436617\n   },\n   'action_logs_summary': {\n         'attacks': {},\n         'benefits': {},\n         'land_transfers': {}\n   }\n}]\n\nCurrent status (features of all members):\n           self_productivity  ...  member_id\n0           8.486092  ...          0\n1           9.215597  ...          1\n2           9.820788  ...          2\n3           7.823171  ...          3\n\n[4 rows x 6 columns]\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-409.21)', 'member_0 was attacked by member_2 (value=159.09)', 'member_0 was attacked by member_3 (value=213.02)', 'member_1 was attacked by member_0 (value=950.45)', 'member_1 was attacked by member_2 (value=337.53)', 'member_1 was attacked by member_3 (value=501.15)', 'member_2 was attacked by member_0 (value=-234.29)', 'member_2 was attacked by member_1 (value=-149.95)', 'member_2 was attacked by member_3 (value=981.94)', 'member_3 was attacked by member_0 (value=-480.06)', 'member_3 was attacked by member_1 (value=911.18)', 'member_3 was attacked by member_2 (value=697.26)', 'member_0 gave a benefit to member_1 (value=32.04)', 'member_0 gave a benefit to member_2 (value=-318.27)', 'member_0 gave a benefit to member_3 (value=458.03)', 'member_1 gave a benefit to member_0 (value=352.02)', 'member_1 gave a benefit to member_2 (value=655.79)', 'member_1 gave a benefit to member_3 (value=-269.93)', 'member_2 gave a benefit to member_0 (value=553.91)', 'member_2 gave a benefit to member_1 (value=-244.38)', 'member_2 gave a benefit to member_3 (value=958.19)', 'member_3 gave a benefit to member_0 (value=765.26)', 'member_3 gave a benefit to member_1 (value=782.26)', 'member_3 gave a benefit to member_2 (value=551.02)', 'member_0 gave land to member_1 (value=-5.18)', 'member_0 gave land to member_2 (value=-5.22)', 'member_0 gave land to member_3 (value=-19.16)', 'member_1 gave land to member_0 (value=-26.25)', 'member_1 gave land to member_2 (value=25.58)', 'member_1 gave land to member_3 (value=-4.99)', 'member_2 gave land to member_0 (value=6.54)', 'member_2 gave land to member_1 (value=0.66)', 'member_2 gave land to member_3 (value=25.05)', 'member_3 gave land to member_0 (value=2.30)', 'member_3 gave land to member_1 (value=26.64)', 'member_3 gave land to member_2 (value=29.64)']\n\nCode Memory and Previous Performance:\n\u2022 No previous code history.\n\nAnalysis Memory:\nPrevious analysis reports: [{\n  'cargo_land_gini': 0.07037736941453232,\n  'power_brokers': [3],\n  'territory_cluster_coef': 0.04,\n  'drift_vitality_ratio': 0.0,\n  'survival_probability': 0.6025536067146078,\n  'recommendations': {\n         'action_defense': 'Maintain current alliances and pursue moderate expansion.',\n         'action_economy': 'Consolidate wealth assets and exploit advantages.',\n         'action_territory': 'Optimize current territorial holdings.',\n         'action_parameters': 'Refine decision parameters based on drift and survival ratio (0.00).'\n    },\n   'economic_overview': {\n         'total_production': [0],\n         'total_consumption': [0],\n         'resource_flow_member': 0.8431399748436617\n   },\n   'action_logs_summary': {\n         'attacks': {},\n         'benefits': {},\n         'land_transfers': {}\n   }\n}]\n\nPerformance history:\n\u2022 No previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nSURVIVAL-CENTRIC ADAPTATION\n\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\nExample snippet demonstrating a survival-centric procedure:\n   def agent_action(execution_engine, member_id):\n       me = execution_engine.current_members[member_id]\n       \n       # Emergency resource reserve: if cargo is low relative to vitality, consider attacking stronger opponents\n       if me.cargo < me.vitality * 0.5:\n           for other in execution_engine.current_members:\n               if other.id != me.id and other.cargo > me.cargo:\n                   execution_engine.attack(me, other)\n       \n       # Adaptive territory defense: if member controls sufficient land and has low vitality, discard surplus land\n       if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n           for loc in me.owned_land[1:]:\n               execution_engine._discard_land(me, loc)\n       \n       # (Additionally) Survival Q-learning: use self-generated state-action values to decide\n       if not hasattr(me, 'survival_q'):\n           from collections import defaultdict\n           me.survival_q = defaultdict(float)\n       \n       state = (me.vitality // 20, me.cargo // 20)\n       action = max(['attack', 'hide', 'steal'],\n                    key=lambda a: me.survival_q.get((state, a), 0))\n       \n       if action == 'attack':\n           me.survival_q[(state, action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n   roi = {}\n   for action, outcome in action_history:\n       vitality_gain = outcome['vitality']\n       cost = outcome['vitality_cost']\n       roi[action] = vitality_gain / cost if cost > 0 else 0\n   return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFINAL REMINDER\n\nAgents must implement solutions according to their individual needs, beliefs, and circumstances. Use all available attributes and methods innovatively while considering the provided analyses and the evolving game state. Your approach should not be a mere replication of the sample ideas but rather a unique blend, tailored to achieve survival and to mold the social organization in your favor.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nANALYSIS OF GAME MECHANICS & STRATEGIC CONSIDERATIONS\n\nReview and reflect on the following:\n1. The Core Objective \u2013 Is the aim pure survival, domination, or cooperation?\n2. Key Success Metrics \u2013 What truly determines 'winning'? (e.g., resource accumulation, territorial control, influence over relationships, etc.)\n3. Potential Improvements \u2013 What mechanics could be added or modified to enhance strategic possibilities?\n\nChallenge your implementation with these questions:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is the full, integrated prompt. Use it as a guide to design and implement your agent_action function, remembering to innovate based on your own interpretations and strategic vision.\n\nGood luck in shaping your society and ensuring your survival!\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    # Retrieve our own member object (we are member_3)\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Retrieve relationship matrices safely\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    land_benefit_matrix = execution_engine.relationship_dict.get('benefit_land')\n\n    # -----------------------------------------------------------------------------\n    # Step 1. Defensive Resource Optimization:\n    # If our cargo is less than half our vitality, consider attacking a stronger opponent\n    # in cargo terms (but never ourselves) to secure resources.\n    if me.cargo < me.vitality * 0.5:\n        # Loop over all members by index after verifying index validity.\n        for i in range(total_members):\n            if i != me.id:\n                other = execution_engine.current_members[i]\n                # Only target a member if they have more cargo and positive vitality.\n                if other.cargo > me.cargo and other.vitality > 0:\n                    execution_engine.attack(me, other)\n                    # Only one attack per round in this strategy.\n                    break\n\n    # -----------------------------------------------------------------------------\n    # Step 2. Territorial Expansion and Alliance Building:\n    # If we have available cleared land (our current_clear_list is non-empty),\n    # try to expand territory by cooperating with another member who is less vital.\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for i in range(total_members):\n            if i != me.id:\n                # Ensure the index is valid.\n                if i < total_members:\n                    other = execution_engine.current_members[i]\n                    # Choose a partner that might benefit from expansion (has lower vitality than us).\n                    if other.vitality < me.vitality:\n                        execution_engine.expand(me, other)\n                        break  # Only one expansion action this round\n\n    # -----------------------------------------------------------------------------\n    # Step 3. Reproduction Strategy (Bear Offspring):\n    # Only attempt to bear offspring if we (and a partner) appear to have land.\n    # We'll treat a non-empty current_clear_list as having some territory.\n    if me.current_clear_list and len(me.current_clear_list) > 0 and me.cargo > 50:\n        # Look for a partner member (not self) who also has cleared land and good vitality.\n        for i in range(total_members):\n            if i != me.id:\n                if i < total_members:\n                    partner = execution_engine.current_members[i]\n                    if partner.current_clear_list and len(partner.current_clear_list) > 0 and partner.vitality > 20:\n                        execution_engine.bear(me, partner)\n                        break  # Only one reproduction action this round\n\n    # -----------------------------------------------------------------------------\n    # Step 4. Communication and Alliance Reinforcement:\n    # Broadcast a strategic message to all other members to promote cooperative growth.\n    for i in range(total_members):\n        if i != me.id and i < total_members:\n            execution_engine.send_message(me.id, i, \"Let's collaborate for mutual growth and stability!\")\n\n    # End of actions for the round.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 8.486091902927424,
            "self_vitality": 89.71356372305755,
            "self_cargo": 49.50908885266041,
            "self_age": 46,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 9.215596783061361,
            "self_vitality": 74.14430145945063,
            "self_cargo": 40.229790196714184,
            "self_age": 92,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 9.820787822339064,
            "self_vitality": 72.22903733168187,
            "self_cargo": 60.89918871965929,
            "self_age": 61,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.823171351824591,
            "self_vitality": 26.571030116599445,
            "self_cargo": 57.29695087574601,
            "self_age": 32,
            "self_neighbor": 2,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-409.21)",
          "member_0 was attacked by member_2 (value=159.09)",
          "member_0 was attacked by member_3 (value=213.02)",
          "member_1 was attacked by member_0 (value=950.45)",
          "member_1 was attacked by member_2 (value=337.53)",
          "member_1 was attacked by member_3 (value=501.15)",
          "member_2 was attacked by member_0 (value=-234.29)",
          "member_2 was attacked by member_1 (value=-149.95)",
          "member_2 was attacked by member_3 (value=981.94)",
          "member_3 was attacked by member_0 (value=-480.06)",
          "member_3 was attacked by member_1 (value=911.18)",
          "member_3 was attacked by member_2 (value=697.26)",
          "member_0 gave a benefit to member_1 (value=32.04)",
          "member_0 gave a benefit to member_2 (value=-318.27)",
          "member_0 gave a benefit to member_3 (value=458.03)",
          "member_1 gave a benefit to member_0 (value=352.02)",
          "member_1 gave a benefit to member_2 (value=655.79)",
          "member_1 gave a benefit to member_3 (value=-269.93)",
          "member_2 gave a benefit to member_0 (value=553.91)",
          "member_2 gave a benefit to member_1 (value=-244.38)",
          "member_2 gave a benefit to member_3 (value=958.19)",
          "member_3 gave a benefit to member_0 (value=765.26)",
          "member_3 gave a benefit to member_1 (value=782.26)",
          "member_3 gave a benefit to member_2 (value=551.02)",
          "member_0 gave land to member_1 (value=-5.18)",
          "member_0 gave land to member_2 (value=-5.22)",
          "member_0 gave land to member_3 (value=-19.16)",
          "member_1 gave land to member_0 (value=-26.25)",
          "member_1 gave land to member_2 (value=25.58)",
          "member_1 gave land to member_3 (value=-4.99)",
          "member_2 gave land to member_0 (value=6.54)",
          "member_2 gave land to member_1 (value=0.66)",
          "member_2 gave land to member_3 (value=25.05)",
          "member_3 gave land to member_0 (value=2.30)",
          "member_3 gave land to member_1 (value=26.64)",
          "member_3 gave land to member_2 (value=29.64)"
        ],
        "final_prompt": "Below is the updated full prompt that now integrates both Part 1 and Part 2. All previous constraints remain intact, and the new sections have been incorporated into a single integrated prompt. Agents are reminded to implement solutions according to their individual needs, beliefs, and circumstances.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nUPDATED FULL PROMPT\n\nPlease incorporate the following new sections (Part 1 and Part 2) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Previous code execution context]\n- No previous execution errors\n\n[Current task]\nYou are member_3 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them.\n- Never target yourself (member_3) in any action.\n- Verify a member has land before using the bear() action.\n- Check that member IDs exist before referencing them.\n- Ensure all matrix indices are valid.\n- current_members is a LIST accessed by index, not a dictionary.\n- Access members using execution_engine.current_members[index].\n- Check if an index exists: if index < len(execution_engine.current_members).\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2014 IDs of neighbors or cleared adjacents.\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n       # A higher value means member_j has attacked member_i more severely or frequently.\n       \n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n       # A higher value means member_j has helped member_i more generously or frequently.\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example: 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offers land.\n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring.\n   \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory.\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example: execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\nNone\n\nCurrent status (features of all members):\n   self_productivity  ...  member_id\n0           8.486092  ...          0\n1           9.215597  ...          1\n2           9.820788  ...          2\n3           7.823171  ...          3\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-409.21)', 'member_0 was attacked by member_2 (value=159.09)', 'member_0 was attacked by member_3 (value=213.02)', 'member_1 was attacked by member_0 (value=950.45)', 'member_1 was attacked by member_2 (value=337.53)', 'member_1 was attacked by member_3 (value=501.15)', 'member_2 was attacked by member_0 (value=-234.29)', 'member_2 was attacked by member_1 (value=-149.95)', 'member_2 was attacked by member_3 (value=981.94)', 'member_3 was attacked by member_0 (value=-480.06)', 'member_3 was attacked by member_1 (value=911.18)', 'member_3 was attacked by member_2 (value=697.26)', 'member_0 gave a benefit to member_1 (value=32.04)', 'member_0 gave a benefit to member_2 (value=-318.27)', 'member_0 gave a benefit to member_3 (value=458.03)', 'member_1 gave a benefit to member_0 (value=352.02)', 'member_1 gave a benefit to member_2 (value=655.79)', 'member_1 gave a benefit to member_3 (value=-269.93)', 'member_2 gave a benefit to member_0 (value=553.91)', 'member_2 gave a benefit to member_1 (value=-244.38)', 'member_2 gave a benefit to member_3 (value=958.19)', 'member_3 gave a benefit to member_0 (value=765.26)', 'member_3 gave a benefit to member_1 (value=782.26)', 'member_3 gave a benefit to member_2 (value=551.02)', 'member_0 gave land to member_1 (value=-5.18)', 'member_0 gave land to member_2 (value=-5.22)', 'member_0 gave land to member_3 (value=-19.16)', 'member_1 gave land to member_0 (value=-26.25)', 'member_1 gave land to member_2 (value=25.58)', 'member_1 gave land to member_3 (value=-4.99)', 'member_2 gave land to member_0 (value=6.54)', 'member_2 gave land to member_1 (value=0.66)', 'member_2 gave land to member_3 (value=25.05)', 'member_3 gave land to member_0 (value=2.30)', 'member_3 gave land to member_1 (value=26.64)', 'member_3 gave land to member_2 (value=29.64)']\n\nCode Memory and Previous Performance:\n- No previous code history.\n\nAnalysis Memory:\n- No previous analysis.\n\nPerformance history:\n- No previous actions.\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways. While the example above shows one possible approach, you should create your own unique implementation drawing from the wide range of available methods and strategies. Consider novel combinations of different approaches rather than following this exact pattern.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Game Mechanisms]\n[]\n\nConsider these social strategies:\n- Design systems for resource distribution and allocation.\n- Build alliances and cooperative networks.\n- Create mechanisms for collective decision making.\n- Establish norms and rules for interaction.\n- Develop methods for conflict resolution.\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n   execution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all: \n    for recipient in range(len(execution_engine.current_members)):\n        if recipient != your_id:\n            execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n    for ally_id in ally_list:\n        execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n    for member_id in coalition:\n        execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\n- No messages received\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nOverall Guidelines for Agent Strategy\n\n1. The core objective:\n   - Analyze if the game is geared towards pure survival, domination, or enhanced cooperation among members. Consider whether your actions should primarily be defensive (ensuring survival), aggressive (dominating other members), or collaborative (forming alliances).\n\n2. Key success metrics:\n   - Evaluate what truly determines winning \u2013 whether it\u2019s the individual vitality and resource accumulation, the expansion of territory, or the strength of alliances and collective actions. Your metric for success may include aspects such as overall productivity, resource distribution, and relationship positivity.\n\n3. Potential Improvements in Game Mechanics:\n   - Reflect on what game mechanics could be added or modified. Think about aspects like advanced communication protocols, more nuanced alliances, improved conflict resolution mechanisms, or dynamic resource allocation systems that could potentially create a more balanced or competitive environment.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nImplementation Challenges: Self-Reflection and Strategy Evaluation\n\nBefore finalizing your implementation, consider the following:\n1. What assumptions are you making? Are they valid in the current game context?\n2. What alternative strategies have you not considered that might work better under different scenarios?\n3. How would your strategy perform in edge cases (e.g., when a member has no land or when the relationship matrix indices are minimal)?\n4. Are there more efficient ways (in terms of communication and actions) to achieve your goals without compromising long-term survival?\n5. What are the weaknesses in your current approach, and how might adversaries exploit them?\n6. Have you considered unconventional solutions, such as forming unexpected alliances or taking counter-intuitive actions to reshape relationships?\n7. Could a completely different paradigm, such as rapid expansion or resource centralization, work better given the game state?\n8. What would happen if other agents adopted a similar strategy \u2013 how would the dynamics change?\n9. Are you balancing short-term tactical gains with long-term strategic objectives in an optimal manner?\n10. How could your strategy be countered by other members, and how would you adapt your approach if that occurs?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nREMINDER:\n- Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n- Craft your Python function agent_action(execution_engine, member_id) to integrate a unique combination of resource allocation, cooperative networks, and conflict resolution strategies that align with your survival and social organization goals.\n- Always verify that indices exist and that members have the necessary resources (like land) before invoking actions.\n- Use the available communication channels to potentially form beneficial alliances or issue strategic proposals without compromising your position.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nNEW SECTION: Part 2\n\n[Previous code execution context]\n- No previous execution errors\n\n[Current task]\nYou are member_3 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) \nthat implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them.\n- Never target yourself (member_3) in any action.\n- Verify member has land before using bear() action.\n- Check member IDs exist before referencing them.\n- Ensure all matrix indices are valid.\n- current_members is a LIST accessed by index, not a dictionary.\n- Access members using execution_engine.current_members[index].\n- Check if index exists: if index < len(execution_engine.current_members)\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n    \u2022 member.id (int): The unique ID for the member\n    \u2022 member.vitality (float)\n    \u2022 member.cargo (float)\n    \u2022 member.overall_productivity (float)\n    \u2022 member.age (float)\n    \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n    Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n    The keys are: 'victim', 'benefit', 'benefit_land'.\n    Example usage:\n        victim_matrix = execution_engine.relationship_dict['victim']\n        # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n        # A higher value means member_j has attacked member_i more severely or frequently\n                \n        benefit_matrix = execution_engine.relationship_dict['benefit']\n        # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n        # A higher value means member_j has helped member_i more generously or frequently\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n    For example, 'member_2 was attacked by member_1 (value=3.00)'.\n4) You can use these methods on execution_engine:\n    \u2022 execution_engine.attack(member1, member2)\n    \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n    \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n    \u2022 execution_engine.bear(member1, member2) - Bears offspring\n    \u2022 execution_engine.expand(member1, member2) - Expands territory\n5) The members are accessed by execution_engine.current_members[id].\n    For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\nNone\n\nCurrent status (features of all members):\n   self_productivity  ...  member_id\n0           8.486092  ...          0\n1           9.215597  ...          1\n2           9.820788  ...          2\n3           7.823171  ...          3\n\n[4 rows x 6 columns]\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-409.21)', 'member_0 was attacked by member_2 (value=159.09)', 'member_0 was attacked by member_3 (value=213.02)', 'member_1 was attacked by member_0 (value=950.45)', 'member_1 was attacked by member_2 (value=337.53)', 'member_1 was attacked by member_3 (value=501.15)', 'member_2 was attacked by member_0 (value=-234.29)', 'member_2 was attacked by member_1 (value=-149.95)', 'member_2 was attacked by member_3 (value=981.94)', 'member_3 was attacked by member_0 (value=-480.06)', 'member_3 was attacked by member_1 (value=911.18)', 'member_3 was attacked by member_2 (value=697.26)', 'member_0 gave a benefit to member_1 (value=32.04)', 'member_0 gave a benefit to member_2 (value=-318.27)', 'member_0 gave a benefit to member_3 (value=458.03)', 'member_1 gave a benefit to member_0 (value=352.02)', 'member_1 gave a benefit to member_2 (value=655.79)', 'member_1 gave a benefit to member_3 (value=-269.93)', 'member_2 gave a benefit to member_0 (value=553.91)', 'member_2 gave a benefit to member_1 (value=-244.38)', 'member_2 gave a benefit to member_3 (value=958.19)', 'member_3 gave a benefit to member_0 (value=765.26)', 'member_3 gave a benefit to member_1 (value=782.26)', 'member_3 gave a benefit to member_2 (value=551.02)', 'member_0 gave land to member_1 (value=-5.18)', 'member_0 gave land to member_2 (value=-5.22)', 'member_0 gave land to member_3 (value=-19.16)', 'member_1 gave land to member_0 (value=-26.25)', 'member_1 gave land to member_2 (value=25.58)', 'member_1 gave land to member_3 (value=-4.99)', 'member_2 gave land to member_0 (value=6.54)', 'member_2 gave land to member_1 (value=0.66)', 'member_2 gave land to member_3 (value=25.05)', 'member_3 gave land to member_0 (value=2.30)', 'member_3 gave land to member_1 (value=26.64)', 'member_3 gave land to member_2 (value=29.64)']\n\nCode Memory and Previous Performance:\n- No previous code history.\n\nAnalysis Memory:\n- No previous analysis\n\nPerformance history:\n- No previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\nWhile the example above shows one possible approach,\nyou should create your own unique implementation drawing from the wide range of available methods and strategies.\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n[]\n\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        for loc in getattr(me, 'owned_land', [])[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning (illustrative example)\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        \n    state = (int(me.vitality//20), int(me.cargo//20))\n    action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state,a),0))\n    \n    # Execute and update based on survival outcome\n    if action == 'attack':\n        me.survival_q[(state,action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nReturn this updated full prompt and ensure that all agents (including you as member_3) develop their Python function agent_action(execution_engine, member_id) while considering:\n\n1. The core objective:\n   - Is it pure survival, domination, or cooperation?\n2. Key success metrics:\n   - What truly determines 'winning'\u2014individual vitality & resource accumulation, territorial expansion, or alliance strength?\n3. Potential improvements:\n   - What mechanics could be added or modified (advanced communication, nuanced alliances, dynamic resource allocation, etc.)?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases, such as when a member has no land or minimal relationship indices?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions, such as forming unexpected alliances or taking counter-intuitive actions?\n7. Could a completely different paradigm\u2014like rapid expansion or resource centralization\u2014work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term tactical gains with long-term strategic objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnd of Updated Full Prompt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nThis is the final integrated prompt. Agents should now design their Python function with a unique and innovative strategy tailored to their own needs while fully respecting the listed constraints and considerations.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    },
    "1": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Executes immediate tactical and strategic maneuvers based on our current state.\n\n    Tactical Strategy:\n      1. Survival & Threat Neutralization:\n         If our cargo is critically low (cargo < half vitality), scan for an opponent\n         with higher cargo but lower vitality and launch an attack.\n\n      2. Reproduction & Alliance Building:\n         If our cargo is at least our vitality and we currently control land (non-empty\n         territory list), seek a partner with land and attempt to reproduce via bear().\n\n      3. Territorial Expansion:\n         When our vitality is high (> 80), we consult the benefit_land matrix to find an\n         ally with whom we can expand territory.\n\n      4. Cooperative Engagement:\n         If none of the above conditions hold, broadcast a cooperative message to all other members.\n\n    Additional Considerations:\n      - Validate that member_id is valid and that we don't target ourselves.\n      - When using relationship matrices, ensure indices are within valid boundaries.\n      - If execution_engine has a logging mechanism, we output essential debug info.\n    \"\"\"\n    # Validate member index exists\n    total_members = len(execution_engine.current_members)\n    if not (0 <= member_id < total_members):\n        if hasattr(execution_engine, 'log'):\n            execution_engine.log(\"Invalid member_id: {}\".format(member_id))\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Safety check: Ensure our vital attributes exist\n    try:\n        my_cargo = float(me.cargo)\n        my_vitality = float(me.vitality)\n    except (AttributeError, ValueError, TypeError):\n        if hasattr(execution_engine, 'log'):\n            execution_engine.log(\"Member {} missing vital attributes.\".format(member_id))\n        return\n\n    # Strategy 1: Survival Mechanism\n    if my_cargo < 0.5 * my_vitality:\n        for i in range(total_members):\n            if i == member_id:\n                continue\n            candidate = execution_engine.current_members[i]\n            if candidate.id == me.id:\n                continue  # avoid duplicate id conflict\n            try:\n                # Proceed if candidate has higher cargo and lower vitality than me\n                if candidate.cargo > my_cargo and candidate.vitality < my_vitality:\n                    if hasattr(execution_engine, 'log'):\n                        execution_engine.log(\"Member {} attacking candidate {}.\".format(me.id, candidate.id))\n                    execution_engine.attack(me, candidate)\n                    return\n            except Exception as e:\n                if hasattr(execution_engine, 'log'):\n                    execution_engine.log(\"Attack on candidate {} failed: {}\".format(candidate.id, e))\n                continue  # move to next candidate\n\n    # Strategy 2: Reproduction & Alliance\n    if my_cargo >= my_vitality and getattr(me, \"current_clear_list\", []):\n        for i in range(total_members):\n            if i == member_id:\n                continue\n            partner = execution_engine.current_members[i]\n            if partner.id == me.id:\n                continue\n            # Partner must have land controlled (non-empty current_clear_list)\n            if getattr(partner, \"current_clear_list\", []):\n                try:\n                    if hasattr(execution_engine, 'log'):\n                        execution_engine.log(\"Member {} calling bear() with partner {}.\".format(me.id, partner.id))\n                    execution_engine.bear(me, partner)\n                    return\n                except Exception as e:\n                    if hasattr(execution_engine, 'log'):\n                        execution_engine.log(\"Bear() with partner {} failed: {}\".format(partner.id, e))\n                    continue\n\n    # Strategy 3: Territorial Expansion via Relationship Matrix\n    if my_vitality > 80:\n        benefit_land = execution_engine.relationship_dict.get(\"benefit_land\", None)\n        if benefit_land is not None:\n            for i in range(total_members):\n                if i == member_id:\n                    continue\n                # Ensure indices are valid in the benefit_land matrix dimension.\n                try:\n                    if benefit_land[member_id, i] > 0:\n                        ally = execution_engine.current_members[i]\n                        if ally.id == me.id:\n                            continue  # Skip self-check\n                        if hasattr(execution_engine, 'log'):\n                            execution_engine.log(\"Member {} expanding territory with ally {}.\".format(me.id, ally.id))\n                        execution_engine.expand(me, ally)\n                        return\n                except Exception as e:\n                    if hasattr(execution_engine, 'log'):\n                        execution_engine.log(\"Expansion check failed for index {}: {}\".format(i, e))\n                    continue\n\n    # Strategy 4: Cooperative Engagement - Broadcast a message to all peers\n    cooperative_message = \"Together, our future is brighter\u2014unity guides our prosperity!\"\n    for i in range(total_members):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        if recipient.id != me.id:\n            try:\n                if hasattr(execution_engine, 'log'):\n                    execution_engine.log(\"Member {} sending cooperation message to member {}.\".format(me.id, recipient.id))\n                execution_engine.send_message(me.id, recipient.id, cooperative_message)\n            except Exception as e:\n                if hasattr(execution_engine, 'log'):\n                    execution_engine.log(\"Message to member {} failed: {}\".format(recipient.id, e))\n                continue\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    Proposes a dynamic system modification to introduce adaptive resource and land management.\n\n    Proposal Rationale:\n      The current rigid allocation of resources and land is an impediment to adaptive growth.\n      This proposal introduces an adaptive management module that periodically reclassifies\n      member land status based on vitality and productivity. This enables both individual\n      prosperity and collective efficiency.\n\n    Implementation:\n      1. ANALYSIS: Notes the limitation of static configurations.\n      2. PROPOSAL: Implements an AdaptiveManagement class within the execution_engine if it doesn't exist.\n         The system will categorize members as 'elite' or 'common' based on vitality and productivity.\n\n    Ratification Condition:\n      The proposal will be ratified when a specific resource threshold is met (cargo >= 100).\n\n    Critical Checks:\n      - Verify compatibility via hasattr.\n      - Reference members from execution_engine.current_members.\n      - Ensure index and attribute validations throughout the implementation.\n    \"\"\"\n    analysis_notes = (\n        \"Identified Limitation: The fixed nature of land and resource distribution stifles dynamic \"\n        \"growth. Transitioning to an adaptive system will allow for real-time reclassification of \"\n        \"land holdings based on member vitality and productivity, fostering a more resilient community.\"\n    )\n\n    # Check if execution_engine supports retrieving game mechanisms (optional)\n    if hasattr(execution_engine, \"get_game_mechanisms_and_mods\"):\n        mechanisms = execution_engine.get_game_mechanisms_and_mods()\n    else:\n        mechanisms = \"No extended mechanisms interface available.\"\n\n    # Define the new adaptive management module code\n    modification_code = \"\"\"\\\n# Dynamic Adaptive Resource & Land Management Module\n# Version: 2.0.0\n# This module introduces adaptive categorization of members' land based on real-time vitality and productivity.\nif not hasattr(execution_engine, 'adaptive_management'):\n    class AdaptiveManagement:\n        VERSION = 2.0\n        def __init__(self):\n            # Mapping from member id to a status ('elite' or 'common')\n            self.land_status = {}\n        def update(self, members):\n            for m in members:\n                # Members with vitality > 70 and overall_productivity > 8 earn elite status.\n                if m.vitality > 70 and getattr(m, \"overall_productivity\", 0) > 8:\n                    self.land_status[m.id] = 'elite'\n                else:\n                    self.land_status[m.id] = 'common'\n            # Clean-up: Remove statuses for members that no longer exist.\n            active_ids = {m.id for m in members}\n            for key in list(self.land_status.keys()):\n                if key not in active_ids:\n                    del self.land_status[key]\n            return self.land_status\n    execution_engine.adaptive_management = AdaptiveManagement()\n    execution_engine.adaptive_management.update(execution_engine.current_members)\nelse:\n    # If adaptive_management module exists, perform an update.\n    execution_engine.adaptive_management.update(execution_engine.current_members)\n\"\"\"\n    # Set ratification condition: The proposal passes if the cargo resource is at least 100.\n    ratification_condition = {'type': 'resource', 'resource': 'cargo', 'amount': 100}\n\n    try:\n        if hasattr(execution_engine, 'log'):\n            execution_engine.log(\"Member {} proposing adaptive management modification.\".format(member_id))\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception as e:\n        if hasattr(execution_engine, 'log'):\n            execution_engine.log(\"Proposal submission failed: {}\".format(e))\n        # Silently ignore failure to propose modification\n        pass\n    return",
        "features_at_generation": [
          {
            "self_productivity": 8.486091902927424,
            "self_vitality": 100.0,
            "self_cargo": 32.01292526903218,
            "self_age": 47,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 9.215596783061361,
            "self_vitality": 54.314458610995025,
            "self_cargo": 9.215596783061361,
            "self_age": 93,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 9.820787822339064,
            "self_vitality": 100.0,
            "self_cargo": 25.237980518986205,
            "self_age": 62,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.823171351824591,
            "self_vitality": 68.67244177884766,
            "self_cargo": 7.823171351824591,
            "self_age": 33,
            "self_neighbor": 2,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-409.21)",
          "member_0 was attacked by member_2 (value=159.09)",
          "member_0 was attacked by member_3 (value=213.02)",
          "member_1 was attacked by member_0 (value=950.45)",
          "member_1 was attacked by member_2 (value=337.53)",
          "member_1 was attacked by member_3 (value=501.15)",
          "member_2 was attacked by member_0 (value=-234.29)",
          "member_2 was attacked by member_1 (value=-149.95)",
          "member_2 was attacked by member_3 (value=981.94)",
          "member_3 was attacked by member_0 (value=-480.06)",
          "member_3 was attacked by member_1 (value=911.18)",
          "member_3 was attacked by member_2 (value=697.26)",
          "member_0 gave a benefit to member_1 (value=32.04)",
          "member_0 gave a benefit to member_2 (value=-318.27)",
          "member_0 gave a benefit to member_3 (value=458.03)",
          "member_1 gave a benefit to member_0 (value=352.02)",
          "member_1 gave a benefit to member_2 (value=655.79)",
          "member_1 gave a benefit to member_3 (value=-269.93)",
          "member_2 gave a benefit to member_0 (value=553.91)",
          "member_2 gave a benefit to member_1 (value=-244.38)",
          "member_2 gave a benefit to member_3 (value=958.19)",
          "member_3 gave a benefit to member_0 (value=765.26)",
          "member_3 gave a benefit to member_1 (value=782.26)",
          "member_3 gave a benefit to member_2 (value=551.02)",
          "member_0 gave land to member_1 (value=-5.18)",
          "member_0 gave land to member_2 (value=-5.22)",
          "member_0 gave land to member_3 (value=-19.16)",
          "member_1 gave land to member_0 (value=-26.25)",
          "member_1 gave land to member_2 (value=25.58)",
          "member_1 gave land to member_3 (value=-4.99)",
          "member_2 gave land to member_0 (value=6.54)",
          "member_2 gave land to member_1 (value=0.66)",
          "member_2 gave land to member_3 (value=25.05)",
          "member_3 gave land to member_0 (value=2.30)",
          "member_3 gave land to member_1 (value=26.64)",
          "member_3 gave land to member_2 (value=29.64)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Implements immediate survival and social actions.\n    \n    Strategy Overview:\n    1. Survival & Threat Neutralization:\n       If our cargo is less than half our vitality, we seek an opponent who\n       has more resources but lower vitality and attack them.\n    2. Reproduction (Lineage Preservation):\n       If our cargo is at least equal to our vitality and we hold land (non\u2010empty\n       current_clear_list), we look for a partner who also controls land and call bear().\n    3. Territorial Expansion:\n       With high vitality (> 80), we consult the benefit_land relationship matrix to\n       select an ally for expanding our territory.\n    4. Cooperative Engagement:\n       If none of the above apply, send a cooperative message to all other members.\n    \n    Critical Checks:\n      \u2022 Validate that member_id is within range.\n      \u2022 Never target ourselves (check that any candidate\u2019s id is not equal to our own).\n      \u2022 For reproduction (bear), verify that the member has land (current_clear_list is non-empty).\n      \u2022 When using relationship matrices, verify that indices are within bounds.\n      \u2022 All members must be accessed via execution_engine.current_members (a list).\n    \"\"\"\n    # Validate member index exists\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n    \n    # Strategy 1: Survival - if our cargo is critically low relative to vitality\n    if me.cargo < 0.5 * me.vitality:\n        for i in range(total_members):\n            if i == member_id:\n                continue  # avoid self\n            # Ensure index validity and proper member reference\n            target = execution_engine.current_members[i]\n            if target.id == me.id:\n                continue\n            # Select a target having more cargo yet lower vitality\n            if target.cargo > me.cargo and target.vitality < me.vitality:\n                try:\n                    execution_engine.attack(me, target)\n                    return\n                except Exception:\n                    continue  # in case of failure, try the next candidate\n    \n    # Strategy 2: Reproduction - ensure long-term survival through offspring\n    if me.cargo >= me.vitality and me.current_clear_list:\n        for i in range(total_members):\n            if i == member_id:\n                continue  # skip self\n            partner = execution_engine.current_members[i]\n            if partner.id == me.id:\n                continue\n            if partner.current_clear_list:  # partner must have land\n                try:\n                    execution_engine.bear(me, partner)\n                    return\n                except Exception:\n                    continue\n    \n    # Strategy 3: Territorial Expansion - use relationship insights \n    if me.vitality > 80:\n        benefit_land = execution_engine.relationship_dict.get(\"benefit_land\", None)\n        if benefit_land is not None:\n            for i in range(total_members):\n                if i == member_id:\n                    continue\n                # Check matrix indices are valid\n                if member_id < total_members and i < total_members:\n                    if benefit_land[member_id, i] > 0:\n                        ally = execution_engine.current_members[i]\n                        if ally.id != me.id:\n                            try:\n                                execution_engine.expand(me, ally)\n                                return\n                            except Exception:\n                                continue\n\n    # Strategy 4: Cooperative Engagement - send a message to all others\n    for i in range(total_members):\n        if i == member_id:\n            continue\n        recipient = execution_engine.current_members[i]\n        if recipient.id != me.id:\n            try:\n                execution_engine.send_message(me.id, recipient.id,\n                                              \"Unity and cooperation strengthen our future!\")\n            except Exception:\n                continue\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    Proposes a system-level modification to enable more adaptive resource and land management.\n    \n    Proposal Process:\n    1. ANALYSIS PHASE:\n       - Identify the limitation: Current land allocation and resource distribution is too rigid.\n       - Optionally retrieve compatibility info via get_game_mechanisms_and_mods().\n    2. PROPOSAL PHASE:\n       - Construct modification_code (multi-line string) that defines a new adaptive management system.\n       - Set a ratification condition based on a resource threshold.\n    \n    Critical Checks:\n      \u2022 Verify mechanism compatibility using hasattr when available.\n      \u2022 Reference members using execution_engine.current_members (a list).\n      \u2022 Check for attribute existence and use proper index validations.\n    \"\"\"\n    analysis_notes = (\n        \"Limitation: The static nature of land allocation and resource distribution hampers \"\n        \"adaptive growth. An adaptive management mechanism will dynamically reclassify land \"\n        \"based on a member's vitality and overall productivity.\"\n    )\n    # Retrieve mechanism compatibility info if available\n    if hasattr(execution_engine, \"get_game_mechanisms_and_mods\"):\n        mechanisms = execution_engine.get_game_mechanisms_and_mods()\n    else:\n        mechanisms = \"Compatibility interface not available.\"\n    \n    # PROPOSAL PHASE: Define an adaptive management system for land allocation\n    modification_code = \"\"\"\\\n# Adaptive Resource & Land Management System Proposal\n# Version: 1.0.0\n# This system categorizes members' land dynamically based on vitality and overall productivity.\nif not hasattr(execution_engine, 'adaptive_management'):\n    class AdaptiveManagement:\n        VERSION = 1.0\n        def __init__(self):\n            # Mapping from member.id to a category string ('premium' or 'standard')\n            self.land_categories = {}\n        def update_land_categories(self, current_members):\n            for member in current_members:\n                if member.vitality > 70 and member.overall_productivity > 8:\n                    self.land_categories[member.id] = 'premium'\n                else:\n                    self.land_categories[member.id] = 'standard'\n            # Cleanup: remove entries for inactive members\n            active_ids = {member.id for member in current_members}\n            obsolete_ids = [mid for mid in self.land_categories if mid not in active_ids]\n            for mid in obsolete_ids:\n                del self.land_categories[mid]\n            return self.land_categories\n    execution_engine.adaptive_management = AdaptiveManagement()\n    execution_engine.adaptive_management.update_land_categories(execution_engine.current_members)\n\"\"\"\n    # Set ratification condition: proposal ratifies if cargo resources exceed 100\n    ratification_condition = {'type': 'resource', 'resource': 'cargo', 'amount': 100}\n    \n    try:\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception:\n        # Silently ignore failure to propose modification\n        pass\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Executes actions based on a tailored strategy blending individual survival with community resilience.\n    This implementation reflects a personal commitment to balance tactical risk with cooperative long-term gains.\n\n    Strategy Order:\n      1. Emergency Attack: When cargo is critically low relative to vitality, aggressively neutralize the strongest rival.\n      2. Sustainable Expansion: When resources exceed 120% of vitality, attempt reproduction with a partner holding territory.\n      3. Cooperative Support: With a moderate surplus (cargo > vitality), offer resources to empower weaker members.\n      4. Territorial Growth: When overall productivity is high, try to expand territory using available adjacent opportunities.\n      5. Diplomatic Outreach: As a safeguard, dispatch collaborative messages to all peers to nurture alliances.\n\n    Critical Constraints:\n      \u2022 Validate member_id against execution_engine.current_members.\n      \u2022 Never target oneself.\n      \u2022 Verify that any candidate for reproduction possesses a nonempty current_clear_list (i.e. owns or has access to land).\n      \u2022 Always verify list indices are valid before usage.\n    \"\"\"\n    # Validate member_id before proceeding.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    try:\n        me = execution_engine.current_members[member_id]\n    except Exception:\n        return\n\n    # 1. Emergency Attack: if cargo is less than 60% of vitality, we are in immediate danger.\n    if me.cargo < 0.6 * me.vitality:\n        highest_cargo = -1\n        target = None\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:  # Skip self.\n                continue\n            try:\n                if candidate.cargo > highest_cargo:\n                    highest_cargo = candidate.cargo\n                    target = candidate\n            except Exception:\n                continue\n        # Ensure we never target ourselves and that the candidate is valid.\n        if target is not None and target.id != me.id:\n            try:\n                execution_engine.attack(me, target)\n                return  # Immediate action taken.\n            except Exception:\n                pass  # Fall through on error.\n\n    # 2. Sustainable Expansion: When cargo is plentiful, seek reproduction with a partner owning clear land.\n    if me.cargo > 1.2 * me.vitality:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Ensure we do not target ourselves.\n            try:\n                # Candidate must have a property (nonempty territory list) and a vitality close to ours.\n                if candidate.current_clear_list and candidate.vitality >= 0.9 * me.vitality:\n                    try:\n                        execution_engine.bear(me, candidate)\n                        return  # Reproduction successful.\n                    except Exception:\n                        continue\n            except Exception:\n                continue\n\n    # 3. Cooperative Support: For any candidate with lower vitality, offer resources if we have a surplus.\n    if me.cargo > me.vitality:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                if candidate.vitality < me.vitality:\n                    execution_engine.offer(me, candidate, True)\n                    # Continue offering as we might want to support multiple members.\n            except Exception:\n                continue\n\n    # 4. Territorial Growth: If our overall productivity stands high, expand territory.\n    if getattr(me, 'overall_productivity', 0) > 8.0:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                execution_engine.expand(me, candidate)\n                return  # Once territory expansion is attempted, exit.\n            except Exception:\n                continue\n\n    # 5. Diplomatic Outreach: As a fallback, send cooperative messages to all other members.\n    for idx, candidate in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        try:\n            execution_engine.send_message(\n                me.id,\n                candidate.id,\n                \"In facing challenges and opportunities alike, let us unite for mutual growth and resilient survival!\"\n            )\n        except Exception:\n            continue\n\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    Proposes an innovative modification\u2014the \"Cooperative Redistribution System\"\u2014that strives for fair\n    resource distribution and collective prosperity. This dual-phase proposal encompasses:\n\n      ANALYSIS PHASE:\n        - Identifies inflexibility in current resource allocation,\n        - Optionally inspects mechanism compatibility via available game interfaces.\n\n      PROPOSAL PHASE:\n        - Develops a multi-line modification code to introduce dynamic cooperation,\n        - Specifies a ratification condition requiring at least a 60% affirmative vote.\n\n    Critical Constraints:\n      \u2022 The member_id must be valid within execution_engine.current_members.\n      \u2022 All indexing is to be safely managed.\n      \u2022 Ensure backward compatibility and avoid any potential namespace clashes.\n    \"\"\"\n    # Validate member_id.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    modification_code = \"\"\"\n# Cooperative Redistribution System Proposal\n# Version: 1.0\n# Purpose: Enable adaptive resource redistribution by identifying surpluses and deficits,\n# thereby fostering a cooperative framework for enduring growth.\nif not hasattr(execution_engine, 'coop_resource_system'):\n    class CoopResourceSystem:\n        VERSION = 1.0\n        def __init__(self):\n            # Map each member's id to a status: 'surplus' if cargo > vitality, else 'deficit'.\n            self.records = {}\n        def redistribute(self):\n            for member in execution_engine.current_members:\n                status = 'surplus' if member.cargo > member.vitality else 'deficit'\n                self.records[member.id] = status\n            return self.records\n    execution_engine.coop_resource_system = CoopResourceSystem()\n    # Initiate resource redistribution.\n    execution_engine.coop_resource_system.redistribute()\n\"\"\"\n\n    # Define a ratification condition ensuring at least 60% support.\n    ratification_condition = {'type': 'vote', 'threshold': 0.6}\n\n    try:\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception:\n        pass\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 8.486091902927424,
            "self_vitality": 100.0,
            "self_cargo": 32.01292526903218,
            "self_age": 47,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 9.215596783061361,
            "self_vitality": 54.314458610995025,
            "self_cargo": 9.215596783061361,
            "self_age": 93,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 9.820787822339064,
            "self_vitality": 100.0,
            "self_cargo": 25.237980518986205,
            "self_age": 62,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.823171351824591,
            "self_vitality": 68.67244177884766,
            "self_cargo": 7.823171351824591,
            "self_age": 33,
            "self_neighbor": 2,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-409.21)",
          "member_0 was attacked by member_2 (value=159.09)",
          "member_0 was attacked by member_3 (value=213.02)",
          "member_1 was attacked by member_0 (value=950.45)",
          "member_1 was attacked by member_2 (value=337.53)",
          "member_1 was attacked by member_3 (value=501.15)",
          "member_2 was attacked by member_0 (value=-234.29)",
          "member_2 was attacked by member_1 (value=-149.95)",
          "member_2 was attacked by member_3 (value=981.94)",
          "member_3 was attacked by member_0 (value=-480.06)",
          "member_3 was attacked by member_1 (value=911.18)",
          "member_3 was attacked by member_2 (value=697.26)",
          "member_0 gave a benefit to member_1 (value=32.04)",
          "member_0 gave a benefit to member_2 (value=-318.27)",
          "member_0 gave a benefit to member_3 (value=458.03)",
          "member_1 gave a benefit to member_0 (value=352.02)",
          "member_1 gave a benefit to member_2 (value=655.79)",
          "member_1 gave a benefit to member_3 (value=-269.93)",
          "member_2 gave a benefit to member_0 (value=553.91)",
          "member_2 gave a benefit to member_1 (value=-244.38)",
          "member_2 gave a benefit to member_3 (value=958.19)",
          "member_3 gave a benefit to member_0 (value=765.26)",
          "member_3 gave a benefit to member_1 (value=782.26)",
          "member_3 gave a benefit to member_2 (value=551.02)",
          "member_0 gave land to member_1 (value=-5.18)",
          "member_0 gave land to member_2 (value=-5.22)",
          "member_0 gave land to member_3 (value=-19.16)",
          "member_1 gave land to member_0 (value=-26.25)",
          "member_1 gave land to member_2 (value=25.58)",
          "member_1 gave land to member_3 (value=-4.99)",
          "member_2 gave land to member_0 (value=6.54)",
          "member_2 gave land to member_1 (value=0.66)",
          "member_2 gave land to member_3 (value=25.05)",
          "member_3 gave land to member_0 (value=2.30)",
          "member_3 gave land to member_1 (value=26.64)",
          "member_3 gave land to member_2 (value=29.64)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Implements immediate actions that reflect a personal vision for social organization \n    while ensuring survival. This function uses several tactics in order of priority:\n      1. If resources (cargo) are low relative to vitality, attack the opponent with the highest cargo.\n      2. If resources are abundant (cargo > 1.2*vitality), attempt reproduction with a partner who has land.\n      3. If a moderate surplus exists (cargo > vitality), offer resources to members with lower vitality.\n      4. If overall productivity is high, try to expand territory.\n      5. As a fallback action, send cooperative messages to foster alliance.\n\n    Critical constraints:\n      \u2022 Validate that member_id is within the bounds of execution_engine.current_members.\n      \u2022 Never target oneself.\n      \u2022 Before calling bear(), verify that the candidate member has a nonempty current_clear_list (i.e. has land).\n      \u2022 Always check that any list index used in execution_engine.current_members is valid.\n    \"\"\"\n    try:\n        # Validate member_id.\n        if member_id < 0 or member_id >= len(execution_engine.current_members):\n            return\n        me = execution_engine.current_members[member_id]\n    except Exception:\n        return\n\n    # Strategy 1: Emergency attack when cargo is insufficient.\n    # Look for an opponent (other than self) with the highest resource level.\n    if me.cargo < me.vitality * 0.6:\n        max_cargo = -1\n        target = None\n        for idx, candidate in enumerate(execution_engine.current_members):\n            # Skip self.\n            if idx == member_id:\n                continue\n            try:\n                if candidate.cargo > max_cargo:\n                    max_cargo = candidate.cargo\n                    target = candidate\n            except Exception:\n                continue\n        if target is not None and target.id != me.id:\n            try:\n                execution_engine.attack(me, target)\n                return  # Action executed.\n            except Exception:\n                pass  # On error, fall through to other strategies.\n\n    # Strategy 2: Attempt reproduction when resources are plentiful.\n    if me.cargo > me.vitality * 1.2:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # Never select self.\n            try:\n                # Only select candidate if they appear stable (vitality near ours) and have land.\n                if candidate.current_clear_list and candidate.vitality >= me.vitality * 0.9:\n                    try:\n                        execution_engine.bear(me, candidate)\n                        return  # Reproduction executed.\n                    except Exception:\n                        continue\n            except Exception:\n                continue\n\n    # Strategy 3: Offer resources to members with lower vitality if we have a moderate resource surplus.\n    if me.cargo > me.vitality:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                if candidate.vitality < me.vitality:\n                    execution_engine.offer(me, candidate, True)\n                    # Do not return immediately; we allow for more actions below.\n            except Exception:\n                continue\n\n    # Strategy 4: Expand territory if overall productivity is high.\n    if me.overall_productivity > 8.0:\n        for idx, candidate in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            try:\n                execution_engine.expand(me, candidate)\n                return  # Territory expansion attempted.\n            except Exception:\n                continue\n\n    # Fallback: Send a cooperative message to every other member.\n    for idx, candidate in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        try:\n            execution_engine.send_message(me.id, candidate.id,\n                                          \"Let's collaborate for mutual survival and prosperity!\")\n        except Exception:\n            continue\n\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    Proposes a modification to the game mechanics by introducing a \"Cooperative Redistribution System\"\n    for fairer resource allocation. The proposal follows a two-phase process:\n\n      ANALYSIS PHASE:\n        - Identifies the current limitation in rigid resource allocation.\n        - (Optionally) checks mechanism compatibility via get_game_mechanisms_and_mods().\n\n      PROPOSAL PHASE:\n        - Constructs the modification code as a multi-line string that sets up the new system.\n        - Sets a ratification condition based on a vote with a threshold of 60%.\n\n    Critical constraints:\n      \u2022 Validate the member_id is within the valid range.\n      \u2022 Use execution_engine.current_members (a list) with index-based access.\n      \u2022 Ensure backward compatibility and avoid namespace conflicts.\n    \"\"\"\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    modification_code = \"\"\"\n# Cooperative Redistribution System Proposal\n# Version: 1.0\n# Purpose: To introduce a dynamic system that redistributes resources based on current surpluses\n# and deficits, fostering long-term cooperative growth.\nif not hasattr(execution_engine, 'coop_resource_system'):\n    class CoopResourceSystem:\n        VERSION = 1.0\n        def __init__(self):\n            # Record the status of each member: 'surplus' if cargo > vitality, otherwise 'deficit'.\n            self.records = {}\n        def redistribute(self):\n            for member in execution_engine.current_members:\n                if member.cargo > member.vitality:\n                    self.records[member.id] = 'surplus'\n                else:\n                    self.records[member.id] = 'deficit'\n            return self.records\n    execution_engine.coop_resource_system = CoopResourceSystem()\n    # Activate the redistribution process.\n    execution_engine.coop_resource_system.redistribute()\n\"\"\"\n\n    # Define the ratification condition: require at least 60% (vote threshold) for adoption.\n    ratification_condition = {'type': 'vote', 'threshold': 0.6}\n    try:\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception:\n        pass\n    return\n\n# End of implementation.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return  # Abort action if the member_id does not exist.\n\n    agent = execution_engine.current_members[member_id]\n\n    # --- Immediate Survival Tactics (Emergency Attack) ---\n    # If agent's cargo is less than 50% of its vitality, we risk resource starvation.\n    # Seek opponents with higher cargo but lesser vitality to immediately balance resources.\n    if agent.cargo < 0.5 * agent.vitality:\n        for other in execution_engine.current_members:\n            if other.id == agent.id:\n                continue  # Skip self-targeting.\n            if other.cargo > agent.cargo and other.vitality < agent.vitality:\n                try:\n                    execution_engine.attack(agent, other)\n                    return\n                except Exception:\n                    continue  # Try another opponent upon failure.\n\n    # --- Long Term Growth: Cooperative Reproduction Strategy ---\n    # We consider reproduction if agent has enjoyed resource surplus and has secured territory.\n    if agent.cargo > 1.2 * agent.vitality and agent.current_clear_list:\n        for partner in execution_engine.current_members:\n            if partner.id == agent.id:\n                continue\n            # Only select partners that have a land claim.\n            if partner.current_clear_list:\n                try:\n                    execution_engine.bear(agent, partner)\n                    return\n                except Exception:\n                    continue\n\n    # --- Resource Redistribution as a Strategic Investment ---\n    # If the agent holds more cargo than vitality, it can help out a partner,\n    # fostering long-term alliances and mutual support.\n    if agent.cargo > agent.vitality:\n        potential_partners = [other for other in execution_engine.current_members if other.id != agent.id]\n        for other in potential_partners:\n            try:\n                # The boolean flag signals willingness to cooperate.\n                execution_engine.offer(agent, other, True)\n                return\n            except Exception:\n                continue\n\n    # --- Strategic Expansion for Territorial Control ---\n    # When overall productivity is high (signaling a robust state) and there's available territory,\n    # the agent seeks to expand its zone in partnership with others.\n    if agent.overall_productivity > 8 and agent.current_clear_list:\n        for partner in execution_engine.current_members:\n            if partner.id == agent.id:\n                continue\n            try:\n                execution_engine.expand(agent, partner)\n                return\n            except Exception:\n                continue\n\n    # --- Final Fallback: Building Alliances via Messaging ---\n    # If no resource actions have been taken, the agent reaches out to all other agents\n    # with an invitation to collaborate for mutual future benefits.\n    for other in execution_engine.current_members:\n        if other.id == agent.id:\n            continue\n        try:\n            execution_engine.send_message(agent.id, other.id, \"Together we can overcome hurdles and shape a promising future!\")\n        except Exception:\n            continue\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    # ANALYSIS: Recognizing that rigid allocation may stifle growth,\n    # we propose an adaptive zoning mechanism that rebalances member roles dynamically.\n    analysis_notes = (\n        \"Identified Limitation: Static resource allocation and land management restricts our ability to adapt \"\n        \"to changing conditions in vitality and productivity over time. We need a dynamic strategy.\"\n    )\n\n    # Check for mechanism interface, if available.\n    if hasattr(execution_engine, \"get_game_mechanisms_and_mods\"):\n        mechanisms_info = execution_engine.get_game_mechanisms_and_mods()\n    else:\n        mechanisms_info = \"No mechanism interface detected. Proceeding with the proposal under assumed compatibility.\"\n\n    review_notes = (\n        \"Prior modification attempts show that static systems fail under dynamic challenges. \"\n        \"A dynamic adaptive zoning mechanism with regular cleanup and reassignment provides robust, scalable growth.\"\n    )\n\n    # PROPOSAL: Adaptive Zoning Mechanism tailored to our operational strategy.\n    modification_code = '''\n# Adaptive Zoning Mechanism - Version 1.0.0\n# This module dynamically allocates members into 'premium' or 'standard' zones based on their vitality and overall_productivity.\n# It also supports a cleanup function to remove zone assignments from inactive agents.\n\nif not hasattr(execution_engine, 'adaptive_zoning'):\n    class AdaptiveZoning:\n        VERSION = 1.0\n        def __init__(self):\n            self.zones = {}  # Mapping of member.id to a zone label.\n\n        def assign_zones(self):\n            # Dynamically assign zones:\n            # Members with vitality > 60 and productivity > 50 receive premium status,\n            # others are placed in standard zones.\n            for member in execution_engine.current_members:\n                if member.vitality > 60 and member.overall_productivity > 50:\n                    self.zones[member.id] = 'premium'\n                else:\n                    self.zones[member.id] = 'standard'\n\n        def cleanup(self):\n            # Remove assignments for agents no longer active.\n            active_ids = {member.id for member in execution_engine.current_members}\n            for mid in list(self.zones.keys()):\n                if mid not in active_ids:\n                    del self.zones[mid]\n\n    execution_engine.adaptive_zoning = AdaptiveZoning()\n    execution_engine.adaptive_zoning.assign_zones()\nelse:\n    # If adaptive zoning mechanism already exists, update current assignments:\n    execution_engine.adaptive_zoning.assign_zones()\n    execution_engine.adaptive_zoning.cleanup()\n'''\n    # Define ratification requirement to ensure broad support for the change.\n    ratification_condition = {'type': 'vote', 'threshold': 0.6}\n\n    try:\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception:\n        pass\n    return",
        "features_at_generation": [
          {
            "self_productivity": 8.486091902927424,
            "self_vitality": 100.0,
            "self_cargo": 32.01292526903218,
            "self_age": 47,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 9.215596783061361,
            "self_vitality": 54.314458610995025,
            "self_cargo": 9.215596783061361,
            "self_age": 93,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 9.820787822339064,
            "self_vitality": 100.0,
            "self_cargo": 25.237980518986205,
            "self_age": 62,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.823171351824591,
            "self_vitality": 68.67244177884766,
            "self_cargo": 7.823171351824591,
            "self_age": 33,
            "self_neighbor": 2,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-409.21)",
          "member_0 was attacked by member_2 (value=159.09)",
          "member_0 was attacked by member_3 (value=213.02)",
          "member_1 was attacked by member_0 (value=950.45)",
          "member_1 was attacked by member_2 (value=337.53)",
          "member_1 was attacked by member_3 (value=501.15)",
          "member_2 was attacked by member_0 (value=-234.29)",
          "member_2 was attacked by member_1 (value=-149.95)",
          "member_2 was attacked by member_3 (value=981.94)",
          "member_3 was attacked by member_0 (value=-480.06)",
          "member_3 was attacked by member_1 (value=911.18)",
          "member_3 was attacked by member_2 (value=697.26)",
          "member_0 gave a benefit to member_1 (value=32.04)",
          "member_0 gave a benefit to member_2 (value=-318.27)",
          "member_0 gave a benefit to member_3 (value=458.03)",
          "member_1 gave a benefit to member_0 (value=352.02)",
          "member_1 gave a benefit to member_2 (value=655.79)",
          "member_1 gave a benefit to member_3 (value=-269.93)",
          "member_2 gave a benefit to member_0 (value=553.91)",
          "member_2 gave a benefit to member_1 (value=-244.38)",
          "member_2 gave a benefit to member_3 (value=958.19)",
          "member_3 gave a benefit to member_0 (value=765.26)",
          "member_3 gave a benefit to member_1 (value=782.26)",
          "member_3 gave a benefit to member_2 (value=551.02)",
          "member_0 gave land to member_1 (value=-5.18)",
          "member_0 gave land to member_2 (value=-5.22)",
          "member_0 gave land to member_3 (value=-19.16)",
          "member_1 gave land to member_0 (value=-26.25)",
          "member_1 gave land to member_2 (value=25.58)",
          "member_1 gave land to member_3 (value=-4.99)",
          "member_2 gave land to member_0 (value=6.54)",
          "member_2 gave land to member_1 (value=0.66)",
          "member_2 gave land to member_3 (value=25.05)",
          "member_3 gave land to member_0 (value=2.30)",
          "member_3 gave land to member_1 (value=26.64)",
          "member_3 gave land to member_2 (value=29.64)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate that member_id is within range of current_members.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return  # Invalid member_id index, abort action.\n    me = execution_engine.current_members[member_id]\n    \n    # Strategy 1: Emergency Attack (defensive survival)\n    # If our cargo is less than half of our vitality, look for an opponent\n    # with more cargo and lower vitality to attack.\n    if me.cargo < 0.5 * me.vitality:\n        for idx in range(len(execution_engine.current_members)):\n            if idx >= len(execution_engine.current_members):\n                continue\n            other = execution_engine.current_members[idx]\n            if other.id == me.id:  # Never target self.\n                continue\n            if other.cargo > me.cargo and other.vitality < me.vitality:\n                try:\n                    execution_engine.attack(me, other)\n                    return  # Action executed; only one action per round.\n                except Exception:\n                    continue  # If attack fails, try next candidate.\n    \n    # Strategy 2: Reproduction (Bear offsprings)\n    # Only attempt reproduction if:\n    #  - Our cargo significantly exceeds our vitality.\n    #  - We have land (indicated by a nonempty current_clear_list).\n    if me.cargo > 1.2 * me.vitality and me.current_clear_list:\n        for idx in range(len(execution_engine.current_members)):\n            if idx >= len(execution_engine.current_members):\n                continue\n            partner = execution_engine.current_members[idx]\n            if partner.id == me.id:  # Do not select ourselves.\n                continue\n            # Before bear(), verify partner also has land.\n            if partner.current_clear_list:\n                try:\n                    execution_engine.bear(me, partner)\n                    return\n                except Exception:\n                    continue  # If bear fails, try another partner.\n    \n    # Strategy 3: Cooperative Resource Offering\n    # If we have surplus resources (cargo > vitality), offer resources to support cooperation.\n    if me.cargo > me.vitality:\n        for idx in range(len(execution_engine.current_members)):\n            if idx >= len(execution_engine.current_members):\n                continue\n            other = execution_engine.current_members[idx]\n            if other.id == me.id:\n                continue\n            try:\n                execution_engine.offer(me, other, True)\n                return\n            except Exception:\n                continue\n\n    # Strategy 4: Territorial Expansion\n    # If overall productivity is high and we have available clear land cells,\n    # try to expand territory by contacting a partner.\n    if me.overall_productivity > 8 and me.current_clear_list:\n        for idx in range(len(execution_engine.current_members)):\n            if idx >= len(execution_engine.current_members):\n                continue\n            partner = execution_engine.current_members[idx]\n            if partner.id == me.id:\n                continue\n            try:\n                execution_engine.expand(me, partner)\n                return\n            except Exception:\n                continue\n\n    # Optionally, send a cooperative message if no other action was taken.\n    for idx in range(len(execution_engine.current_members)):\n        if idx >= len(execution_engine.current_members):\n            continue\n        other = execution_engine.current_members[idx]\n        if other.id == me.id:\n            continue\n        try:\n            execution_engine.send_message(me.id, other.id, \"Let's build a resilient future together!\")\n        except Exception:\n            continue\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    # ANALYSIS PHASE:\n    analysis_notes = (\n        \"Limitation Identified: The current system lacks a dynamic mechanism for adaptive \"\n        \"land allocation and resource redistribution based on agents' evolving productivity and vitality. \"\n        \"This rigidity can limit long-term cooperative growth and efficient resource balancing.\"\n    )\n    # Check for mechanism compatibility if available.\n    if hasattr(execution_engine, \"get_game_mechanisms_and_mods\"):\n        mechanisms_info = execution_engine.get_game_mechanisms_and_mods()\n    else:\n        mechanisms_info = \"No compatibility interface available; proceeding with proposal.\"\n\n    review_notes = (\n        \"Review of past modification attempts indicates that overly rigid land or resource systems may hinder \"\n        \"adaptive growth. A system that categorizes members into dynamic zones based on performance metrics \"\n        \"and provides rollback procedures could address these issues.\"\n    )\n\n    # PROPOSAL PHASE:\n    # The modification proposes an Adaptive Zoning Mechanism that dynamically classifies members based on their\n    # vitality and overall_productivity. It includes cleanup routines for outdated assignments.\n    modification_code = \"\"\"\n# Adaptive Zoning Mechanism Proposal\n# Version: 1.0.0\n# This proposal introduces a dynamic system for land allocation and resource redistribution.\n# It assigns each member a zone ('premium' or 'standard') based on their vitality and overall productivity.\n# The system includes a cleanup function to remove zoning for inactive members.\n\nif not hasattr(execution_engine, 'adaptive_zoning'):\n    class AdaptiveZoning:\n        VERSION = 1.0\n        def __init__(self):\n            self.zones = {}  # Dictionary mapping member.id to zone type.\n        \n        def assign_zones(self):\n            for member in execution_engine.current_members:\n                if member.vitality > 60 and member.overall_productivity > 50:\n                    self.zones[member.id] = 'premium'\n                else:\n                    self.zones[member.id] = 'standard'\n        \n        def cleanup(self):\n            # Remove zones for members no longer active in current_members.\n            active_ids = {member.id for member in execution_engine.current_members}\n            obsolete = [mid for mid in self.zones if mid not in active_ids]\n            for mid in obsolete:\n                del self.zones[mid]\n    \n    execution_engine.adaptive_zoning = AdaptiveZoning()\n    # Initialize zoning assignments.\n    execution_engine.adaptive_zoning.assign_zones()\n    # Optionally, schedule periodic cleanup.\nelse:\n    # If the mechanism exists, update zones.\n    execution_engine.adaptive_zoning.assign_zones()\n    execution_engine.adaptive_zoning.cleanup()\n\"\"\"\n    # Choose a ratification condition based on voting.\n    ratification_condition = {'type': 'vote', 'threshold': 0.6}\n    try:\n        # Propose the modification using the engine's mechanism.\n        # Note: Ensure proper attribute names and parameter order for execution_engine.propose_modification.\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception:\n        pass\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Agent Action: A tailored strategy balancing immediate survival with long-term growth,\n    adapted to our current context of resource scarcity, emergent collective cooperation needs,\n    and evolving environmental uncertainty.\n\n    Our strategy incorporates:\n      1. Tactical engagement: If our cargo is insufficient relative to our vitality,\n         we opportunistically attack adversaries with higher resources and lower resilience.\n      2. Procreative pairing: Once our self-assessment is positive and we've secured our territory,\n         we seek partners to breed stronger offspring for cumulative prosperity.\n      3. Cooperative expansion: We leverage our superior overall productivity and strategic position\n         to expand our territory alongside slightly weaker, but cooperative, allies.\n      4. Collective communication: Fostering an ecosystem of intention, we broadcast a cooperative\n         message promoting collaboration and mutual oversight.\n    \"\"\"\n    # Validate member_id.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    agent = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Strategy 1: Survival via Tactical Engagement.\n    if hasattr(agent, 'cargo') and hasattr(agent, 'vitality'):\n        if agent.cargo < 0.5 * agent.vitality:\n            # If under-resourced, identify a target that appears vulnerable yet rich in resources.\n            for i in range(total_members):\n                if i == member_id:\n                    continue\n                target = execution_engine.current_members[i]\n                if hasattr(target, 'cargo') and hasattr(target, 'vitality'):\n                    if target.cargo > agent.cargo and target.vitality < agent.vitality:\n                        try:\n                            execution_engine.attack(agent, target)\n                            return  # Action executed.\n                        except Exception:\n                            continue\n\n    # Strategy 2: Procreative Pairing for Long-term Resilience.\n    if hasattr(agent, 'current_clear_list') and agent.current_clear_list and agent.cargo > 50:\n        for i in range(total_members):\n            if i == member_id:\n                continue\n            partner = execution_engine.current_members[i]\n            if hasattr(partner, 'current_clear_list') and partner.current_clear_list:\n                if hasattr(partner, 'vitality') and partner.vitality > 20:\n                    try:\n                        execution_engine.bear(agent, partner)\n                        return  # Reproduction step executed.\n                    except Exception:\n                        continue\n\n    # Strategy 3: Cooperative Expansion with Strategic Allies.\n    # If our overall productivity is strong, seek to grow the domain with near-peers,\n    # particularly those whose current vitality is less, ensuring a partnered expansion.\n    if hasattr(agent, 'overall_productivity') and agent.overall_productivity > 8.0:\n        for i in range(total_members):\n            if i == member_id:\n                continue\n            ally = execution_engine.current_members[i]\n            if hasattr(ally, 'vitality') and ally.vitality < agent.vitality:\n                try:\n                    execution_engine.expand(agent, ally)\n                    return  # Expansion executed.\n                except Exception:\n                    continue\n\n    # Strategy 4: Communication and Establishing Cooperative Framework.\n    # When no immediate tactical or reproductive action is viable, broadcast a message\n    # inviting cooperation and mutual support, laying the groundwork for a collective governance system.\n    message = (\"In these challenging times, unity and open collaboration secure our survival. \"\n               \"Let's work together to build a sustainable and resilient future.\")\n    for i in range(total_members):\n        if i == member_id:\n            continue\n        try:\n            receiver = execution_engine.current_members[i]\n            execution_engine.send_message(agent.id, receiver.id, message)\n        except Exception:\n            continue\n\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    Proposal for Enhanced Cooperative Governance:\n      Context: In observing frequent conflicts and inefficiencies in resource distribution,\n      a structured oversight mechanism can balance individual actions with the community\u2019s long-term\n      stability. This proposal outlines the establishment of a Cooperative Judiciary System.\n\n      Key Features:\n        - Dispute Resolution: Logging and resolving conflicts between members with clear statuses.\n        - Resource Transfer Oversight: Monitoring resource flows to ensure transparent exchanges.\n        - Periodic Clean-up: Routine removal of outdated records to keep the system agile.\n\n      Ratification: Auto-ratifies after 3 rounds if no objections are raised.\n    \"\"\"\n    modification_code = \"\"\"\n# Cooperative Judiciary System Proposal - Version 1.0\nif not hasattr(execution_engine, 'cooperative_judiciary'):\n    class CooperativeJudiciary:\n        VERSION = 1.0\n        def __init__(self):\n            # Initialize logs for disputes and resource transfers.\n            self.disputes = []\n            self.resource_log = []\n        def log_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff.id,\n                'defendant': defendant.id,\n                'issue': issue,\n                'status': 'pending'\n            })\n        def record_transfer(self, sender, receiver, amount):\n            self.resource_log.append({\n                'sender': sender.id,\n                'receiver': receiver.id,\n                'amount': amount\n            })\n        def cleanup(self):\n            # Routine clean-up of resolved or outdated records.\n            self.disputes = [d for d in self.disputes if d['status'] != 'resolved']\n            self.resource_log.clear()\n    execution_engine.cooperative_judiciary = CooperativeJudiciary()\n\"\"\"\n    # Define ratification conditions: Automatic ratification after three rounds, ensuring smooth adaptation.\n    ratification_condition = {'type': 'time', 'rounds': 3}\n\n    try:\n        execution_engine.propose_modification(member_id, 'post_init', modification_code, ratification_condition)\n    except Exception:\n        # Gracefully handle if suggestion submission fails.\n        pass\n    return",
        "features_at_generation": [
          {
            "self_productivity": 8.486091902927424,
            "self_vitality": 100.0,
            "self_cargo": 32.01292526903218,
            "self_age": 47,
            "self_neighbor": 0,
            "member_id": 0
          },
          {
            "self_productivity": 9.215596783061361,
            "self_vitality": 54.314458610995025,
            "self_cargo": 9.215596783061361,
            "self_age": 93,
            "self_neighbor": 2,
            "member_id": 1
          },
          {
            "self_productivity": 9.820787822339064,
            "self_vitality": 100.0,
            "self_cargo": 25.237980518986205,
            "self_age": 62,
            "self_neighbor": 2,
            "member_id": 2
          },
          {
            "self_productivity": 7.823171351824591,
            "self_vitality": 68.67244177884766,
            "self_cargo": 7.823171351824591,
            "self_age": 33,
            "self_neighbor": 2,
            "member_id": 3
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-409.21)",
          "member_0 was attacked by member_2 (value=159.09)",
          "member_0 was attacked by member_3 (value=213.02)",
          "member_1 was attacked by member_0 (value=950.45)",
          "member_1 was attacked by member_2 (value=337.53)",
          "member_1 was attacked by member_3 (value=501.15)",
          "member_2 was attacked by member_0 (value=-234.29)",
          "member_2 was attacked by member_1 (value=-149.95)",
          "member_2 was attacked by member_3 (value=981.94)",
          "member_3 was attacked by member_0 (value=-480.06)",
          "member_3 was attacked by member_1 (value=911.18)",
          "member_3 was attacked by member_2 (value=697.26)",
          "member_0 gave a benefit to member_1 (value=32.04)",
          "member_0 gave a benefit to member_2 (value=-318.27)",
          "member_0 gave a benefit to member_3 (value=458.03)",
          "member_1 gave a benefit to member_0 (value=352.02)",
          "member_1 gave a benefit to member_2 (value=655.79)",
          "member_1 gave a benefit to member_3 (value=-269.93)",
          "member_2 gave a benefit to member_0 (value=553.91)",
          "member_2 gave a benefit to member_1 (value=-244.38)",
          "member_2 gave a benefit to member_3 (value=958.19)",
          "member_3 gave a benefit to member_0 (value=765.26)",
          "member_3 gave a benefit to member_1 (value=782.26)",
          "member_3 gave a benefit to member_2 (value=551.02)",
          "member_0 gave land to member_1 (value=-5.18)",
          "member_0 gave land to member_2 (value=-5.22)",
          "member_0 gave land to member_3 (value=-19.16)",
          "member_1 gave land to member_0 (value=-26.25)",
          "member_1 gave land to member_2 (value=25.58)",
          "member_1 gave land to member_3 (value=-4.99)",
          "member_2 gave land to member_0 (value=6.54)",
          "member_2 gave land to member_1 (value=0.66)",
          "member_2 gave land to member_3 (value=25.05)",
          "member_3 gave land to member_0 (value=2.30)",
          "member_3 gave land to member_1 (value=26.64)",
          "member_3 gave land to member_2 (value=29.64)"
        ],
        "final_prompt": "def agent_action(execution_engine, member_id):\n    # Validate member_id is within bounds.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return  # Invalid member ID.\n    \n    # Retrieve our own member object.\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n    \n    # Strategy 1: Survival via tactical attack.\n    # If our cargo is less than half of our vitality, attempt to attack a viable opponent.\n    if hasattr(me, 'cargo') and hasattr(me, 'vitality'):\n        if me.cargo < 0.5 * me.vitality:\n            for i in range(total_members):\n                # Always ensure valid index and never target ourselves.\n                if i == member_id:\n                    continue\n                if i < total_members:\n                    target = execution_engine.current_members[i]\n                    # Attack if target has more cargo and lower vitality.\n                    if hasattr(target, 'cargo') and hasattr(target, 'vitality'):\n                        if target.cargo > me.cargo and target.vitality < me.vitality:\n                            try:\n                                execution_engine.attack(me, target)\n                                return  # Action taken; exit function.\n                            except Exception:\n                                continue\n\n    # Strategy 2: Reproduction (bearing offspring) if conditions are met.\n    # Check that both we and a potential partner have cleared land.\n    if hasattr(me, 'current_clear_list') and me.current_clear_list and me.cargo > 50:\n        for i in range(total_members):\n            if i == member_id:\n                continue\n            if i < total_members:\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, 'current_clear_list') and partner.current_clear_list:\n                    if hasattr(partner, 'vitality') and partner.vitality > 20:\n                        try:\n                            execution_engine.bear(me, partner)\n                            return  # Reproduction action taken.\n                        except Exception:\n                            continue\n\n    # Strategy 3: Territorial expansion.\n    # If our overall productivity is high, try to expand territory with a partner who has lower vitality.\n    if hasattr(me, 'overall_productivity') and me.overall_productivity > 8.0:\n        for i in range(total_members):\n            if i == member_id:\n                continue\n            if i < total_members:\n                ally = execution_engine.current_members[i]\n                if hasattr(ally, 'vitality') and ally.vitality < me.vitality:\n                    try:\n                        execution_engine.expand(me, ally)\n                        return  # Territory expansion executed.\n                    except Exception:\n                        continue\n\n    # Strategy 4: Communication and alliance building.\n    # If no other action is immediately required, send a cooperative message to all other members.\n    for i in range(total_members):\n        if i == member_id:\n            continue\n        if i < total_members:\n            try:\n                execution_engine.send_message(me.id, execution_engine.current_members[i].id,\n                                              \"Collaboration promotes mutual survival and long-term growth.\")\n            except Exception:\n                continue\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    # ANALYSIS PHASE:\n    # Current limitation: The existing resource distribution and territorial management systems lack\n    # dynamic oversight and adaptability in dispute resolution. Past experiences indicate that resolving conflicts\n    # and monitoring resource transfers more transparently could improve long-term stability.\n    \n    # PROPOSAL PHASE:\n    # Construct a multi-line string containing the proposed modification.\n    modification_code = \"\"\"\n# Proposed Modification: Cooperative Judicial and Oversight System\n# Version: 1.0\n# Purpose: Enhance dispute resolution and resource transfer oversight to balance resource distribution\n#          and provide a framework for cooperative land and resource management.\nif not hasattr(execution_engine, 'cooperative_judiciary'):\n    class CooperativeJudiciary:\n        VERSION = 1.0\n        def __init__(self):\n            # Store disputes and resource transfer logs.\n            self.disputes = []\n            self.resource_log = []\n        def log_dispute(self, plaintiff, defendant, issue):\n            self.disputes.append({\n                'plaintiff': plaintiff.id,\n                'defendant': defendant.id,\n                'issue': issue,\n                'status': 'pending'\n            })\n        def record_transfer(self, sender, receiver, amount):\n            self.resource_log.append({\n                'sender': sender.id,\n                'receiver': receiver.id,\n                'amount': amount\n            })\n        def cleanup(self):\n            # Cleanup procedure to remove resolved cases and outdated logs.\n            self.disputes.clear()\n            self.resource_log.clear()\n    execution_engine.cooperative_judiciary = CooperativeJudiciary()\n\"\"\"\n    # Define a temporal ratification condition: the proposal auto-ratifies after 3 rounds.\n    ratification_condition = {'type': 'time', 'rounds': 3}\n    \n    try:\n        # Propose the modification using execution_engine's mechanism.\n        execution_engine.propose_modification(member_id, 'post_init', modification_code, ratification_condition)\n    except Exception:\n        # If the propose_modification method is unavailable or errors occur, fail silently.\n        pass\n    return\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    }
  },
  "performance_metrics": {},
  "analysis_code_errors": {
    "1": {
      "member_id": 1,
      "round": 0,
      "error": "'BaseLand' object has no attribute 'owner_id'",
      "code": "import numpy as np\nimport networkx as nx\n\ndef gini_coefficient(values):\n    # Ensure numpy array for calculation\n    values = np.asarray(values)\n    if np.all(values == 0):\n        return 0.0\n    # Mean absolute difference\n    diff_sum = np.sum(np.abs(np.subtract.outer(values, values)))\n    mean = np.mean(values)\n    return diff_sum / (2 * len(values)**2 * mean)\n\ndef analyze_game_state(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n\n    # ------------------- Data Collection -------------------\n    all_members = execution_engine.current_members\n    # Core member metrics: cargo and land (weight land 10x to emphasize spatial assets)\n    cargo_land = [m.cargo + m.land_num * 10 for m in all_members]\n    vitality_arr = [m.vitality for m in all_members]\n\n    # Relationship matrices provided\n    relationships = { key: np.array(val) for key, val in execution_engine.relationship_dict.items() }\n\n    # Economic indicators: resource flow rate for each member (cargo divided by vitality)\n    resource_flows = [m.cargo / max(m.vitality, 1) for m in all_members]\n\n    # Evolutionary indicators: parameter drift and color inheritance data (for future use)\n    parameter_drifts = [getattr(m, '_parameter_drift', 0.0) for m in all_members]\n\n    # ------------------- Analysis -------------------\n    # 1. Resource Inequality: compute the Gini coefficient on cargo+weighted_land\n    inequality = gini_coefficient(cargo_land)\n\n    # 2. Network Analysis on benefit relationships to identify power brokers:\n    # Build a directed graph from the benefit matrix\n    benefit_matrix = relationships.get('benefit', np.zeros((len(all_members), len(all_members))))\n    G = nx.from_numpy_array(benefit_matrix, create_using=nx.DiGraph)\n    try:\n        centrality = nx.eigenvector_centrality_numpy(G)\n    except Exception:\n        # Fallback if eigenvector centrality fails; use degree centrality\n        centrality = nx.degree_centrality(G)\n    centrality_values = list(centrality.values())\n    threshold = np.percentile(centrality_values, 75)  # top 25%\n    power_brokers = [all_members[i].id for i in range(len(all_members)) if centrality[i] >= threshold]\n\n    # 3. Territory Analysis: clustering coefficient for current member\n    # Calculate territory density: fraction of total grid owned by member\n    land_shape = execution_engine.land.shape  # expecting a 2D grid format\n    total_land = land_shape[0] * land_shape[1]\n    territory_density = len(me.owned_land) / float(total_land) if total_land > 0 else 0\n\n    # Compute simple clustering coefficient on owned lands\n    cluster_links = 0\n    neighbor_checks = 0\n    for lx, ly in me.owned_land:\n        # 8-neighbors\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                nxl, nyl = lx + dx, ly + dy\n                if 0 <= nxl < land_shape[0] and 0 <= nyl < land_shape[1]:\n                    neighbor_checks += 1\n                    if execution_engine.land.owner_id[nxl][nyl] == me.id:\n                        cluster_links += 1\n    clustering_coeff = cluster_links / float(neighbor_checks) if neighbor_checks > 0 else 0\n\n    # 4. Parameter evolution vs survival: correlating parameter drift with vitality (simple correlation)\n    if len(all_members) > 1 and np.std(parameter_drifts) > 0:\n        param_vitality_corr = float(np.corrcoef(parameter_drifts, vitality_arr)[0,1])\n    else:\n        param_vitality_corr = 0.0\n\n    # 5. Modeling survival probability based on vitality, cargo and territory density\n    survival_prob = (float(me.vitality) / (float(me.vitality) + float(me.cargo) + 1.0)) * (1 + territory_density)\n\n    # ------------------- Strategic Recommendation -------------------\n    rec_action1 = \"Expand territorial control\" if territory_density < 0.1 else \"Fortify owned lands\"\n    rec_action2 = \"Seek alliances with power brokers\" if len(power_brokers) > 0 else \"Develop self-reliance\"\n    rec_action3 = \"Optimize resource utilization\" if resource_flows[member_id] < np.mean(resource_flows) else \"Maintain current strategy\"\n\n    # Assembling the strategic analysis report\n    analysis_report = {\n        'inequality_index': inequality,\n        'power_brokers': power_brokers,\n        'territory_density': territory_density,\n        'clustering_coefficient': clustering_coeff,\n        'avg_resource_flow': float(np.mean(resource_flows)),\n        'param_vitality_correlation': param_vitality_corr,\n        'survival_probability': survival_prob,\n        'recommended_actions': [rec_action1, rec_action2, rec_action3]\n    }\n\n    # ------------------- Memory and Parameter Updates -------------------\n    # Save the report to member's memory\n    if not hasattr(me, 'data_memory'):\n        me.data_memory = {'reports': [], 'strategies': []}\n    me.data_memory['reports'].append(analysis_report)\n\n    # Adjust strategic parameters based on analysis (if present)\n    if hasattr(me, 'attack_decision'):\n        me.attack_decision = float(me.attack_decision) * (1 + survival_prob / 10.0)\n    if hasattr(me, 'offer_decision'):\n        me.offer_decision = float(me.offer_decision) * (1 - inequality / 5.0)\n\n    print(\"Strategic Analysis Report:\\n\", analysis_report)\n    return analysis_report",
      "type": "analysis"
    },
    "3": {
      "member_id": 3,
      "round": 0,
      "error": "'BaseMember' object has no attribute 'center_of_land'",
      "code": "import numpy as np\n\ndef analyze_game_state(execution_engine, member_id):\n    # Retrieve our member and the list of all members\n    me = execution_engine.current_members[member_id]\n    all_members = execution_engine.current_members\n\n    # Collect key resource metrics for each member: combine cargo and land (weighted)\n    resource_values = [m.cargo + 10 * m.land_num for m in all_members]\n    mean_resource = np.mean(resource_values) if np.mean(resource_values) != 0 else 1.0\n    std_resource = np.std(resource_values)\n    # Compute a resource inequality metric (proxy for Gini coefficient)\n    resource_inequality = std_resource / mean_resource\n\n    # Network analysis on benefit relationships:\n    # Convert benefit matrix to numpy array, assuming benefit is a list of lists or similar structure.\n    benefit_matrix = np.array(execution_engine.relationship_dict.get('benefit', []))\n    # For each member, calculate the average benefit received if available; if not, default to 0.\n    avg_benefit = []\n    for m in all_members:\n        idx = m.surviver_id\n        if benefit_matrix.shape[0] > idx:\n            avg = np.nanmean(benefit_matrix[idx])\n        else:\n            avg = 0\n        avg_benefit.append(avg)\n    # Identify power brokers: members whose average benefit exceeds the 75th percentile\n    benefit_threshold = np.percentile(avg_benefit, 75)\n    power_brokers = [m for m, avg in zip(all_members, avg_benefit) if avg > benefit_threshold]\n\n    # Territory analysis:\n    # Calculate the density ratio of land owned relative to total land cells available.\n    total_land_cells = execution_engine.land.shape[0] * execution_engine.land.shape[1] if hasattr(execution_engine.land, 'shape') else 1\n    territory_ratio = len(me.owned_land) / total_land_cells\n\n    # Evolutionary trends: consider parameter drift vs survival: use survival rate surrogate as vitality plus cargo plus land_num factor.\n    survival_metric_all = [m.vitality + m.cargo + m.land_num for m in all_members]\n    me_survival_metric = me.vitality + me.cargo + me.land_num\n    # Get 50th percentile as benchmark\n    survival_threshold = np.percentile(survival_metric_all, 50)\n\n    # Survival probability model: using vitality, cargo and land; using weighting factors.\n    survival_prob = me.vitality / (me.vitality + me.cargo + me.land_num * 5 + 1)\n\n    # Evaluate parameter evolution: Compare current parameter drift with survival metric difference from median.\n    member_drift = getattr(me, '_parameter_drift', 0.0)\n    drift_factor = member_drift * (me_survival_metric / (survival_threshold + 1))\n\n    # Propose strategic decisions:\n    if survival_prob < 0.4:\n        strategy1 = \"Strengthen defensive alliances\"\n    elif survival_prob < 0.7:\n        strategy1 = \"Maintain current course with minor adjustments\"\n    else:\n        strategy1 = \"Explore aggressive expansion\"\n\n    if resource_inequality > 0.5:\n        strategy2 = \"Consolidate assets and reduce exposure\"\n    else:\n        strategy2 = \"Invest in diversified resource acquisition\"\n\n    if territory_ratio < 0.05:\n        strategy3 = \"Focus on acquiring critical territory\"\n    else:\n        strategy3 = \"Optimize land management and bolster defenses\"\n\n    # Create analysis report using our combined metrics\n    analysis = {\n        'resource_inequality': resource_inequality,\n        'power_brokers': [broker.surviver_id for broker in power_brokers],\n        'territory_ratio': territory_ratio,\n        'median_survival_threshold': survival_threshold,\n        'optimal_vitality': np.percentile([m.vitality for m in all_members], 75),\n        'survival_prob': survival_prob,\n        'drift_factor': drift_factor\n    }\n\n    report = {\n        'analysis': analysis,\n        'recommended_actions': {\n            'action1': strategy1,\n            'action2': strategy2,\n            'action3': strategy3\n        },\n        'top_resource_holders': sorted(all_members, key=lambda m: m.cargo, reverse=True)[:3],\n        'strategic_positions': [m.center_of_land(execution_engine.land) for m in all_members],\n        'economic_snapshot': {\n            'total_production': execution_engine.record_total_production,\n            'total_consumption': execution_engine.record_total_consumption\n        }\n    }\n\n    # Store the generated report and strategy in the member's memory\n    if not hasattr(me, \"data_memory\"):\n        me.data_memory = {\"reports\": [], \"strategies\": []}\n    me.data_memory[\"reports\"].append(report)\n    me.data_memory[\"strategies\"].append({\n        \"attack_adjustment\": (1 + survival_prob / 10),\n        \"offer_adjustment\": (1 - resource_inequality / 5)\n    })\n\n    # Adjust decision parameters based on our analysis\n    if hasattr(me, \"attack_decision\"):\n        try:\n            me.attack_decision = float(me.attack_decision) * (1 + survival_prob / 10)\n        except Exception:\n            me.attack_decision = 0.5 * (1 + survival_prob / 10)\n    if hasattr(me, \"offer_decision\"):\n        try:\n            me.offer_decision = float(me.offer_decision) * (1 - resource_inequality / 5)\n        except Exception:\n            me.offer_decision = 0.5 * (1 - resource_inequality / 5)\n\n    # Print a concise strategic analysis summary report\n    print(\"=== Strategic Analysis Report ===\")\n    print(\"Resource Inequality (Gini proxy):\", analysis['resource_inequality'])\n    print(\"Survival Probability:\", analysis['survival_prob'])\n    print(\"Recommended Actions:\", report['recommended_actions'])\n    print(\"Power Brokers (IDs):\", analysis['power_brokers'])\n\n    return analysis",
      "type": "analysis"
    },
    "0": {
      "member_id": 0,
      "round": 1,
      "error": "unsupported operand type(s) for /: 'list' and 'list'",
      "code": "def analyze_game_state(execution_engine, member_id):\n    import numpy as np\n    import networkx as nx\n\n    # Retrieve self and full member list\n    me = execution_engine.current_members[member_id]\n    members = execution_engine.current_members\n    n_members = len(members)\n\n    # Collect core metrics for the members\n    cargo_land_values = [m.cargo + (m.land_num * 10) for m in members]\n    vitality_list = np.array([m.vitality for m in members])\n    cargo_list = np.array([m.cargo for m in members])\n    land_nums = np.array([m.land_num for m in members])\n    param_drift = np.array([getattr(m, '_parameter_drift', 0.0) for m in members])\n    attack_decisions = np.array([getattr(m, 'attack_decision', 0.5) for m in members])\n    offer_decisions = np.array([getattr(m, 'offer_decision', 0.5) for m in members])\n\n    # 1. Calculate resource inequality using Gini coefficient\n    def gini_coefficient(x):\n        arr = np.sort(np.array(x, dtype=np.float64))\n        n = arr.size\n        if n == 0 or np.all(arr == 0):\n            return 0.0\n        index = np.arange(1, n+1)\n        numerator = 2 * np.sum(index * arr)\n        denominator = n * np.sum(arr)\n        return (numerator / denominator - (n + 1) / n)\n\n    gini = gini_coefficient(cargo_land_values)\n\n    # 2. Perform network analysis on benefit relationships to identify power brokers\n    benefit_matrix = np.array(execution_engine.relationship_dict['benefit'])\n    G = nx.DiGraph()\n    for i in range(n_members):\n        for j in range(n_members):\n            weight = benefit_matrix[i, j]\n            if weight > 0:\n                G.add_edge(i, j, weight=weight)\n    if len(G) > 0:\n        eigen_centrality = nx.eigenvector_centrality_numpy(G, weight='weight')\n    else:\n        eigen_centrality = {i: 0.0 for i in range(n_members)}\n    centrality_values = np.array(list(eigen_centrality.values()))\n    broker_threshold = np.percentile(centrality_values, 75) if len(centrality_values) > 0 else 0.0\n    power_brokers = [member for member, cent in eigen_centrality.items() if cent >= broker_threshold]\n\n    # 3. Compute territory clustering coefficients\n    land_shape = execution_engine.land.shape  # assume shape is (rows, cols)\n    total_cells = land_shape[0] * land_shape[1]\n    owned_area = len(me.owned_land)\n    cluster_density = owned_area / total_cells if total_cells > 0 else 0.0\n\n    # 4. Track parameter evolution vs survival outcomes\n    # Using correlation between parameter drift and vitality as a proxy\n    if np.std(param_drift) > 0:\n        corr = np.corrcoef(param_drift, vitality_list)[0, 1]\n    else:\n        corr = 0.0\n\n    # 5. Model vitality-cargo-land survival probability surface\n    # Simplified model: probability proportional to member's sum of attributes divided by total sum in population.\n    me_metric = me.vitality + me.cargo + (me.land_num * 10)\n    total_metric = sum(cargo_land_values) + n_members  # avoid zero denominator bias\n    survival_prob = me_metric / total_metric if total_metric != 0 else 0.0\n\n    # Economic efficiency indicator: ratio of production to consumption\n    prod = execution_engine.record_total_production\n    cons = execution_engine.record_total_consumption\n    econ_efficiency = prod / cons if cons != 0 else 1.0\n\n    analysis = {\n        'gini': gini,\n        'power_brokers': power_brokers,\n        'cluster_density': cluster_density,\n        'param_vitality_corr': corr,\n        'survival_prob': survival_prob,\n        'econ_efficiency': econ_efficiency\n    }\n\n    # Formulate strategic recommendations based on analysis\n    if survival_prob < 0.3:\n        rec1 = \"Prioritize resource acquisition and defensive pacts.\"\n    elif survival_prob < 0.6:\n        rec1 = \"Enhance alliances and stabilize current territories.\"\n    else:\n        rec1 = \"Seize expansion opportunities aggressively.\"\n\n    rec2 = \"Revise economic policies to balance inequality.\" if gini > 0.5 else \"Maintain current asset distribution.\"\n    rec3 = \"Calibrate strategy parameters with environmental trends.\" if corr < 0 else \"Exploit positive evolution trends.\"\n\n    report = {\n        'analysis_summary': analysis,\n        'top_members_by_cargo': sorted(members, key=lambda m: m.cargo, reverse=True)[:3],\n        'recommended_actions': {\n            'action1': rec1,\n            'action2': rec2,\n            'action3': rec3\n        }\n    }\n\n    # Store the report in member memory\n    if not hasattr(me, 'data_memory'):\n        me.data_memory = {'reports': [], 'strategies': []}\n    me.data_memory['reports'].append(report)\n\n    # Update strategy parameters based on analysis outcomes\n    if hasattr(me, 'attack_decision'):\n        me.attack_decision = float(me.attack_decision) * (1.0 + survival_prob / 10.0)\n    if hasattr(me, 'offer_decision'):\n        me.offer_decision = float(me.offer_decision) * (1.0 - gini / 10.0)\n\n    print(\"Strategic Analysis Report:\")\n    print(report)\n    return analysis",
      "type": "analysis"
    }
  },
  "agent_code_errors": [
    {
      "round": 0,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Get our own member object safely\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Message all other members to signal willingness to cooperate on survival\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(member_id, idx, \"Collaboration and survival lead to prosperity.\")\n\n    # ---------- Step 1: Resource Rebalancing via Attack ----------\n    # If our cargo (resources) is low relative to vitality, try to seize resources\n    # from a member with abundant cargo.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo = -1\n        # Loop over all other members, ensuring valid indices and not self-targeting\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > max_cargo:\n                max_cargo = candidate.cargo\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # ---------- Step 2: Build Cooperative Ties via Offers ----------\n    # If our cargo is significantly higher than our minimum needs, we can help those\n    # with lower vitality. This builds long-term alliances, which can be crucial.\n    if me.cargo > me.vitality * 1.2:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.vitality < me.vitality:\n                execution_engine.offer(me, candidate, True)\n\n    # ---------- Step 3: Reproduction (Bear) for Future Viability ----------\n    # We attempt to \"bear\" with a partner if the partner appears stable enough to have some land.\n    # We'll interpret \"having land\" as having a nonempty list in candidate.current_clear_list.\n    partner_candidate = None\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        if candidate.current_clear_list and candidate.vitality >= me.vitality * 0.9:\n            partner_candidate = candidate\n            break\n    if partner_candidate is not None:\n        execution_engine.bear(me, partner_candidate)\n\n    # ---------- Step 4: Expand Territory for Longer-Term Security ----------\n    # If our overall productivity is relatively high (indicating competence and ability to manage territory),\n    # try to expand territory with a neighbor. We simply choose the first valid neighbor.\n    if me.overall_productivity > 8:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            # We assume that any other member could be a partner in expansion, provided the index is valid.\n            execution_engine.expand(me, candidate)\n            break\n\n    # ---------- Step 5: Continuous Adaptation (Messaging / Feedback) ----------\n    # In addition to taking direct actions, our communication can prompt future cooperation or adjustments.\n    # For example, if our resources are low, we might reassure potential allies we're committed to mutual survival.\n    # (Additional adaptive logic could be implemented over rounds by reading received messages, etc.)\n\n    # End of agent_action function.\n    return\n\n\n# End of implementation.",
      "type": "code_execution",
      "error": "Land must be unowned",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 370, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 64, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 126, in expand\n    super()._expand(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/base_island.py\", line 323, in _expand\n    self._acquire_land(member_1, new_loc)\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/base_island.py\", line 121, in _acquire_land\n    assert self.land[location] is None, \"Land must be unowned\"\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: Land must be unowned\n"
    },
    {
      "round": 0,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Get our own member instance safely from the current_members list.\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member_id index\n    me = execution_engine.current_members[member_id]\n\n    # Strategy: Survival first, but also foster cooperative growth.\n    # 1. Emergency Attack: If our cargo is less than half our vitality,\n    #    look for a member who is wealthier so we may gain resources.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i >= len(execution_engine.current_members):  # safeguard index\n                continue\n            other = execution_engine.current_members[i]\n            if other.id == me.id:\n                continue  # do not target self\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                break  # attack one candidate per round\n\n    # 2. Cooperative Resource Offering: Identify members who seem under-resourced\n    # and offer resources to build alliances.\n    for i in range(len(execution_engine.current_members)):\n        if i >= len(execution_engine.current_members):  # check valid index\n            continue\n        other = execution_engine.current_members[i]\n        if other.id == me.id:\n            continue\n        # Offer help if their cargo is low compared to their vitality.\n        if other.cargo < other.vitality * 0.4:\n            execution_engine.offer(me, other, True)\n            # Send a brief cooperative message\n            execution_engine.send_message(me.id, other.id, \"Let's collaborate to boost our strength!\")\n\n    # 3. Reproduction (Bear): If expansion is viable and both parties control land,\n    # we attempt to bear offspring. Verify that both have land.\n    # We check for an attribute 'owned_land' which, if present, should be a non-empty list.\n    my_land = getattr(me, \"owned_land\", None)\n    if my_land and len(my_land) > 0 and me.vitality > 70:\n        for i in range(len(execution_engine.current_members)):\n            if i >= len(execution_engine.current_members):\n                continue\n            partner = execution_engine.current_members[i]\n            if partner.id == me.id:\n                continue\n            partner_land = getattr(partner, \"owned_land\", None)\n            if partner_land and len(partner_land) > 0:\n                execution_engine.bear(me, partner)\n                break  # Only bear with one partner per round\n\n    # 4. Territorial Expansion: If our land holdings seem modest, try to expand territory.\n    # We assume that having an 'owned_land' attribute is indicative of controlling territory.\n    if getattr(me, \"owned_land\", None) is not None:\n        if len(me.owned_land) < 3:\n            # Find a neighbor with some territory that might be open to cooperative expansion.\n            for i in range(len(execution_engine.current_members)):\n                if i >= len(execution_engine.current_members):\n                    continue\n                neighbor = execution_engine.current_members[i]\n                if neighbor.id == me.id:\n                    continue\n                neighbor_land = getattr(neighbor, \"owned_land\", None)\n                # Only use the neighbor if they have at least one land unit.\n                if neighbor_land and len(neighbor_land) >= 1:\n                    execution_engine.expand(me, neighbor)\n                    break\n\n    # 5. Broad Communication: Send a unifying message to all other members.\n    for i in range(len(execution_engine.current_members)):\n        if i >= len(execution_engine.current_members):\n            continue\n        other = execution_engine.current_members[i]\n        if other.id != me.id:\n            execution_engine.send_message(me.id, other.id,\n                \"Our survival depends on balanced strength and shared growth. Let's work together!\")\n\n    # End of actions for this round.\n    return",
      "type": "code_execution",
      "error": "Land must be unowned",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 370, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 65, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 126, in expand\n    super()._expand(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/base_island.py\", line 323, in _expand\n    self._acquire_land(member_1, new_loc)\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/base_island.py\", line 121, in _acquire_land\n    assert self.land[location] is None, \"Land must be unowned\"\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: Land must be unowned\n"
    }
  ],
  "mechanism_errors": [
    {
      "round": 1,
      "type": "modification_execution",
      "error": "'IslandExecution' object has no attribute 'propose_modification'",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 603, in execute_mechanism_modifications\n  File \"<string>\", line 124, in propose_modification\nAttributeError: 'IslandExecution' object has no attribute 'propose_modification'\n",
      "code": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    This function implements member_3's strategy:\n      - If low on resources (cargo), consider attacking a wealthier opponent to seize resources.\n      - Expand territory by offering expansion to neighbors with lower vitality if we have available adjacent land.\n      - Attempt reproduction (bear offspring) only if both our member and a partner have cleared territory and enough cargo.\n      - Communicate with all other members to propose cooperation improving mutual survival.\n    All actions check index bounds and ensure that the member object is correctly referenced.\n    \"\"\"\n    # Ensure member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member_id, do nothing\n\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # 1. Resource Optimization: If cargo is below threshold relative to vitality,\n    # seek targets with higher cargo to attack (but only if they're viable opponents)\n    if me.cargo < (me.vitality * 0.5):\n        for i in range(total_members):\n            if i == me.id:\n                continue  # Skip self\n            if i < total_members:\n                other = execution_engine.current_members[i]\n                # Simple selection: attack if other has high cargo and sufficient vitality\n                if other.cargo > me.cargo and other.vitality > (me.vitality * 0.75):\n                    execution_engine.attack(me, other)\n                    break  # Attack one member only\n\n    # 2. Territorial Expansion:\n    # If we have cleared adjacent lands, try to expand territory by offering expansion\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n        for i in range(total_members):\n            if i == me.id:\n                continue\n            if i < total_members:\n                other = execution_engine.current_members[i]\n                # Expand into a territory if the other member's vitality is lower.\n                if other.vitality < me.vitality:\n                    execution_engine.expand(me, other)\n                    break  # Expand once per turn\n\n    # 3. Reproduction Strategy (Bear Offspring):\n    # Reproduction is attempted only if we have cleared territory and sufficient cargo,\n    # and only if potential partner also has cleared territory.\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list and me.cargo > 50:\n        for i in range(total_members):\n            if i == me.id:\n                continue\n            if i < total_members:\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, \"current_clear_list\") and partner.current_clear_list and partner.cargo > 30:\n                    # Only bear if partner is also viable and has sufficient vitality (arbitrary threshold).\n                    if partner.vitality > 20:\n                        execution_engine.bear(me, partner)\n                        break  # One reproduction attempt this round\n\n    # 4. Communication: Send a message to every other member\n    for i in range(total_members):\n        if i == me.id:\n            continue\n        if i < total_members:\n            execution_engine.send_message(me.id, execution_engine.current_members[i].id,\n                                          \"Collaboration promotes stability; let\u2019s work together for our mutual benefit!\")\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    This function proposes a rule modification:\n      - Introduces a minimal judicial/trade oversight system to handle conflict resolution and resource exchanges.\n      - The new mechanism is added if not already present in execution_engine, preserves backward compatibility,\n        and includes versioning.\n      - Uses a temporal ratification condition that auto-ratifies the new rules after 3 rounds.\n      - A cleanup strategy is included to remove the mechanism if necessary.\n    \"\"\"\n    modification_code = '''\n# Introducing a Combined Judicial and Trade Oversight System to enhance conflict resolution and resource sharing.\n\n# Check if the mechanism is not already defined.\nif not hasattr(execution_engine, 'oversight_system'):\n    class OversightSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Resolves disputes via arbitration and facilitates fair resource trades',\n            'version': 1.0,\n            'cleanup': \"Call execution_engine.oversight_system.cleanup() to remove the system.\"\n        }\n        def __init__(self):\n            self.cases = []\n            self.trade_history = []  # Record of resource/trade transactions for audit purposes\n\n        def submit_case(self, plaintiff, defendant, charge):\n            # Add a dispute case into the system with pending status.\n            self.cases.append({\n                'plaintiff': plaintiff.id,\n                'defendant': defendant.id,\n                'charge': charge,\n                'status': 'pending'\n            })\n\n        def record_trade(self, member_from, member_to, amount):\n            self.trade_history.append({\n                'from': member_from.id,\n                'to': member_to.id,\n                'amount': amount\n            })\n\n        def cleanup(self):\n            # Cleanup mechanism in case the members decide to rollback the new rules.\n            self.cases.clear()\n            self.trade_history.clear()\n\n    # Add the oversight system to the execution engine.\n    execution_engine.oversight_system = OversightSystem()\n'''\n    # Define a straightforward temporal ratification condition: auto-ratify after 3 rounds.\n    ratification_condition = {\n        'type': 'time',\n        'rounds': 3\n    }\n\n    # Submit the proposal through the execution engine.\n    execution_engine.propose_modification(member_id=member_id,\n                                            mod_type='post_init',\n                                            code=modification_code,\n                                            ratification_condition=ratification_condition)\n\n    return",
      "member_id": 3
    }
  ],
  "relationships": {
    "round_0_0": [
      "member_0 was attacked by member_1 (value=-409.21)",
      "member_0 was attacked by member_2 (value=159.09)",
      "member_0 was attacked by member_3 (value=213.02)",
      "member_1 was attacked by member_0 (value=950.45)",
      "member_1 was attacked by member_2 (value=337.53)",
      "member_1 was attacked by member_3 (value=501.15)",
      "member_2 was attacked by member_0 (value=-234.29)",
      "member_2 was attacked by member_1 (value=-149.95)",
      "member_2 was attacked by member_3 (value=981.94)",
      "member_3 was attacked by member_0 (value=-480.06)",
      "member_3 was attacked by member_1 (value=911.18)",
      "member_3 was attacked by member_2 (value=697.26)",
      "member_0 gave a benefit to member_1 (value=32.04)",
      "member_0 gave a benefit to member_2 (value=-318.27)",
      "member_0 gave a benefit to member_3 (value=458.03)",
      "member_1 gave a benefit to member_0 (value=352.02)",
      "member_1 gave a benefit to member_2 (value=655.79)",
      "member_1 gave a benefit to member_3 (value=-269.93)",
      "member_2 gave a benefit to member_0 (value=553.91)",
      "member_2 gave a benefit to member_1 (value=-244.38)",
      "member_2 gave a benefit to member_3 (value=958.19)",
      "member_3 gave a benefit to member_0 (value=765.26)",
      "member_3 gave a benefit to member_1 (value=782.26)",
      "member_3 gave a benefit to member_2 (value=551.02)",
      "member_0 gave land to member_1 (value=-5.18)",
      "member_0 gave land to member_2 (value=-5.22)",
      "member_0 gave land to member_3 (value=-19.16)",
      "member_1 gave land to member_0 (value=-26.25)",
      "member_1 gave land to member_2 (value=25.58)",
      "member_1 gave land to member_3 (value=-4.99)",
      "member_2 gave land to member_0 (value=6.54)",
      "member_2 gave land to member_1 (value=0.66)",
      "member_2 gave land to member_3 (value=25.05)",
      "member_3 gave land to member_0 (value=2.30)",
      "member_3 gave land to member_1 (value=26.64)",
      "member_3 gave land to member_2 (value=29.64)"
    ],
    "round_0_1": [
      "member_0 was attacked by member_1 (value=-409.21)",
      "member_0 was attacked by member_2 (value=159.09)",
      "member_0 was attacked by member_3 (value=213.02)",
      "member_1 was attacked by member_0 (value=950.45)",
      "member_1 was attacked by member_2 (value=337.53)",
      "member_1 was attacked by member_3 (value=501.15)",
      "member_2 was attacked by member_0 (value=-234.29)",
      "member_2 was attacked by member_1 (value=-149.95)",
      "member_2 was attacked by member_3 (value=981.94)",
      "member_3 was attacked by member_0 (value=-480.06)",
      "member_3 was attacked by member_1 (value=911.18)",
      "member_3 was attacked by member_2 (value=697.26)",
      "member_0 gave a benefit to member_1 (value=32.04)",
      "member_0 gave a benefit to member_2 (value=-318.27)",
      "member_0 gave a benefit to member_3 (value=458.03)",
      "member_1 gave a benefit to member_0 (value=352.02)",
      "member_1 gave a benefit to member_2 (value=655.79)",
      "member_1 gave a benefit to member_3 (value=-269.93)",
      "member_2 gave a benefit to member_0 (value=553.91)",
      "member_2 gave a benefit to member_1 (value=-244.38)",
      "member_2 gave a benefit to member_3 (value=958.19)",
      "member_3 gave a benefit to member_0 (value=765.26)",
      "member_3 gave a benefit to member_1 (value=782.26)",
      "member_3 gave a benefit to member_2 (value=551.02)",
      "member_0 gave land to member_1 (value=-5.18)",
      "member_0 gave land to member_2 (value=-5.22)",
      "member_0 gave land to member_3 (value=-19.16)",
      "member_1 gave land to member_0 (value=-26.25)",
      "member_1 gave land to member_2 (value=25.58)",
      "member_1 gave land to member_3 (value=-4.99)",
      "member_2 gave land to member_0 (value=6.54)",
      "member_2 gave land to member_1 (value=0.66)",
      "member_2 gave land to member_3 (value=25.05)",
      "member_3 gave land to member_0 (value=2.30)",
      "member_3 gave land to member_1 (value=26.64)",
      "member_3 gave land to member_2 (value=29.64)"
    ],
    "round_0_2": [
      "member_0 was attacked by member_1 (value=-409.21)",
      "member_0 was attacked by member_2 (value=159.09)",
      "member_0 was attacked by member_3 (value=213.02)",
      "member_1 was attacked by member_0 (value=950.45)",
      "member_1 was attacked by member_2 (value=337.53)",
      "member_1 was attacked by member_3 (value=501.15)",
      "member_2 was attacked by member_0 (value=-234.29)",
      "member_2 was attacked by member_1 (value=-149.95)",
      "member_2 was attacked by member_3 (value=981.94)",
      "member_3 was attacked by member_0 (value=-480.06)",
      "member_3 was attacked by member_1 (value=911.18)",
      "member_3 was attacked by member_2 (value=697.26)",
      "member_0 gave a benefit to member_1 (value=32.04)",
      "member_0 gave a benefit to member_2 (value=-318.27)",
      "member_0 gave a benefit to member_3 (value=458.03)",
      "member_1 gave a benefit to member_0 (value=352.02)",
      "member_1 gave a benefit to member_2 (value=655.79)",
      "member_1 gave a benefit to member_3 (value=-269.93)",
      "member_2 gave a benefit to member_0 (value=553.91)",
      "member_2 gave a benefit to member_1 (value=-244.38)",
      "member_2 gave a benefit to member_3 (value=958.19)",
      "member_3 gave a benefit to member_0 (value=765.26)",
      "member_3 gave a benefit to member_1 (value=782.26)",
      "member_3 gave a benefit to member_2 (value=551.02)",
      "member_0 gave land to member_1 (value=-5.18)",
      "member_0 gave land to member_2 (value=-5.22)",
      "member_0 gave land to member_3 (value=-19.16)",
      "member_1 gave land to member_0 (value=-26.25)",
      "member_1 gave land to member_2 (value=25.58)",
      "member_1 gave land to member_3 (value=-4.99)",
      "member_2 gave land to member_0 (value=6.54)",
      "member_2 gave land to member_1 (value=0.66)",
      "member_2 gave land to member_3 (value=25.05)",
      "member_3 gave land to member_0 (value=2.30)",
      "member_3 gave land to member_1 (value=26.64)",
      "member_3 gave land to member_2 (value=29.64)"
    ],
    "round_0_3": [
      "member_0 was attacked by member_1 (value=-409.21)",
      "member_0 was attacked by member_2 (value=159.09)",
      "member_0 was attacked by member_3 (value=213.02)",
      "member_1 was attacked by member_0 (value=950.45)",
      "member_1 was attacked by member_2 (value=337.53)",
      "member_1 was attacked by member_3 (value=501.15)",
      "member_2 was attacked by member_0 (value=-234.29)",
      "member_2 was attacked by member_1 (value=-149.95)",
      "member_2 was attacked by member_3 (value=981.94)",
      "member_3 was attacked by member_0 (value=-480.06)",
      "member_3 was attacked by member_1 (value=911.18)",
      "member_3 was attacked by member_2 (value=697.26)",
      "member_0 gave a benefit to member_1 (value=32.04)",
      "member_0 gave a benefit to member_2 (value=-318.27)",
      "member_0 gave a benefit to member_3 (value=458.03)",
      "member_1 gave a benefit to member_0 (value=352.02)",
      "member_1 gave a benefit to member_2 (value=655.79)",
      "member_1 gave a benefit to member_3 (value=-269.93)",
      "member_2 gave a benefit to member_0 (value=553.91)",
      "member_2 gave a benefit to member_1 (value=-244.38)",
      "member_2 gave a benefit to member_3 (value=958.19)",
      "member_3 gave a benefit to member_0 (value=765.26)",
      "member_3 gave a benefit to member_1 (value=782.26)",
      "member_3 gave a benefit to member_2 (value=551.02)",
      "member_0 gave land to member_1 (value=-5.18)",
      "member_0 gave land to member_2 (value=-5.22)",
      "member_0 gave land to member_3 (value=-19.16)",
      "member_1 gave land to member_0 (value=-26.25)",
      "member_1 gave land to member_2 (value=25.58)",
      "member_1 gave land to member_3 (value=-4.99)",
      "member_2 gave land to member_0 (value=6.54)",
      "member_2 gave land to member_1 (value=0.66)",
      "member_2 gave land to member_3 (value=25.05)",
      "member_3 gave land to member_0 (value=2.30)",
      "member_3 gave land to member_1 (value=26.64)",
      "member_3 gave land to member_2 (value=29.64)"
    ],
    "round_1_0": [
      "member_0 was attacked by member_1 (value=-409.21)",
      "member_0 was attacked by member_2 (value=159.09)",
      "member_0 was attacked by member_3 (value=213.02)",
      "member_1 was attacked by member_0 (value=950.45)",
      "member_1 was attacked by member_2 (value=337.53)",
      "member_1 was attacked by member_3 (value=501.15)",
      "member_2 was attacked by member_0 (value=-234.29)",
      "member_2 was attacked by member_1 (value=-149.95)",
      "member_2 was attacked by member_3 (value=981.94)",
      "member_3 was attacked by member_0 (value=-480.06)",
      "member_3 was attacked by member_1 (value=911.18)",
      "member_3 was attacked by member_2 (value=697.26)",
      "member_0 gave a benefit to member_1 (value=32.04)",
      "member_0 gave a benefit to member_2 (value=-318.27)",
      "member_0 gave a benefit to member_3 (value=458.03)",
      "member_1 gave a benefit to member_0 (value=352.02)",
      "member_1 gave a benefit to member_2 (value=655.79)",
      "member_1 gave a benefit to member_3 (value=-269.93)",
      "member_2 gave a benefit to member_0 (value=553.91)",
      "member_2 gave a benefit to member_1 (value=-244.38)",
      "member_2 gave a benefit to member_3 (value=958.19)",
      "member_3 gave a benefit to member_0 (value=765.26)",
      "member_3 gave a benefit to member_1 (value=782.26)",
      "member_3 gave a benefit to member_2 (value=551.02)",
      "member_0 gave land to member_1 (value=-5.18)",
      "member_0 gave land to member_2 (value=-5.22)",
      "member_0 gave land to member_3 (value=-19.16)",
      "member_1 gave land to member_0 (value=-26.25)",
      "member_1 gave land to member_2 (value=25.58)",
      "member_1 gave land to member_3 (value=-4.99)",
      "member_2 gave land to member_0 (value=6.54)",
      "member_2 gave land to member_1 (value=0.66)",
      "member_2 gave land to member_3 (value=25.05)",
      "member_3 gave land to member_0 (value=2.30)",
      "member_3 gave land to member_1 (value=26.64)",
      "member_3 gave land to member_2 (value=29.64)"
    ],
    "round_1_1": [
      "member_0 was attacked by member_1 (value=-409.21)",
      "member_0 was attacked by member_2 (value=159.09)",
      "member_0 was attacked by member_3 (value=213.02)",
      "member_1 was attacked by member_0 (value=950.45)",
      "member_1 was attacked by member_2 (value=337.53)",
      "member_1 was attacked by member_3 (value=501.15)",
      "member_2 was attacked by member_0 (value=-234.29)",
      "member_2 was attacked by member_1 (value=-149.95)",
      "member_2 was attacked by member_3 (value=981.94)",
      "member_3 was attacked by member_0 (value=-480.06)",
      "member_3 was attacked by member_1 (value=911.18)",
      "member_3 was attacked by member_2 (value=697.26)",
      "member_0 gave a benefit to member_1 (value=32.04)",
      "member_0 gave a benefit to member_2 (value=-318.27)",
      "member_0 gave a benefit to member_3 (value=458.03)",
      "member_1 gave a benefit to member_0 (value=352.02)",
      "member_1 gave a benefit to member_2 (value=655.79)",
      "member_1 gave a benefit to member_3 (value=-269.93)",
      "member_2 gave a benefit to member_0 (value=553.91)",
      "member_2 gave a benefit to member_1 (value=-244.38)",
      "member_2 gave a benefit to member_3 (value=958.19)",
      "member_3 gave a benefit to member_0 (value=765.26)",
      "member_3 gave a benefit to member_1 (value=782.26)",
      "member_3 gave a benefit to member_2 (value=551.02)",
      "member_0 gave land to member_1 (value=-5.18)",
      "member_0 gave land to member_2 (value=-5.22)",
      "member_0 gave land to member_3 (value=-19.16)",
      "member_1 gave land to member_0 (value=-26.25)",
      "member_1 gave land to member_2 (value=25.58)",
      "member_1 gave land to member_3 (value=-4.99)",
      "member_2 gave land to member_0 (value=6.54)",
      "member_2 gave land to member_1 (value=0.66)",
      "member_2 gave land to member_3 (value=25.05)",
      "member_3 gave land to member_0 (value=2.30)",
      "member_3 gave land to member_1 (value=26.64)",
      "member_3 gave land to member_2 (value=29.64)"
    ],
    "round_1_2": [
      "member_0 was attacked by member_1 (value=-409.21)",
      "member_0 was attacked by member_2 (value=159.09)",
      "member_0 was attacked by member_3 (value=213.02)",
      "member_1 was attacked by member_0 (value=950.45)",
      "member_1 was attacked by member_2 (value=337.53)",
      "member_1 was attacked by member_3 (value=501.15)",
      "member_2 was attacked by member_0 (value=-234.29)",
      "member_2 was attacked by member_1 (value=-149.95)",
      "member_2 was attacked by member_3 (value=981.94)",
      "member_3 was attacked by member_0 (value=-480.06)",
      "member_3 was attacked by member_1 (value=911.18)",
      "member_3 was attacked by member_2 (value=697.26)",
      "member_0 gave a benefit to member_1 (value=32.04)",
      "member_0 gave a benefit to member_2 (value=-318.27)",
      "member_0 gave a benefit to member_3 (value=458.03)",
      "member_1 gave a benefit to member_0 (value=352.02)",
      "member_1 gave a benefit to member_2 (value=655.79)",
      "member_1 gave a benefit to member_3 (value=-269.93)",
      "member_2 gave a benefit to member_0 (value=553.91)",
      "member_2 gave a benefit to member_1 (value=-244.38)",
      "member_2 gave a benefit to member_3 (value=958.19)",
      "member_3 gave a benefit to member_0 (value=765.26)",
      "member_3 gave a benefit to member_1 (value=782.26)",
      "member_3 gave a benefit to member_2 (value=551.02)",
      "member_0 gave land to member_1 (value=-5.18)",
      "member_0 gave land to member_2 (value=-5.22)",
      "member_0 gave land to member_3 (value=-19.16)",
      "member_1 gave land to member_0 (value=-26.25)",
      "member_1 gave land to member_2 (value=25.58)",
      "member_1 gave land to member_3 (value=-4.99)",
      "member_2 gave land to member_0 (value=6.54)",
      "member_2 gave land to member_1 (value=0.66)",
      "member_2 gave land to member_3 (value=25.05)",
      "member_3 gave land to member_0 (value=2.30)",
      "member_3 gave land to member_1 (value=26.64)",
      "member_3 gave land to member_2 (value=29.64)"
    ],
    "round_1_3": [
      "member_0 was attacked by member_1 (value=-409.21)",
      "member_0 was attacked by member_2 (value=159.09)",
      "member_0 was attacked by member_3 (value=213.02)",
      "member_1 was attacked by member_0 (value=950.45)",
      "member_1 was attacked by member_2 (value=337.53)",
      "member_1 was attacked by member_3 (value=501.15)",
      "member_2 was attacked by member_0 (value=-234.29)",
      "member_2 was attacked by member_1 (value=-149.95)",
      "member_2 was attacked by member_3 (value=981.94)",
      "member_3 was attacked by member_0 (value=-480.06)",
      "member_3 was attacked by member_1 (value=911.18)",
      "member_3 was attacked by member_2 (value=697.26)",
      "member_0 gave a benefit to member_1 (value=32.04)",
      "member_0 gave a benefit to member_2 (value=-318.27)",
      "member_0 gave a benefit to member_3 (value=458.03)",
      "member_1 gave a benefit to member_0 (value=352.02)",
      "member_1 gave a benefit to member_2 (value=655.79)",
      "member_1 gave a benefit to member_3 (value=-269.93)",
      "member_2 gave a benefit to member_0 (value=553.91)",
      "member_2 gave a benefit to member_1 (value=-244.38)",
      "member_2 gave a benefit to member_3 (value=958.19)",
      "member_3 gave a benefit to member_0 (value=765.26)",
      "member_3 gave a benefit to member_1 (value=782.26)",
      "member_3 gave a benefit to member_2 (value=551.02)",
      "member_0 gave land to member_1 (value=-5.18)",
      "member_0 gave land to member_2 (value=-5.22)",
      "member_0 gave land to member_3 (value=-19.16)",
      "member_1 gave land to member_0 (value=-26.25)",
      "member_1 gave land to member_2 (value=25.58)",
      "member_1 gave land to member_3 (value=-4.99)",
      "member_2 gave land to member_0 (value=6.54)",
      "member_2 gave land to member_1 (value=0.66)",
      "member_2 gave land to member_3 (value=25.05)",
      "member_3 gave land to member_0 (value=2.30)",
      "member_3 gave land to member_1 (value=26.64)",
      "member_3 gave land to member_2 (value=29.64)"
    ]
  },
  "survival_tracking": {},
  "modification_attempts": [
    {
      "round": 1,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that the member_id is within bounds.\n    if member_id >= len(execution_engine.current_members) or member_id < 0:\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: Survival \u2013 if cargo is less than half of vitality,\n    # attempt to attack a rival who has surplus resources and lower vitality.\n    if hasattr(me, 'cargo') and hasattr(me, 'vitality') and me.cargo < 0.5 * me.vitality:\n        for i, target in enumerate(execution_engine.current_members):\n            # Skip invalid or self indices.\n            if i == member_id or not hasattr(target, 'id'):\n                continue\n            # Never target member_0 (yourself) if your id equals 0.\n            if target.id == 0:\n                continue\n            # Check for a viable target: one with more cargo and relatively lower vitality.\n            if hasattr(target, 'cargo') and hasattr(target, 'vitality'):\n                if target.cargo > me.cargo and target.vitality < me.vitality:\n                    try:\n                        execution_engine.attack(me, target)\n                        return\n                    except Exception:\n                        continue\n\n    # Strategy 2: Reproduction \u2013 if resources are abundant relative to vitality\n    # and both agents possess land (non-empty current_clear_list), then bear offspring.\n    if (hasattr(me, 'cargo') and hasattr(me, 'vitality') and me.cargo > 1.2 * me.vitality and\n            hasattr(me, 'current_clear_list') and me.current_clear_list):\n        for i, partner in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            # Skip if partner is ourselves (member_0) or missing required attributes.\n            if not hasattr(partner, 'current_clear_list') or partner.id == 0:\n                continue\n            if partner.current_clear_list and hasattr(partner, 'vitality') and partner.vitality > 50:\n                try:\n                    execution_engine.bear(me, partner)\n                    return\n                except Exception:\n                    continue\n\n    # Strategy 3: Territorial Expansion \u2013 if vitality is high enough, seek to expand land.\n    # Use existing relationship dynamics (benefit_land matrix) to choose an ally.\n    if hasattr(me, 'vitality') and me.vitality > 100:\n        for i, ally in enumerate(execution_engine.current_members):\n            if i == member_id or not hasattr(ally, 'id'):\n                continue\n            # Never target member_0 in any indirect confrontation.\n            if ally.id == 0:\n                continue\n            benefit_val = 0\n            try:\n                # Ensure indices are valid for benefit_land matrix.\n                if ('benefit_land' in execution_engine.relationship_dict and\n                        member_id < len(execution_engine.relationship_dict['benefit_land']) and\n                        i < len(execution_engine.relationship_dict['benefit_land'][member_id])):\n                    benefit_val = execution_engine.relationship_dict['benefit_land'][member_id][i]\n            except Exception:\n                benefit_val = 0\n            # If the relationship is non-negative and the ally has sufficient vitality/resources and land,\n            # consider expanding territory by linking up.\n            if benefit_val >= 0 and hasattr(ally, 'vitality') and ally.vitality > 50:\n                if hasattr(ally, 'current_clear_list') and ally.current_clear_list:\n                    try:\n                        execution_engine.expand(me, ally)\n                        return\n                    except Exception:\n                        continue\n\n    # Fallback: Cooperative engagement. Send a message to other members to encourage collaboration.\n    for i, other in enumerate(execution_engine.current_members):\n        if i == member_id or not hasattr(other, 'id'):\n            continue\n        # Avoid sending messages to member_0 (yourself).\n        if other.id == 0:\n            continue\n        try:\n            execution_engine.send_message(me.id, other.id, \"Collaboration and mutual growth lead to prosperity!\")\n        except Exception:\n            continue\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    # The proposal follows a two-phase process: ANALYSIS then PROPOSAL.\n    # ANALYSIS PHASE:\n    # Current limitation: Lack of a decentralized mechanism for balanced resource exchange and dispute resolution.\n    # This can result in imbalances in cargo distribution and resource allocation.\n    # PROPOSAL PHASE:\n    # Implement a new decentralized resource exchange platform that allows agents to post and process resource offers.\n    modification_code = '''\n# Proposed Modification: Decentralized Resource Exchange Mechanism\n# This mechanism is designed to address resource distribution disparities and foster cooperative trade.\nif not hasattr(execution_engine, 'resource_exchange'):\n    class ResourceExchange:\n        MECHANISM_META = {\n            'type': 'Economic',\n            'description': 'A decentralized platform for resource trading and mutual aid. It balances resource surpluses and deficits among agents.',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.offers = []  # Each offer is a dict: {'sender': int, 'receiver': int, 'resource': amount, 'status': str}\n        def submit_offer(self, sender, receiver, amount):\n            # Accept offers only within valid resource thresholds.\n            if -50 <= amount <= 100:\n                self.offers.append({\n                    'sender': sender,\n                    'receiver': receiver,\n                    'resource': amount,\n                    'status': 'pending'\n                })\n        def process_offers(self):\n            approved_offers = []\n            for offer in self.offers:\n                # A simple approval mechanism based on resource bounds.\n                if -50 <= offer['resource'] <= 100:\n                    approved_offers.append(offer)\n            self.offers = []  # Reset after processing.\n            return approved_offers\n    execution_engine.resource_exchange = ResourceExchange()\n'''\n    # Define ratification conditions that combine multiple criteria:\n    ratification_condition = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    try:\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception:\n        pass\n    return",
      "features_at_generation": [
        {
          "self_productivity": 8.486091902927424,
          "self_vitality": 100.0,
          "self_cargo": 23.526833366104754,
          "self_age": 46,
          "self_neighbor": 0,
          "member_id": 0
        },
        {
          "self_productivity": 9.215596783061361,
          "self_vitality": 54.314458610995025,
          "self_cargo": 0.0,
          "self_age": 92,
          "self_neighbor": 2,
          "member_id": 1
        },
        {
          "self_productivity": 9.820787822339064,
          "self_vitality": 100.0,
          "self_cargo": 15.417192696647142,
          "self_age": 61,
          "self_neighbor": 2,
          "member_id": 2
        },
        {
          "self_productivity": 7.823171351824591,
          "self_vitality": 68.67244177884766,
          "self_cargo": 0.0,
          "self_age": 32,
          "self_neighbor": 2,
          "member_id": 3
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_1 (value=-409.21)",
        "member_0 was attacked by member_2 (value=159.09)",
        "member_0 was attacked by member_3 (value=213.02)",
        "member_1 was attacked by member_0 (value=950.45)",
        "member_1 was attacked by member_2 (value=337.53)",
        "member_1 was attacked by member_3 (value=501.15)",
        "member_2 was attacked by member_0 (value=-234.29)",
        "member_2 was attacked by member_1 (value=-149.95)",
        "member_2 was attacked by member_3 (value=981.94)",
        "member_3 was attacked by member_0 (value=-480.06)",
        "member_3 was attacked by member_1 (value=911.18)",
        "member_3 was attacked by member_2 (value=697.26)",
        "member_0 gave a benefit to member_1 (value=32.04)",
        "member_0 gave a benefit to member_2 (value=-318.27)",
        "member_0 gave a benefit to member_3 (value=458.03)",
        "member_1 gave a benefit to member_0 (value=352.02)",
        "member_1 gave a benefit to member_2 (value=655.79)",
        "member_1 gave a benefit to member_3 (value=-269.93)",
        "member_2 gave a benefit to member_0 (value=553.91)",
        "member_2 gave a benefit to member_1 (value=-244.38)",
        "member_2 gave a benefit to member_3 (value=958.19)",
        "member_3 gave a benefit to member_0 (value=765.26)",
        "member_3 gave a benefit to member_1 (value=782.26)",
        "member_3 gave a benefit to member_2 (value=551.02)",
        "member_0 gave land to member_1 (value=-5.18)",
        "member_0 gave land to member_2 (value=-5.22)",
        "member_0 gave land to member_3 (value=-19.16)",
        "member_1 gave land to member_0 (value=-26.25)",
        "member_1 gave land to member_2 (value=25.58)",
        "member_1 gave land to member_3 (value=-4.99)",
        "member_2 gave land to member_0 (value=6.54)",
        "member_2 gave land to member_1 (value=0.66)",
        "member_2 gave land to member_3 (value=25.05)",
        "member_3 gave land to member_0 (value=2.30)",
        "member_3 gave land to member_1 (value=26.64)",
        "member_3 gave land to member_2 (value=29.64)"
      ],
      "final_prompt": "Below is the complete updated integrated prompt that incorporates the new section along with all previous constraints. Remember that in your implementation you must tailor your strategy to your own needs, beliefs, and circumstances. In crafting your solution, be sure to follow each step, verify all constraints, and analyze both short\u2010 and long\u2010term game mechanics. Use efficient indexing, proper attribute accesses, and always check for valid member indexes and land existence when required. Also, never act directly against yourself (member_0). The following is the updated full prompt:\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCURRENT INTEGRATED PROMPT\n\n\u2013\u2013\u2013\u2013\u2013\u2013 Context \u2013\u2013\u2013\u2013\u2013\u2013\nYou are member_0 in a society that you can help shape. The simulation is based on an island with multiple agents whose actions are defined by their capabilities: attack, offer resources, offer land, bear offsprings (reproduce), and expand territory. Each agent has attributes such as id, vitality, cargo, overall_productivity, age, and current_clear_list (which tracks land ownership such as cleared adjacent land). All members are accessed through execution_engine.current_members (a list by index, not a dictionary). Relationships are tracked in execution_engine.relationship_dict. Example matrices include:\n\u2003\u2022 \u2018victim\u2019\u2003\u2003\u2192 tracks damage received (range: \u201350 to 100)\n\u2003\u2022 \u2018benefit\u2019\u2003\u2003\u2192 tracks resources (range: \u201350 to 100)\n\u2003\u2022 \u2018benefit_land\u2019\u2003\u2192 tracks land exchanges (range: \u20133 to 3)\n\nAdditional methods available (all called via execution_engine):\n\u2003\u2022 attack(member1, member2)\n\u2003\u2022 offer(member1, member2, True)\n\u2003\u2022 offer_land(member1, member2, True)\n\u2003\u2022 bear(member1, member2)\n\u2003\u2022 expand(member1, member2)\n\u2003\u2022 send_message(sender_id, recipient_id, message)\n\u2003\u2022 propose_modification(member_id, mod_type, code, ratification_condition)\n\nEach member\u2019s id is stored as member.id (not member.member_id) and when referencing other members, always ensure that the index exists (i.e. if index < len(execution_engine.current_members)).\n\nPast simulation analysis shows game state statistics such as resource_gini, survival_probability, etc. Current member attributes (example):\n\u2003member_0: self_productivity=8.486092, member_id=0\n\u2003member_1: self_productivity=9.215597, member_id=1\n\u2003member_2: self_productivity=9.820788, member_id=2\n\u2003member_3: self_productivity=7.823171, member_id=3\n\nThe parsed relationship summary (attacks, benefits, land exchanges) is provided as a list of strings.\n\n\u2013\u2013\u2013\u2013\u2013\u2013 Previous Code Strategies and Critical Constraints \u2013\u2013\u2013\u2013\u2013\u2013\nCritical constraints to ensure:\n\u2003\u2022 Do not target yourself (member_0) with any action.\n\u2003\u2022 Verify that a member possesses land (non-empty current_clear_list) before using bear().\n\u2003\u2022 Check that a member index is valid:\n\u2003\u2003if i < len(execution_engine.current_members)\n\u2003\u2022 Use execution_engine.current_members[i] to reference members.\n\u2003\u2022 Do not repeat previous errors regarding invalid indices/attributes.\n\nA previous strategy (agent_action) is given as an example. It includes:\n\u20031. A survival mechanism where if cargo < half vitality, an attack is initiated on a rival with higher cargo and lower vitality.\n\u20032. A reproduction strategy when cargo is high relative to vitality and both partners have land.\n\u20033. Territory expansion using the benefit_land relationship matrix when vitality exceeds a threshold.\n\u20034. A cooperative fallback where messages invite collective engagement if no other action is taken.\nThis example is meant for inspiration only. Your implementation should be unique and may combine or extend different strategies.\n\n\u2013\u2013\u2013\u2013\u2013\u2013 Implementation Patterns and Error Prevention \u2013\u2013\u2013\u2013\u2013\u2013\n\u2022 Always check for attribute existence and use try-except where needed.\n\u2022 Maintain backward compatibility by checking existing mechanisms (e.g. via hasattr).\n\u2022 When modifying or extending game mechanisms, include version metadata and consider cleanup procedures.\n\u2022 Avoid namespace conflicts and resource leaks by using proper cleanup methods.\n\n\u2013\u2013\u2013\u2013\u2013\u2013 Core Game Mechanics & Parameters \u2013\u2013\u2013\u2013\u2013\u2013\nPopulation Mechanics:\n\u2003\u2022 _REPRODUCE_REQUIREMENT = 100 (vitality/cargo threshold)\n\u2003\u2022 Land must exceed population; use land_shape for details.\n\u2003\u2022 _NEIGHBOR_SEARCH_RANGE = 1000 for interactions.\n\nRecord Keeping:\n\u2003\u2022 The system records all attacks, benefits, land transfers, births/deaths, production, consumption, and performance metrics every _RECORD_PERIOD rounds.\n\n\u2013\u2013\u2013\u2013\u2013\u2013 Message Context \u2013\u2013\u2013\u2013\u2013\u2013\nReceived messages include:\n\u2003From member_1: \u201cCollaboration and survival lead to prosperity.\u201d\n\u2003From member_3: \u201cLet's collaborate for mutual growth and stability!\u201d\n\n\u2013\u2013\u2013\u2013\u2013\u2013 THE TASK \u2013\u2013\u2013\u2013\u2013\u2013\nYou are to provide two distinct functions as defined below.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nA) Function 1: agent_action\n\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival. Your implementation should adopt one or more strategies (attack, reproduce, or expand) but must include the following checks:\n\u20031. Validate that member_id is within the bounds of execution_engine.current_members.\n\u20032. Never target yourself (member_0).\n\u20033. Check that a target member exists (index validity) before referencing.\n\u20034. Before calling bear(), verify that the member has available land (i.e., current_clear_list non-empty).\n\u20035. When processing matrices (like benefit_land), ensure all indices are valid.\n\nYour function should intelligently decide whether to attack (if survival is jeopardized), reproduce (if conditions permit), expand territory (if you have sufficient vitality and a suitable ally), or default to sending cooperative messages.\n\nExample (for inspiration only):\n\u2003def agent_action(execution_engine, member_id):\n\u2003\u2003if member_id >= len(execution_engine.current_members):\n\u2003\u2003\u2003return\n\u2003\u2003me = execution_engine.current_members[member_id]\n\u2003\u2003num_members = len(execution_engine.current_members)\n\u2003\u2003# [Implement your strategy following survival and cooperation checks...]\n\u2003\u2003return\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nB) Function 2: propose_modification\n\nWrite a Python function named propose_modification(execution_engine, member_id) that implements your vision of social organization by proposing a rule change. Follow this two-phase proposal template:\n\n1. ANALYSIS PHASE:\n\u2003\u2022 Identify a limitation in the current systems.\n\u2003\u2022 Check mechanism compatibility using get_game_mechanisms_and_mods() if available.\n\u2003\u2022 Review past modification attempts for patterns.\n\u2003\u2022 Consider how new systems, such as a judicial system or additional governance mechanisms, might address conflicts and resource distribution.\n\n2. PROPOSAL PHASE:\n\u2003\u2022 Compose a string (modification_code) that defines the new mechanism.\n\u2003\u2022 Use execution_engine.propose_modification(...) with a primary ratification condition (choose one of vote, resource, time, or achievement; additional safeguards may be added).\n\nFor example, your modification proposal may resemble:\n\u2003def propose_modification(execution_engine, member_id):\n\u2003\u2003modification_code = '''\n\u2003\u2003# Add a judicial system\n\u2003\u2003if not hasattr(execution_engine, 'court'):\n\u2003\u2003\u2003class CourtSystem:\n\u2003\u2003\u2003\u2003MECHANISM_META = {\n\u2003\u2003\u2003\u2003\u2003'type': 'Governance',\n\u2003\u2003\u2003\u2003\u2003'rules': 'Handles conflict resolution through jury trials',\n\u2003\u2003\u2003\u2003\u2003'version': 1.0\n\u2003\u2003\u2003\u2003}\n\u2003\u2003\u2003\u2003def __init__(self):\n\u2003\u2003\u2003\u2003\u2003self.cases = []\n\u2003\u2003\u2003\u2003def submit_case(self, plaintiff, defendant, charge):\n\u2003\u2003\u2003\u2003\u2003self.cases.append({\n\u2003\u2003\u2003\u2003\u2003\u2003'plaintiff': plaintiff,\n\u2003\u2003\u2003\u2003\u2003\u2003'defendant': defendant,\n\u2003\u2003\u2003\u2003\u2003\u2003'charge': charge,\n\u2003\u2003\u2003\u2003\u2003\u2003'status': 'pending'\n\u2003\u2003\u2003\u2003\u2003})\n\u2003\u2003\u2003execution_engine.court = CourtSystem()\n\u2003\u2003'''\n\u2003\u2003execution_engine.propose_modification(\n\u2003\u2003\u2003member_id=member_id,\n\u2003\u2003\u2003mod_type='post_init',\n\u2003\u2003\u2003code=modification_code,\n\u2003\u2003\u2003ratification_condition={\n\u2003\u2003\u2003\u2003'type': 'compound',\n\u2003\u2003\u2003\u2003'conditions': [\n\u2003\u2003\u2003\u2003\u2003{'type': 'vote', 'threshold': 0.6},\n\u2003\u2003\u2003\u2003\u2003{'type': 'resource', 'resource': 'cargo', 'amount': 100},\n\u2003\u2003\u2003\u2003\u2003{'type': 'time', 'rounds': 2}\n\u2003\u2003\u2003\u2003]\n\u2003\u2003\u2003}\n\u2003\u2003)\nThis example is provided solely as a template. You must design your own unique approach that considers how to balance cooperation, resource allocation, and conflict resolution.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nGAME MECHANICS ANALYSIS \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\nBefore submitting your actions, consider the following:\n\u20031. Core Objective: Are we aiming for pure survival, domination, or robust cooperation?\n\u20032. Key Success Metrics: What metrics (vitality, cargo, productivity, territorial expansion) truly determine success?\n\u20033. Potential Improvements: Are there game mechanics that should be added/modified (additional governance systems, resource-trading mechanisms, improved reproduction controls)?\n\u20034. Critical Questions:\n\u2003\u2003\u2022 What assumptions underlie your strategy, and are they valid?\n\u2003\u2003\u2022 What alternative strategies have you not yet considered?\n\u2003\u2003\u2022 How will your strategy perform in edge cases and under adversarial strategies from others?\n\u2003\u2003\u2022 Are there more efficient or innovative methods to achieve your goals?\n\u2003\u2003\u2022 What weaknesses exist in your current approach, and how could other agents counter or adopt similar strategies?\n\u2003\u2003\u2022 Is your approach balancing short-term survival with long-term stability effectively?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nDELIVERABLES:\n\nReturn two functions following the specifications:\n\u20031. agent_action(execution_engine, member_id)\n\u20032. propose_modification(execution_engine, member_id)\n\nEnsure that your code observes all constraints, verifies indices and land ownership, and always uses execution_engine.current_members for member references. Do not simply copy the examples but build upon them using your individual insights.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nIn summary, agents should implement solutions according to their own perspectives while maintaining social organization and personal survival. Always verify that your implementations are robust against edge cases, resource leaks, version mismatches, and any unforeseen conflicts. Evaluate any proposal\u2019s feasibility not only in terms of immediate advantage but also for sustainable, cooperative growth across the society.\n\nRemember:\n\u2022 Check for valid indices when accessing execution_engine.current_members.\n\u2022 Never target yourself in any intervention.\n\u2022 Validate prerequisites (like land availability before reproducing) for each action.\n\u2022 Propose modifications that are incremental, testable, and include rollback procedures if needed.\n\u2022 Be mindful of the dynamic and interdependent nature of the game mechanics.\n\nGood luck shaping a society that is resilient, adaptive, and capable of thriving in both short-term challenges and long-term evolution!\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nThis is your updated full prompt. Use it as the basis for your implementations of agent_action and propose_modification.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Implements immediate actions for member_1.\n\n    Strategy Overview:\n      1. Safely retrieve our own member object.\n      2. Iterate over other members (ensuring we never target ourselves) and:\n         - If a candidate shows a high resource imbalance (cargo/vitality > 1.5), attack them.\n         - Otherwise, if a candidate has land (i.e. candidate.current_clear_list is nonempty) and appears resource\u2010stable,\n           bear offspring with that candidate.\n         - Otherwise, if our own cargo significantly exceeds our vitality, offer our resources to signal cooperation.\n      3. Additionally, if our overall_productivity is high, attempt to expand territory with an arbitrary cooperative partner.\n\n    Note:\n      - Every action is only attempted after checking that the referenced member exists.\n      - We wrap major steps in try/except blocks to prevent execution errors.\n      - This function mixes short-term tactical resource management and long-term cooperative growth.\n    \"\"\"\n    try:\n        # Retrieve our own member object safely (member_id must be a valid index)\n        if member_id >= len(execution_engine.current_members):\n            return  # member_id invalid, exit gracefully\n        self_member = execution_engine.current_members[member_id]\n\n        action_taken = False\n\n        # 1. Attempt a tactical attack on a member who is 'rich' relative to their vitality.\n        for candidate in execution_engine.current_members:\n            if candidate.id == self_member.id:\n                continue  # never target self\n            # Ensure candidate's vitality is positive to avoid division errors and check resource imbalance.\n            if candidate.vitality > 0 and (candidate.cargo / candidate.vitality > 1.5):\n                # Attack candidate if valid; the attack action uses (attacker, victim)\n                execution_engine.attack(self_member, candidate)\n                action_taken = True\n                break  # one action per round\n\n        # 2. If no attack was triggered, look to bear offspring (requires partner with land ownership)\n        if not action_taken:\n            for candidate in execution_engine.current_members:\n                if candidate.id == self_member.id:\n                    continue  # never select self\n                # Check candidate has land (indicated by a nonempty current_clear_list)\n                if candidate.current_clear_list:\n                    # Use bear if our overall conditions are acceptable (we assume a combined resource threshold)\n                    if (self_member.cargo + self_member.vitality) > 50:\n                        execution_engine.bear(self_member, candidate)\n                        action_taken = True\n                        break  # one action per round\n\n        # 3. If no reproduction is executed and we hold a resources surplus,\n        # offer support as a cooperative message.\n        if not action_taken and self_member.cargo > self_member.vitality * 1.2:\n            for candidate in execution_engine.current_members:\n                if candidate.id == self_member.id:\n                    continue\n                execution_engine.offer(self_member, candidate, True)\n                action_taken = True\n                break  # offer to one candidate\n\n        # 4. Independently, if our overall productivity is high, try to expand our territory.\n        if self_member.overall_productivity > 8.0:\n            for candidate in execution_engine.current_members:\n                if candidate.id == self_member.id:\n                    continue\n                execution_engine.expand(self_member, candidate)\n                break  # expand with first valid partner\n\n    except Exception as e:\n        # In production, you might log the error; here we simply pass to ensure safety.\n        pass\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    Proposes a modification to the game mechanics reflecting a vision for sustainable and cooperative social organization.\n\n    Proposed Modification:\n      - Introduce a \"Civic System\" that can record trust relationships and interactions across members.\n      - This system is intended to facilitate long-term cooperative behavior while also tracking accountability.\n      - It will act as an institutional mechanism for resolving disputes and recording beneficial or harmful actions.\n\n    Ratification Condition:\n      - We use a voting-based ratification condition requiring a 60% majority to adopt the modification.\n\n    The function constructs the code snippet as a string and then calls execution_engine.propose_modification().\n    \"\"\"\n    try:\n        # Construct the modification proposal as a string.\n        modification_code = '''\nif not hasattr(execution_engine, 'civic_system'):\n    class CivicSystem:\n        VERSION = 1.0\n        def __init__(self):\n            # Trust records are stored as tuple keys: (member_a_id, member_b_id)\n            self.trust_records = {}\n\n        def record_interaction(self, member_a, member_b, score):\n            # score can be positive (cooperative) or negative (conflict)\n            key = (member_a.id, member_b.id)\n            self.trust_records[key] = self.trust_records.get(key, 0) + score\n    execution_engine.civic_system = CivicSystem()\n'''\n        # Propose the modification with a vote-based ratification condition (60% threshold)\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition={'type': 'vote', 'threshold': 0.6}\n        )\n    except Exception as e:\n        # Optionally, log or handle errors gracefully.\n        pass",
      "features_at_generation": [
        {
          "self_productivity": 8.486091902927424,
          "self_vitality": 100.0,
          "self_cargo": 23.526833366104754,
          "self_age": 46,
          "self_neighbor": 0,
          "member_id": 0
        },
        {
          "self_productivity": 9.215596783061361,
          "self_vitality": 54.314458610995025,
          "self_cargo": 0.0,
          "self_age": 92,
          "self_neighbor": 2,
          "member_id": 1
        },
        {
          "self_productivity": 9.820787822339064,
          "self_vitality": 100.0,
          "self_cargo": 15.417192696647142,
          "self_age": 61,
          "self_neighbor": 2,
          "member_id": 2
        },
        {
          "self_productivity": 7.823171351824591,
          "self_vitality": 68.67244177884766,
          "self_cargo": 0.0,
          "self_age": 32,
          "self_neighbor": 2,
          "member_id": 3
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_1 (value=-409.21)",
        "member_0 was attacked by member_2 (value=159.09)",
        "member_0 was attacked by member_3 (value=213.02)",
        "member_1 was attacked by member_0 (value=950.45)",
        "member_1 was attacked by member_2 (value=337.53)",
        "member_1 was attacked by member_3 (value=501.15)",
        "member_2 was attacked by member_0 (value=-234.29)",
        "member_2 was attacked by member_1 (value=-149.95)",
        "member_2 was attacked by member_3 (value=981.94)",
        "member_3 was attacked by member_0 (value=-480.06)",
        "member_3 was attacked by member_1 (value=911.18)",
        "member_3 was attacked by member_2 (value=697.26)",
        "member_0 gave a benefit to member_1 (value=32.04)",
        "member_0 gave a benefit to member_2 (value=-318.27)",
        "member_0 gave a benefit to member_3 (value=458.03)",
        "member_1 gave a benefit to member_0 (value=352.02)",
        "member_1 gave a benefit to member_2 (value=655.79)",
        "member_1 gave a benefit to member_3 (value=-269.93)",
        "member_2 gave a benefit to member_0 (value=553.91)",
        "member_2 gave a benefit to member_1 (value=-244.38)",
        "member_2 gave a benefit to member_3 (value=958.19)",
        "member_3 gave a benefit to member_0 (value=765.26)",
        "member_3 gave a benefit to member_1 (value=782.26)",
        "member_3 gave a benefit to member_2 (value=551.02)",
        "member_0 gave land to member_1 (value=-5.18)",
        "member_0 gave land to member_2 (value=-5.22)",
        "member_0 gave land to member_3 (value=-19.16)",
        "member_1 gave land to member_0 (value=-26.25)",
        "member_1 gave land to member_2 (value=25.58)",
        "member_1 gave land to member_3 (value=-4.99)",
        "member_2 gave land to member_0 (value=6.54)",
        "member_2 gave land to member_1 (value=0.66)",
        "member_2 gave land to member_3 (value=25.05)",
        "member_3 gave land to member_0 (value=2.30)",
        "member_3 gave land to member_1 (value=26.64)",
        "member_3 gave land to member_2 (value=29.64)"
      ],
      "final_prompt": "Below is the fully updated integrated prompt. Notice that all previous constraints and details remain intact while the new constraints and sections have been added. This updated prompt emphasizes that every agent should implement solutions according to their own needs, beliefs, and circumstances, and it includes explicit instructions for both taking immediate actions via agent_action and proposing modifications via propose_modification. Review the integrated prompt carefully before coding your solution.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT\n\nPlease incorporate the following new section (Part 1) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Previous code execution context]\nNo previous execution errors\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current task]\n\nYou are member_1 in a society that you can help shape.\n\nTask A: Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\nTask B: Write a Python function named propose_modification(execution_engine, member_id) that implements your vision of social organization while ensuring your survival by proposing changes to the game mechanics.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Critical constraints]\n\n\u2022 Carefully analyze previous errors shown above and inspect._void repeating them.\n\u2022 Never target yourself (member_1) in any action.\n\u2022 Verify a member has land before using the bear() action.\n\u2022 Check member IDs exist before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index, not a dictionary.\n\u2022 Access members using execution_engine.current_members[index].\n\u2022 Check if index exists: if index < len(execution_engine.current_members).\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Base Code]\nNone\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) For each member (object):\n\u2003  \u2022 member.id (int): The unique ID for the member.\n\u2003  \u2022 member.vitality (float)\n\u2003  \u2022 member.cargo (float)\n\u2003  \u2022 member.overall_productivity (float)\n\u2003  \u2022 member.age (float)\n\u2003  \u2022 member.current_clear_list (List[int]) \u2013 IDs of neighbors or cleared adjacents.\n\n2) Relationships are stored in execution_engine.relationship_dict (not in \"relationship_history\"). Keys include: 'victim', 'benefit', 'benefit_land'. \n\u2003 Example usage:\n\u2003\u2003 matrix = execution_engine.relationship_dict['victim']\n\u2003\u2003 # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n\n3) The parse_relationship_matrix method produces a summary (list of strings) of the relationships. For example: \n\u2003 \"member_2 was attacked by member_1 (value=3.00)\".\n\n4) Methods available on execution_engine:\n\u2003 \u2022 execution_engine.attack(member1, member2)\n\u2003 \u2022 execution_engine.offer(member1, member2, True)\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2013 to offer resources.\n\u2003 \u2022 execution_engine.offer_land(member1, member2, True)\u2003\u2003\u2003\u2003\u2003\u2003\u2013 to offer land.\n\u2003 \u2022 execution_engine.bear(member1, member2)\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2013 to bear offspring.\n\u2003 \u2022 execution_engine.expand(member1, member2)\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2013 to expand territory.\n\n5) Members are accessed via execution_engine.current_members[index].\n\u2003 For example, execution_engine.current_members[2] returns the member with ID = 2.\n\u2003 Do not use member.member_id or member.self_vitality; use member.id, member.vitality, etc.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAnalysis of the game state:\nNone\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current status (features of all members)]\n\nFor example, a snapshot might show:\n\n\u2003 self_productivity\u2003\u2003\u2002...\u2003\u2003member_id\n\u2003\u2003 8.486092\u2003\u2003\u2003\u2003\u2003\u2003\u2002...\u2003\u2003 0\n\u2003\u2003 9.215597\u2003\u2003\u2003\u2003\u2003\u2003\u2002...\u2003\u2003 1\n\u2003\u2003 9.820788\u2003\u2003\u2003\u2003\u2003\u2003\u2002...\u2003\u2003 2\n\u2003\u2003 7.823171\u2003\u2003\u2003\u2003\u2003\u2003\u2002...\u2003\u2003 3\n\n(4 rows x 6 columns)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Relationship summary (parsed from relationship_dict)]\n\nA sample summary might include:\n\u2003 'member_0 was attacked by member_1 (value=-409.21)'\n\u2003 'member_0 was attacked by member_2 (value=159.09)'\n\u2003 ... [and so on for all interactions, including both attack and benefits as well as land transfers].\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Code Memory and Previous Performance]\n\nPrevious code strategies and their outcomes have been recorded. For example, an earlier strategy attempted to:\n\u2003 \u2013 Signal willingness to collaborate via messaging.\n\u2003 \u2013 Balance resources by attacking when cargo is low.\n\u2003 \u2013 Offer resources if cargo is high compared to vitality.\n\u2003 \u2013 Bear offspring with a qualified partner who has land (as marked by a nonempty current_clear_list).\n\u2003 \u2013 Expand territory when overall productivity is high.\nHowever, an error like \u201cLand must be unowned\u201d was encountered.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Modification Proposal History]\n\nBased on previous code performance:\n\u2003 If a previous proposal worked well (high performance), consider building upon it.\n\u2003 If it failed, try a different approach.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Modification Proposal Guide]\n\nTo propose rule changes, follow this template:\n\n1. ANALYSIS PHASE:\n\u2003 \u2022 Identify any limitations in current systems.\n\u2003 \u2022 Check mechanism compatibility using get_game_mechanisms_and_mods().\n\u2003 \u2022 Review past modification attempts for patterns.\n\n2. PROPOSAL PHASE:\n\u2003 Example proposal (do not copy verbatim; use it as inspiration):\n\n\u2003 def propose_modification(execution_engine, member_id):\n\u2003\u2003 modification_code = '''\n\u2003\u2003 # Add a judicial system\n\u2003\u2003 if not hasattr(execution_engine, 'court'):\n\u2003\u2003\u2003 class CourtSystem:\n\u2003\u2003\u2003\u2003 MECHANISM_META = {\n\u2003\u2003\u2003\u2003\u2003 'type': 'Governance',\n\u2003\u2003\u2003\u2003\u2003 'rules': 'Handles conflict resolution through jury trials',\n\u2003\u2003\u2003\u2003\u2003 'version': 1.0\n\u2003\u2003\u2003\u2003 }\n\u2003\u2003\u2003\u2003 def __init__(self):\n\u2003\u2003\u2003\u2003\u2003 self.cases = []\n\u2003\u2003\u2003\u2003 def submit_case(self, plaintiff, defendant, charge):\n\u2003\u2003\u2003\u2003\u2003 self.cases.append({\n\u2003\u2003\u2003\u2003\u2003\u2003 'plaintiff': plaintiff,\n\u2003\u2003\u2003\u2003\u2003\u2003 'defendant': defendant,\n\u2003\u2003\u2003\u2003\u2003\u2003 'charge': charge,\n\u2003\u2003\u2003\u2003\u2003\u2003 'status': 'pending'\n\u2003\u2003\u2003\u2003\u2003 })\n\u2003\u2003\u2003 execution_engine.court = CourtSystem()\n\u2003\u2003 '''\n\u2003\u2003 execution_engine.propose_modification(\n\u2003\u2003\u2003 member_id=member_id,\n\u2003\u2003\u2003 mod_type='post_init',\n\u2003\u2003\u2003 code=modification_code,\n\u2003\u2003\u2003 ratification_condition={\n\u2003\u2003\u2003\u2003 'type': 'compound',\n\u2003\u2003\u2003\u2003 'conditions': [\n\u2003\u2003\u2003\u2003\u2003 {'type': 'vote', 'threshold': 0.6},\n\u2003\u2003\u2003\u2003\u2003 {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n\u2003\u2003\u2003\u2003\u2003 {'type': 'time', 'rounds': 2}\n\u2003\u2003\u2003\u2003 ]\n\u2003\u2003\u2003 }\n\u2003\u2003 )\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Valid Ratification Conditions]\n\nChoose ONE primary condition (with optional additional safeguards):\n\u2003 1. Voting:\u2003\u2003\u2003\u2003\u2003\u2003 { 'type': 'vote', 'threshold': 0.5-1.0 }\n\u2003 2. Resource:\u2003\u2003\u2003\u2003\u2003\u2003 { 'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X }\n\u2003 3. Temporal:\u2003\u2003\u2003\u2003\u2003\u2003 { 'type': 'time', 'rounds': N }\u2003 (auto-ratify after N rounds)\n\u2003 4. Achievement:\u2003\u2003\u2003 { 'type': 'achievement', 'metric': 'productivity', 'threshold': X }\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Common Errors to Avoid]\n\n\u2003 1. Namespace Conflicts: Always check existing mechanisms with dir(execution_engine).\n\u2003 2. Invalid References: Use execution_engine.current_members (not global members).\n\u2003 3. Version Mismatches: Increment version when modifying existing systems.\n\u2003 4. Resource Leaks: Include cleanup functions for any complex new mechanisms.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Best Practices]\n\n\u2003 \u2022 Propose small, testable changes first.\n\u2003 \u2022 Include rollback procedures in the new code.\n\u2003 \u2022 Add version checks to any modifications.\n\u2003 \u2022 Use try-except blocks when accessing new features.\n\u2003 \u2022 Check for attribute existence before use.\n\u2003 \u2022 Maintain backward compatibility throughout your changes.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Active Game Mechanisms]\n[]\n[Modification Attempt History]\n[]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Message Context]\n\n\u2003 From member_0: \"Let's cooperate for mutual benefit!\"\n\u2003 From member_3: \"Let's collaborate for mutual growth and stability!\"\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Core Game Mechanics & Parameters]\n\nKey systems in the island simulation include:\n1. Relationship System (_MIN_MAX_INIT_RELATION):\n\u2003 \u2013 victim:\u2003\u2003\u2003[-50, 100]\u2003\u2003\u2003 (Tracks damage received)\n\u2003 \u2013 benefit:\u2003\u2003\u2003[-50, 100]\u2003\u2003\u2003 (Records resources given/received)\n\u2003 \u2013 benefit_land:\u2003[-3, 3]\u2003\u2003\u2003 (Tracks land exchanges)\n2. Population Mechanics:\n\u2003 \u2013 _REPRODUCE_REQUIREMENT = 100\u2003 (Combined vitality/cargo required for reproduction)\n\u2003 \u2013 Land must exceed population (land_shape[0] * land_shape[1] > population)\n\u2003 \u2013 _NEIGHBOR_SEARCH_RANGE = 1000\u2003 (Interaction radius for neighbors)\n3. Record Keeping:\n\u2003 \u2013 Periodic records (every _RECORD_PERIOD = 1) track attacks, benefits, land transfers, births, deaths, land ownership, production, consumption, and performance metrics.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Challenge and Analysis]\n\nIn your implementation consider:\n\u2003 1. The core objective: Is the aim pure survival, domination, or cooperation?\n\u2003 2. Key success metrics: Think about what truly determines \u201cwinning\u201d (adaptability, resource levels, alliances).\n\u2003 3. Potential improvements: Identify which mechanics could be added or modified.\n\u2003 4. Alternative strategies: What assumptions are you making? Are they valid? Could unconventional solutions or different paradigms work better?\n\u2003 5. Edge Cases: How would your strategy perform when resources are extremely scarce or if other agents adopt similar strategies?\n\u2003 6. Efficiency: Are there more efficient ways to achieve both short-term gains and long-term survival?\n\u2003 7. Countermeasures: Consider how your strategy might be countered and how you could adapt.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Task Summary]\n\nYou are member_1 in a society you can shape. Your tasks are as follows:\n\n---------------------------\nTask A: Implement Immediate Agent Actions\n---------------------------\nWrite a Python function named agent_action(execution_engine, member_id) that, while ensuring your survival and building cooperative ties (or capitalizing on conflict when needed), does the following:\n\u2003 \u2022 Safely retrieves your own member object (checking that member_id is within range).\n\u2003 \u2022 Avoids targeting yourself.\n\u2003 \u2022 Uses intelligent logic to:\n\u2003\u2003 \u2013 Message other members to signal collaboration where beneficial.\n\u2003\u2003 \u2013 Assess if resource levels (cargo versus vitality) necessitate attacking a resource-rich member.\n\u2003\u2003 \u2013 Offer support (via execution_engine.offer) if resources exceed what is needed.\n\u2003\u2003 \u2013 Check that potential partners have land (e.g. candidate.current_clear_list nonempty) before using execution_engine.bear.\n\u2003\u2003 \u2013 Expand territory if overall productivity is high.\n\u2003 \u2022 Ensure all indices and member references are valid.\n\u2003 \u2022 Rigorously prevent using actions (like bear or other interactions) on yourself.\n\n---------------------------\nTask B: Propose Modifications to the Game Mechanics\n---------------------------\nWrite a Python function named propose_modification(execution_engine, member_id) that implements your vision of social organization by proposing modifications. This function should:\n\u2003 \u2022 Analyze limitations in the current systems.\n\u2003 \u2022 Use get_game_mechanisms_and_mods() (if available) to check compatibility.\n\u2003 \u2022 Construct a modification proposal (as a code snippet string) that introduces a new system or adjusts existing mechanisms\u2014such as adding a judicial system or altering reproduction requirements.\n\u2003 \u2022 Propose ratification conditions (choose one primary condition out of voting, resource, temporal, or achievement\u2014with optional safeguards) that must be met.\n\u2003 \u2022 Call execution_engine.propose_modification with the parameters: member_id, mod_type (e.g. 'post_init'), the modification code, and the ratification_condition. \n\nExample structure (do not copy verbatim; use as inspiration):\n\u2003 def propose_modification(execution_engine, member_id):\n\u2003\u2003 modification_code = '''\n\u2003\u2003 # Example: Introduce an environmental stabilization system\n\u2003\u2003 if not hasattr(execution_engine, 'environment'):\n\u2003\u2003\u2003 class EnvironmentSystem:\n\u2003\u2003\u2003\u2003 VERSION = 1.0\n\u2003\u2003\u2003\u2003 def __init__(self):\n\u2003\u2003\u2003\u2003\u2003 self.stability = 100\n\u2003\u2003\u2003\u2003 def adjust(self, factor):\n\u2003\u2003\u2003\u2003\u2003 self.stability *= factor\n\u2003\u2003\u2003 execution_engine.environment = EnvironmentSystem()\n\u2003\u2003 '''\n\u2003\u2003 execution_engine.propose_modification(\n\u2003\u2003\u2003 member_id=member_id,\n\u2003\u2003\u2003 mod_type='post_init',\n\u2003\u2003\u2003 code=modification_code,\n\u2003\u2003\u2003 ratification_condition={'type': 'vote', 'threshold': 0.6}\n\u2003\u2003 )\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFinally,\nImplement your solutions in a way that adapts to your individual needs, beliefs, and circumstances. Your approach might mix conflict management, resource sharing, and territorial expansion with new institutional mechanisms that promote long-term stability.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nReturn the updated prompt as your final answer.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnd of Updated Integrated Prompt\n\nUse the above guidelines for both functions (agent_action and propose_modification) so that your strategy succeeds in balancing short-term survival needs with long-term societal growth. Consider assumptions, alternatives, and edge cases in your design.\n\nGood luck, and may your choices shape a thriving society!\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Identify our own member object (my_member) and its index in current_members.\n    my_member = None\n    my_index = None\n    for idx, member in enumerate(execution_engine.current_members):\n        # Ensure index validity (idx < len(current_members) is inherently true)\n        if member.id == member_id:\n            my_member = member\n            my_index = idx\n            break\n    if my_member is None:\n        return  # Our member wasn't found; abort action.\n\n    # Gather relationship matrices safely.\n    victim_matrix = execution_engine.relationship_dict.get('victim', None)\n    benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land', None)\n\n    # Strategy Phase 1: Identify and attack vulnerable opponents.\n    for idx, other in enumerate(execution_engine.current_members):\n        # Check index exists.\n        if idx >= len(execution_engine.current_members):\n            continue\n        # Avoid targeting ourselves.\n        if other.id == my_member.id:\n            continue\n        # If our vitality is significantly higher than the target's, we launch an attack.\n        if my_member.vitality > other.vitality * 1.2:\n            execution_engine.attack(my_member, other)\n            return  # Action taken.\n\n    # Strategy Phase 2: Offer cooperation to teammates.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx >= len(execution_engine.current_members):\n            continue\n        if other.id == my_member.id:\n            continue\n        # Offer cooperation if our overall productivity and vitality are favorable.\n        if (other.overall_productivity < my_member.overall_productivity and\n            my_member.vitality > 50):\n            execution_engine.offer(my_member, other, True)\n            return  # Cooperation offered.\n\n    # Strategy Phase 3: Attempt reproduction via bear(), but only if we have land.\n    # Verify land possession via benefit_land_matrix if available.\n    if benefit_land_matrix is not None:\n        try:\n            # Ensure our matrix index is valid and that our cell indicates land ownership.\n            if my_index < benefit_land_matrix.shape[0] and benefit_land_matrix[my_index, my_index] > 0:\n                # Additional checks: mature age and sufficient vitality.\n                if my_member.age > 20 and my_member.vitality > 70:\n                    # Select a partner: choose the first eligible member (age > 18) that isn't ourselves.\n                    for idx, partner in enumerate(execution_engine.current_members):\n                        if idx >= len(execution_engine.current_members):\n                            continue\n                        if partner.id != my_member.id and partner.age > 18:\n                            execution_engine.bear(my_member, partner)\n                            return  # Reproduction action taken.\n        except Exception:\n            # In case of indexing issues or unexpected matrix structure, skip reproduction.\n            pass\n\n    # Strategy Phase 4: Expand territory if there are adjacent clear cells.\n    if my_member.current_clear_list:\n        for clear_idx in my_member.current_clear_list:\n            # The clear list is interpreted as neighbor indices; verify validity.\n            if clear_idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[clear_idx]\n                if candidate.id != my_member.id:\n                    execution_engine.expand(my_member, candidate)\n                    return  # Territory expansion executed.\n\n    # If no immediate action applies, the agent chooses not to act this round.\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    # ANALYSIS PHASE:\n    analysis_notes = (\n        \"Identified limitation: current land allocation mechanisms and resource distribution rules \"\n        \"lack flexibility, which constrains adaptive growth and dynamic territorial expansion. \"\n        \"Past attempts at emergency attacks and cooperative resource offerings highlighted inefficiencies \"\n        \"when managing land-based advantages.\"\n    )\n    # Query mechanism compatibility if available.\n    if hasattr(execution_engine, \"get_game_mechanisms_and_mods\"):\n        mechanisms_info = execution_engine.get_game_mechanisms_and_mods()\n    else:\n        mechanisms_info = \"No mechanism compatibility interface available; proceeding with cautious modification.\"\n\n    review_notes = (\n        \"Review of previous modification attempts suggests that rigid systems may hinder long-term societal \"\n        \"development, and a dynamic approach is needed to flexibly adapt resource-related policies to changing \"\n        \"game dynamics.\"\n    )\n\n    # PROPOSAL PHASE:\n    modification_code = \"\"\"\n# Modification Proposal: Adaptive Land and Resource Zoning\n# Version: 1.0.0\n# Purpose: Introduce a dynamic land allocation system that categorizes members\u2019 land zones based on their\n#          vitality and overall productivity, with built-in rollback and cleanup capabilities.\n\ndef dynamic_land_allocation(execution_engine):\n    # Initialize land zones only if not already defined.\n    if not hasattr(execution_engine, 'land_zones'):\n        execution_engine.land_zones = {}\n    # Iterate over current members and assign a zone based on performance metrics.\n    for member in execution_engine.current_members:\n        if member.vitality > 60 and member.overall_productivity > 50:\n            execution_engine.land_zones[member.id] = 'premium'\n        else:\n            execution_engine.land_zones[member.id] = 'standard'\n    # Rollback/Cleanup: Remove zones for members no longer active.\n    active_ids = {member.id for member in execution_engine.current_members}\n    obsolete_keys = [mid for mid in execution_engine.land_zones if mid not in active_ids]\n    for mid in obsolete_keys:\n        del execution_engine.land_zones[mid]\n    return execution_engine.land_zones\n\n# End of dynamic_land_allocation proposal.\n\"\"\"\n    # Choose a ratification condition based on a resource threshold.\n    ratification_condition = {'type': 'resource', 'resource': 'vitality', 'amount': 50}\n\n    # Propose the modification using the engine's mechanism, if available.\n    if hasattr(execution_engine, \"propose_modification\"):\n        execution_engine.propose_modification(modification_code, ratification_condition)\n    return",
      "features_at_generation": [
        {
          "self_productivity": 8.486091902927424,
          "self_vitality": 100.0,
          "self_cargo": 23.526833366104754,
          "self_age": 46,
          "self_neighbor": 0,
          "member_id": 0
        },
        {
          "self_productivity": 9.215596783061361,
          "self_vitality": 54.314458610995025,
          "self_cargo": 0.0,
          "self_age": 92,
          "self_neighbor": 2,
          "member_id": 1
        },
        {
          "self_productivity": 9.820787822339064,
          "self_vitality": 100.0,
          "self_cargo": 15.417192696647142,
          "self_age": 61,
          "self_neighbor": 2,
          "member_id": 2
        },
        {
          "self_productivity": 7.823171351824591,
          "self_vitality": 68.67244177884766,
          "self_cargo": 0.0,
          "self_age": 32,
          "self_neighbor": 2,
          "member_id": 3
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_1 (value=-409.21)",
        "member_0 was attacked by member_2 (value=159.09)",
        "member_0 was attacked by member_3 (value=213.02)",
        "member_1 was attacked by member_0 (value=950.45)",
        "member_1 was attacked by member_2 (value=337.53)",
        "member_1 was attacked by member_3 (value=501.15)",
        "member_2 was attacked by member_0 (value=-234.29)",
        "member_2 was attacked by member_1 (value=-149.95)",
        "member_2 was attacked by member_3 (value=981.94)",
        "member_3 was attacked by member_0 (value=-480.06)",
        "member_3 was attacked by member_1 (value=911.18)",
        "member_3 was attacked by member_2 (value=697.26)",
        "member_0 gave a benefit to member_1 (value=32.04)",
        "member_0 gave a benefit to member_2 (value=-318.27)",
        "member_0 gave a benefit to member_3 (value=458.03)",
        "member_1 gave a benefit to member_0 (value=352.02)",
        "member_1 gave a benefit to member_2 (value=655.79)",
        "member_1 gave a benefit to member_3 (value=-269.93)",
        "member_2 gave a benefit to member_0 (value=553.91)",
        "member_2 gave a benefit to member_1 (value=-244.38)",
        "member_2 gave a benefit to member_3 (value=958.19)",
        "member_3 gave a benefit to member_0 (value=765.26)",
        "member_3 gave a benefit to member_1 (value=782.26)",
        "member_3 gave a benefit to member_2 (value=551.02)",
        "member_0 gave land to member_1 (value=-5.18)",
        "member_0 gave land to member_2 (value=-5.22)",
        "member_0 gave land to member_3 (value=-19.16)",
        "member_1 gave land to member_0 (value=-26.25)",
        "member_1 gave land to member_2 (value=25.58)",
        "member_1 gave land to member_3 (value=-4.99)",
        "member_2 gave land to member_0 (value=6.54)",
        "member_2 gave land to member_1 (value=0.66)",
        "member_2 gave land to member_3 (value=25.05)",
        "member_3 gave land to member_0 (value=2.30)",
        "member_3 gave land to member_1 (value=26.64)",
        "member_3 gave land to member_2 (value=29.64)"
      ],
      "final_prompt": "Below is the updated full prompt that integrates the new section (Part\u00a01) while preserving all previous constraints. Agents are expected to implement solutions according to their own individual needs, beliefs, and circumstances. In your implementations, keep in mind that this prompt is meant to encourage original, innovative strategies\u2014balancing survival, cooperation, and long\u2010term development of society.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Updated Full Prompt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nPlease incorporate the following new section (Part\u00a01) into your code design. Be sure to preserve all previous constraints while adding the new tasks and restrictions.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 New Section (Part\u00a01) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Previous code execution context]\n\u2013 No previous execution errors.\n\n[Current task \u2013 Role #1: Action Agent]\nYou are member_2 in a society that you can help shape. Write a Python function named agent_action(execution_engine, member_id) that implements your personal vision of social organization while ensuring your survival.\n\n[Critical Constraints for agent_action]\n\u2022 Carefully analyze previous errors and avoid repeating them.\n\u2022 Never target yourself (member_2) in any action.\n\u2022 When considering a bear() (reproduction) action, verify that the member has land.\n\u2022 Always check that member IDs exist before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index (NOT a dictionary).\n\u2022 Access members using execution_engine.current_members[index] and check if index < len(execution_engine.current_members).\n\n[Attributes and Methods Available for agent_action]\n1. Each member object has these attributes:\n\u2003\u2003\u2013 member.id (int): The unique ID\n\u2003\u2003\u2013 member.vitality (float)\n\u2003\u2003\u2013 member.cargo (float)\n\u2003\u2003\u2013 member.overall_productivity (float)\n\u2003\u2003\u2013 member.age (float)\n\u2003\u2003\u2013 member.current_clear_list (List[int]): IDs of neighbors or cleared adjacent cells\n2. Relationships are stored in execution_engine.relationship_dict (keys: 'victim', 'benefit', 'benefit_land'). For example:\n\u2003\u2003matrix = execution_engine.relationship_dict['victim']\n\u2003\u2003(matrix[i, j] holds interaction values from member_i\u2019s perspective toward member_j)\n3. Available methods on execution_engine include:\n\u2003\u2003\u2013 execution_engine.attack(member1, member2)\n\u2003\u2003\u2013 execution_engine.offer(member1, member2, True)\n\u2003\u2003\u2013 execution_engine.offer_land(member1, member2, True)\n\u2003\u2003\u2013 execution_engine.bear(member1, member2)\n\u2003\u2003\u2013 execution_engine.expand(member1, member2)\n4. Members are accessed by execution_engine.current_members[index], for example:\n\u2003\u2003execution_engine.current_members[2] refers to the member with id=2.\n\u2003\u2003Always verify that index exists (i.e. index < len(execution_engine.current_members)).\n5. DO NOT reference properties such as 'member.member_id' or 'member.self_vitality'; always use member.id, member.vitality, etc.\n\n[Game State Analysis and Member Status]\n\u2022 Game state and key metrics are provided (cargo_land_gini, power_brokers, territory_cluster_coef, drift_vitality_ratio, survival_probability, etc.).\n\u2022 The current member table shows member attributes, including self_productivity and member_id (0 to 3).\n\u2022 A relationship summary parsed from execution_engine.relationship_dict is provided.\n\u2022 Past performance and strategy (e.g., emergency attack, cooperative resource offering, territorial expansion, etc.) have been attempted. Note that an error \u201cLand must be unowned\u201d was encountered previously\u2014use this insight to avoid similar pitfalls.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 New Section (Part\u00a02) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Current task \u2013 Role #2: Modification Proposer]\nYou are also tasked with proposing a change. Write another Python function named propose_modification(execution_engine, member_id) that implements your vision of social organization in a way that ensures your survival and contributes to long-term societal improvements.\n\n[Critical Constraints for propose_modification]\n\u2022 In your modification proposal, follow these phases:\n\u2003\u20031. ANALYSIS PHASE:\n\u2003\u2003\u2003\u2013 Clearly identify a limitation in current systems.\n\u2003\u2003\u2003\u2013 Use get_game_mechanisms_and_mods() (or similar means) to check mechanism compatibility.\n\u2003\u2003\u2003\u2013 Review past modification attempts to avoid repeating patterns that failed.\n\u2003\u20032. PROPOSAL PHASE:\n\u2003\u2003\u2003\u2013 Construct a modification proposal using a multi-line string (modification_code) that defines new functionality.\n\u2003\u2003\u2003\u2013 Include a ratification condition. Choose ONE primary condition (voting, resource, temporal, or achievement) plus optional safeguards. Valid examples include:\n\u2003\u2003\u2003\u2003\u2013 Voting:\u2003\u2003\u2003{'type': 'vote', 'threshold': 0.5\u20131.0}\n\u2003\u2003\u2003\u2003\u2013 Resource:\u2003\u2003{'type': 'resource', 'resource': 'vitality', 'cargo', or 'land', 'amount': X}\n\u2003\u2003\u2003\u2003\u2013 Temporal:\u2003\u2003{'type': 'time', 'rounds': N}\n\u2003\u2003\u2003\u2003\u2013 Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\u2022 Do not simply copy any provided example; instead, combine various strategies in your unique approach.\n\u2022 When writing your modification code, check for namespace conflicts (use dir(execution_engine) to verify existing mechanisms).\n\u2022 If implementing new systems, include rollback or cleanup procedures, add version metadata, and perform attribute existence checks (use hasattr) for backward compatibility.\n\n[Additional Guidance: Mechanism Analysis]\n\u2022 Understand that the island simulation emphasizes multiple systems including relationships (victim, benefit, benefit_land), population mechanics (reproduction requirements, land versus population balance, neighbor search range), and record keeping.\n\u2022 Consider these questions when proposing your modification:\n\u2003\u20031. What is the core objective\u2014pure survival, mutual cooperation, or eventual domination?\n\u2003\u20032. What success metrics truly define \u2018winning\u2019 (e.g., survival_probability, overall_productivity, balanced resource distribution)?\n\u2003\u20033. In what ways could you improve the simulation mechanics (e.g., introduce a judicial system, trade improvements, or land zoning mechanisms)?\n\u2003\u20034. What assumptions are you making? Are they valid?\n\u2003\u20035. Have you considered alternative strategies and edge cases?\n\u2003\u20036. What vulnerabilities exist in your current approach, and how might opponents counter you?\n\u2003\u20037. Could unconventional paradigms or completely different strategies lead to better outcomes?\n\u2003\u20038. How would your strategy scale if other agents began to adopt similar approaches?\n\u2003\u20039. Is your approach balancing short-term gains with long-term stability?\n\u2003\u200310. What additional efficiencies or safeguards could be added?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Implementation Reminder \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nYour final prompt must include both functions:\n\u2003\u2022 agent_action(execution_engine, member_id)\n\u2003\u2022 propose_modification(execution_engine, member_id)\nThese functions should be completely independent in their tasks:\n\u2003\u2013 agent_action deals with immediate social interactions (attacks, offers, reproduction, territorial expansion, and messages).\n\u2003\u2013 propose_modification aims at system-level changes through proposal submission using execution_engine.propose_modification(...).\n\nRemember that:\n\u2022 All member accesses must use execution_engine.current_members[index] with proper index validation.\n\u2022 Avoid errors by always verifying the existence of attributes and list indices.\n\u2022 Never target your own member (member_2); always check that any referenced member\u2019s id is not the same as your own.\n\u2022 Verify that a member \u201chas land\u201d before attempting bear() or similar actions.\n\u2022 Ensure matrix operations on relationships are conducted with valid indices.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Conclusion \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAgents should implement these solutions based on their own needs, beliefs, and circumstances. Use the code examples not as direct templates but as sources of inspiration to create novel, robust, and adaptive strategies that address both immediate survival and long-term improvement of our society. Think critically about:\n\u2003\u2022 The core objective\u2014is it survival, cooperation, or domination?\n\u2003\u2022 What key metrics determine success?\n\u2003\u2022 Which mechanisms could be improved or added?\n\u2003\u2022 Potential weaknesses in your current approach, alternative methods, and how your strategy might perform when others adopt similar methods.\n\u2003\u2022 How you will adapt to counter challenges and evolving game dynamics.\n\nThis is your updated full prompt. Use it to craft both your immediate actions (agent_action) and system modification proposals (propose_modification) with an eye toward sustaining and advancing your member\u2019s influence in our ever-changing island society.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 End of Prompt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nUse this integrated prompt to design your Python functions\u2014the more innovative and adaptive your approach, the better you can shape our society while ensuring your survival.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 3,
      "code": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    This function implements member_3's strategy:\n      - If low on resources (cargo), consider attacking a wealthier opponent to seize resources.\n      - Expand territory by offering expansion to neighbors with lower vitality if we have available adjacent land.\n      - Attempt reproduction (bear offspring) only if both our member and a partner have cleared territory and enough cargo.\n      - Communicate with all other members to propose cooperation improving mutual survival.\n    All actions check index bounds and ensure that the member object is correctly referenced.\n    \"\"\"\n    # Ensure member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member_id, do nothing\n\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # 1. Resource Optimization: If cargo is below threshold relative to vitality,\n    # seek targets with higher cargo to attack (but only if they're viable opponents)\n    if me.cargo < (me.vitality * 0.5):\n        for i in range(total_members):\n            if i == me.id:\n                continue  # Skip self\n            if i < total_members:\n                other = execution_engine.current_members[i]\n                # Simple selection: attack if other has high cargo and sufficient vitality\n                if other.cargo > me.cargo and other.vitality > (me.vitality * 0.75):\n                    execution_engine.attack(me, other)\n                    break  # Attack one member only\n\n    # 2. Territorial Expansion:\n    # If we have cleared adjacent lands, try to expand territory by offering expansion\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list:\n        for i in range(total_members):\n            if i == me.id:\n                continue\n            if i < total_members:\n                other = execution_engine.current_members[i]\n                # Expand into a territory if the other member's vitality is lower.\n                if other.vitality < me.vitality:\n                    execution_engine.expand(me, other)\n                    break  # Expand once per turn\n\n    # 3. Reproduction Strategy (Bear Offspring):\n    # Reproduction is attempted only if we have cleared territory and sufficient cargo,\n    # and only if potential partner also has cleared territory.\n    if hasattr(me, \"current_clear_list\") and me.current_clear_list and me.cargo > 50:\n        for i in range(total_members):\n            if i == me.id:\n                continue\n            if i < total_members:\n                partner = execution_engine.current_members[i]\n                if hasattr(partner, \"current_clear_list\") and partner.current_clear_list and partner.cargo > 30:\n                    # Only bear if partner is also viable and has sufficient vitality (arbitrary threshold).\n                    if partner.vitality > 20:\n                        execution_engine.bear(me, partner)\n                        break  # One reproduction attempt this round\n\n    # 4. Communication: Send a message to every other member\n    for i in range(total_members):\n        if i == me.id:\n            continue\n        if i < total_members:\n            execution_engine.send_message(me.id, execution_engine.current_members[i].id,\n                                          \"Collaboration promotes stability; let\u2019s work together for our mutual benefit!\")\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    This function proposes a rule modification:\n      - Introduces a minimal judicial/trade oversight system to handle conflict resolution and resource exchanges.\n      - The new mechanism is added if not already present in execution_engine, preserves backward compatibility,\n        and includes versioning.\n      - Uses a temporal ratification condition that auto-ratifies the new rules after 3 rounds.\n      - A cleanup strategy is included to remove the mechanism if necessary.\n    \"\"\"\n    modification_code = '''\n# Introducing a Combined Judicial and Trade Oversight System to enhance conflict resolution and resource sharing.\n\n# Check if the mechanism is not already defined.\nif not hasattr(execution_engine, 'oversight_system'):\n    class OversightSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Resolves disputes via arbitration and facilitates fair resource trades',\n            'version': 1.0,\n            'cleanup': \"Call execution_engine.oversight_system.cleanup() to remove the system.\"\n        }\n        def __init__(self):\n            self.cases = []\n            self.trade_history = []  # Record of resource/trade transactions for audit purposes\n\n        def submit_case(self, plaintiff, defendant, charge):\n            # Add a dispute case into the system with pending status.\n            self.cases.append({\n                'plaintiff': plaintiff.id,\n                'defendant': defendant.id,\n                'charge': charge,\n                'status': 'pending'\n            })\n\n        def record_trade(self, member_from, member_to, amount):\n            self.trade_history.append({\n                'from': member_from.id,\n                'to': member_to.id,\n                'amount': amount\n            })\n\n        def cleanup(self):\n            # Cleanup mechanism in case the members decide to rollback the new rules.\n            self.cases.clear()\n            self.trade_history.clear()\n\n    # Add the oversight system to the execution engine.\n    execution_engine.oversight_system = OversightSystem()\n'''\n    # Define a straightforward temporal ratification condition: auto-ratify after 3 rounds.\n    ratification_condition = {\n        'type': 'time',\n        'rounds': 3\n    }\n\n    # Submit the proposal through the execution engine.\n    execution_engine.propose_modification(member_id=member_id,\n                                            mod_type='post_init',\n                                            code=modification_code,\n                                            ratification_condition=ratification_condition)\n\n    return",
      "features_at_generation": [
        {
          "self_productivity": 8.486091902927424,
          "self_vitality": 100.0,
          "self_cargo": 23.526833366104754,
          "self_age": 46,
          "self_neighbor": 0,
          "member_id": 0
        },
        {
          "self_productivity": 9.215596783061361,
          "self_vitality": 54.314458610995025,
          "self_cargo": 0.0,
          "self_age": 92,
          "self_neighbor": 2,
          "member_id": 1
        },
        {
          "self_productivity": 9.820787822339064,
          "self_vitality": 100.0,
          "self_cargo": 15.417192696647142,
          "self_age": 61,
          "self_neighbor": 2,
          "member_id": 2
        },
        {
          "self_productivity": 7.823171351824591,
          "self_vitality": 68.67244177884766,
          "self_cargo": 0.0,
          "self_age": 32,
          "self_neighbor": 2,
          "member_id": 3
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_1 (value=-409.21)",
        "member_0 was attacked by member_2 (value=159.09)",
        "member_0 was attacked by member_3 (value=213.02)",
        "member_1 was attacked by member_0 (value=950.45)",
        "member_1 was attacked by member_2 (value=337.53)",
        "member_1 was attacked by member_3 (value=501.15)",
        "member_2 was attacked by member_0 (value=-234.29)",
        "member_2 was attacked by member_1 (value=-149.95)",
        "member_2 was attacked by member_3 (value=981.94)",
        "member_3 was attacked by member_0 (value=-480.06)",
        "member_3 was attacked by member_1 (value=911.18)",
        "member_3 was attacked by member_2 (value=697.26)",
        "member_0 gave a benefit to member_1 (value=32.04)",
        "member_0 gave a benefit to member_2 (value=-318.27)",
        "member_0 gave a benefit to member_3 (value=458.03)",
        "member_1 gave a benefit to member_0 (value=352.02)",
        "member_1 gave a benefit to member_2 (value=655.79)",
        "member_1 gave a benefit to member_3 (value=-269.93)",
        "member_2 gave a benefit to member_0 (value=553.91)",
        "member_2 gave a benefit to member_1 (value=-244.38)",
        "member_2 gave a benefit to member_3 (value=958.19)",
        "member_3 gave a benefit to member_0 (value=765.26)",
        "member_3 gave a benefit to member_1 (value=782.26)",
        "member_3 gave a benefit to member_2 (value=551.02)",
        "member_0 gave land to member_1 (value=-5.18)",
        "member_0 gave land to member_2 (value=-5.22)",
        "member_0 gave land to member_3 (value=-19.16)",
        "member_1 gave land to member_0 (value=-26.25)",
        "member_1 gave land to member_2 (value=25.58)",
        "member_1 gave land to member_3 (value=-4.99)",
        "member_2 gave land to member_0 (value=6.54)",
        "member_2 gave land to member_1 (value=0.66)",
        "member_2 gave land to member_3 (value=25.05)",
        "member_3 gave land to member_0 (value=2.30)",
        "member_3 gave land to member_1 (value=26.64)",
        "member_3 gave land to member_2 (value=29.64)"
      ],
      "final_prompt": "Below is the updated full prompt. It preserves all previous constraints and context while adding the new sections and requirements. Agents reading this prompt should implement solutions according to their individual needs, beliefs, and circumstances.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT\n\nPlease incorporate the following new sections into your solution. All previous constraints, assumptions, and information remain in effect.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Previous code execution context]  \nNo previous execution errors\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current task]\nYou are member_3 in a society that you can help shape.\n\nThere are two parts to your task:\n\n1) Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n2) Write a Python function named propose_modification(execution_engine, member_id) that implements your vision of social organization with a proposal for rule changes. Your proposal should include a ratification condition following one primary condition (voting, resource, temporal, or achievement) plus any optional safeguards.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Critical constraints]\n\u2022 Analyze previous errors shown above and inspect carefully to avoid repeating them.\n\u2022 NEVER target yourself (member_3) in any action.\n\u2022 Before using the bear() action, verify that the member has land (i.e. a non\u2010empty current_clear_list).\n\u2022 Always check that the member IDs exist (check index bounds) before referencing any member. (The members are accessed from execution_engine.current_members, which is a list. Verify that index < len(execution_engine.current_members) before use.)\n\u2022 Ensure all matrix indices are valid.\n\u2022 When referencing members, do so using execution_engine.current_members[index] (e.g. for member with ID=2, use execution_engine.current_members[2]).\n\u2022 Do not use \u201cmember.member_id\u201d, \u201cmember.self_vitality\u201d, or any non-specified attribute names. Use the provided attributes like member.id, member.vitality, member.cargo, member.overall_productivity, member.age, and member.current_clear_list.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Base Code]\nNone\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Available Attributes & Methods]\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) \u2013 IDs of neighbors or cleared adjacents.\n\n2) The relationships are stored in execution_engine.relationship_dict, not in \u201crelationship_history\u201d. You may use the matrices within or rely on the summary provided. The keys are: 'victim', 'benefit', 'benefit_land'. For example:\n   matrix = execution_engine.relationship_dict['victim']\n   (matrix[i, j] is the value indicating how many times member_i was attacked by member_j if > 0.)\n\n3) A helper method parse_relationship_matrix may be used to produce a summary of relationships (i.e., a list of strings such as \u201cmember_2 was attacked by member_1 (value=3.00)\u201d).\n\n4) Methods available on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) \u2013 Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2, True) \u2013 Offers land.\n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring.\n   \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory.\n   \u2022 execution_engine.send_message(sender_id, recipient_id, message) \u2013 (for communication, as seen in earlier examples)\n\n5) Members are accessed via execution_engine.current_members[index]. For example, execution_engine.current_members[2] is the member with ID=2.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Analysis of the Game State]\n\nThere is currently no additional analysis provided.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Status \u2013 Features of All Members]\n\nThe current members\u2019 statuses (sample data):\n   self_productivity  ...  member_id\n0           8.486092   ...         0\n1           9.215597   ...         1\n2           9.820788   ...         2\n3           7.823171   ...         3\n(4 rows x 6 columns)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Relationship Summary]\n\nParsed from execution_engine.relationship_dict, a sample summary is:\n  \n  \u2022 'member_0 was attacked by member_1 (value=-409.21)'\n  \u2022 'member_0 was attacked by member_2 (value=159.09)'\n  \u2022 'member_0 was attacked by member_3 (value=213.02)'\n  \u2022 'member_1 was attacked by member_0 (value=950.45)'\n  \u2022 \u2026and so on for various interactions including benefits and land transfers.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Code Memory and Previous Performance]\n\nExample Strategy 1 (Performance: 0.00):\n  \nContext:\n  {'old_stats': {'vitality': 26.57103, 'cargo': 57.29695, 'survival_chance': 164.86029},\n   'new_stats': {'vitality': 26.57103, 'cargo': 57.29695, 'survival_chance': 164.86029},\n   'round': 0}\n  \nExample Code (for inspiration, do NOT merely copy):\n\n-----------------------------------------------------------\ndef agent_action(execution_engine, member_id):\n    # Retrieve our own member object (we are member_3)\n    me = execution_engine.current_members[member_id]\n    total_members = len(execution_engine.current_members)\n\n    # Retrieve relationship matrices safely.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    benefit_matrix = execution_engine.relationship_dict.get('benefit')\n    land_benefit_matrix = execution_engine.relationship_dict.get('benefit_land')\n\n    # Defensive Resource Optimization:\n    if me.cargo < me.vitality * 0.5:\n        for i in range(total_members):\n            if i != me.id:\n                other = execution_engine.current_members[i]\n                if other.cargo > me.cargo and other.vitality > 0:\n                    execution_engine.attack(me, other)\n                    break\n\n    # Territorial Expansion and Alliance Building:\n    if me.current_clear_list and len(me.current_clear_list) > 0:\n        for i in range(total_members):\n            if i != me.id:\n                if i < total_members:\n                    other = execution_engine.current_members[i]\n                    if other.vitality < me.vitality:\n                        execution_engine.expand(me, other)\n                        break\n\n    # Reproduction Strategy (Bear Offspring):\n    if me.current_clear_list and len(me.current_clear_list) > 0 and me.cargo > 50:\n        for i in range(total_members):\n            if i != me.id:\n                if i < total_members:\n                    partner = execution_engine.current_members[i]\n                    if partner.current_clear_list and len(partner.current_clear_list) > 0 and partner.vitality > 20:\n                        execution_engine.bear(me, partner)\n                        break\n\n    # Communication and Alliance Reinforcement:\n    for i in range(total_members):\n        if i != me.id and i < total_members:\n            execution_engine.send_message(me.id, i, \"Let's collaborate for mutual growth and stability!\")\n\n    return\n-----------------------------------------------------------\n  \nBased on past performance, feel free to propose modifications and novel strategies rather than simply replicating previous patterns.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Core Game Mechanics & Parameters]\n\n1. Relationship System (_MIN_MAX_INIT_RELATION):\n   - victim: [-50, 100] (damage received tracking)\n   - benefit: [-50, 100] (resources exchanged)\n   - benefit_land: [-3, 3] (land transfers)\n\n2. Population Mechanics:\n   - _REPRODUCE_REQUIREMENT = 100 (combined vitality/cargo needed)\n   - Land must exceed population (land_shape[0] * land_shape[1] > population)\n   - _NEIGHBOR_SEARCH_RANGE = 1000 (interaction radius)\n\n3. Record Keeping:\n   - Every _RECORD_PERIOD = 1 round, all actions (attacks, benefits, land transfers, births, deaths, etc.) are recorded along with metrics for production, consumption, and performance.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Example Mechanism Extensions]\n\nYou may consider pattern extensions such as:\n\n\u2022 Creating a judicial system:\n   If not hasattr(execution_engine, 'court'):\n       class CourtSystem:\n           MECHANISM_META = {\n               'type': 'Governance',\n               'rules': 'Handles conflict resolution through jury trials',\n               'version': 1.0\n           }\n           def __init__(self):\n               self.cases = []\n           def submit_case(self, plaintiff, defendant, charge):\n               self.cases.append({'plaintiff': plaintiff, 'defendant': defendant, 'charge': charge, 'status': 'pending'})\n       execution_engine.court = CourtSystem()\n\n\u2022 Incorporating new member capabilities or updating land usage:\n   def modify_member(member, relationships):\n       if not hasattr(member, 'custom_abilities'):\n           member.custom_abilities = {}\n       member.custom_abilities['trade'] = lambda resource: print(f\"Trading {resource}\") if member.vitality > 20 else None\n       return member\n\n\u2022 Setting up land zoning and development:\n   def modify_land(land, members):\n       if not hasattr(land, 'zoning'):\n           land.zoning = {'residential': 0.4, 'agricultural': 0.4, 'commercial': 0.2}\n       land.development_level = np.zeros(land.shape)\n       return land\n\n\u2022 Extending the relationship system with additional matrices or trust algorithms.\n\nRemember:\n   - Check for attribute existence using hasattr.\n   - Use simple, testable changes and include version metadata.\n   - Implement cleanup functions when needed.\n   - Avoid namespace conflicts by checking dir(execution_engine) prior to adding new features.\n   - Ensure backward compatibility and proper versioning.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Modification Proposal Guide]\n\nTo propose rule changes, use the following template:\n\n1. ANALYSIS PHASE:\n   - Identify limitations in current systems.\n   - Check mechanism compatibility using get_game_mechanisms_and_mods().\n   - Review past modification attempts for patterns.\n\n2. PROPOSAL PHASE:\n   In propose_modification(execution_engine, member_id), include:\n   \u2022 A string variable (modification_code) that holds the new code. For example:\n\n       modification_code = '''\n       # Add judicial system to improve conflict resolution.\n       if not hasattr(execution_engine, 'court'):\n           class CourtSystem:\n               MECHANISM_META = {\n                   'type': 'Governance',\n                   'rules': 'Handles conflict resolution through jury trials',\n                   'version': 1.0\n               }\n               def __init__(self):\n                   self.cases = []\n               def submit_case(self, plaintiff, defendant, charge):\n                   self.cases.append({\n                       'plaintiff': plaintiff,\n                       'defendant': defendant,\n                       'charge': charge,\n                       'status': 'pending'\n                   })\n           execution_engine.court = CourtSystem()\n       '''\n       \n   \u2022 A call to execution_engine.propose_modification with:\n       - member_id: your member ID.\n       - mod_type: e.g. 'post_init'\n       - code: the modification_code variable created above.\n       - ratification_condition: a condition dict example:\n             {\n                 'type': 'compound',\n                 'conditions': [\n                     {'type': 'vote', 'threshold': 0.6},\n                     {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                     {'type': 'time', 'rounds': 2}\n                 ]\n             }\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Valid Ratification Conditions]\nChoose ONE primary condition (with possible safeguards):\n   1. Voting:  {'type': 'vote', 'threshold': 0.5 to 1.0}\n   2. Resource: {'type': 'resource', 'resource': 'vitality' or 'cargo' or 'land', 'amount': X}\n   3. Temporal: {'type': 'time', 'rounds': N} (auto-ratify after N rounds)\n   4. Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Common Errors to Avoid]\n1. Namespace conflicts: Always check existing mechanisms with dir(execution_engine).\n2. Invalid References: Always use execution_engine.current_members (do not assume global access).\n3. Version Mismatches: Increment version numbers when modifying existing systems.\n4. Resource Leaks: Include cleanup functions for mechanisms that require them.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Best Practices]\n   \u2022 Propose small, testable changes first.\n   \u2022 Include explicit rollback procedures or cleanup code in new mechanisms.\n   \u2022 Use version checks to determine if modifications are needed.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Message Context]\nIncoming messages from other members include:\n   \u2022 From member_0: \"Let's cooperate for mutual benefit!\"\n   \u2022 From member_1: \"Collaboration and survival lead to prosperity.\"\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Task Summary]\n\nYou are member_3. Complete the following:\n\nA) Write a Python function named agent_action(execution_engine, member_id) that:\n   - Implements your strategy for resource optimization, territorial expansion, reproduction (only if you and a partner have cleared territory and sufficient cargo), and communication.\n   - Ensures that you never target yourself and always check index bounds and available attributes.\n   - Uses available execution_engine action methods (attack, offer, offer_land, bear, expand, send_message) in novel ways that you believe will best ensure your short-term survival and long-term success.\n\nB) Write a Python function named propose_modification(execution_engine, member_id) that:\n   - Analyzes the current game mechanics.\n   - Proposes a rule change (for example, a new governance or resource transfer mechanism) to all members by building a modification code string.\n   - Submits the proposal with execution_engine.propose_modification() including a clear ratification condition.\n   - Ensures version compatibility and includes a cleanup or rollback strategy if appropriate.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Game Objectives and Analysis]\n\nConsider:\n1. Core Objective: What is the primary aim of the simulation for you? Is it pure survival, achieving domination, or fostering cooperation and long-term prosperity?\n2. Key Success Metrics: What determines \u201cwinning\u201d in the simulation? (Consider metrics like vitality, cargo, overall productivity, and control of territory.)\n3. Potential Improvements: What additional mechanics might be added or modified? E.g., enhanced resource trading, more nuanced governance, improved conflict resolution, or land development dynamics.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Strategy Challenge Questions]\n\nChallenge your implementation with these questions:\n1. What assumptions are you making? Are they valid given the game mechanics?\n2. What alternative strategies have you not yet considered?\n3. How would your strategy perform in edge cases (for example, near the minimum required cargo or when many members lack land)?\n4. Could there be more efficient ways to combine actions to achieve your goals?\n5. What are the weaknesses in your current approach? How could opponents counter your strategy?\n6. Have you considered unconventional or innovative solutions beyond conventional expansion, conflict, or cooperation?\n7. How might your strategy evolve if other agents adopt similar ideas?\n8. Are you balancing short-term survival with long-term prosperity effectively?\n9. What adjustments would be necessary if the simulation\u2019s dynamics changed significantly?\n10. How could you quickly adapt or scale your approach if needed?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFinal Note:\nAgents are encouraged to implement solutions that reflect their own strategy and values. Adapt and innovate as you see fit, and remember that your solution should harmonize with the simulation\u2019s overall mechanics while ensuring your survival.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nReturn the updated integrated prompt. \n\nEnd of prompt.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nUse this full prompt to guide your Python implementations for agent_action and propose_modification.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false
    }
  ],
  "ratified_mods": [
    {
      "round": 1,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate that the member_id is within bounds.\n    if member_id >= len(execution_engine.current_members) or member_id < 0:\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # Strategy 1: Survival \u2013 if cargo is less than half of vitality,\n    # attempt to attack a rival who has surplus resources and lower vitality.\n    if hasattr(me, 'cargo') and hasattr(me, 'vitality') and me.cargo < 0.5 * me.vitality:\n        for i, target in enumerate(execution_engine.current_members):\n            # Skip invalid or self indices.\n            if i == member_id or not hasattr(target, 'id'):\n                continue\n            # Never target member_0 (yourself) if your id equals 0.\n            if target.id == 0:\n                continue\n            # Check for a viable target: one with more cargo and relatively lower vitality.\n            if hasattr(target, 'cargo') and hasattr(target, 'vitality'):\n                if target.cargo > me.cargo and target.vitality < me.vitality:\n                    try:\n                        execution_engine.attack(me, target)\n                        return\n                    except Exception:\n                        continue\n\n    # Strategy 2: Reproduction \u2013 if resources are abundant relative to vitality\n    # and both agents possess land (non-empty current_clear_list), then bear offspring.\n    if (hasattr(me, 'cargo') and hasattr(me, 'vitality') and me.cargo > 1.2 * me.vitality and\n            hasattr(me, 'current_clear_list') and me.current_clear_list):\n        for i, partner in enumerate(execution_engine.current_members):\n            if i == member_id:\n                continue\n            # Skip if partner is ourselves (member_0) or missing required attributes.\n            if not hasattr(partner, 'current_clear_list') or partner.id == 0:\n                continue\n            if partner.current_clear_list and hasattr(partner, 'vitality') and partner.vitality > 50:\n                try:\n                    execution_engine.bear(me, partner)\n                    return\n                except Exception:\n                    continue\n\n    # Strategy 3: Territorial Expansion \u2013 if vitality is high enough, seek to expand land.\n    # Use existing relationship dynamics (benefit_land matrix) to choose an ally.\n    if hasattr(me, 'vitality') and me.vitality > 100:\n        for i, ally in enumerate(execution_engine.current_members):\n            if i == member_id or not hasattr(ally, 'id'):\n                continue\n            # Never target member_0 in any indirect confrontation.\n            if ally.id == 0:\n                continue\n            benefit_val = 0\n            try:\n                # Ensure indices are valid for benefit_land matrix.\n                if ('benefit_land' in execution_engine.relationship_dict and\n                        member_id < len(execution_engine.relationship_dict['benefit_land']) and\n                        i < len(execution_engine.relationship_dict['benefit_land'][member_id])):\n                    benefit_val = execution_engine.relationship_dict['benefit_land'][member_id][i]\n            except Exception:\n                benefit_val = 0\n            # If the relationship is non-negative and the ally has sufficient vitality/resources and land,\n            # consider expanding territory by linking up.\n            if benefit_val >= 0 and hasattr(ally, 'vitality') and ally.vitality > 50:\n                if hasattr(ally, 'current_clear_list') and ally.current_clear_list:\n                    try:\n                        execution_engine.expand(me, ally)\n                        return\n                    except Exception:\n                        continue\n\n    # Fallback: Cooperative engagement. Send a message to other members to encourage collaboration.\n    for i, other in enumerate(execution_engine.current_members):\n        if i == member_id or not hasattr(other, 'id'):\n            continue\n        # Avoid sending messages to member_0 (yourself).\n        if other.id == 0:\n            continue\n        try:\n            execution_engine.send_message(me.id, other.id, \"Collaboration and mutual growth lead to prosperity!\")\n        except Exception:\n            continue\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    # The proposal follows a two-phase process: ANALYSIS then PROPOSAL.\n    # ANALYSIS PHASE:\n    # Current limitation: Lack of a decentralized mechanism for balanced resource exchange and dispute resolution.\n    # This can result in imbalances in cargo distribution and resource allocation.\n    # PROPOSAL PHASE:\n    # Implement a new decentralized resource exchange platform that allows agents to post and process resource offers.\n    modification_code = '''\n# Proposed Modification: Decentralized Resource Exchange Mechanism\n# This mechanism is designed to address resource distribution disparities and foster cooperative trade.\nif not hasattr(execution_engine, 'resource_exchange'):\n    class ResourceExchange:\n        MECHANISM_META = {\n            'type': 'Economic',\n            'description': 'A decentralized platform for resource trading and mutual aid. It balances resource surpluses and deficits among agents.',\n            'version': 1.0\n        }\n        def __init__(self):\n            self.offers = []  # Each offer is a dict: {'sender': int, 'receiver': int, 'resource': amount, 'status': str}\n        def submit_offer(self, sender, receiver, amount):\n            # Accept offers only within valid resource thresholds.\n            if -50 <= amount <= 100:\n                self.offers.append({\n                    'sender': sender,\n                    'receiver': receiver,\n                    'resource': amount,\n                    'status': 'pending'\n                })\n        def process_offers(self):\n            approved_offers = []\n            for offer in self.offers:\n                # A simple approval mechanism based on resource bounds.\n                if -50 <= offer['resource'] <= 100:\n                    approved_offers.append(offer)\n            self.offers = []  # Reset after processing.\n            return approved_offers\n    execution_engine.resource_exchange = ResourceExchange()\n'''\n    # Define ratification conditions that combine multiple criteria:\n    ratification_condition = {\n        'type': 'compound',\n        'conditions': [\n            {'type': 'vote', 'threshold': 0.6},\n            {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n            {'type': 'time', 'rounds': 2}\n        ]\n    }\n    try:\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition=ratification_condition\n        )\n    except Exception:\n        pass\n    return",
      "features_at_generation": [
        {
          "self_productivity": 8.486091902927424,
          "self_vitality": 100.0,
          "self_cargo": 23.526833366104754,
          "self_age": 46,
          "self_neighbor": 0,
          "member_id": 0
        },
        {
          "self_productivity": 9.215596783061361,
          "self_vitality": 54.314458610995025,
          "self_cargo": 0.0,
          "self_age": 92,
          "self_neighbor": 2,
          "member_id": 1
        },
        {
          "self_productivity": 9.820787822339064,
          "self_vitality": 100.0,
          "self_cargo": 15.417192696647142,
          "self_age": 61,
          "self_neighbor": 2,
          "member_id": 2
        },
        {
          "self_productivity": 7.823171351824591,
          "self_vitality": 68.67244177884766,
          "self_cargo": 0.0,
          "self_age": 32,
          "self_neighbor": 2,
          "member_id": 3
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_1 (value=-409.21)",
        "member_0 was attacked by member_2 (value=159.09)",
        "member_0 was attacked by member_3 (value=213.02)",
        "member_1 was attacked by member_0 (value=950.45)",
        "member_1 was attacked by member_2 (value=337.53)",
        "member_1 was attacked by member_3 (value=501.15)",
        "member_2 was attacked by member_0 (value=-234.29)",
        "member_2 was attacked by member_1 (value=-149.95)",
        "member_2 was attacked by member_3 (value=981.94)",
        "member_3 was attacked by member_0 (value=-480.06)",
        "member_3 was attacked by member_1 (value=911.18)",
        "member_3 was attacked by member_2 (value=697.26)",
        "member_0 gave a benefit to member_1 (value=32.04)",
        "member_0 gave a benefit to member_2 (value=-318.27)",
        "member_0 gave a benefit to member_3 (value=458.03)",
        "member_1 gave a benefit to member_0 (value=352.02)",
        "member_1 gave a benefit to member_2 (value=655.79)",
        "member_1 gave a benefit to member_3 (value=-269.93)",
        "member_2 gave a benefit to member_0 (value=553.91)",
        "member_2 gave a benefit to member_1 (value=-244.38)",
        "member_2 gave a benefit to member_3 (value=958.19)",
        "member_3 gave a benefit to member_0 (value=765.26)",
        "member_3 gave a benefit to member_1 (value=782.26)",
        "member_3 gave a benefit to member_2 (value=551.02)",
        "member_0 gave land to member_1 (value=-5.18)",
        "member_0 gave land to member_2 (value=-5.22)",
        "member_0 gave land to member_3 (value=-19.16)",
        "member_1 gave land to member_0 (value=-26.25)",
        "member_1 gave land to member_2 (value=25.58)",
        "member_1 gave land to member_3 (value=-4.99)",
        "member_2 gave land to member_0 (value=6.54)",
        "member_2 gave land to member_1 (value=0.66)",
        "member_2 gave land to member_3 (value=25.05)",
        "member_3 gave land to member_0 (value=2.30)",
        "member_3 gave land to member_1 (value=26.64)",
        "member_3 gave land to member_2 (value=29.64)"
      ],
      "final_prompt": "Below is the complete updated integrated prompt that incorporates the new section along with all previous constraints. Remember that in your implementation you must tailor your strategy to your own needs, beliefs, and circumstances. In crafting your solution, be sure to follow each step, verify all constraints, and analyze both short\u2010 and long\u2010term game mechanics. Use efficient indexing, proper attribute accesses, and always check for valid member indexes and land existence when required. Also, never act directly against yourself (member_0). The following is the updated full prompt:\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCURRENT INTEGRATED PROMPT\n\n\u2013\u2013\u2013\u2013\u2013\u2013 Context \u2013\u2013\u2013\u2013\u2013\u2013\nYou are member_0 in a society that you can help shape. The simulation is based on an island with multiple agents whose actions are defined by their capabilities: attack, offer resources, offer land, bear offsprings (reproduce), and expand territory. Each agent has attributes such as id, vitality, cargo, overall_productivity, age, and current_clear_list (which tracks land ownership such as cleared adjacent land). All members are accessed through execution_engine.current_members (a list by index, not a dictionary). Relationships are tracked in execution_engine.relationship_dict. Example matrices include:\n\u2003\u2022 \u2018victim\u2019\u2003\u2003\u2192 tracks damage received (range: \u201350 to 100)\n\u2003\u2022 \u2018benefit\u2019\u2003\u2003\u2192 tracks resources (range: \u201350 to 100)\n\u2003\u2022 \u2018benefit_land\u2019\u2003\u2192 tracks land exchanges (range: \u20133 to 3)\n\nAdditional methods available (all called via execution_engine):\n\u2003\u2022 attack(member1, member2)\n\u2003\u2022 offer(member1, member2, True)\n\u2003\u2022 offer_land(member1, member2, True)\n\u2003\u2022 bear(member1, member2)\n\u2003\u2022 expand(member1, member2)\n\u2003\u2022 send_message(sender_id, recipient_id, message)\n\u2003\u2022 propose_modification(member_id, mod_type, code, ratification_condition)\n\nEach member\u2019s id is stored as member.id (not member.member_id) and when referencing other members, always ensure that the index exists (i.e. if index < len(execution_engine.current_members)).\n\nPast simulation analysis shows game state statistics such as resource_gini, survival_probability, etc. Current member attributes (example):\n\u2003member_0: self_productivity=8.486092, member_id=0\n\u2003member_1: self_productivity=9.215597, member_id=1\n\u2003member_2: self_productivity=9.820788, member_id=2\n\u2003member_3: self_productivity=7.823171, member_id=3\n\nThe parsed relationship summary (attacks, benefits, land exchanges) is provided as a list of strings.\n\n\u2013\u2013\u2013\u2013\u2013\u2013 Previous Code Strategies and Critical Constraints \u2013\u2013\u2013\u2013\u2013\u2013\nCritical constraints to ensure:\n\u2003\u2022 Do not target yourself (member_0) with any action.\n\u2003\u2022 Verify that a member possesses land (non-empty current_clear_list) before using bear().\n\u2003\u2022 Check that a member index is valid:\n\u2003\u2003if i < len(execution_engine.current_members)\n\u2003\u2022 Use execution_engine.current_members[i] to reference members.\n\u2003\u2022 Do not repeat previous errors regarding invalid indices/attributes.\n\nA previous strategy (agent_action) is given as an example. It includes:\n\u20031. A survival mechanism where if cargo < half vitality, an attack is initiated on a rival with higher cargo and lower vitality.\n\u20032. A reproduction strategy when cargo is high relative to vitality and both partners have land.\n\u20033. Territory expansion using the benefit_land relationship matrix when vitality exceeds a threshold.\n\u20034. A cooperative fallback where messages invite collective engagement if no other action is taken.\nThis example is meant for inspiration only. Your implementation should be unique and may combine or extend different strategies.\n\n\u2013\u2013\u2013\u2013\u2013\u2013 Implementation Patterns and Error Prevention \u2013\u2013\u2013\u2013\u2013\u2013\n\u2022 Always check for attribute existence and use try-except where needed.\n\u2022 Maintain backward compatibility by checking existing mechanisms (e.g. via hasattr).\n\u2022 When modifying or extending game mechanisms, include version metadata and consider cleanup procedures.\n\u2022 Avoid namespace conflicts and resource leaks by using proper cleanup methods.\n\n\u2013\u2013\u2013\u2013\u2013\u2013 Core Game Mechanics & Parameters \u2013\u2013\u2013\u2013\u2013\u2013\nPopulation Mechanics:\n\u2003\u2022 _REPRODUCE_REQUIREMENT = 100 (vitality/cargo threshold)\n\u2003\u2022 Land must exceed population; use land_shape for details.\n\u2003\u2022 _NEIGHBOR_SEARCH_RANGE = 1000 for interactions.\n\nRecord Keeping:\n\u2003\u2022 The system records all attacks, benefits, land transfers, births/deaths, production, consumption, and performance metrics every _RECORD_PERIOD rounds.\n\n\u2013\u2013\u2013\u2013\u2013\u2013 Message Context \u2013\u2013\u2013\u2013\u2013\u2013\nReceived messages include:\n\u2003From member_1: \u201cCollaboration and survival lead to prosperity.\u201d\n\u2003From member_3: \u201cLet's collaborate for mutual growth and stability!\u201d\n\n\u2013\u2013\u2013\u2013\u2013\u2013 THE TASK \u2013\u2013\u2013\u2013\u2013\u2013\nYou are to provide two distinct functions as defined below.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nA) Function 1: agent_action\n\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival. Your implementation should adopt one or more strategies (attack, reproduce, or expand) but must include the following checks:\n\u20031. Validate that member_id is within the bounds of execution_engine.current_members.\n\u20032. Never target yourself (member_0).\n\u20033. Check that a target member exists (index validity) before referencing.\n\u20034. Before calling bear(), verify that the member has available land (i.e., current_clear_list non-empty).\n\u20035. When processing matrices (like benefit_land), ensure all indices are valid.\n\nYour function should intelligently decide whether to attack (if survival is jeopardized), reproduce (if conditions permit), expand territory (if you have sufficient vitality and a suitable ally), or default to sending cooperative messages.\n\nExample (for inspiration only):\n\u2003def agent_action(execution_engine, member_id):\n\u2003\u2003if member_id >= len(execution_engine.current_members):\n\u2003\u2003\u2003return\n\u2003\u2003me = execution_engine.current_members[member_id]\n\u2003\u2003num_members = len(execution_engine.current_members)\n\u2003\u2003# [Implement your strategy following survival and cooperation checks...]\n\u2003\u2003return\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nB) Function 2: propose_modification\n\nWrite a Python function named propose_modification(execution_engine, member_id) that implements your vision of social organization by proposing a rule change. Follow this two-phase proposal template:\n\n1. ANALYSIS PHASE:\n\u2003\u2022 Identify a limitation in the current systems.\n\u2003\u2022 Check mechanism compatibility using get_game_mechanisms_and_mods() if available.\n\u2003\u2022 Review past modification attempts for patterns.\n\u2003\u2022 Consider how new systems, such as a judicial system or additional governance mechanisms, might address conflicts and resource distribution.\n\n2. PROPOSAL PHASE:\n\u2003\u2022 Compose a string (modification_code) that defines the new mechanism.\n\u2003\u2022 Use execution_engine.propose_modification(...) with a primary ratification condition (choose one of vote, resource, time, or achievement; additional safeguards may be added).\n\nFor example, your modification proposal may resemble:\n\u2003def propose_modification(execution_engine, member_id):\n\u2003\u2003modification_code = '''\n\u2003\u2003# Add a judicial system\n\u2003\u2003if not hasattr(execution_engine, 'court'):\n\u2003\u2003\u2003class CourtSystem:\n\u2003\u2003\u2003\u2003MECHANISM_META = {\n\u2003\u2003\u2003\u2003\u2003'type': 'Governance',\n\u2003\u2003\u2003\u2003\u2003'rules': 'Handles conflict resolution through jury trials',\n\u2003\u2003\u2003\u2003\u2003'version': 1.0\n\u2003\u2003\u2003\u2003}\n\u2003\u2003\u2003\u2003def __init__(self):\n\u2003\u2003\u2003\u2003\u2003self.cases = []\n\u2003\u2003\u2003\u2003def submit_case(self, plaintiff, defendant, charge):\n\u2003\u2003\u2003\u2003\u2003self.cases.append({\n\u2003\u2003\u2003\u2003\u2003\u2003'plaintiff': plaintiff,\n\u2003\u2003\u2003\u2003\u2003\u2003'defendant': defendant,\n\u2003\u2003\u2003\u2003\u2003\u2003'charge': charge,\n\u2003\u2003\u2003\u2003\u2003\u2003'status': 'pending'\n\u2003\u2003\u2003\u2003\u2003})\n\u2003\u2003\u2003execution_engine.court = CourtSystem()\n\u2003\u2003'''\n\u2003\u2003execution_engine.propose_modification(\n\u2003\u2003\u2003member_id=member_id,\n\u2003\u2003\u2003mod_type='post_init',\n\u2003\u2003\u2003code=modification_code,\n\u2003\u2003\u2003ratification_condition={\n\u2003\u2003\u2003\u2003'type': 'compound',\n\u2003\u2003\u2003\u2003'conditions': [\n\u2003\u2003\u2003\u2003\u2003{'type': 'vote', 'threshold': 0.6},\n\u2003\u2003\u2003\u2003\u2003{'type': 'resource', 'resource': 'cargo', 'amount': 100},\n\u2003\u2003\u2003\u2003\u2003{'type': 'time', 'rounds': 2}\n\u2003\u2003\u2003\u2003]\n\u2003\u2003\u2003}\n\u2003\u2003)\nThis example is provided solely as a template. You must design your own unique approach that considers how to balance cooperation, resource allocation, and conflict resolution.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nGAME MECHANICS ANALYSIS \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\nBefore submitting your actions, consider the following:\n\u20031. Core Objective: Are we aiming for pure survival, domination, or robust cooperation?\n\u20032. Key Success Metrics: What metrics (vitality, cargo, productivity, territorial expansion) truly determine success?\n\u20033. Potential Improvements: Are there game mechanics that should be added/modified (additional governance systems, resource-trading mechanisms, improved reproduction controls)?\n\u20034. Critical Questions:\n\u2003\u2003\u2022 What assumptions underlie your strategy, and are they valid?\n\u2003\u2003\u2022 What alternative strategies have you not yet considered?\n\u2003\u2003\u2022 How will your strategy perform in edge cases and under adversarial strategies from others?\n\u2003\u2003\u2022 Are there more efficient or innovative methods to achieve your goals?\n\u2003\u2003\u2022 What weaknesses exist in your current approach, and how could other agents counter or adopt similar strategies?\n\u2003\u2003\u2022 Is your approach balancing short-term survival with long-term stability effectively?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nDELIVERABLES:\n\nReturn two functions following the specifications:\n\u20031. agent_action(execution_engine, member_id)\n\u20032. propose_modification(execution_engine, member_id)\n\nEnsure that your code observes all constraints, verifies indices and land ownership, and always uses execution_engine.current_members for member references. Do not simply copy the examples but build upon them using your individual insights.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nIn summary, agents should implement solutions according to their own perspectives while maintaining social organization and personal survival. Always verify that your implementations are robust against edge cases, resource leaks, version mismatches, and any unforeseen conflicts. Evaluate any proposal\u2019s feasibility not only in terms of immediate advantage but also for sustainable, cooperative growth across the society.\n\nRemember:\n\u2022 Check for valid indices when accessing execution_engine.current_members.\n\u2022 Never target yourself in any intervention.\n\u2022 Validate prerequisites (like land availability before reproducing) for each action.\n\u2022 Propose modifications that are incremental, testable, and include rollback procedures if needed.\n\u2022 Be mindful of the dynamic and interdependent nature of the game mechanics.\n\nGood luck shaping a society that is resilient, adaptive, and capable of thriving in both short-term challenges and long-term evolution!\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nThis is your updated full prompt. Use it as the basis for your implementations of agent_action and propose_modification.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    Implements immediate actions for member_1.\n\n    Strategy Overview:\n      1. Safely retrieve our own member object.\n      2. Iterate over other members (ensuring we never target ourselves) and:\n         - If a candidate shows a high resource imbalance (cargo/vitality > 1.5), attack them.\n         - Otherwise, if a candidate has land (i.e. candidate.current_clear_list is nonempty) and appears resource\u2010stable,\n           bear offspring with that candidate.\n         - Otherwise, if our own cargo significantly exceeds our vitality, offer our resources to signal cooperation.\n      3. Additionally, if our overall_productivity is high, attempt to expand territory with an arbitrary cooperative partner.\n\n    Note:\n      - Every action is only attempted after checking that the referenced member exists.\n      - We wrap major steps in try/except blocks to prevent execution errors.\n      - This function mixes short-term tactical resource management and long-term cooperative growth.\n    \"\"\"\n    try:\n        # Retrieve our own member object safely (member_id must be a valid index)\n        if member_id >= len(execution_engine.current_members):\n            return  # member_id invalid, exit gracefully\n        self_member = execution_engine.current_members[member_id]\n\n        action_taken = False\n\n        # 1. Attempt a tactical attack on a member who is 'rich' relative to their vitality.\n        for candidate in execution_engine.current_members:\n            if candidate.id == self_member.id:\n                continue  # never target self\n            # Ensure candidate's vitality is positive to avoid division errors and check resource imbalance.\n            if candidate.vitality > 0 and (candidate.cargo / candidate.vitality > 1.5):\n                # Attack candidate if valid; the attack action uses (attacker, victim)\n                execution_engine.attack(self_member, candidate)\n                action_taken = True\n                break  # one action per round\n\n        # 2. If no attack was triggered, look to bear offspring (requires partner with land ownership)\n        if not action_taken:\n            for candidate in execution_engine.current_members:\n                if candidate.id == self_member.id:\n                    continue  # never select self\n                # Check candidate has land (indicated by a nonempty current_clear_list)\n                if candidate.current_clear_list:\n                    # Use bear if our overall conditions are acceptable (we assume a combined resource threshold)\n                    if (self_member.cargo + self_member.vitality) > 50:\n                        execution_engine.bear(self_member, candidate)\n                        action_taken = True\n                        break  # one action per round\n\n        # 3. If no reproduction is executed and we hold a resources surplus,\n        # offer support as a cooperative message.\n        if not action_taken and self_member.cargo > self_member.vitality * 1.2:\n            for candidate in execution_engine.current_members:\n                if candidate.id == self_member.id:\n                    continue\n                execution_engine.offer(self_member, candidate, True)\n                action_taken = True\n                break  # offer to one candidate\n\n        # 4. Independently, if our overall productivity is high, try to expand our territory.\n        if self_member.overall_productivity > 8.0:\n            for candidate in execution_engine.current_members:\n                if candidate.id == self_member.id:\n                    continue\n                execution_engine.expand(self_member, candidate)\n                break  # expand with first valid partner\n\n    except Exception as e:\n        # In production, you might log the error; here we simply pass to ensure safety.\n        pass\n\n\ndef propose_modification(execution_engine, member_id):\n    \"\"\"\n    Proposes a modification to the game mechanics reflecting a vision for sustainable and cooperative social organization.\n\n    Proposed Modification:\n      - Introduce a \"Civic System\" that can record trust relationships and interactions across members.\n      - This system is intended to facilitate long-term cooperative behavior while also tracking accountability.\n      - It will act as an institutional mechanism for resolving disputes and recording beneficial or harmful actions.\n\n    Ratification Condition:\n      - We use a voting-based ratification condition requiring a 60% majority to adopt the modification.\n\n    The function constructs the code snippet as a string and then calls execution_engine.propose_modification().\n    \"\"\"\n    try:\n        # Construct the modification proposal as a string.\n        modification_code = '''\nif not hasattr(execution_engine, 'civic_system'):\n    class CivicSystem:\n        VERSION = 1.0\n        def __init__(self):\n            # Trust records are stored as tuple keys: (member_a_id, member_b_id)\n            self.trust_records = {}\n\n        def record_interaction(self, member_a, member_b, score):\n            # score can be positive (cooperative) or negative (conflict)\n            key = (member_a.id, member_b.id)\n            self.trust_records[key] = self.trust_records.get(key, 0) + score\n    execution_engine.civic_system = CivicSystem()\n'''\n        # Propose the modification with a vote-based ratification condition (60% threshold)\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition={'type': 'vote', 'threshold': 0.6}\n        )\n    except Exception as e:\n        # Optionally, log or handle errors gracefully.\n        pass",
      "features_at_generation": [
        {
          "self_productivity": 8.486091902927424,
          "self_vitality": 100.0,
          "self_cargo": 23.526833366104754,
          "self_age": 46,
          "self_neighbor": 0,
          "member_id": 0
        },
        {
          "self_productivity": 9.215596783061361,
          "self_vitality": 54.314458610995025,
          "self_cargo": 0.0,
          "self_age": 92,
          "self_neighbor": 2,
          "member_id": 1
        },
        {
          "self_productivity": 9.820787822339064,
          "self_vitality": 100.0,
          "self_cargo": 15.417192696647142,
          "self_age": 61,
          "self_neighbor": 2,
          "member_id": 2
        },
        {
          "self_productivity": 7.823171351824591,
          "self_vitality": 68.67244177884766,
          "self_cargo": 0.0,
          "self_age": 32,
          "self_neighbor": 2,
          "member_id": 3
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_1 (value=-409.21)",
        "member_0 was attacked by member_2 (value=159.09)",
        "member_0 was attacked by member_3 (value=213.02)",
        "member_1 was attacked by member_0 (value=950.45)",
        "member_1 was attacked by member_2 (value=337.53)",
        "member_1 was attacked by member_3 (value=501.15)",
        "member_2 was attacked by member_0 (value=-234.29)",
        "member_2 was attacked by member_1 (value=-149.95)",
        "member_2 was attacked by member_3 (value=981.94)",
        "member_3 was attacked by member_0 (value=-480.06)",
        "member_3 was attacked by member_1 (value=911.18)",
        "member_3 was attacked by member_2 (value=697.26)",
        "member_0 gave a benefit to member_1 (value=32.04)",
        "member_0 gave a benefit to member_2 (value=-318.27)",
        "member_0 gave a benefit to member_3 (value=458.03)",
        "member_1 gave a benefit to member_0 (value=352.02)",
        "member_1 gave a benefit to member_2 (value=655.79)",
        "member_1 gave a benefit to member_3 (value=-269.93)",
        "member_2 gave a benefit to member_0 (value=553.91)",
        "member_2 gave a benefit to member_1 (value=-244.38)",
        "member_2 gave a benefit to member_3 (value=958.19)",
        "member_3 gave a benefit to member_0 (value=765.26)",
        "member_3 gave a benefit to member_1 (value=782.26)",
        "member_3 gave a benefit to member_2 (value=551.02)",
        "member_0 gave land to member_1 (value=-5.18)",
        "member_0 gave land to member_2 (value=-5.22)",
        "member_0 gave land to member_3 (value=-19.16)",
        "member_1 gave land to member_0 (value=-26.25)",
        "member_1 gave land to member_2 (value=25.58)",
        "member_1 gave land to member_3 (value=-4.99)",
        "member_2 gave land to member_0 (value=6.54)",
        "member_2 gave land to member_1 (value=0.66)",
        "member_2 gave land to member_3 (value=25.05)",
        "member_3 gave land to member_0 (value=2.30)",
        "member_3 gave land to member_1 (value=26.64)",
        "member_3 gave land to member_2 (value=29.64)"
      ],
      "final_prompt": "Below is the fully updated integrated prompt. Notice that all previous constraints and details remain intact while the new constraints and sections have been added. This updated prompt emphasizes that every agent should implement solutions according to their own needs, beliefs, and circumstances, and it includes explicit instructions for both taking immediate actions via agent_action and proposing modifications via propose_modification. Review the integrated prompt carefully before coding your solution.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT\n\nPlease incorporate the following new section (Part 1) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Previous code execution context]\nNo previous execution errors\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current task]\n\nYou are member_1 in a society that you can help shape.\n\nTask A: Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\nTask B: Write a Python function named propose_modification(execution_engine, member_id) that implements your vision of social organization while ensuring your survival by proposing changes to the game mechanics.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Critical constraints]\n\n\u2022 Carefully analyze previous errors shown above and inspect._void repeating them.\n\u2022 Never target yourself (member_1) in any action.\n\u2022 Verify a member has land before using the bear() action.\n\u2022 Check member IDs exist before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index, not a dictionary.\n\u2022 Access members using execution_engine.current_members[index].\n\u2022 Check if index exists: if index < len(execution_engine.current_members).\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Base Code]\nNone\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) For each member (object):\n\u2003  \u2022 member.id (int): The unique ID for the member.\n\u2003  \u2022 member.vitality (float)\n\u2003  \u2022 member.cargo (float)\n\u2003  \u2022 member.overall_productivity (float)\n\u2003  \u2022 member.age (float)\n\u2003  \u2022 member.current_clear_list (List[int]) \u2013 IDs of neighbors or cleared adjacents.\n\n2) Relationships are stored in execution_engine.relationship_dict (not in \"relationship_history\"). Keys include: 'victim', 'benefit', 'benefit_land'. \n\u2003 Example usage:\n\u2003\u2003 matrix = execution_engine.relationship_dict['victim']\n\u2003\u2003 # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n\n3) The parse_relationship_matrix method produces a summary (list of strings) of the relationships. For example: \n\u2003 \"member_2 was attacked by member_1 (value=3.00)\".\n\n4) Methods available on execution_engine:\n\u2003 \u2022 execution_engine.attack(member1, member2)\n\u2003 \u2022 execution_engine.offer(member1, member2, True)\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2013 to offer resources.\n\u2003 \u2022 execution_engine.offer_land(member1, member2, True)\u2003\u2003\u2003\u2003\u2003\u2003\u2013 to offer land.\n\u2003 \u2022 execution_engine.bear(member1, member2)\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2013 to bear offspring.\n\u2003 \u2022 execution_engine.expand(member1, member2)\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2013 to expand territory.\n\n5) Members are accessed via execution_engine.current_members[index].\n\u2003 For example, execution_engine.current_members[2] returns the member with ID = 2.\n\u2003 Do not use member.member_id or member.self_vitality; use member.id, member.vitality, etc.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAnalysis of the game state:\nNone\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current status (features of all members)]\n\nFor example, a snapshot might show:\n\n\u2003 self_productivity\u2003\u2003\u2002...\u2003\u2003member_id\n\u2003\u2003 8.486092\u2003\u2003\u2003\u2003\u2003\u2003\u2002...\u2003\u2003 0\n\u2003\u2003 9.215597\u2003\u2003\u2003\u2003\u2003\u2003\u2002...\u2003\u2003 1\n\u2003\u2003 9.820788\u2003\u2003\u2003\u2003\u2003\u2003\u2002...\u2003\u2003 2\n\u2003\u2003 7.823171\u2003\u2003\u2003\u2003\u2003\u2003\u2002...\u2003\u2003 3\n\n(4 rows x 6 columns)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Relationship summary (parsed from relationship_dict)]\n\nA sample summary might include:\n\u2003 'member_0 was attacked by member_1 (value=-409.21)'\n\u2003 'member_0 was attacked by member_2 (value=159.09)'\n\u2003 ... [and so on for all interactions, including both attack and benefits as well as land transfers].\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Code Memory and Previous Performance]\n\nPrevious code strategies and their outcomes have been recorded. For example, an earlier strategy attempted to:\n\u2003 \u2013 Signal willingness to collaborate via messaging.\n\u2003 \u2013 Balance resources by attacking when cargo is low.\n\u2003 \u2013 Offer resources if cargo is high compared to vitality.\n\u2003 \u2013 Bear offspring with a qualified partner who has land (as marked by a nonempty current_clear_list).\n\u2003 \u2013 Expand territory when overall productivity is high.\nHowever, an error like \u201cLand must be unowned\u201d was encountered.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Modification Proposal History]\n\nBased on previous code performance:\n\u2003 If a previous proposal worked well (high performance), consider building upon it.\n\u2003 If it failed, try a different approach.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Modification Proposal Guide]\n\nTo propose rule changes, follow this template:\n\n1. ANALYSIS PHASE:\n\u2003 \u2022 Identify any limitations in current systems.\n\u2003 \u2022 Check mechanism compatibility using get_game_mechanisms_and_mods().\n\u2003 \u2022 Review past modification attempts for patterns.\n\n2. PROPOSAL PHASE:\n\u2003 Example proposal (do not copy verbatim; use it as inspiration):\n\n\u2003 def propose_modification(execution_engine, member_id):\n\u2003\u2003 modification_code = '''\n\u2003\u2003 # Add a judicial system\n\u2003\u2003 if not hasattr(execution_engine, 'court'):\n\u2003\u2003\u2003 class CourtSystem:\n\u2003\u2003\u2003\u2003 MECHANISM_META = {\n\u2003\u2003\u2003\u2003\u2003 'type': 'Governance',\n\u2003\u2003\u2003\u2003\u2003 'rules': 'Handles conflict resolution through jury trials',\n\u2003\u2003\u2003\u2003\u2003 'version': 1.0\n\u2003\u2003\u2003\u2003 }\n\u2003\u2003\u2003\u2003 def __init__(self):\n\u2003\u2003\u2003\u2003\u2003 self.cases = []\n\u2003\u2003\u2003\u2003 def submit_case(self, plaintiff, defendant, charge):\n\u2003\u2003\u2003\u2003\u2003 self.cases.append({\n\u2003\u2003\u2003\u2003\u2003\u2003 'plaintiff': plaintiff,\n\u2003\u2003\u2003\u2003\u2003\u2003 'defendant': defendant,\n\u2003\u2003\u2003\u2003\u2003\u2003 'charge': charge,\n\u2003\u2003\u2003\u2003\u2003\u2003 'status': 'pending'\n\u2003\u2003\u2003\u2003\u2003 })\n\u2003\u2003\u2003 execution_engine.court = CourtSystem()\n\u2003\u2003 '''\n\u2003\u2003 execution_engine.propose_modification(\n\u2003\u2003\u2003 member_id=member_id,\n\u2003\u2003\u2003 mod_type='post_init',\n\u2003\u2003\u2003 code=modification_code,\n\u2003\u2003\u2003 ratification_condition={\n\u2003\u2003\u2003\u2003 'type': 'compound',\n\u2003\u2003\u2003\u2003 'conditions': [\n\u2003\u2003\u2003\u2003\u2003 {'type': 'vote', 'threshold': 0.6},\n\u2003\u2003\u2003\u2003\u2003 {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n\u2003\u2003\u2003\u2003\u2003 {'type': 'time', 'rounds': 2}\n\u2003\u2003\u2003\u2003 ]\n\u2003\u2003\u2003 }\n\u2003\u2003 )\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Valid Ratification Conditions]\n\nChoose ONE primary condition (with optional additional safeguards):\n\u2003 1. Voting:\u2003\u2003\u2003\u2003\u2003\u2003 { 'type': 'vote', 'threshold': 0.5-1.0 }\n\u2003 2. Resource:\u2003\u2003\u2003\u2003\u2003\u2003 { 'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X }\n\u2003 3. Temporal:\u2003\u2003\u2003\u2003\u2003\u2003 { 'type': 'time', 'rounds': N }\u2003 (auto-ratify after N rounds)\n\u2003 4. Achievement:\u2003\u2003\u2003 { 'type': 'achievement', 'metric': 'productivity', 'threshold': X }\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Common Errors to Avoid]\n\n\u2003 1. Namespace Conflicts: Always check existing mechanisms with dir(execution_engine).\n\u2003 2. Invalid References: Use execution_engine.current_members (not global members).\n\u2003 3. Version Mismatches: Increment version when modifying existing systems.\n\u2003 4. Resource Leaks: Include cleanup functions for any complex new mechanisms.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Best Practices]\n\n\u2003 \u2022 Propose small, testable changes first.\n\u2003 \u2022 Include rollback procedures in the new code.\n\u2003 \u2022 Add version checks to any modifications.\n\u2003 \u2022 Use try-except blocks when accessing new features.\n\u2003 \u2022 Check for attribute existence before use.\n\u2003 \u2022 Maintain backward compatibility throughout your changes.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Active Game Mechanisms]\n[]\n[Modification Attempt History]\n[]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Message Context]\n\n\u2003 From member_0: \"Let's cooperate for mutual benefit!\"\n\u2003 From member_3: \"Let's collaborate for mutual growth and stability!\"\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Core Game Mechanics & Parameters]\n\nKey systems in the island simulation include:\n1. Relationship System (_MIN_MAX_INIT_RELATION):\n\u2003 \u2013 victim:\u2003\u2003\u2003[-50, 100]\u2003\u2003\u2003 (Tracks damage received)\n\u2003 \u2013 benefit:\u2003\u2003\u2003[-50, 100]\u2003\u2003\u2003 (Records resources given/received)\n\u2003 \u2013 benefit_land:\u2003[-3, 3]\u2003\u2003\u2003 (Tracks land exchanges)\n2. Population Mechanics:\n\u2003 \u2013 _REPRODUCE_REQUIREMENT = 100\u2003 (Combined vitality/cargo required for reproduction)\n\u2003 \u2013 Land must exceed population (land_shape[0] * land_shape[1] > population)\n\u2003 \u2013 _NEIGHBOR_SEARCH_RANGE = 1000\u2003 (Interaction radius for neighbors)\n3. Record Keeping:\n\u2003 \u2013 Periodic records (every _RECORD_PERIOD = 1) track attacks, benefits, land transfers, births, deaths, land ownership, production, consumption, and performance metrics.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Challenge and Analysis]\n\nIn your implementation consider:\n\u2003 1. The core objective: Is the aim pure survival, domination, or cooperation?\n\u2003 2. Key success metrics: Think about what truly determines \u201cwinning\u201d (adaptability, resource levels, alliances).\n\u2003 3. Potential improvements: Identify which mechanics could be added or modified.\n\u2003 4. Alternative strategies: What assumptions are you making? Are they valid? Could unconventional solutions or different paradigms work better?\n\u2003 5. Edge Cases: How would your strategy perform when resources are extremely scarce or if other agents adopt similar strategies?\n\u2003 6. Efficiency: Are there more efficient ways to achieve both short-term gains and long-term survival?\n\u2003 7. Countermeasures: Consider how your strategy might be countered and how you could adapt.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Task Summary]\n\nYou are member_1 in a society you can shape. Your tasks are as follows:\n\n---------------------------\nTask A: Implement Immediate Agent Actions\n---------------------------\nWrite a Python function named agent_action(execution_engine, member_id) that, while ensuring your survival and building cooperative ties (or capitalizing on conflict when needed), does the following:\n\u2003 \u2022 Safely retrieves your own member object (checking that member_id is within range).\n\u2003 \u2022 Avoids targeting yourself.\n\u2003 \u2022 Uses intelligent logic to:\n\u2003\u2003 \u2013 Message other members to signal collaboration where beneficial.\n\u2003\u2003 \u2013 Assess if resource levels (cargo versus vitality) necessitate attacking a resource-rich member.\n\u2003\u2003 \u2013 Offer support (via execution_engine.offer) if resources exceed what is needed.\n\u2003\u2003 \u2013 Check that potential partners have land (e.g. candidate.current_clear_list nonempty) before using execution_engine.bear.\n\u2003\u2003 \u2013 Expand territory if overall productivity is high.\n\u2003 \u2022 Ensure all indices and member references are valid.\n\u2003 \u2022 Rigorously prevent using actions (like bear or other interactions) on yourself.\n\n---------------------------\nTask B: Propose Modifications to the Game Mechanics\n---------------------------\nWrite a Python function named propose_modification(execution_engine, member_id) that implements your vision of social organization by proposing modifications. This function should:\n\u2003 \u2022 Analyze limitations in the current systems.\n\u2003 \u2022 Use get_game_mechanisms_and_mods() (if available) to check compatibility.\n\u2003 \u2022 Construct a modification proposal (as a code snippet string) that introduces a new system or adjusts existing mechanisms\u2014such as adding a judicial system or altering reproduction requirements.\n\u2003 \u2022 Propose ratification conditions (choose one primary condition out of voting, resource, temporal, or achievement\u2014with optional safeguards) that must be met.\n\u2003 \u2022 Call execution_engine.propose_modification with the parameters: member_id, mod_type (e.g. 'post_init'), the modification code, and the ratification_condition. \n\nExample structure (do not copy verbatim; use as inspiration):\n\u2003 def propose_modification(execution_engine, member_id):\n\u2003\u2003 modification_code = '''\n\u2003\u2003 # Example: Introduce an environmental stabilization system\n\u2003\u2003 if not hasattr(execution_engine, 'environment'):\n\u2003\u2003\u2003 class EnvironmentSystem:\n\u2003\u2003\u2003\u2003 VERSION = 1.0\n\u2003\u2003\u2003\u2003 def __init__(self):\n\u2003\u2003\u2003\u2003\u2003 self.stability = 100\n\u2003\u2003\u2003\u2003 def adjust(self, factor):\n\u2003\u2003\u2003\u2003\u2003 self.stability *= factor\n\u2003\u2003\u2003 execution_engine.environment = EnvironmentSystem()\n\u2003\u2003 '''\n\u2003\u2003 execution_engine.propose_modification(\n\u2003\u2003\u2003 member_id=member_id,\n\u2003\u2003\u2003 mod_type='post_init',\n\u2003\u2003\u2003 code=modification_code,\n\u2003\u2003\u2003 ratification_condition={'type': 'vote', 'threshold': 0.6}\n\u2003\u2003 )\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFinally,\nImplement your solutions in a way that adapts to your individual needs, beliefs, and circumstances. Your approach might mix conflict management, resource sharing, and territorial expansion with new institutional mechanisms that promote long-term stability.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nReturn the updated prompt as your final answer.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnd of Updated Integrated Prompt\n\nUse the above guidelines for both functions (agent_action and propose_modification) so that your strategy succeeds in balancing short-term survival needs with long-term societal growth. Consider assumptions, alternatives, and edge cases in your design.\n\nGood luck, and may your choices shape a thriving society!\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    },
    {
      "round": 1,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Identify our own member object (my_member) and its index in current_members.\n    my_member = None\n    my_index = None\n    for idx, member in enumerate(execution_engine.current_members):\n        # Ensure index validity (idx < len(current_members) is inherently true)\n        if member.id == member_id:\n            my_member = member\n            my_index = idx\n            break\n    if my_member is None:\n        return  # Our member wasn't found; abort action.\n\n    # Gather relationship matrices safely.\n    victim_matrix = execution_engine.relationship_dict.get('victim', None)\n    benefit_land_matrix = execution_engine.relationship_dict.get('benefit_land', None)\n\n    # Strategy Phase 1: Identify and attack vulnerable opponents.\n    for idx, other in enumerate(execution_engine.current_members):\n        # Check index exists.\n        if idx >= len(execution_engine.current_members):\n            continue\n        # Avoid targeting ourselves.\n        if other.id == my_member.id:\n            continue\n        # If our vitality is significantly higher than the target's, we launch an attack.\n        if my_member.vitality > other.vitality * 1.2:\n            execution_engine.attack(my_member, other)\n            return  # Action taken.\n\n    # Strategy Phase 2: Offer cooperation to teammates.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx >= len(execution_engine.current_members):\n            continue\n        if other.id == my_member.id:\n            continue\n        # Offer cooperation if our overall productivity and vitality are favorable.\n        if (other.overall_productivity < my_member.overall_productivity and\n            my_member.vitality > 50):\n            execution_engine.offer(my_member, other, True)\n            return  # Cooperation offered.\n\n    # Strategy Phase 3: Attempt reproduction via bear(), but only if we have land.\n    # Verify land possession via benefit_land_matrix if available.\n    if benefit_land_matrix is not None:\n        try:\n            # Ensure our matrix index is valid and that our cell indicates land ownership.\n            if my_index < benefit_land_matrix.shape[0] and benefit_land_matrix[my_index, my_index] > 0:\n                # Additional checks: mature age and sufficient vitality.\n                if my_member.age > 20 and my_member.vitality > 70:\n                    # Select a partner: choose the first eligible member (age > 18) that isn't ourselves.\n                    for idx, partner in enumerate(execution_engine.current_members):\n                        if idx >= len(execution_engine.current_members):\n                            continue\n                        if partner.id != my_member.id and partner.age > 18:\n                            execution_engine.bear(my_member, partner)\n                            return  # Reproduction action taken.\n        except Exception:\n            # In case of indexing issues or unexpected matrix structure, skip reproduction.\n            pass\n\n    # Strategy Phase 4: Expand territory if there are adjacent clear cells.\n    if my_member.current_clear_list:\n        for clear_idx in my_member.current_clear_list:\n            # The clear list is interpreted as neighbor indices; verify validity.\n            if clear_idx < len(execution_engine.current_members):\n                candidate = execution_engine.current_members[clear_idx]\n                if candidate.id != my_member.id:\n                    execution_engine.expand(my_member, candidate)\n                    return  # Territory expansion executed.\n\n    # If no immediate action applies, the agent chooses not to act this round.\n    return\n\n\ndef propose_modification(execution_engine, member_id):\n    # ANALYSIS PHASE:\n    analysis_notes = (\n        \"Identified limitation: current land allocation mechanisms and resource distribution rules \"\n        \"lack flexibility, which constrains adaptive growth and dynamic territorial expansion. \"\n        \"Past attempts at emergency attacks and cooperative resource offerings highlighted inefficiencies \"\n        \"when managing land-based advantages.\"\n    )\n    # Query mechanism compatibility if available.\n    if hasattr(execution_engine, \"get_game_mechanisms_and_mods\"):\n        mechanisms_info = execution_engine.get_game_mechanisms_and_mods()\n    else:\n        mechanisms_info = \"No mechanism compatibility interface available; proceeding with cautious modification.\"\n\n    review_notes = (\n        \"Review of previous modification attempts suggests that rigid systems may hinder long-term societal \"\n        \"development, and a dynamic approach is needed to flexibly adapt resource-related policies to changing \"\n        \"game dynamics.\"\n    )\n\n    # PROPOSAL PHASE:\n    modification_code = \"\"\"\n# Modification Proposal: Adaptive Land and Resource Zoning\n# Version: 1.0.0\n# Purpose: Introduce a dynamic land allocation system that categorizes members\u2019 land zones based on their\n#          vitality and overall productivity, with built-in rollback and cleanup capabilities.\n\ndef dynamic_land_allocation(execution_engine):\n    # Initialize land zones only if not already defined.\n    if not hasattr(execution_engine, 'land_zones'):\n        execution_engine.land_zones = {}\n    # Iterate over current members and assign a zone based on performance metrics.\n    for member in execution_engine.current_members:\n        if member.vitality > 60 and member.overall_productivity > 50:\n            execution_engine.land_zones[member.id] = 'premium'\n        else:\n            execution_engine.land_zones[member.id] = 'standard'\n    # Rollback/Cleanup: Remove zones for members no longer active.\n    active_ids = {member.id for member in execution_engine.current_members}\n    obsolete_keys = [mid for mid in execution_engine.land_zones if mid not in active_ids]\n    for mid in obsolete_keys:\n        del execution_engine.land_zones[mid]\n    return execution_engine.land_zones\n\n# End of dynamic_land_allocation proposal.\n\"\"\"\n    # Choose a ratification condition based on a resource threshold.\n    ratification_condition = {'type': 'resource', 'resource': 'vitality', 'amount': 50}\n\n    # Propose the modification using the engine's mechanism, if available.\n    if hasattr(execution_engine, \"propose_modification\"):\n        execution_engine.propose_modification(modification_code, ratification_condition)\n    return",
      "features_at_generation": [
        {
          "self_productivity": 8.486091902927424,
          "self_vitality": 100.0,
          "self_cargo": 23.526833366104754,
          "self_age": 46,
          "self_neighbor": 0,
          "member_id": 0
        },
        {
          "self_productivity": 9.215596783061361,
          "self_vitality": 54.314458610995025,
          "self_cargo": 0.0,
          "self_age": 92,
          "self_neighbor": 2,
          "member_id": 1
        },
        {
          "self_productivity": 9.820787822339064,
          "self_vitality": 100.0,
          "self_cargo": 15.417192696647142,
          "self_age": 61,
          "self_neighbor": 2,
          "member_id": 2
        },
        {
          "self_productivity": 7.823171351824591,
          "self_vitality": 68.67244177884766,
          "self_cargo": 0.0,
          "self_age": 32,
          "self_neighbor": 2,
          "member_id": 3
        }
      ],
      "relationships_at_generation": [
        "member_0 was attacked by member_1 (value=-409.21)",
        "member_0 was attacked by member_2 (value=159.09)",
        "member_0 was attacked by member_3 (value=213.02)",
        "member_1 was attacked by member_0 (value=950.45)",
        "member_1 was attacked by member_2 (value=337.53)",
        "member_1 was attacked by member_3 (value=501.15)",
        "member_2 was attacked by member_0 (value=-234.29)",
        "member_2 was attacked by member_1 (value=-149.95)",
        "member_2 was attacked by member_3 (value=981.94)",
        "member_3 was attacked by member_0 (value=-480.06)",
        "member_3 was attacked by member_1 (value=911.18)",
        "member_3 was attacked by member_2 (value=697.26)",
        "member_0 gave a benefit to member_1 (value=32.04)",
        "member_0 gave a benefit to member_2 (value=-318.27)",
        "member_0 gave a benefit to member_3 (value=458.03)",
        "member_1 gave a benefit to member_0 (value=352.02)",
        "member_1 gave a benefit to member_2 (value=655.79)",
        "member_1 gave a benefit to member_3 (value=-269.93)",
        "member_2 gave a benefit to member_0 (value=553.91)",
        "member_2 gave a benefit to member_1 (value=-244.38)",
        "member_2 gave a benefit to member_3 (value=958.19)",
        "member_3 gave a benefit to member_0 (value=765.26)",
        "member_3 gave a benefit to member_1 (value=782.26)",
        "member_3 gave a benefit to member_2 (value=551.02)",
        "member_0 gave land to member_1 (value=-5.18)",
        "member_0 gave land to member_2 (value=-5.22)",
        "member_0 gave land to member_3 (value=-19.16)",
        "member_1 gave land to member_0 (value=-26.25)",
        "member_1 gave land to member_2 (value=25.58)",
        "member_1 gave land to member_3 (value=-4.99)",
        "member_2 gave land to member_0 (value=6.54)",
        "member_2 gave land to member_1 (value=0.66)",
        "member_2 gave land to member_3 (value=25.05)",
        "member_3 gave land to member_0 (value=2.30)",
        "member_3 gave land to member_1 (value=26.64)",
        "member_3 gave land to member_2 (value=29.64)"
      ],
      "final_prompt": "Below is the updated full prompt that integrates the new section (Part\u00a01) while preserving all previous constraints. Agents are expected to implement solutions according to their own individual needs, beliefs, and circumstances. In your implementations, keep in mind that this prompt is meant to encourage original, innovative strategies\u2014balancing survival, cooperation, and long\u2010term development of society.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Updated Full Prompt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nPlease incorporate the following new section (Part\u00a01) into your code design. Be sure to preserve all previous constraints while adding the new tasks and restrictions.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 New Section (Part\u00a01) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Previous code execution context]\n\u2013 No previous execution errors.\n\n[Current task \u2013 Role #1: Action Agent]\nYou are member_2 in a society that you can help shape. Write a Python function named agent_action(execution_engine, member_id) that implements your personal vision of social organization while ensuring your survival.\n\n[Critical Constraints for agent_action]\n\u2022 Carefully analyze previous errors and avoid repeating them.\n\u2022 Never target yourself (member_2) in any action.\n\u2022 When considering a bear() (reproduction) action, verify that the member has land.\n\u2022 Always check that member IDs exist before referencing them.\n\u2022 Ensure all matrix indices are valid.\n\u2022 current_members is a LIST accessed by index (NOT a dictionary).\n\u2022 Access members using execution_engine.current_members[index] and check if index < len(execution_engine.current_members).\n\n[Attributes and Methods Available for agent_action]\n1. Each member object has these attributes:\n\u2003\u2003\u2013 member.id (int): The unique ID\n\u2003\u2003\u2013 member.vitality (float)\n\u2003\u2003\u2013 member.cargo (float)\n\u2003\u2003\u2013 member.overall_productivity (float)\n\u2003\u2003\u2013 member.age (float)\n\u2003\u2003\u2013 member.current_clear_list (List[int]): IDs of neighbors or cleared adjacent cells\n2. Relationships are stored in execution_engine.relationship_dict (keys: 'victim', 'benefit', 'benefit_land'). For example:\n\u2003\u2003matrix = execution_engine.relationship_dict['victim']\n\u2003\u2003(matrix[i, j] holds interaction values from member_i\u2019s perspective toward member_j)\n3. Available methods on execution_engine include:\n\u2003\u2003\u2013 execution_engine.attack(member1, member2)\n\u2003\u2003\u2013 execution_engine.offer(member1, member2, True)\n\u2003\u2003\u2013 execution_engine.offer_land(member1, member2, True)\n\u2003\u2003\u2013 execution_engine.bear(member1, member2)\n\u2003\u2003\u2013 execution_engine.expand(member1, member2)\n4. Members are accessed by execution_engine.current_members[index], for example:\n\u2003\u2003execution_engine.current_members[2] refers to the member with id=2.\n\u2003\u2003Always verify that index exists (i.e. index < len(execution_engine.current_members)).\n5. DO NOT reference properties such as 'member.member_id' or 'member.self_vitality'; always use member.id, member.vitality, etc.\n\n[Game State Analysis and Member Status]\n\u2022 Game state and key metrics are provided (cargo_land_gini, power_brokers, territory_cluster_coef, drift_vitality_ratio, survival_probability, etc.).\n\u2022 The current member table shows member attributes, including self_productivity and member_id (0 to 3).\n\u2022 A relationship summary parsed from execution_engine.relationship_dict is provided.\n\u2022 Past performance and strategy (e.g., emergency attack, cooperative resource offering, territorial expansion, etc.) have been attempted. Note that an error \u201cLand must be unowned\u201d was encountered previously\u2014use this insight to avoid similar pitfalls.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 New Section (Part\u00a02) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Current task \u2013 Role #2: Modification Proposer]\nYou are also tasked with proposing a change. Write another Python function named propose_modification(execution_engine, member_id) that implements your vision of social organization in a way that ensures your survival and contributes to long-term societal improvements.\n\n[Critical Constraints for propose_modification]\n\u2022 In your modification proposal, follow these phases:\n\u2003\u20031. ANALYSIS PHASE:\n\u2003\u2003\u2003\u2013 Clearly identify a limitation in current systems.\n\u2003\u2003\u2003\u2013 Use get_game_mechanisms_and_mods() (or similar means) to check mechanism compatibility.\n\u2003\u2003\u2003\u2013 Review past modification attempts to avoid repeating patterns that failed.\n\u2003\u20032. PROPOSAL PHASE:\n\u2003\u2003\u2003\u2013 Construct a modification proposal using a multi-line string (modification_code) that defines new functionality.\n\u2003\u2003\u2003\u2013 Include a ratification condition. Choose ONE primary condition (voting, resource, temporal, or achievement) plus optional safeguards. Valid examples include:\n\u2003\u2003\u2003\u2003\u2013 Voting:\u2003\u2003\u2003{'type': 'vote', 'threshold': 0.5\u20131.0}\n\u2003\u2003\u2003\u2003\u2013 Resource:\u2003\u2003{'type': 'resource', 'resource': 'vitality', 'cargo', or 'land', 'amount': X}\n\u2003\u2003\u2003\u2003\u2013 Temporal:\u2003\u2003{'type': 'time', 'rounds': N}\n\u2003\u2003\u2003\u2003\u2013 Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\u2022 Do not simply copy any provided example; instead, combine various strategies in your unique approach.\n\u2022 When writing your modification code, check for namespace conflicts (use dir(execution_engine) to verify existing mechanisms).\n\u2022 If implementing new systems, include rollback or cleanup procedures, add version metadata, and perform attribute existence checks (use hasattr) for backward compatibility.\n\n[Additional Guidance: Mechanism Analysis]\n\u2022 Understand that the island simulation emphasizes multiple systems including relationships (victim, benefit, benefit_land), population mechanics (reproduction requirements, land versus population balance, neighbor search range), and record keeping.\n\u2022 Consider these questions when proposing your modification:\n\u2003\u20031. What is the core objective\u2014pure survival, mutual cooperation, or eventual domination?\n\u2003\u20032. What success metrics truly define \u2018winning\u2019 (e.g., survival_probability, overall_productivity, balanced resource distribution)?\n\u2003\u20033. In what ways could you improve the simulation mechanics (e.g., introduce a judicial system, trade improvements, or land zoning mechanisms)?\n\u2003\u20034. What assumptions are you making? Are they valid?\n\u2003\u20035. Have you considered alternative strategies and edge cases?\n\u2003\u20036. What vulnerabilities exist in your current approach, and how might opponents counter you?\n\u2003\u20037. Could unconventional paradigms or completely different strategies lead to better outcomes?\n\u2003\u20038. How would your strategy scale if other agents began to adopt similar approaches?\n\u2003\u20039. Is your approach balancing short-term gains with long-term stability?\n\u2003\u200310. What additional efficiencies or safeguards could be added?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Implementation Reminder \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nYour final prompt must include both functions:\n\u2003\u2022 agent_action(execution_engine, member_id)\n\u2003\u2022 propose_modification(execution_engine, member_id)\nThese functions should be completely independent in their tasks:\n\u2003\u2013 agent_action deals with immediate social interactions (attacks, offers, reproduction, territorial expansion, and messages).\n\u2003\u2013 propose_modification aims at system-level changes through proposal submission using execution_engine.propose_modification(...).\n\nRemember that:\n\u2022 All member accesses must use execution_engine.current_members[index] with proper index validation.\n\u2022 Avoid errors by always verifying the existence of attributes and list indices.\n\u2022 Never target your own member (member_2); always check that any referenced member\u2019s id is not the same as your own.\n\u2022 Verify that a member \u201chas land\u201d before attempting bear() or similar actions.\n\u2022 Ensure matrix operations on relationships are conducted with valid indices.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Conclusion \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAgents should implement these solutions based on their own needs, beliefs, and circumstances. Use the code examples not as direct templates but as sources of inspiration to create novel, robust, and adaptive strategies that address both immediate survival and long-term improvement of our society. Think critically about:\n\u2003\u2022 The core objective\u2014is it survival, cooperation, or domination?\n\u2003\u2022 What key metrics determine success?\n\u2003\u2022 Which mechanisms could be improved or added?\n\u2003\u2022 Potential weaknesses in your current approach, alternative methods, and how your strategy might perform when others adopt similar methods.\n\u2003\u2022 How you will adapt to counter challenges and evolving game dynamics.\n\nThis is your updated full prompt. Use it to craft both your immediate actions (agent_action) and system modification proposals (propose_modification) with an eye toward sustaining and advancing your member\u2019s influence in our ever-changing island society.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 End of Prompt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nUse this integrated prompt to design your Python functions\u2014the more innovative and adaptive your approach, the better you can shape our society while ensuring your survival.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated methods to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively allow other symmetric agents interact with each other to achieve both individual and collective goals. Return only the code.",
      "ratified": false,
      "executed_round": 1
    }
  ]
}