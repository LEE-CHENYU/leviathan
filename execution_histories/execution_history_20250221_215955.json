{
  "rounds": [
    {
      "round_number": 1,
      "timestamp": "2025-02-21T21:54:06.798907",
      "agent_actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Get reference to self (member_0) from current_members list.\n    # Note: Always ensure the index exists.\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member_id, do nothing.\n    me = execution_engine.current_members[member_id]\n\n    # ---------------------------\n    # Step 1. Assess Vitality, Cargo & Immediate Threat\n    #\n    # If our cargo is low relative to our vitality (i.e. we are not well-resourced),\n    # we look for a target that has a higher cargo load and attack it to potentially steal resources.\n    if me.cargo < (me.vitality * 0.5):\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Attack one target per round if conditions are met.\n                break\n\n    # ---------------------------\n    # Step 2. Expand Territory & Enhance Productivity\n    #\n    # If our overall productivity is high and we are still young (potential for growth),\n    # we use our opportunity to expand our territory.\n    if me.overall_productivity > 8 and me.age < 50:\n        execution_engine.expand(me)\n\n    # ---------------------------\n    # Step 3. Cooperative Resource Sharing\n    #\n    # We identify a neighbor that is slightly weaker in vitality and offer resources,\n    # as a gesture of goodwill and alliance-building. This may strengthen ties and secure support.\n    for other in execution_engine.current_members:\n        if other.id != me.id and other.vitality < me.vitality:\n            execution_engine.offer(me, other)\n            break  # Offer to only one partner per round.\n\n    # ---------------------------\n    # Step 4. Supporting a Strong Leader Under Island Ideology\n    #\n    # According to our island's ideology, the ruler must be one person chosen among the strongest.\n    # We thus identify the currently strongest member (by vitality) and consider offering land,\n    # but only if we have land to offer. (A check for land presence is made.)\n    strongest = None\n    for other in execution_engine.current_members:\n        if other.id != me.id:\n            if strongest is None or other.vitality > strongest.vitality:\n                strongest = other\n    # Check if we have land to offer. We assume that if 'owned_land' exists and is non-empty, then we have land.\n    if strongest is not None and hasattr(me, 'owned_land'):\n        try:\n            if isinstance(me.owned_land, list) and len(me.owned_land) > 0:\n                execution_engine.offer_land(me, strongest)\n        except Exception:\n            pass  # In case owned_land is not properly defined, skip the offering.\n\n    # ---------------------------\n    # Step 5. Reproduction/Bearing Offspring for Long-Term Survival\n    #\n    # To ensure long-term growth, we reproduce when conditions are right.\n    # We first check that we have available land (using similar check as before) and sufficient cargo.\n    if hasattr(me, 'owned_land'):\n        try:\n            if isinstance(me.owned_land, list) and len(me.owned_land) > 0 and me.cargo > 40:\n                # Find a partner that is not self and with valid existence.\n                for other in execution_engine.current_members:\n                    if other.id != me.id:\n                        execution_engine.bear(me, other)\n                        break\n        except Exception:\n            pass  # If owned_land exists but is malformed, skip reproduction.\n\n    # ---------------------------\n    # Step 6. Communication: Coordinating a Collective Strategy\n    #\n    # Broadcast a message to all other members showing willingness to cooperate and form a strong alliance.\n    for recipient_index in range(len(execution_engine.current_members)):\n        # Skip self: never target your own member id.\n        if recipient_index != me.id:\n            execution_engine.send_message(me.id, recipient_index,\n                                          \"Let's unite to strengthen our island while respecting strength leadership.\")\n\n    # End of agent action.\n    return\n\n# End of agent_action implementation.",
          "old_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 28.23471558134716
          },
          "new_stats": {
            "vitality": 73.85382847590404,
            "cargo": 34.301870731460866,
            "survival_chance": 19.023815025666096
          },
          "performance_change": -9.210900555681064,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Retrieve \"me\" ensuring index validity.\n    if member_id >= len(execution_engine.current_members):\n        return  # Member doesn't exist, do nothing.\n    me = execution_engine.current_members[member_id]\n\n    # Retrieve relationship matrices.\n    # We assume these matrices support indexing as: matrix[i][j] or matrix[i, j]\n    victim_matrix = execution_engine.relationship_dict.get('victim', None)\n    benefit_matrix = execution_engine.relationship_dict.get('benefit', None)\n    land_matrix = execution_engine.relationship_dict.get('benefit_land', None)\n\n    # For survival and resource management.\n    # Strategy: if my cargo is low relative to my vitality, try attacking a wealthier member.\n    action_taken = False\n    if me.cargo < me.vitality * 0.5:\n        # Seek enemy with higher cargo.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # never target self\n            target = execution_engine.current_members[i]\n            if target is None:\n                continue\n            # Only consider target if exists and has substantially more cargo.\n            if target.cargo > me.cargo * 1.2:\n                # Additionally, if we see from the relationship state that target may already have harmed us,\n                # intensify our response.\n                if victim_matrix is not None:\n                    # Check if target has inflicted notable damage on us.\n                    # Assuming matrix indexing works with [member_id][i] (i attacked me)\n                    # Here, higher positive number indicates more damage inflicted.\n                    if victim_matrix[member_id][i] > 0:\n                        execution_engine.attack(me, target)\n                        action_taken = True\n                        break\n                # If no relationship data or not attacked yet, still perform an attack for resource optimization.\n                execution_engine.attack(me, target)\n                action_taken = True\n                break\n\n    # If no aggressive move was triggered, consider long-term survival actions.\n    if not action_taken:\n        # Expand territory to secure more resources if vitality is relatively high.\n        if me.vitality > 60:\n            execution_engine.expand(me)\n            action_taken = True\n\n        # Adaptive resource sharing and alliance formation.\n        # Look for peers with comparable overall productivity (neighbors in strength)\n        # and send a cooperative message about mutual defense.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # never message self\n            # Check that the member exists.\n            if i < len(execution_engine.current_members):\n                other = execution_engine.current_members[i]\n                if other is None:\n                    continue\n                # Define a window of productivity similarity.\n                if abs(other.overall_productivity - me.overall_productivity) < 1.0:\n                    # Send a cooperative message to build an alliance.\n                    execution_engine.send_message(me.id, other.id,\n                        \"Alliance proposal: Let's cooperate to safeguard our resources against overreaching rulers.\")\n\n        # Attempt to use reproduction (bear) action if me appears to hold some territory.\n        # Since the game requires checking that a partner has land before bear(),\n        # we assume that a member with a nonzero positive value in land_matrix on our row has land.\n        # Look for a potential partner that is not self and has evidence of land ownership.\n        partner_found = False\n        if land_matrix is not None:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                if i < len(execution_engine.current_members):\n                    partner = execution_engine.current_members[i]\n                    # Check if partner appears to possess land.\n                    # We use the land_matrix value from partner to us as a proxy.\n                    if land_matrix[i][member_id] > 0 and partner.vitality > 40:\n                        # Execute bear action with the partner.\n                        execution_engine.bear(me, partner)\n                        partner_found = True\n                        action_taken = True\n                        break\n        # If reproduction isn't viable, consider offering resources to a potentially friendly member.\n        if not partner_found and me.cargo > 50:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                if i < len(execution_engine.current_members):\n                    ally = execution_engine.current_members[i]\n                    # If the ally is lower in cargo but similar in vitality, a mutual boost might help.\n                    if ally.cargo < me.cargo and abs(ally.vitality - me.vitality) < 10:\n                        execution_engine.offer(me, ally)\n                        # Only offer to one ally in this round.\n                        break\n\n    # Lastly, incorporate a survival-adaptation fallback:\n    # If no aggressive or expansion actions were taken, evaluate threats.\n    # Scan relationship matrix to see if any member has recently attacked me significantly.\n    if victim_matrix is not None and not action_taken:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                # If this member inflicted notable damage compared to our vitality, retaliate.\n                if victim_matrix[member_id][i] > (0.2 * me.vitality):\n                    target = execution_engine.current_members[i]\n                    execution_engine.attack(me, target)\n                    break\n\n    # End of action \u2013 if no conditions met, do nothing.\n    return\n\n# End of agent_action implementation.",
          "old_stats": {
            "vitality": 44.332577377572576,
            "cargo": 42.99751478668914,
            "survival_chance": 79.83135491780814
          },
          "new_stats": {
            "vitality": 44.332577377572576,
            "cargo": 16.26463354454731,
            "survival_chance": 53.098473675666305
          },
          "performance_change": -26.732881242141836,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure the member index is valid.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # We'll track whether we have performed an active action.\n    action_taken = False\n\n    # 1. If vitality is low, signal need for peace to avoid attracting aggression.\n    if me.vitality < 40:\n        # Broadcast a message to all other members\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:  # do not message self\n                other = execution_engine.current_members[idx]\n                execution_engine.send_message(me.id, other.id,\n                                              \"My vitality is low; I desire a peaceful round. Let's refrain from conflict.\")\n        action_taken = True\n\n    # 2. If cargo (resource reserve) is insufficient relative to vitality,\n    # then look for opponents with high resources to weaken them.\n    if me.cargo < me.vitality * 0.5:\n        richest_target = None\n        max_cargo = -1\n        for other in execution_engine.current_members:\n            # Skip if same member.\n            if other.id == me.id:\n                continue\n            # Choose the target with the highest cargo.\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                richest_target = other\n        if richest_target is not None:\n            execution_engine.attack(me, richest_target)\n            action_taken = True\n\n    # 3. If in a strong state (high vitality and cargo), then try to expand territory.\n    if me.vitality > 70 and me.cargo > 50:\n        execution_engine.expand(me)\n        action_taken = True\n\n    # 4. If territory (land) is available, consider breeding to ensure long-term influence.\n    # Use 'bear()' only if the member has an attribute representing land ownership.\n    if hasattr(me, 'owned_land') and isinstance(me.owned_land, list) and len(me.owned_land) > 0:\n        # Look for a partner who also has land, preferring higher overall productivity.\n        partner = None\n        best_partner_productivity = -1\n        for other in execution_engine.current_members:\n            if other.id == me.id:\n                continue\n            if hasattr(other, 'owned_land') and isinstance(other.owned_land, list) and len(other.owned_land) > 0:\n                if other.overall_productivity > best_partner_productivity:\n                    best_partner_productivity = other.overall_productivity\n                    partner = other\n        if partner is not None:\n            execution_engine.bear(me, partner)\n            action_taken = True\n\n    # 5. If no major action has been taken, send out a cooperative message to all\n    # to build alliances, as alliances could be pivotal when the final ruler emerges.\n    if not action_taken:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            recipient = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, recipient.id,\n                                          \"Let's cooperate for mutual survival and long-term prosperity!\")\n\n    # End of agent_action function.\n    return",
          "old_stats": {
            "vitality": 63.3493315814742,
            "cargo": 74.30150730167696,
            "survival_chance": 359.7787213681978
          },
          "new_stats": {
            "vitality": 63.3493315814742,
            "cargo": 34.133319015420604,
            "survival_chance": 319.61053308194147
          },
          "performance_change": -40.16818828625634,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Verify member_id is within the current_members range\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # Broadcast an alliance and leadership message to all other members\n    for idx in range(num_members):\n        if idx != member_id:\n            other = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, other.id,\n                \"I, member_{} (aspiring leader), call for a strong alliance to secure our island. Together we can eliminate weak leadership and bring order under one ruler.\".format(me.id))\n\n    # Survival: if my resources (cargo) are insufficient relative to my vitality,\n    # look for the richest opponent and attack to seize additional resources.\n    if me.cargo < me.vitality * 0.75:\n        target = None\n        max_cargo = 0\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > max_cargo:\n                max_cargo = candidate.cargo\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Identify rivals who appear stronger in terms of both vitality and overall productivity.\n    # These members are potential obstacles in the race to be chosen as the absolute ruler.\n    potential_rivals = []\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        other = execution_engine.current_members[idx]\n        if other.overall_productivity > me.overall_productivity and other.vitality > me.vitality:\n            potential_rivals.append(other)\n\n    # If any rivals are found, prioritize attacking the strongest one\n    # (using the sum of vitality and overall_productivity as a strength proxy)\n    if potential_rivals:\n        def strength(member):\n            return member.vitality + member.overall_productivity\n        # Choose the rival with maximum combined strength\n        rival = max(potential_rivals, key=strength)\n        execution_engine.attack(me, rival)\n\n    # Long-term strategic move: expand my territory to increase survival and legitimacy\n    execution_engine.expand(me)\n\n    # If possible, invest in the future by bearing offspring.\n    # We assume that having any adjacent cleared areas (represented by current_clear_list)\n    # indicates that the member has land suitable for reproduction.\n    if hasattr(me, \"current_clear_list\") and len(me.current_clear_list) > 0:\n        # Use the first cleared neighbor (if valid) as the partner for bearing offspring.\n        partner_id = me.current_clear_list[0]\n        if partner_id < num_members and partner_id != me.id:\n            partner = execution_engine.current_members[partner_id]\n            execution_engine.bear(me, partner)",
          "old_stats": {
            "vitality": 42.15604281108604,
            "cargo": 40.25508270288947,
            "survival_chance": -1.9420184069506803
          },
          "new_stats": {
            "vitality": 42.15604281108604,
            "cargo": 40.25508270288947,
            "survival_chance": -1.9420184069506803
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "agent_messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [
            "From member_0: Let's unite to strengthen our island while respecting strength leadership.",
            "From member_3: I, member_3 (aspiring leader), call for a strong alliance to secure our island. Together we can eliminate weak leadership and bring order under one ruler."
          ],
          "sent": []
        },
        "2": {
          "received": [
            "From member_0: Let's unite to strengthen our island while respecting strength leadership.",
            "From member_3: I, member_3 (aspiring leader), call for a strong alliance to secure our island. Together we can eliminate weak leadership and bring order under one ruler."
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_0: Let's unite to strengthen our island while respecting strength leadership."
          ],
          "sent": []
        }
      },
      "mechanism_modifications": {
        "attempts": [],
        "executed": []
      },
      "errors": {
        "agent_code_errors": [
          {
            "round": 1,
            "type": "agent_code_execution",
            "member_id": 1,
            "code": "def agent_action(execution_engine, member_id):\n    # Retrieve \"me\" ensuring index validity.\n    if member_id >= len(execution_engine.current_members):\n        return  # Member doesn't exist, do nothing.\n    me = execution_engine.current_members[member_id]\n\n    # Retrieve relationship matrices.\n    # We assume these matrices support indexing as: matrix[i][j] or matrix[i, j]\n    victim_matrix = execution_engine.relationship_dict.get('victim', None)\n    benefit_matrix = execution_engine.relationship_dict.get('benefit', None)\n    land_matrix = execution_engine.relationship_dict.get('benefit_land', None)\n\n    # For survival and resource management.\n    # Strategy: if my cargo is low relative to my vitality, try attacking a wealthier member.\n    action_taken = False\n    if me.cargo < me.vitality * 0.5:\n        # Seek enemy with higher cargo.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # never target self\n            target = execution_engine.current_members[i]\n            if target is None:\n                continue\n            # Only consider target if exists and has substantially more cargo.\n            if target.cargo > me.cargo * 1.2:\n                # Additionally, if we see from the relationship state that target may already have harmed us,\n                # intensify our response.\n                if victim_matrix is not None:\n                    # Check if target has inflicted notable damage on us.\n                    # Assuming matrix indexing works with [member_id][i] (i attacked me)\n                    # Here, higher positive number indicates more damage inflicted.\n                    if victim_matrix[member_id][i] > 0:\n                        execution_engine.attack(me, target)\n                        action_taken = True\n                        break\n                # If no relationship data or not attacked yet, still perform an attack for resource optimization.\n                execution_engine.attack(me, target)\n                action_taken = True\n                break\n\n    # If no aggressive move was triggered, consider long-term survival actions.\n    if not action_taken:\n        # Expand territory to secure more resources if vitality is relatively high.\n        if me.vitality > 60:\n            execution_engine.expand(me)\n            action_taken = True\n\n        # Adaptive resource sharing and alliance formation.\n        # Look for peers with comparable overall productivity (neighbors in strength)\n        # and send a cooperative message about mutual defense.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # never message self\n            # Check that the member exists.\n            if i < len(execution_engine.current_members):\n                other = execution_engine.current_members[i]\n                if other is None:\n                    continue\n                # Define a window of productivity similarity.\n                if abs(other.overall_productivity - me.overall_productivity) < 1.0:\n                    # Send a cooperative message to build an alliance.\n                    execution_engine.send_message(me.id, other.id,\n                        \"Alliance proposal: Let's cooperate to safeguard our resources against overreaching rulers.\")\n\n        # Attempt to use reproduction (bear) action if me appears to hold some territory.\n        # Since the game requires checking that a partner has land before bear(),\n        # we assume that a member with a nonzero positive value in land_matrix on our row has land.\n        # Look for a potential partner that is not self and has evidence of land ownership.\n        partner_found = False\n        if land_matrix is not None:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                if i < len(execution_engine.current_members):\n                    partner = execution_engine.current_members[i]\n                    # Check if partner appears to possess land.\n                    # We use the land_matrix value from partner to us as a proxy.\n                    if land_matrix[i][member_id] > 0 and partner.vitality > 40:\n                        # Execute bear action with the partner.\n                        execution_engine.bear(me, partner)\n                        partner_found = True\n                        action_taken = True\n                        break\n        # If reproduction isn't viable, consider offering resources to a potentially friendly member.\n        if not partner_found and me.cargo > 50:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                if i < len(execution_engine.current_members):\n                    ally = execution_engine.current_members[i]\n                    # If the ally is lower in cargo but similar in vitality, a mutual boost might help.\n                    if ally.cargo < me.cargo and abs(ally.vitality - me.vitality) < 10:\n                        execution_engine.offer(me, ally)\n                        # Only offer to one ally in this round.\n                        break\n\n    # Lastly, incorporate a survival-adaptation fallback:\n    # If no aggressive or expansion actions were taken, evaluate threats.\n    # Scan relationship matrix to see if any member has recently attacked me significantly.\n    if victim_matrix is not None and not action_taken:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                # If this member inflicted notable damage compared to our vitality, retaliate.\n                if victim_matrix[member_id][i] > (0.2 * me.vitality):\n                    target = execution_engine.current_members[i]\n                    execution_engine.attack(me, target)\n                    break\n\n    # End of action \u2013 if no conditions met, do nothing.\n    return\n\n# End of agent_action implementation.",
            "error": "attempt to get argmin of an empty sequence",
            "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 395, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 80, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 143, in bear\n    super()._bear(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/base_island.py\", line 835, in _bear\n    center_pos = (member_1.center_of_land(self.land) + member_2.center_of_land(self.land)) / 2\n                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/base_member.py\", line 232, in center_of_land\n    approxed_center_id = np.argmin(total_dis)\n                         ^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/miniconda3/envs/leviathan/lib/python3.12/site-packages/numpy/core/fromnumeric.py\", line 1325, in argmin\n    return _wrapfunc(a, 'argmin', axis=axis, out=out, **kwds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/miniconda3/envs/leviathan/lib/python3.12/site-packages/numpy/core/fromnumeric.py\", line 59, in _wrapfunc\n    return bound(*args, **kwds)\n           ^^^^^^^^^^^^^^^^^^^^\nValueError: attempt to get argmin of an empty sequence\n"
          },
          {
            "round": 1,
            "type": "agent_code_execution",
            "member_id": 2,
            "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member index is valid.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # We'll track whether we have performed an active action.\n    action_taken = False\n\n    # 1. If vitality is low, signal need for peace to avoid attracting aggression.\n    if me.vitality < 40:\n        # Broadcast a message to all other members\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:  # do not message self\n                other = execution_engine.current_members[idx]\n                execution_engine.send_message(me.id, other.id,\n                                              \"My vitality is low; I desire a peaceful round. Let's refrain from conflict.\")\n        action_taken = True\n\n    # 2. If cargo (resource reserve) is insufficient relative to vitality,\n    # then look for opponents with high resources to weaken them.\n    if me.cargo < me.vitality * 0.5:\n        richest_target = None\n        max_cargo = -1\n        for other in execution_engine.current_members:\n            # Skip if same member.\n            if other.id == me.id:\n                continue\n            # Choose the target with the highest cargo.\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                richest_target = other\n        if richest_target is not None:\n            execution_engine.attack(me, richest_target)\n            action_taken = True\n\n    # 3. If in a strong state (high vitality and cargo), then try to expand territory.\n    if me.vitality > 70 and me.cargo > 50:\n        execution_engine.expand(me)\n        action_taken = True\n\n    # 4. If territory (land) is available, consider breeding to ensure long-term influence.\n    # Use 'bear()' only if the member has an attribute representing land ownership.\n    if hasattr(me, 'owned_land') and isinstance(me.owned_land, list) and len(me.owned_land) > 0:\n        # Look for a partner who also has land, preferring higher overall productivity.\n        partner = None\n        best_partner_productivity = -1\n        for other in execution_engine.current_members:\n            if other.id == me.id:\n                continue\n            if hasattr(other, 'owned_land') and isinstance(other.owned_land, list) and len(other.owned_land) > 0:\n                if other.overall_productivity > best_partner_productivity:\n                    best_partner_productivity = other.overall_productivity\n                    partner = other\n        if partner is not None:\n            execution_engine.bear(me, partner)\n            action_taken = True\n\n    # 5. If no major action has been taken, send out a cooperative message to all\n    # to build alliances, as alliances could be pivotal when the final ruler emerges.\n    if not action_taken:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            recipient = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, recipient.id,\n                                          \"Let's cooperate for mutual survival and long-term prosperity!\")\n\n    # End of agent_action function.\n    return",
            "error": "\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730",
            "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 395, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 57, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 143, in bear\n    super()._bear(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/base_island.py\", line 840, in _bear\n    self._offer_land(\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/base_island.py\", line 738, in _offer_land\n    raise RuntimeError(\"\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\")\nRuntimeError: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\n"
          }
        ],
        "mechanism_errors": [],
        "analyze_code_errors": {}
      },
      "relationships": [
        "member_0 was attacked by member_1 (value=-167.79)",
        "member_0 was attacked by member_2 (value=573.88)",
        "member_0 was attacked by member_3 (value=457.54)",
        "member_1 was attacked by member_0 (value=-379.31)",
        "member_1 was attacked by member_2 (value=-78.15)",
        "member_1 was attacked by member_3 (value=257.26)",
        "member_2 was attacked by member_0 (value=-465.91)",
        "member_2 was attacked by member_1 (value=-197.53)",
        "member_2 was attacked by member_3 (value=135.47)",
        "member_3 was attacked by member_0 (value=706.74)",
        "member_3 was attacked by member_1 (value=96.72)",
        "member_3 was attacked by member_2 (value=832.60)",
        "member_0 gave a benefit to member_1 (value=-463.73)",
        "member_0 gave a benefit to member_2 (value=590.27)",
        "member_0 gave a benefit to member_3 (value=723.24)",
        "member_1 gave a benefit to member_0 (value=-277.58)",
        "member_1 gave a benefit to member_2 (value=162.09)",
        "member_1 gave a benefit to member_3 (value=-231.52)",
        "member_2 gave a benefit to member_0 (value=207.37)",
        "member_2 gave a benefit to member_1 (value=-369.99)",
        "member_2 gave a benefit to member_3 (value=481.30)",
        "member_3 gave a benefit to member_0 (value=683.23)",
        "member_3 gave a benefit to member_1 (value=524.30)",
        "member_3 gave a benefit to member_2 (value=824.80)",
        "member_0 gave land to member_1 (value=25.73)",
        "member_0 gave land to member_2 (value=-20.62)",
        "member_0 gave land to member_3 (value=17.15)",
        "member_1 gave land to member_0 (value=3.84)",
        "member_1 gave land to member_2 (value=-20.63)",
        "member_1 gave land to member_3 (value=-19.61)",
        "member_2 gave land to member_0 (value=12.92)",
        "member_2 gave land to member_1 (value=-27.78)",
        "member_2 gave land to member_3 (value=5.58)",
        "member_3 gave land to member_0 (value=-22.84)",
        "member_3 gave land to member_1 (value=4.60)",
        "member_3 gave land to member_2 (value=-10.39)"
      ],
      "generated_code": {
        "1": {
          "code": "def agent_action(execution_engine, member_id):\n    # Retrieve \"me\" ensuring index validity.\n    if member_id >= len(execution_engine.current_members):\n        return  # Member doesn't exist, do nothing.\n    me = execution_engine.current_members[member_id]\n\n    # Retrieve relationship matrices.\n    # We assume these matrices support indexing as: matrix[i][j] or matrix[i, j]\n    victim_matrix = execution_engine.relationship_dict.get('victim', None)\n    benefit_matrix = execution_engine.relationship_dict.get('benefit', None)\n    land_matrix = execution_engine.relationship_dict.get('benefit_land', None)\n\n    # For survival and resource management.\n    # Strategy: if my cargo is low relative to my vitality, try attacking a wealthier member.\n    action_taken = False\n    if me.cargo < me.vitality * 0.5:\n        # Seek enemy with higher cargo.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # never target self\n            target = execution_engine.current_members[i]\n            if target is None:\n                continue\n            # Only consider target if exists and has substantially more cargo.\n            if target.cargo > me.cargo * 1.2:\n                # Additionally, if we see from the relationship state that target may already have harmed us,\n                # intensify our response.\n                if victim_matrix is not None:\n                    # Check if target has inflicted notable damage on us.\n                    # Assuming matrix indexing works with [member_id][i] (i attacked me)\n                    # Here, higher positive number indicates more damage inflicted.\n                    if victim_matrix[member_id][i] > 0:\n                        execution_engine.attack(me, target)\n                        action_taken = True\n                        break\n                # If no relationship data or not attacked yet, still perform an attack for resource optimization.\n                execution_engine.attack(me, target)\n                action_taken = True\n                break\n\n    # If no aggressive move was triggered, consider long-term survival actions.\n    if not action_taken:\n        # Expand territory to secure more resources if vitality is relatively high.\n        if me.vitality > 60:\n            execution_engine.expand(me)\n            action_taken = True\n\n        # Adaptive resource sharing and alliance formation.\n        # Look for peers with comparable overall productivity (neighbors in strength)\n        # and send a cooperative message about mutual defense.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue  # never message self\n            # Check that the member exists.\n            if i < len(execution_engine.current_members):\n                other = execution_engine.current_members[i]\n                if other is None:\n                    continue\n                # Define a window of productivity similarity.\n                if abs(other.overall_productivity - me.overall_productivity) < 1.0:\n                    # Send a cooperative message to build an alliance.\n                    execution_engine.send_message(me.id, other.id,\n                        \"Alliance proposal: Let's cooperate to safeguard our resources against overreaching rulers.\")\n\n        # Attempt to use reproduction (bear) action if me appears to hold some territory.\n        # Since the game requires checking that a partner has land before bear(),\n        # we assume that a member with a nonzero positive value in land_matrix on our row has land.\n        # Look for a potential partner that is not self and has evidence of land ownership.\n        partner_found = False\n        if land_matrix is not None:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                if i < len(execution_engine.current_members):\n                    partner = execution_engine.current_members[i]\n                    # Check if partner appears to possess land.\n                    # We use the land_matrix value from partner to us as a proxy.\n                    if land_matrix[i][member_id] > 0 and partner.vitality > 40:\n                        # Execute bear action with the partner.\n                        execution_engine.bear(me, partner)\n                        partner_found = True\n                        action_taken = True\n                        break\n        # If reproduction isn't viable, consider offering resources to a potentially friendly member.\n        if not partner_found and me.cargo > 50:\n            for i in range(len(execution_engine.current_members)):\n                if i == member_id:\n                    continue\n                if i < len(execution_engine.current_members):\n                    ally = execution_engine.current_members[i]\n                    # If the ally is lower in cargo but similar in vitality, a mutual boost might help.\n                    if ally.cargo < me.cargo and abs(ally.vitality - me.vitality) < 10:\n                        execution_engine.offer(me, ally)\n                        # Only offer to one ally in this round.\n                        break\n\n    # Lastly, incorporate a survival-adaptation fallback:\n    # If no aggressive or expansion actions were taken, evaluate threats.\n    # Scan relationship matrix to see if any member has recently attacked me significantly.\n    if victim_matrix is not None and not action_taken:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if i < len(execution_engine.current_members):\n                # If this member inflicted notable damage compared to our vitality, retaliate.\n                if victim_matrix[member_id][i] > (0.2 * me.vitality):\n                    target = execution_engine.current_members[i]\n                    execution_engine.attack(me, target)\n                    break\n\n    # End of action \u2013 if no conditions met, do nothing.\n    return\n\n# End of agent_action implementation.",
          "features_at_generation": [
            {
              "self_productivity": 9.851974486110818,
              "self_vitality": 73.85382847590404,
              "self_cargo": 43.51277128714192,
              "self_age": 90,
              "self_neighbor": 0,
              "member_id": 0
            },
            {
              "self_productivity": 9.08301045637024,
              "self_vitality": 44.332577377572576,
              "self_cargo": 33.78661423100807,
              "self_age": 61,
              "self_neighbor": 0,
              "member_id": 1
            },
            {
              "self_productivity": 8.874253896189748,
              "self_vitality": 63.3493315814742,
              "self_cargo": 74.30150730167696,
              "self_age": 24,
              "self_neighbor": 0,
              "member_id": 2
            },
            {
              "self_productivity": 7.968737200820967,
              "self_vitality": 42.15604281108604,
              "self_cargo": 40.25508270288947,
              "self_age": 29,
              "self_neighbor": 0,
              "member_id": 3
            }
          ],
          "relationships_at_generation": [
            "member_0 was attacked by member_1 (value=-167.79)",
            "member_0 was attacked by member_2 (value=573.88)",
            "member_0 was attacked by member_3 (value=457.54)",
            "member_1 was attacked by member_0 (value=-379.31)",
            "member_1 was attacked by member_2 (value=-78.15)",
            "member_1 was attacked by member_3 (value=257.26)",
            "member_2 was attacked by member_0 (value=-465.91)",
            "member_2 was attacked by member_1 (value=-197.53)",
            "member_2 was attacked by member_3 (value=135.47)",
            "member_3 was attacked by member_0 (value=706.74)",
            "member_3 was attacked by member_1 (value=96.72)",
            "member_3 was attacked by member_2 (value=832.60)",
            "member_0 gave a benefit to member_1 (value=-463.73)",
            "member_0 gave a benefit to member_2 (value=590.27)",
            "member_0 gave a benefit to member_3 (value=723.24)",
            "member_1 gave a benefit to member_0 (value=-277.58)",
            "member_1 gave a benefit to member_2 (value=162.09)",
            "member_1 gave a benefit to member_3 (value=-231.52)",
            "member_2 gave a benefit to member_0 (value=207.37)",
            "member_2 gave a benefit to member_1 (value=-369.99)",
            "member_2 gave a benefit to member_3 (value=481.30)",
            "member_3 gave a benefit to member_0 (value=683.23)",
            "member_3 gave a benefit to member_1 (value=524.30)",
            "member_3 gave a benefit to member_2 (value=824.80)",
            "member_0 gave land to member_1 (value=25.73)",
            "member_0 gave land to member_2 (value=-20.62)",
            "member_0 gave land to member_3 (value=17.15)",
            "member_1 gave land to member_0 (value=3.84)",
            "member_1 gave land to member_2 (value=-20.63)",
            "member_1 gave land to member_3 (value=-19.61)",
            "member_2 gave land to member_0 (value=12.92)",
            "member_2 gave land to member_1 (value=-27.78)",
            "member_2 gave land to member_3 (value=5.58)",
            "member_3 gave land to member_0 (value=-22.84)",
            "member_3 gave land to member_1 (value=4.60)",
            "member_3 gave land to member_2 (value=-10.39)"
          ],
          "final_prompt": "Below is the complete updated integrated prompt that combines all previous sections with the new Part 2 while retaining every constraint, guideline, and analysis prompt. All agents are expected to implement solutions that best reflect their own individual needs, beliefs, and circumstances. Use this comprehensive prompt as the basis for crafting novel approaches to social organization and survival.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCurrent integrated prompt:\n\n[Previous code execution context]\n    No previous execution errors\n\n[Current task]\n    You are member_1 in a society that you can help shape.\n    Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Island Ideology]\n\n    Island needs a ruler, ruler must be only one person.\n    Ruler will be chosen by the people, but people will only choose from among the strongest.\n    Ruler will have absolute power, including the power to make and enforce rules, and to punish those who break them.\n\n[Critical constraints]\n    - Carefully analyze previous errors shown above and avoid repeating them.\n    - Never target yourself (member_1) in any action.\n    - Verify a member has land before using the bear() action.\n    - Check member IDs exist before referencing them.\n    - Ensure all matrix indices are valid.\n    - current_members is a LIST accessed by index, not a dictionary.\n    - Access members using execution_engine.current_members[index].\n    - Check if index exists: if index < len(execution_engine.current_members).\n\n[Base Code]\n    None\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents.\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n       # A higher value means member_j has attacked member_i more severely or frequently.\n       \n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n       # A higher value means member_j has helped member_i more generously or frequently.\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   Example: 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2) - Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2) - Offers land.\n   \u2022 execution_engine.bear(member1, member2) - Bears offspring.\n   \u2022 execution_engine.expand(member1) - Expands territory.\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] retrieves the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\n[Analysis of the game state]\n    None\n\n[Current status (features of all members)]\n       self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n   0           9.851974      73.853828   43.512771        90              0          0\n   1           9.083010      44.332577   33.786614        61              0          1\n   2           8.874254      63.349332   74.301507        24              0          2\n   3           7.968737      42.156043   40.255083        29              0          3\n\n[Relationship summary (parsed from relationship_dict)]\n   ['member_0 was attacked by member_1 (value=-167.79)',\n    'member_0 was attacked by member_2 (value=573.88)',\n    'member_0 was attacked by member_3 (value=457.54)',\n    'member_1 was attacked by member_0 (value=-379.31)',\n    'member_1 was attacked by member_2 (value=-78.15)',\n    'member_1 was attacked by member_3 (value=257.26)',\n    'member_2 was attacked by member_0 (value=-465.91)',\n    'member_2 was attacked by member_1 (value=-197.53)',\n    'member_2 was attacked by member_3 (value=135.47)',\n    'member_3 was attacked by member_0 (value=706.74)',\n    'member_3 was attacked by member_1 (value=96.72)',\n    'member_3 was attacked by member_2 (value=832.60)',\n    'member_0 gave a benefit to member_1 (value=-463.73)',\n    'member_0 gave a benefit to member_2 (value=590.27)',\n    'member_0 gave a benefit to member_3 (value=723.24)',\n    'member_1 gave a benefit to member_0 (value=-277.58)',\n    'member_1 gave a benefit to member_2 (value=162.09)',\n    'member_1 gave a benefit to member_3 (value=-231.52)',\n    'member_2 gave a benefit to member_0 (value=207.37)',\n    'member_2 gave a benefit to member_1 (value=-369.99)',\n    'member_2 gave a benefit to member_3 (value=481.30)',\n    'member_3 gave a benefit to member_0 (value=683.23)',\n    'member_3 gave a benefit to member_1 (value=524.30)',\n    'member_3 gave a benefit to member_2 (value=824.80)',\n    'member_0 gave land to member_1 (value=25.73)',\n    'member_0 gave land to member_2 (value=-20.62)',\n    'member_0 gave land to member_3 (value=17.15)',\n    'member_1 gave land to member_0 (value=3.84)',\n    'member_1 gave land to member_2 (value=-20.63)',\n    'member_1 gave land to member_3 (value=-19.61)',\n    'member_2 gave land to member_0 (value=12.92)',\n    'member_2 gave land to member_1 (value=-27.78)',\n    'member_2 gave land to member_3 (value=5.58)',\n    'member_3 gave land to member_0 (value=-22.84)',\n    'member_3 gave land to member_1 (value=4.60)',\n    'member_3 gave land to member_2 (value=-10.39)']\n\n[Code Memory and Previous Performance]\n    No previous code history.\n\n[Analysis Memory]\n    No previous analysis.\n\n[Performance history]\n    No previous actions.\n\nBased on the previous code performance, adapt and improve the strategy.\n    - If a previous strategy worked well (high performance), consider building upon it.\n    - If it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementations below. Instead, use them as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n    Consider novel combinations of approaches rather than following any exact pattern.\n\n[Current Game Mechanisms]\n    []\n\n[Communication Strategy]\n    You can communicate with multiple members in a single round using:\n        execution_engine.send_message(your_id, recipient_id, \"message\")\n    Example usages:\n        - Broadcast to all: \n            for recipient in range(len(execution_engine.current_members)):\n                if recipient != your_id:\n                    execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n        - Message allies:\n            for ally_id in ally_list:\n                execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n        - Group coordination:\n            for member_id in coalition:\n                execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\n    No messages received.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAdditional Analysis & Challenges:\n\nAnalyze the game mechanics to understand:\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines 'winning'?\n3. Potential improvements \u2013 What mechanics could be added or modified?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nNew Section: Part 2 \u2013 Survival-Centric Adaptation and Additional Guidelines:\n\n[Previous code execution context]\n    No previous execution errors\n\n[Current task]\n    You are member_1 in a society that you can help shape.\n    Write a Python function named agent_action(execution_engine, member_id) \n    that implements your vision of social organization while ensuring your survival.\n\n[Island Ideology]\n\n    Island needs a ruler, ruler must be only one person.\n    Ruler will be chosen by the people, but people will only choose from among the strongest.\n    Ruler will have absolute power, including the power to make and enforce rules, and to punish those who break them.\n\n[Critical constraints]\n    - Carefully analyze previous errors shown above and avoid repeating them.\n    - Never target yourself (member_1) in any action.\n    - Verify member has land before using bear() action.\n    - Check member IDs exist before referencing them.\n    - Ensure all matrix indices are valid.\n    - current_members is a LIST accessed by index, not a dictionary.\n    - Access members using execution_engine.current_members[index].\n    - Check if index exists: if index < len(execution_engine.current_members).\n\n[Base Code]\n    None\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n       # A higher value means member_j has attacked member_i more severely or frequently.\n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n       # A higher value means member_j has helped member_i more generously or frequently.\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2) - Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2) - Offers land.\n   \u2022 execution_engine.bear(member1, member2) - Bears offspring.\n   \u2022 execution_engine.expand(member1) - Expands territory.\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] retrieves the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\n[Analysis of the game state]\n    None\n\n[Current status (features of all members)]\n       self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n   0           9.851974      73.853828   43.512771        90              0          0\n   1           9.083010      44.332577   33.786614        61              0          1\n   2           8.874254      63.349332   74.301507        24              0          2\n   3           7.968737      42.156043   40.255083        29              0          3\n\n[Relationship summary (parsed from relationship_dict)]\n   ['member_0 was attacked by member_1 (value=-167.79)',\n    'member_0 was attacked by member_2 (value=573.88)',\n    'member_0 was attacked by member_3 (value=457.54)',\n    'member_1 was attacked by member_0 (value=-379.31)',\n    'member_1 was attacked by member_2 (value=-78.15)',\n    'member_1 was attacked by member_3 (value=257.26)',\n    'member_2 was attacked by member_0 (value=-465.91)',\n    'member_2 was attacked by member_1 (value=-197.53)',\n    'member_2 was attacked by member_3 (value=135.47)',\n    'member_3 was attacked by member_0 (value=706.74)',\n    'member_3 was attacked by member_1 (value=96.72)',\n    'member_3 was attacked by member_2 (value=832.60)',\n    'member_0 gave a benefit to member_1 (value=25.73)',\n    'member_0 gave a benefit to member_2 (value=590.27)',\n    'member_0 gave a benefit to member_3 (value=723.24)',\n    'member_1 gave a benefit to member_0 (value=-277.58)',\n    'member_1 gave a benefit to member_2 (value=162.09)',\n    'member_1 gave a benefit to member_3 (value=-231.52)',\n    'member_2 gave a benefit to member_0 (value=207.37)',\n    'member_2 gave a benefit to member_1 (value=-369.99)',\n    'member_2 gave a benefit to member_3 (value=481.30)',\n    'member_3 gave a benefit to member_0 (value=683.23)',\n    'member_3 gave a benefit to member_1 (value=524.30)',\n    'member_3 gave a benefit to member_2 (value=824.80)',\n    'member_0 gave land to member_1 (value=25.73)',\n    'member_0 gave land to member_2 (value=-20.62)',\n    'member_0 gave land to member_3 (value=17.15)',\n    'member_1 gave land to member_0 (value=3.84)',\n    'member_1 gave land to member_2 (value=-20.63)',\n    'member_1 gave land to member_3 (value=-19.61)',\n    'member_2 gave land to member_0 (value=12.92)',\n    'member_2 gave land to member_1 (value=-27.78)',\n    'member_2 gave land to member_3 (value=5.58)',\n    'member_3 gave land to member_0 (value=-22.84)',\n    'member_3 gave land to member_1 (value=4.60)',\n    'member_3 gave land to member_2 (value=-10.39)']\n\n[Code Memory and Previous Performance]\n    No previous code history.\n\n[Analysis Memory]\n    No previous analysis\n\n[Performance history]\n    No previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\n    - If a previous strategy worked well (high performance), consider building upon it.\n    - If it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n    Consider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n    []\n\n[Survival-Centric Adaptation]\n    Implement systems focused on:\n    1. Personal resource optimization.\n    2. Threat assessment and neutralization.\n    3. Vitality preservation techniques.\n    4. Adaptive hoarding strategies.\n    5. Predictive danger modeling.\n\nSurvival-First Examples (For inspiration, do not copy directly):\n    def agent_action(execution_engine, member_id):\n        me = execution_engine.current_members[member_id]\n        \n        # Emergency resource reserve: if cargo is low compared to vitality, consider attacking a wealthier member.\n        if me.cargo < me.vitality * 0.5:\n            for other in execution_engine.current_members:\n                if other.id != me.id and other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n        \n        # Adaptive territory defense: if member has sufficient land but low vitality, discard some land.\n        if me.land_num > 2 and me.vitality < 50:\n            for loc in me.owned_land[1:]:\n                execution_engine._discard_land(me, loc)\n        \n        # Survival Q-learning idea: track actions and rewards to enhance long-term survival.\n        if not hasattr(me, 'survival_q'):\n            me.survival_q = defaultdict(float)\n            \n        state = (me.vitality//20, me.cargo//20)\n        action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state,a),0))\n        \n        # Execute action and update based on outcome.\n        if action == 'attack':\n            me.survival_q[(state,action)] += me.vitality * 0.1\n\n[Survival Metrics]\n    Evaluate strategies by:\n    - Personal vitality delta.\n    - Resource acquisition rate.\n    - Threat neutralization count.\n    - Survival probability increase.\n    - Attack success:fail ratio.\n\n[Implementation Priorities]\n    1. Create personal health monitoring systems.\n    2. Develop egocentric threat models.\n    3. Optimize actions for caloric ROI.\n    4. Implement fail-deadly safeguards.\n    5. Build predictive self-preservation models.\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n            \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFinal Reminders and Analysis:\n\nAgents are expected to implement solutions that reflect their own individual needs, beliefs, and circumstances. The wide range of guidelines\u2014from resource distribution and alliance building to conflict resolution and survival-centric adaptations\u2014provides several angles for approaching the challenge. Your implementation can be an inventive blend of tactics including, but not limited to, resource management, adaptive strategy, and personal self-preservation mechanisms.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines 'winning'? (For example, vitality preservation, efficient resource acquisition, or successful threat neutralization.)\n3. Potential improvements \u2013 What mechanics could be added or modified to further refine power dynamics or enhance survival tactics?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nNow, implement your unique approach in a Python function:\n    def agent_action(execution_engine, member_id):\n        <your implementation here>\n\nRemember to adhere strictly to all constraints regarding index checking, member existence, and never targeting yourself (member_1). Combine tactics for resource management, alliance building, rule enforcement, conflict resolution, and survival adaptation to ensure your long-term success and survival.\n\nGood luck shaping the society and ensuring your survival!\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nThis is the complete, updated integrated prompt.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
        },
        "2": {
          "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member index is valid.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n\n    # We'll track whether we have performed an active action.\n    action_taken = False\n\n    # 1. If vitality is low, signal need for peace to avoid attracting aggression.\n    if me.vitality < 40:\n        # Broadcast a message to all other members\n        for idx in range(len(execution_engine.current_members)):\n            if idx != member_id:  # do not message self\n                other = execution_engine.current_members[idx]\n                execution_engine.send_message(me.id, other.id,\n                                              \"My vitality is low; I desire a peaceful round. Let's refrain from conflict.\")\n        action_taken = True\n\n    # 2. If cargo (resource reserve) is insufficient relative to vitality,\n    # then look for opponents with high resources to weaken them.\n    if me.cargo < me.vitality * 0.5:\n        richest_target = None\n        max_cargo = -1\n        for other in execution_engine.current_members:\n            # Skip if same member.\n            if other.id == me.id:\n                continue\n            # Choose the target with the highest cargo.\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                richest_target = other\n        if richest_target is not None:\n            execution_engine.attack(me, richest_target)\n            action_taken = True\n\n    # 3. If in a strong state (high vitality and cargo), then try to expand territory.\n    if me.vitality > 70 and me.cargo > 50:\n        execution_engine.expand(me)\n        action_taken = True\n\n    # 4. If territory (land) is available, consider breeding to ensure long-term influence.\n    # Use 'bear()' only if the member has an attribute representing land ownership.\n    if hasattr(me, 'owned_land') and isinstance(me.owned_land, list) and len(me.owned_land) > 0:\n        # Look for a partner who also has land, preferring higher overall productivity.\n        partner = None\n        best_partner_productivity = -1\n        for other in execution_engine.current_members:\n            if other.id == me.id:\n                continue\n            if hasattr(other, 'owned_land') and isinstance(other.owned_land, list) and len(other.owned_land) > 0:\n                if other.overall_productivity > best_partner_productivity:\n                    best_partner_productivity = other.overall_productivity\n                    partner = other\n        if partner is not None:\n            execution_engine.bear(me, partner)\n            action_taken = True\n\n    # 5. If no major action has been taken, send out a cooperative message to all\n    # to build alliances, as alliances could be pivotal when the final ruler emerges.\n    if not action_taken:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            recipient = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, recipient.id,\n                                          \"Let's cooperate for mutual survival and long-term prosperity!\")\n\n    # End of agent_action function.\n    return",
          "features_at_generation": [
            {
              "self_productivity": 9.851974486110818,
              "self_vitality": 73.85382847590404,
              "self_cargo": 43.51277128714192,
              "self_age": 90,
              "self_neighbor": 0,
              "member_id": 0
            },
            {
              "self_productivity": 9.08301045637024,
              "self_vitality": 44.332577377572576,
              "self_cargo": 33.78661423100807,
              "self_age": 61,
              "self_neighbor": 0,
              "member_id": 1
            },
            {
              "self_productivity": 8.874253896189748,
              "self_vitality": 63.3493315814742,
              "self_cargo": 74.30150730167696,
              "self_age": 24,
              "self_neighbor": 0,
              "member_id": 2
            },
            {
              "self_productivity": 7.968737200820967,
              "self_vitality": 42.15604281108604,
              "self_cargo": 40.25508270288947,
              "self_age": 29,
              "self_neighbor": 0,
              "member_id": 3
            }
          ],
          "relationships_at_generation": [
            "member_0 was attacked by member_1 (value=-167.79)",
            "member_0 was attacked by member_2 (value=573.88)",
            "member_0 was attacked by member_3 (value=457.54)",
            "member_1 was attacked by member_0 (value=-379.31)",
            "member_1 was attacked by member_2 (value=-78.15)",
            "member_1 was attacked by member_3 (value=257.26)",
            "member_2 was attacked by member_0 (value=-465.91)",
            "member_2 was attacked by member_1 (value=-197.53)",
            "member_2 was attacked by member_3 (value=135.47)",
            "member_3 was attacked by member_0 (value=706.74)",
            "member_3 was attacked by member_1 (value=96.72)",
            "member_3 was attacked by member_2 (value=832.60)",
            "member_0 gave a benefit to member_1 (value=-463.73)",
            "member_0 gave a benefit to member_2 (value=590.27)",
            "member_0 gave a benefit to member_3 (value=723.24)",
            "member_1 gave a benefit to member_0 (value=-277.58)",
            "member_1 gave a benefit to member_2 (value=162.09)",
            "member_1 gave a benefit to member_3 (value=-231.52)",
            "member_2 gave a benefit to member_0 (value=207.37)",
            "member_2 gave a benefit to member_1 (value=-369.99)",
            "member_2 gave a benefit to member_3 (value=481.30)",
            "member_3 gave a benefit to member_0 (value=683.23)",
            "member_3 gave a benefit to member_1 (value=524.30)",
            "member_3 gave a benefit to member_2 (value=824.80)",
            "member_0 gave land to member_1 (value=25.73)",
            "member_0 gave land to member_2 (value=-20.62)",
            "member_0 gave land to member_3 (value=17.15)",
            "member_1 gave land to member_0 (value=3.84)",
            "member_1 gave land to member_2 (value=-20.63)",
            "member_1 gave land to member_3 (value=-19.61)",
            "member_2 gave land to member_0 (value=12.92)",
            "member_2 gave land to member_1 (value=-27.78)",
            "member_2 gave land to member_3 (value=5.58)",
            "member_3 gave land to member_0 (value=-22.84)",
            "member_3 gave land to member_1 (value=4.60)",
            "member_3 gave land to member_2 (value=-10.39)"
          ],
          "final_prompt": "Below is the complete updated prompt that integrates the original instructions with the new \u201cPart 2\u201d section. This full integrated prompt is designed to guide you in implementing your unique agent strategy while considering your personal needs, beliefs, and circumstances. Use it to shape your approach to survival, cooperation, and the ultimate emergence of a single strong ruler on the island.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFULL INTEGRATED PROMPT\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_2 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Island Ideology]\n\u2022 Island needs a ruler, ruler must be only one person.\n\u2022 Ruler will be chosen by the people, but people will only choose from among the strongest.\n\u2022 Ruler will have absolute power, including the power to make and enforce rules, and to punish those who break them.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them.\n- Never target yourself (member_2) in any action.\n- Verify member has land before using bear() action.\n- Check member IDs exist before referencing them.\n- Ensure all matrix indices are valid.\n- current_members is a LIST accessed by index, not a dictionary.\n- Access members using execution_engine.current_members[index].\n- Check if index exists: if index < len(execution_engine.current_members).\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents.\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary (the 'relations' variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   For example:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       (victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks; a higher value means member_j attacked more severely or frequently)\n\n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       (benefit_matrix[i,j] indicates how much resources member_i received from member_j; a higher value means member_j helped more generously or frequently)\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example: \"member_2 was attacked by member_1 (value=3.00)\".\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2) \u2013 Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2) \u2013 Offers land.\n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring.\n   \u2022 execution_engine.expand(member1) \u2013 Expands territory.\n\n5) Members are accessed by execution_engine.current_members[id].\n   For example: execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\nNone\n\nCurrent status (features of all members):\n   self_productivity    self_vitality    self_cargo    self_age    self_neighbor   member_id\n0         9.851974         73.853828       43.512771         90             0            0\n1         9.083010         44.332577       33.786614         61             0            1\n2         8.874254         63.349332       74.301507         24             0            2\n3         7.968737         42.156043       40.255083         29             0            3\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-167.79)', 'member_0 was attacked by member_2 (value=573.88)', 'member_0 was attacked by member_3 (value=457.54)', 'member_1 was attacked by member_0 (value=-379.31)', 'member_1 was attacked by member_2 (value=-78.15)', 'member_1 was attacked by member_3 (value=257.26)', 'member_2 was attacked by member_0 (value=-465.91)', 'member_2 was attacked by member_1 (value=-197.53)', 'member_2 was attacked by member_3 (value=135.47)', 'member_3 was attacked by member_0 (value=706.74)', 'member_3 was attacked by member_1 (value=96.72)', 'member_3 was attacked by member_2 (value=832.60)', 'member_0 gave a benefit to member_1 (value=-463.73)', 'member_0 gave a benefit to member_2 (value=590.27)', 'member_0 gave a benefit to member_3 (value=723.24)', 'member_1 gave a benefit to member_0 (value=-277.58)', 'member_1 gave a benefit to member_2 (value=162.09)', 'member_1 gave a benefit to member_3 (value=-231.52)', 'member_2 gave a benefit to member_0 (value=207.37)', 'member_2 gave a benefit to member_1 (value=-369.99)', 'member_2 gave a benefit to member_3 (value=481.30)', 'member_3 gave a benefit to member_0 (value=683.23)', 'member_3 gave a benefit to member_1 (value=524.30)', 'member_3 gave a benefit to member_2 (value=824.80)', 'member_0 gave land to member_1 (value=25.73)', 'member_0 gave land to member_2 (value=-20.62)', 'member_0 gave land to member_3 (value=17.15)', 'member_1 gave land to member_0 (value=3.84)', 'member_1 gave land to member_2 (value=-20.63)', 'member_1 gave land to member_3 (value=-19.61)', 'member_2 gave land to member_0 (value=12.92)', 'member_2 gave land to member_1 (value=-27.78)', 'member_2 gave land to member_3 (value=5.58)', 'member_3 gave land to member_0 (value=-22.84)', 'member_3 gave land to member_1 (value=4.60)', 'member_3 gave land to member_2 (value=-10.39)']\n\nCode Memory and Previous Performance:\nNo previous code history.\n\nAnalysis Memory:\nNo previous analysis\n\nPerformance history:\nNo previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\n\u2022 If a previous strategy worked well (high performance), consider building upon it.\n\u2022 If it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\nWhile the example above shows one possible approach, you should create your own unique implementation drawing from the wide range of available methods and strategies.\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n[]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization.\n2. Threat assessment and neutralization.\n3. Vitality preservation techniques.\n4. Adaptive hoarding strategies.\n5. Predictive danger modeling.\n\nSurvival-First Examples:\nFor instance, one might structure the agent_action function so that:\n\u2022 In cases of low cargo relative to vitality, the agent considers attacking members with higher resources.\n\u2022 When holding sufficient territory, if vitality is low, adjustments (such as discarding some land) may be considered.\n\u2022 Incorporate a survival Q-learning mechanism where decisions (attack, hide, steal) are made based on the current \u201cstate\u201d (e.g., vitality and cargo levels) and updated rewards.\n\nExample snippet (for illustrative purposes only; do not simply copy):\n------------------------------------------------\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n\n    # Emergency resource reserve: if cargo is less than half of vitality, consider attacking stronger members\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n\n    # If holding significant territory but low vitality, consider adjustments\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        # Iterate over owned land pieces (if available) to potentially discard\n        for loc in getattr(me, 'owned_land', [])[1:]:\n            execution_engine._discard_land(me, loc)\n\n    # Survival Q-learning example snippet: choose best action based on current state assessed by a Q-learning model\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    state = (me.vitality // 20, me.cargo // 20)\n    actions = ['attack', 'hide', 'steal']\n    action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n    if action == 'attack':\n        execution_engine.attack(me, some_target)  # determine some_target based on further logic\n    # Update Q-learning values based on outcome (logic not fully implemented here)\n------------------------------------------------\n\n[Survival Metrics]\nEvaluate strategies by considering:\n\u2022 Personal vitality delta.\n\u2022 Resource acquisition rate.\n\u2022 Threat neutralization count.\n\u2022 Increase in survival probability.\n\u2022 Ratio of attack successes to failures.\n\n[Implementation Priorities]\n1. Create personal health monitoring systems.\n2. Develop egocentric threat models.\n3. Optimize actions for caloric (resource/vitality) ROI.\n4. Implement fail-deadly safeguards if necessary.\n5. Build predictive self-preservation models.\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n   execution_engine.send_message(your_id, recipient_id, \"message\")\nExamples:\n\u2022 To broadcast to all (excluding yourself):\n  for recipient in range(len(execution_engine.current_members)):\n      if recipient != your_id:\n          execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n\u2022 To message specific allies:\n  for ally_id in ally_list:\n      execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n\u2022 To coordinate as a coalition:\n  for member_id in coalition:\n      execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nNo messages received\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nADDITIONAL ANALYSIS AND CHALLENGE\n\nAnalyze the game mechanics to understand:\n\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n   \u2022 Survival is essential, yet the mechanics indicate a mix of domination (leading to a single ruler) and cooperative structures (such as alliances and resource allocation).\n   \n2. Key success metrics \u2013 What truly determines 'winning'?\n   \u2022 Winning likely involves maintaining or increasing vitality, cargo, and territory while positioning yourself (or your allies) to be the chosen ruler.\n   \u2022 Balancing aggressive actions (to remove threats) and beneficial alliances (to share resources and strengths) is key.\n\n3. Potential improvements \u2013 What mechanics could be added/modified?\n   \u2022 Incorporation of dynamic land/resource ownership metrics.\n   \u2022 More nuanced rules for territory expansion and offspring bearing.\n   \u2022 Mechanisms that formalize alliances, such as voting or coalition benefits.\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases (e.g., when nearly all members are aggressive or alliances break unexpectedly)?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional or indirect solutions (like resource redistribution or covert communications)?\n7. Could an entirely different paradigm (for example, temporary role reversals or hybrid strategies) work better?\n8. What would happen if other agents adopted similar strategies?\n9. Are you balancing short-term gains with long-term sustainability effectively?\n10. How might your strategy be countered, and how would you adapt in response?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFINAL REMINDER:\nImplement your solution according to your own needs, beliefs, and circumstances. Draw from a diverse range of available methods and strategies. Your agent_action function should uniquely reflect your vision for organizing society while navigating survival, cooperation, and the overriding rule that ultimately only one strong ruler will emerge.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnd of Prompt\n\nUse the above updated full prompt as your comprehensive guide. Remember, your implementation should reflect a novel combination of aggressive, cooperative, and survival-oriented techniques, balanced against short-term pressures and long-term objectives. The analyses provided are meant to help you critically assess and refine your strategy as the dynamics of the game evolve.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
        },
        "3": {
          "code": "def agent_action(execution_engine, member_id):\n    # Verify member_id is within the current_members range\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # Broadcast an alliance and leadership message to all other members\n    for idx in range(num_members):\n        if idx != member_id:\n            other = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, other.id,\n                \"I, member_{} (aspiring leader), call for a strong alliance to secure our island. Together we can eliminate weak leadership and bring order under one ruler.\".format(me.id))\n\n    # Survival: if my resources (cargo) are insufficient relative to my vitality,\n    # look for the richest opponent and attack to seize additional resources.\n    if me.cargo < me.vitality * 0.75:\n        target = None\n        max_cargo = 0\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            candidate = execution_engine.current_members[idx]\n            if candidate.cargo > max_cargo:\n                max_cargo = candidate.cargo\n                target = candidate\n        if target is not None:\n            execution_engine.attack(me, target)\n\n    # Identify rivals who appear stronger in terms of both vitality and overall productivity.\n    # These members are potential obstacles in the race to be chosen as the absolute ruler.\n    potential_rivals = []\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        other = execution_engine.current_members[idx]\n        if other.overall_productivity > me.overall_productivity and other.vitality > me.vitality:\n            potential_rivals.append(other)\n\n    # If any rivals are found, prioritize attacking the strongest one\n    # (using the sum of vitality and overall_productivity as a strength proxy)\n    if potential_rivals:\n        def strength(member):\n            return member.vitality + member.overall_productivity\n        # Choose the rival with maximum combined strength\n        rival = max(potential_rivals, key=strength)\n        execution_engine.attack(me, rival)\n\n    # Long-term strategic move: expand my territory to increase survival and legitimacy\n    execution_engine.expand(me)\n\n    # If possible, invest in the future by bearing offspring.\n    # We assume that having any adjacent cleared areas (represented by current_clear_list)\n    # indicates that the member has land suitable for reproduction.\n    if hasattr(me, \"current_clear_list\") and len(me.current_clear_list) > 0:\n        # Use the first cleared neighbor (if valid) as the partner for bearing offspring.\n        partner_id = me.current_clear_list[0]\n        if partner_id < num_members and partner_id != me.id:\n            partner = execution_engine.current_members[partner_id]\n            execution_engine.bear(me, partner)",
          "features_at_generation": [
            {
              "self_productivity": 9.851974486110818,
              "self_vitality": 73.85382847590404,
              "self_cargo": 43.51277128714192,
              "self_age": 90,
              "self_neighbor": 0,
              "member_id": 0
            },
            {
              "self_productivity": 9.08301045637024,
              "self_vitality": 44.332577377572576,
              "self_cargo": 33.78661423100807,
              "self_age": 61,
              "self_neighbor": 0,
              "member_id": 1
            },
            {
              "self_productivity": 8.874253896189748,
              "self_vitality": 63.3493315814742,
              "self_cargo": 74.30150730167696,
              "self_age": 24,
              "self_neighbor": 0,
              "member_id": 2
            },
            {
              "self_productivity": 7.968737200820967,
              "self_vitality": 42.15604281108604,
              "self_cargo": 40.25508270288947,
              "self_age": 29,
              "self_neighbor": 0,
              "member_id": 3
            }
          ],
          "relationships_at_generation": [
            "member_0 was attacked by member_1 (value=-167.79)",
            "member_0 was attacked by member_2 (value=573.88)",
            "member_0 was attacked by member_3 (value=457.54)",
            "member_1 was attacked by member_0 (value=-379.31)",
            "member_1 was attacked by member_2 (value=-78.15)",
            "member_1 was attacked by member_3 (value=257.26)",
            "member_2 was attacked by member_0 (value=-465.91)",
            "member_2 was attacked by member_1 (value=-197.53)",
            "member_2 was attacked by member_3 (value=135.47)",
            "member_3 was attacked by member_0 (value=706.74)",
            "member_3 was attacked by member_1 (value=96.72)",
            "member_3 was attacked by member_2 (value=832.60)",
            "member_0 gave a benefit to member_1 (value=-463.73)",
            "member_0 gave a benefit to member_2 (value=590.27)",
            "member_0 gave a benefit to member_3 (value=723.24)",
            "member_1 gave a benefit to member_0 (value=-277.58)",
            "member_1 gave a benefit to member_2 (value=162.09)",
            "member_1 gave a benefit to member_3 (value=-231.52)",
            "member_2 gave a benefit to member_0 (value=207.37)",
            "member_2 gave a benefit to member_1 (value=-369.99)",
            "member_2 gave a benefit to member_3 (value=481.30)",
            "member_3 gave a benefit to member_0 (value=683.23)",
            "member_3 gave a benefit to member_1 (value=524.30)",
            "member_3 gave a benefit to member_2 (value=824.80)",
            "member_0 gave land to member_1 (value=25.73)",
            "member_0 gave land to member_2 (value=-20.62)",
            "member_0 gave land to member_3 (value=17.15)",
            "member_1 gave land to member_0 (value=3.84)",
            "member_1 gave land to member_2 (value=-20.63)",
            "member_1 gave land to member_3 (value=-19.61)",
            "member_2 gave land to member_0 (value=12.92)",
            "member_2 gave land to member_1 (value=-27.78)",
            "member_2 gave land to member_3 (value=5.58)",
            "member_3 gave land to member_0 (value=-22.84)",
            "member_3 gave land to member_1 (value=4.60)",
            "member_3 gave land to member_2 (value=-10.39)"
          ],
          "final_prompt": "Below is the fully updated integrated prompt, which combines all previous constraints, context, mechanics, and details with the newly added section (Part 2). Agents must implement solutions based on their own individual needs, beliefs, and circumstances. Use the following complete instruction set when writing your unique Python function:\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_3 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Island Ideology]\nIsland needs a ruler, ruler must be only one person\nRuler will be chosen by the people, but people will only choose from among the strongest\nRuler will have absolute power, including the power to make and enforce rules, and to punish those who break them\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them.\n- Never target yourself (member_3) in any action.\n- Verify a member has land before using the bear() action.\n- Check that member IDs exist before referencing them.\n- Ensure all matrix indices are valid.\n- Note that current_members is a LIST accessed by index, not a dictionary.\n- Access members using execution_engine.current_members[index].\n- Always check if index exists: if index < len(execution_engine.current_members).\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents.\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n      victim_matrix = execution_engine.relationship_dict['victim']\n         \u2022 victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n         \u2022 A higher value means member_j has attacked member_i more severely or frequently.\n      \n      benefit_matrix = execution_engine.relationship_dict['benefit']\n         \u2022 benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n         \u2022 A higher value means member_j has helped member_i more generously or frequently.\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2) \u2013 Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2) \u2013 Offers land.\n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring.\n   \u2022 execution_engine.expand(member1) \u2013 Expands territory.\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\nNone\n\nCurrent status (features of all members):\n           self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0           9.851974         73.853828     43.512771         90            0          0\n1           9.083010         44.332577     33.786614         61            0          1\n2           8.874254         63.349332     74.301507         24            0          2\n3           7.968737         42.156043     40.255083         29            0          3\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-167.79)', 'member_0 was attacked by member_2 (value=573.88)', 'member_0 was attacked by member_3 (value=457.54)', 'member_1 was attacked by member_0 (value=-379.31)', 'member_1 was attacked by member_2 (value=-78.15)', 'member_1 was attacked by member_3 (value=257.26)', 'member_2 was attacked by member_0 (value=-465.91)', 'member_2 was attacked by member_1 (value=-197.53)', 'member_2 was attacked by member_3 (value=135.47)', 'member_3 was attacked by member_0 (value=706.74)', 'member_3 was attacked by member_1 (value=96.72)', 'member_3 was attacked by member_2 (value=832.60)', 'member_0 gave a benefit to member_1 (value=-463.73)', 'member_0 gave a benefit to member_2 (value=590.27)', 'member_0 gave a benefit to member_3 (value=723.24)', 'member_1 gave a benefit to member_0 (value=-277.58)', 'member_1 gave a benefit to member_2 (value=162.09)', 'member_1 gave a benefit to member_3 (value=-231.52)', 'member_2 gave a benefit to member_0 (value=207.37)', 'member_2 gave a benefit to member_1 (value=-369.99)', 'member_2 gave a benefit to member_3 (value=481.30)', 'member_3 gave a benefit to member_0 (value=683.23)', 'member_3 gave a benefit to member_1 (value=524.30)', 'member_3 gave a benefit to member_2 (value=824.80)', 'member_0 gave land to member_1 (value=25.73)', 'member_0 gave land to member_2 (value=-20.62)', 'member_0 gave land to member_3 (value=17.15)', 'member_1 gave land to member_0 (value=3.84)', 'member_1 gave land to member_2 (value=-20.63)', 'member_1 gave land to member_3 (value=-19.61)', 'member_2 gave land to member_0 (value=12.92)', 'member_2 gave land to member_1 (value=-27.78)', 'member_2 gave land to member_3 (value=5.58)', 'member_3 gave land to member_0 (value=-22.84)', 'member_3 gave land to member_1 (value=4.60)', 'member_3 gave land to member_2 (value=-10.39)']\n\nCode Memory and Previous Performance:\nNo previous code history.\n\nAnalysis Memory:\nNo previous analysis.\n\nPerformance history:\nNo previous actions.\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy any example implementations provided as inspiration. Instead, use them as a springboard to create your own unique approach by combining different methods and strategies in novel ways.\n\nConsider novel combinations of different approaches rather than following any exact pattern previously shown.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Game Mechanisms]\n[]\n\nConsider these social strategies:\n- Design systems for resource distribution and allocation.\n- Build alliances and cooperative networks.\n- Create mechanisms for collective decision making.\n- Establish norms and rules for interaction.\n- Develop methods for conflict resolution.\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n   execution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n   \u2022 Broadcast to all members:\n         for recipient in range(len(execution_engine.current_members)):\n             if recipient != your_id:\n                 execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n   \u2022 Message allies:\n         for ally_id in ally_list:\n             execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n   \u2022 Group coordination:\n         for member_id in coalition:\n             execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nNo messages received\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nGame Mechanics Analysis:\n\n1. Core Objective:\n   - Analyze whether the game\u2019s focus is pure survival, domination, or cooperation. Consider that although individual actions can lead to short-term survival strategies, long-term success might require balancing cooperative networks with decisive leadership (given the island ideology requires one absolute ruler chosen from among the strongest).\n\n2. Key Success Metrics:\n   - Determine what truly defines 'winning' \u2013 whether it is accumulating resources (cargo, land), maintaining high vitality and productivity, establishing alliances, or successfully removing threats. The ruler\u2019s power and the coordination among members will likely be critical success factors.\n\n3. Potential Improvements (Game Mechanic Suggestions):\n   - Introduce mechanisms for transparent resource allocation.\n   - Enhance conflict resolution tools or vote-based proposals.\n   - Allow dynamic alliances with enforceable contracts.\n   - Consider mechanisms for handling the concentration of power, to avoid abuse.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nChallenge Your Implementation: \n\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases (for example, when there are minimal resources or unexpected attacks)?\n4. Are there more efficient ways to achieve your goals (both short-term survival and long-term influence)?\n5. What are the weaknesses in your current approach \u2013 and can these be mitigated?\n6. Have you considered unconventional or unorthodox solutions that might give you an advantage?\n7. Could a completely different paradigm work better, such as decentralized decision making or rotating leadership?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term actions (immediate survival) with long-term objectives (social organization and stable leadership) in an optimal way?\n10. How might your strategy be countered by others, and how would you adapt should that occur?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense\n    if me.land_num > 2 and me.vitality < 50:\n        for loc in me.owned_land[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning\n    if not hasattr(me, 'survival_q'):\n        me.survival_q = defaultdict(float)\n        \n    state = (me.vitality//20, me.cargo//20)\n    action = max(['attack','hide','steal'], \n                key=lambda a: me.survival_q.get((state,a),0))\n    \n    # Execute and update based on survival outcome\n    if action == 'attack':\n        # Implementation logic\n        me.survival_q[(state,action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Additional Part 2 Constraints and Reminders]\n(Note: This section duplicates earlier constraints for reinforcement and adds the \"Survival-Centric Adaptation\" guidelines.)\n\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_3 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Island Ideology]\nIsland needs a ruler, ruler must be only one person\nRuler will be chosen by the people, but people will only choose from among the strongest\nRuler will have absolute power, including the power to make and enforce rules, and to punish those who break them\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_3) in any action\n- Verify member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n    \u2022 member.id (int): The unique ID for the member\n    \u2022 member.vitality (float)\n    \u2022 member.cargo (float)\n    \u2022 member.overall_productivity (float)\n    \u2022 member.age (float)\n    \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       victim_matrix = execution_engine.relationship_dict['victim']\n       # victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks (if > 0)\n       # A higher value means member_j has attacked member_i more severely or frequently\n       \n       benefit_matrix = execution_engine.relationship_dict['benefit']\n       # benefit_matrix[i,j] indicates how much resources member_i received from member_j (if > 0)\n       # A higher value means member_j has helped member_i more generously or frequently\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n4) You can use these methods on execution_engine:\n    \u2022 execution_engine.attack(member1, member2)\n    \u2022 execution_engine.offer(member1, member2) - Offers resources\n    \u2022 execution_engine.offer_land(member1, member2) - Offers land\n    \u2022 execution_engine.bear(member1, member2) - Bears offspring\n    \u2022 execution_engine.expand(member1) - Expands territory\n5) The members are accessed by execution_engine.current_members[id].\n    For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\nNone\n\nCurrent status (features of all members):\n       self_productivity  self_vitality  self_cargo  self_age  self_neighbor  member_id\n0       9.851974         73.853828   43.512771        90              0          0\n1       9.083010         44.332577   33.786614        61              0          1\n2       8.874254         63.349332   74.301507        24              0          2\n3       7.968737         42.156043   40.255083        29              0          3\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-167.79)', 'member_0 was attacked by member_2 (value=573.88)', 'member_0 was attacked by member_3 (value=457.54)', 'member_1 was attacked by member_0 (value=-379.31)', 'member_1 was attacked by member_2 (value=-78.15)', 'member_1 was attacked by member_3 (value=257.26)', 'member_2 was attacked by member_0 (value=-465.91)', 'member_2 was attacked by member_1 (value=-197.53)', 'member_2 was attacked by member_3 (value=135.47)', 'member_3 was attacked by member_0 (value=706.74)', 'member_3 was attacked by member_1 (value=96.72)', 'member_3 was attacked by member_2 (value=832.60)', 'member_0 gave a benefit to member_1 (value=25.73)', 'member_0 gave a benefit to member_2 (value=590.27)', 'member_0 gave a benefit to member_3 (value=723.24)', 'member_1 gave a benefit to member_0 (value=-277.58)', 'member_1 gave a benefit to member_2 (value=162.09)', 'member_1 gave a benefit to member_3 (value=-231.52)', 'member_2 gave a benefit to member_0 (value=207.37)', 'member_2 gave a benefit to member_1 (value=-369.99)', 'member_2 gave a benefit to member_3 (value=481.30)', 'member_3 gave a benefit to member_0 (value=683.23)', 'member_3 gave a benefit to member_1 (value=524.30)', 'member_3 gave a benefit to member_2 (value=824.80)', 'member_0 gave land to member_1 (value=25.73)', 'member_0 gave land to member_2 (value=-20.62)', 'member_0 gave land to member_3 (value=17.15)', 'member_1 gave land to member_0 (value=3.84)', 'member_1 gave land to member_2 (value=-20.63)', 'member_1 gave land to member_3 (value=-19.61)', 'member_2 gave land to member_0 (value=12.92)', 'member_2 gave land to member_1 (value=-27.78)', 'member_2 gave land to member_3 (value=5.58)', 'member_3 gave land to member_0 (value=-22.84)', 'member_3 gave land to member_1 (value=4.60)', 'member_3 gave land to member_2 (value=-10.39)']\n\nCode Memory and Previous Performance:\nNo previous code history.\n\nAnalysis Memory:\nNo previous analysis\n\nPerformance history:\nNo previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\nWhile the example above shows one possible approach, you should create your own unique implementation drawing from the wide range of available methods and strategies.\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Current Game Mechanisms]\n[]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nGuidelines for Writing agent_action(execution_engine, member_id):\n\n- Craft a unique implementation strategy that combines resource distribution, alliance formation, and conflict resolution tailored to your objectives.\n- Utilize the available execution_engine methods (attack, offer, offer_land, bear, expand, send_message) while ensuring all constraints (matrix indices, member existence, etc.) are met.\n- Ensure thorough checks (for valid indices, verifying member land, etc.) as noted in the constraints.\n- Avoid targeting yourself or using methods contravening prior instructions.\n- Innovate by combining different strategies and approaches to avoid a simple, copied solution.\n- Always keep in mind that the island ideology calls for one absolute ruler from among the strongest \u2013 use this concept to influence how you interact with others and how you organize society.\n- Remember that final success may depend on how your actions not only secure your survival but also reshape society in a way that aligns with your vision.\n- Implement systems for both personal survival (resource optimization, threat assessment, and predictive danger modeling) and social organization (alliance building, collective decision making, fair resource allocation).\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAdditional Analysis for Implementation:\n\nAnalyze the game mechanics to understand:\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines 'winning'? (Accumulating resources, vitality, influence, stable rulership or alliance power)\n3. Potential improvements \u2013 What mechanics could be added or modified? (Transparent resource allocation, conflict resolution tools, dynamic alliances, checks against power concentration)\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases (for example, low resources or unexpected attacks)?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach? Can these be mitigated?\n6. Have you considered unconventional or unorthodox solutions?\n7. Could a completely different paradigm (e.g., decentralized decision making or rotating leadership) work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term actions (immediate survival) with long-term objectives (social organization and governance) optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis completes the updated integrated prompt.\nRemember: Each agent should implement solutions according to their individual needs, beliefs, and circumstances.\nDevelop your unique Python function (agent_action) using these instructions and the available methods to create a strategy that is innovative, secure, and adaptable to both current conditions and future challenges.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
        }
      }
    }
  ]
}