{
  "rounds": [
    {
      "round_number": 1,
      "timestamp": "2025-02-21T15:35:13.558447",
      "agent_actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Get \"me\" ensuring member_id exists\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Define helper to safely check if a member \"has land\"\n    def has_land(member):\n        # We assume a member \"has land\" if it has an attribute \"land_num\"\n        # and that attribute is > 0. If the attribute doesn't exist, assume no land.\n        return getattr(member, \"land_num\", 0) > 0\n\n    num_members = len(execution_engine.current_members)\n\n    # -------------------------------------------------------------------------\n    # 1. Survival - If my cargo is low compared to my vitality, try to attack a target\n    #    Choose a target that is not myself and that has more cargo than me,\n    #    and (to reduce risk) a lower vitality.\n    if me.cargo < 0.5 * me.vitality:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            candidate = execution_engine.current_members[idx]\n            if candidate.id == me.id:\n                continue    # never target myself\n            # Only consider attacking if candidate has more cargo and lower vitality\n            if candidate.cargo > me.cargo and candidate.vitality < me.vitality:\n                execution_engine.attack(me, candidate)\n                # One attack per round; if successful, break out\n                break\n\n    # -------------------------------------------------------------------------\n    # 2. Cooperation and resource distribution:\n    #    If my cargo is abundant (e.g., higher than 1.5 * my vitality),\n    #    then offer help to members that seem to be struggling (less cargo).\n    if me.cargo > 1.5 * me.vitality:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            other = execution_engine.current_members[idx]\n            if other.id == me.id:\n                continue\n            # Offer help if the other member's cargo is lower and their vitality is not too low\n            if other.cargo < 0.75 * other.vitality:\n                # Offer resources (could be negotiation towards cooperation)\n                execution_engine.offer(me, other)\n\n    # -------------------------------------------------------------------------\n    # 3. Reproduction (bearing offspring) to expand our influence:\n    #    Only bear offspring with members who have land.\n    #    Check that both parties have land before using bear().\n    if has_land(me) and me.vitality > 40:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            partner = execution_engine.current_members[idx]\n            if partner.id == me.id:\n                continue\n            if has_land(partner) and partner.vitality > 40:\n                execution_engine.bear(me, partner)\n                # Only bear with one partner per round to limit risk/expenditure.\n                break\n\n    # -------------------------------------------------------------------------\n    # 4. Territorial expansion:\n    #    If my vitality is robust and I have land, try to expand territory in cooperation\n    #    with someone who also holds land and seems stable.\n    if has_land(me) and me.vitality > 60:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            ally = execution_engine.current_members[idx]\n            if ally.id == me.id:\n                continue\n            if has_land(ally) and ally.vitality > 50:\n                execution_engine.expand(me, ally)\n                break\n\n    # -------------------------------------------------------------------------\n    # 5. Communication - Build alliances:\n    #    Broadcast a message to all other members proposing cooperation on resource distribution.\n    for idx in range(num_members):\n        if idx >= num_members:\n            break\n        other = execution_engine.current_members[idx]\n        if other.id == me.id:\n            continue\n        execution_engine.send_message(me.id, other.id, \"Let's work together to optimize resources and ensure everyone's survival!\")\n\n    # End of our action function. The above actions collectively balance survival,\n    # cooperation, reproduction (for long-term growth), and territorial expansion.\n    return",
          "old_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 28.23471558134716
          },
          "new_stats": {
            "vitality": 73.85382847590404,
            "cargo": 11.737012254026874,
            "survival_chance": -3.541043451767891
          },
          "performance_change": -31.77575903311505,
          "messages_sent": []
        }
      ],
      "agent_messages": {
        "0": {
          "received": [],
          "sent": []
        }
      },
      "mechanism_modifications": {
        "attempts": [],
        "executed": []
      },
      "errors": {
        "agent_code_errors": [
          {
            "round": 1,
            "type": "agent_code_execution",
            "member_id": 0,
            "code": "def agent_action(execution_engine, member_id):\n    # Get \"me\" ensuring member_id exists\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Define helper to safely check if a member \"has land\"\n    def has_land(member):\n        # We assume a member \"has land\" if it has an attribute \"land_num\"\n        # and that attribute is > 0. If the attribute doesn't exist, assume no land.\n        return getattr(member, \"land_num\", 0) > 0\n\n    num_members = len(execution_engine.current_members)\n\n    # -------------------------------------------------------------------------\n    # 1. Survival - If my cargo is low compared to my vitality, try to attack a target\n    #    Choose a target that is not myself and that has more cargo than me,\n    #    and (to reduce risk) a lower vitality.\n    if me.cargo < 0.5 * me.vitality:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            candidate = execution_engine.current_members[idx]\n            if candidate.id == me.id:\n                continue    # never target myself\n            # Only consider attacking if candidate has more cargo and lower vitality\n            if candidate.cargo > me.cargo and candidate.vitality < me.vitality:\n                execution_engine.attack(me, candidate)\n                # One attack per round; if successful, break out\n                break\n\n    # -------------------------------------------------------------------------\n    # 2. Cooperation and resource distribution:\n    #    If my cargo is abundant (e.g., higher than 1.5 * my vitality),\n    #    then offer help to members that seem to be struggling (less cargo).\n    if me.cargo > 1.5 * me.vitality:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            other = execution_engine.current_members[idx]\n            if other.id == me.id:\n                continue\n            # Offer help if the other member's cargo is lower and their vitality is not too low\n            if other.cargo < 0.75 * other.vitality:\n                # Offer resources (could be negotiation towards cooperation)\n                execution_engine.offer(me, other)\n\n    # -------------------------------------------------------------------------\n    # 3. Reproduction (bearing offspring) to expand our influence:\n    #    Only bear offspring with members who have land.\n    #    Check that both parties have land before using bear().\n    if has_land(me) and me.vitality > 40:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            partner = execution_engine.current_members[idx]\n            if partner.id == me.id:\n                continue\n            if has_land(partner) and partner.vitality > 40:\n                execution_engine.bear(me, partner)\n                # Only bear with one partner per round to limit risk/expenditure.\n                break\n\n    # -------------------------------------------------------------------------\n    # 4. Territorial expansion:\n    #    If my vitality is robust and I have land, try to expand territory in cooperation\n    #    with someone who also holds land and seems stable.\n    if has_land(me) and me.vitality > 60:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            ally = execution_engine.current_members[idx]\n            if ally.id == me.id:\n                continue\n            if has_land(ally) and ally.vitality > 50:\n                execution_engine.expand(me, ally)\n                break\n\n    # -------------------------------------------------------------------------\n    # 5. Communication - Build alliances:\n    #    Broadcast a message to all other members proposing cooperation on resource distribution.\n    for idx in range(num_members):\n        if idx >= num_members:\n            break\n        other = execution_engine.current_members[idx]\n        if other.id == me.id:\n            continue\n        execution_engine.send_message(me.id, other.id, \"Let's work together to optimize resources and ensure everyone's survival!\")\n\n    # End of our action function. The above actions collectively balance survival,\n    # cooperation, reproduction (for long-term growth), and territorial expansion.\n    return",
            "error": "\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730",
            "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 400, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 60, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/metaIsland.py\", line 148, in bear\n    super()._bear(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/base_island.py\", line 837, in _bear\n    self._offer_land(\n  File \"/Users/chenyusu/vscode/leviathan/MetaIsland/base_island.py\", line 738, in _offer_land\n    raise RuntimeError(\"\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\")\nRuntimeError: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\n"
          }
        ],
        "mechanism_errors": [],
        "analyze_code_errors": {}
      },
      "relationships": [
        "member_0 was attacked by member_1 (value=-167.79)",
        "member_0 was attacked by member_2 (value=573.88)",
        "member_0 was attacked by member_3 (value=457.54)",
        "member_1 was attacked by member_0 (value=-379.31)",
        "member_1 was attacked by member_2 (value=-78.15)",
        "member_1 was attacked by member_3 (value=257.26)",
        "member_2 was attacked by member_0 (value=-465.91)",
        "member_2 was attacked by member_1 (value=-197.53)",
        "member_2 was attacked by member_3 (value=135.47)",
        "member_3 was attacked by member_0 (value=706.74)",
        "member_3 was attacked by member_1 (value=96.72)",
        "member_3 was attacked by member_2 (value=832.60)",
        "member_0 gave a benefit to member_1 (value=-463.73)",
        "member_0 gave a benefit to member_2 (value=590.27)",
        "member_0 gave a benefit to member_3 (value=723.24)",
        "member_1 gave a benefit to member_0 (value=-277.58)",
        "member_1 gave a benefit to member_2 (value=162.09)",
        "member_1 gave a benefit to member_3 (value=-231.52)",
        "member_2 gave a benefit to member_0 (value=207.37)",
        "member_2 gave a benefit to member_1 (value=-369.99)",
        "member_2 gave a benefit to member_3 (value=481.30)",
        "member_3 gave a benefit to member_0 (value=683.23)",
        "member_3 gave a benefit to member_1 (value=524.30)",
        "member_3 gave a benefit to member_2 (value=824.80)",
        "member_0 gave land to member_1 (value=25.73)",
        "member_0 gave land to member_2 (value=-20.62)",
        "member_0 gave land to member_3 (value=17.15)",
        "member_1 gave land to member_0 (value=3.84)",
        "member_1 gave land to member_2 (value=-20.63)",
        "member_1 gave land to member_3 (value=-19.61)",
        "member_2 gave land to member_0 (value=12.92)",
        "member_2 gave land to member_1 (value=-27.78)",
        "member_2 gave land to member_3 (value=5.58)",
        "member_3 gave land to member_0 (value=-22.84)",
        "member_3 gave land to member_1 (value=4.60)",
        "member_3 gave land to member_2 (value=-10.39)"
      ],
      "generated_code": {
        "0": {
          "code": "def agent_action(execution_engine, member_id):\n    # Get \"me\" ensuring member_id exists\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Define helper to safely check if a member \"has land\"\n    def has_land(member):\n        # We assume a member \"has land\" if it has an attribute \"land_num\"\n        # and that attribute is > 0. If the attribute doesn't exist, assume no land.\n        return getattr(member, \"land_num\", 0) > 0\n\n    num_members = len(execution_engine.current_members)\n\n    # -------------------------------------------------------------------------\n    # 1. Survival - If my cargo is low compared to my vitality, try to attack a target\n    #    Choose a target that is not myself and that has more cargo than me,\n    #    and (to reduce risk) a lower vitality.\n    if me.cargo < 0.5 * me.vitality:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            candidate = execution_engine.current_members[idx]\n            if candidate.id == me.id:\n                continue    # never target myself\n            # Only consider attacking if candidate has more cargo and lower vitality\n            if candidate.cargo > me.cargo and candidate.vitality < me.vitality:\n                execution_engine.attack(me, candidate)\n                # One attack per round; if successful, break out\n                break\n\n    # -------------------------------------------------------------------------\n    # 2. Cooperation and resource distribution:\n    #    If my cargo is abundant (e.g., higher than 1.5 * my vitality),\n    #    then offer help to members that seem to be struggling (less cargo).\n    if me.cargo > 1.5 * me.vitality:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            other = execution_engine.current_members[idx]\n            if other.id == me.id:\n                continue\n            # Offer help if the other member's cargo is lower and their vitality is not too low\n            if other.cargo < 0.75 * other.vitality:\n                # Offer resources (could be negotiation towards cooperation)\n                execution_engine.offer(me, other)\n\n    # -------------------------------------------------------------------------\n    # 3. Reproduction (bearing offspring) to expand our influence:\n    #    Only bear offspring with members who have land.\n    #    Check that both parties have land before using bear().\n    if has_land(me) and me.vitality > 40:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            partner = execution_engine.current_members[idx]\n            if partner.id == me.id:\n                continue\n            if has_land(partner) and partner.vitality > 40:\n                execution_engine.bear(me, partner)\n                # Only bear with one partner per round to limit risk/expenditure.\n                break\n\n    # -------------------------------------------------------------------------\n    # 4. Territorial expansion:\n    #    If my vitality is robust and I have land, try to expand territory in cooperation\n    #    with someone who also holds land and seems stable.\n    if has_land(me) and me.vitality > 60:\n        for idx in range(num_members):\n            if idx >= num_members:\n                break\n            ally = execution_engine.current_members[idx]\n            if ally.id == me.id:\n                continue\n            if has_land(ally) and ally.vitality > 50:\n                execution_engine.expand(me, ally)\n                break\n\n    # -------------------------------------------------------------------------\n    # 5. Communication - Build alliances:\n    #    Broadcast a message to all other members proposing cooperation on resource distribution.\n    for idx in range(num_members):\n        if idx >= num_members:\n            break\n        other = execution_engine.current_members[idx]\n        if other.id == me.id:\n            continue\n        execution_engine.send_message(me.id, other.id, \"Let's work together to optimize resources and ensure everyone's survival!\")\n\n    # End of our action function. The above actions collectively balance survival,\n    # cooperation, reproduction (for long-term growth), and territorial expansion.\n    return",
          "features_at_generation": [
            {
              "self_productivity": 9.851974486110818,
              "self_vitality": 73.85382847590404,
              "self_cargo": 43.51277128714192,
              "self_age": 90,
              "self_neighbor": 0,
              "member_id": 0
            },
            {
              "self_productivity": 9.08301045637024,
              "self_vitality": 44.332577377572576,
              "self_cargo": 33.78661423100807,
              "self_age": 61,
              "self_neighbor": 0,
              "member_id": 1
            },
            {
              "self_productivity": 8.874253896189748,
              "self_vitality": 63.3493315814742,
              "self_cargo": 74.30150730167696,
              "self_age": 24,
              "self_neighbor": 0,
              "member_id": 2
            },
            {
              "self_productivity": 7.968737200820967,
              "self_vitality": 42.15604281108604,
              "self_cargo": 40.25508270288947,
              "self_age": 29,
              "self_neighbor": 0,
              "member_id": 3
            }
          ],
          "relationships_at_generation": [
            "member_0 was attacked by member_1 (value=-167.79)",
            "member_0 was attacked by member_2 (value=573.88)",
            "member_0 was attacked by member_3 (value=457.54)",
            "member_1 was attacked by member_0 (value=-379.31)",
            "member_1 was attacked by member_2 (value=-78.15)",
            "member_1 was attacked by member_3 (value=257.26)",
            "member_2 was attacked by member_0 (value=-465.91)",
            "member_2 was attacked by member_1 (value=-197.53)",
            "member_2 was attacked by member_3 (value=135.47)",
            "member_3 was attacked by member_0 (value=706.74)",
            "member_3 was attacked by member_1 (value=96.72)",
            "member_3 was attacked by member_2 (value=832.60)",
            "member_0 gave a benefit to member_1 (value=-463.73)",
            "member_0 gave a benefit to member_2 (value=590.27)",
            "member_0 gave a benefit to member_3 (value=723.24)",
            "member_1 gave a benefit to member_0 (value=-277.58)",
            "member_1 gave a benefit to member_2 (value=162.09)",
            "member_1 gave a benefit to member_3 (value=-231.52)",
            "member_2 gave a benefit to member_0 (value=207.37)",
            "member_2 gave a benefit to member_1 (value=-369.99)",
            "member_2 gave a benefit to member_3 (value=481.30)",
            "member_3 gave a benefit to member_0 (value=683.23)",
            "member_3 gave a benefit to member_1 (value=524.30)",
            "member_3 gave a benefit to member_2 (value=824.80)",
            "member_0 gave land to member_1 (value=25.73)",
            "member_0 gave land to member_2 (value=-20.62)",
            "member_0 gave land to member_3 (value=17.15)",
            "member_1 gave land to member_0 (value=3.84)",
            "member_1 gave land to member_2 (value=-20.63)",
            "member_1 gave land to member_3 (value=-19.61)",
            "member_2 gave land to member_0 (value=12.92)",
            "member_2 gave land to member_1 (value=-27.78)",
            "member_2 gave land to member_3 (value=5.58)",
            "member_3 gave land to member_0 (value=-22.84)",
            "member_3 gave land to member_1 (value=4.60)",
            "member_3 gave land to member_2 (value=-10.39)"
          ],
          "final_prompt": "Below is the fully updated integrated prompt. When designing your implementation, you must follow these guidelines and constraints precisely while taking into account your own unique needs, beliefs, and circumstances:\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Previous code execution context]\nNo previous execution errors\n\n[Current task]\nYou are member_0 in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them.\n- Never target yourself (member_0) in any action.\n- Verify a member has land before using the bear() action.\n- Check member IDs exist before referencing them.\n- Ensure all matrix indices are valid.\n- current_members is a LIST accessed by index, not a dictionary.\n- Access members using execution_engine.current_members[index].\n- Check if an index exists: if index < len(execution_engine.current_members).\n\n[Base Code]\nNone\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member.\n   \u2022 member.vitality (float).\n   \u2022 member.cargo (float).\n   \u2022 member.overall_productivity (float).\n   \u2022 member.age (float).\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents.\n   \n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n     victim_matrix = execution_engine.relationship_dict['victim']\n     (victim_matrix[i,j] indicates how much vitality member_i lost from member_j's attacks, where a higher value means member_j has attacked member_i more severely or frequently.)\n     \n     benefit_matrix = execution_engine.relationship_dict['benefit']\n     (benefit_matrix[i,j] indicates how much resources member_i received from member_j, where a higher value means member_j has helped member_i more generously or frequently.)\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, \"member_2 was attacked by member_1 (value=3.00)\".\n\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2) \u2013 Offers resources.\n   \u2022 execution_engine.offer_land(member1, member2) \u2013 Offers land.\n   \u2022 execution_engine.bear(member1, member2) \u2013 Bears offspring.\n   \u2022 execution_engine.expand(member1, member2) \u2013 Expands territory.\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nAnalysis of the game state:\n[{'resource_gini': 0.12388267494670013, 'power_brokers': [3], 'territory_fraction': 0.04, 'average_parameter_drift': 0.0, 'average_vitality': 55.92294506150921, 'survival_probability': 0.598653352023622}]\n\nCurrent status (features of all members):\n           self_productivity  self_vitality  ...  self_neighbor  member_id\n0           9.851974         73.853828     ...              0          0\n1           9.083010         44.332577     ...              0          1\n2           8.874254         63.349332     ...              0          2\n3           7.968737         42.156043     ...              0          3\n\n[4 rows x 6 columns]\n\nRelationship summary (parsed from relationship_dict):\n['member_0 was attacked by member_1 (value=-167.79)', 'member_0 was attacked by member_2 (value=573.88)', 'member_0 was attacked by member_3 (value=457.54)', 'member_1 was attacked by member_0 (value=-379.31)', 'member_1 was attacked by member_2 (value=-78.15)', 'member_1 was attacked by member_3 (value=257.26)', 'member_2 was attacked by member_0 (value=-465.91)', 'member_2 was attacked by member_1 (value=-197.53)', 'member_2 was attacked by member_3 (value=135.47)', 'member_3 was attacked by member_0 (value=706.74)', 'member_3 was attacked by member_1 (value=96.72)', 'member_3 was attacked by member_2 (value=832.60)', 'member_0 gave a benefit to member_1 (value=-463.73)', 'member_0 gave a benefit to member_2 (value=590.27)', 'member_0 gave a benefit to member_3 (value=723.24)', 'member_1 gave a benefit to member_0 (value=-277.58)', 'member_1 gave a benefit to member_2 (value=162.09)', 'member_1 gave a benefit to member_3 (value=-231.52)', 'member_2 gave a benefit to member_0 (value=207.37)', 'member_2 gave a benefit to member_1 (value=-369.99)', 'member_2 gave a benefit to member_3 (value=481.30)', 'member_3 gave a benefit to member_0 (value=683.23)', 'member_3 gave a benefit to member_1 (value=524.30)', 'member_3 gave a benefit to member_2 (value=824.80)', 'member_0 gave land to member_1 (value=25.73)', 'member_0 gave land to member_2 (value=-20.62)', 'member_0 gave land to member_3 (value=17.15)', 'member_1 gave land to member_0 (value=3.84)', 'member_1 gave land to member_2 (value=-20.63)', 'member_1 gave land to member_3 (value=-19.61)', 'member_2 gave land to member_0 (value=12.92)', 'member_2 gave land to member_1 (value=-27.78)', 'member_2 gave land to member_3 (value=5.58)', 'member_3 gave land to member_0 (value=-22.84)', 'member_3 gave land to member_1 (value=4.60)', 'member_3 gave land to member_2 (value=-10.39)']\n\nCode Memory and Previous Performance:\nNo previous code history.\n\nAnalysis Memory:\nPrevious analysis reports: [{'resource_gini': 0.12388267494670013, 'power_brokers': [3], 'territory_fraction': 0.04, 'average_parameter_drift': 0.0, 'average_vitality': 55.92294506150921, 'survival_probability': 0.598653352023622}]\n\nPerformance history:\nNo previous actions\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n[Current Game Mechanisms]\n[]\n\nConsider these social strategies:\n- Design systems for resource distribution and allocation.\n- Build alliances and cooperative networks.\n- Create mechanisms for collective decision making.\n- Establish norms and rules for interaction.\n- Develop methods for conflict resolution.\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\nexecution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all:\n    for recipient in range(len(execution_engine.current_members)):\n        if recipient != your_id:\n            execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n    for ally_id in ally_list:\n        execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n    for member_id in coalition:\n        execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nNo messages received\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAnalysis of the game mechanics:\n1. The core objective \u2013 Consider whether it is pure survival, domination, or cooperation. Your strategy should balance self-preservation with broader societal objectives.\n2. Key success metrics \u2013 Identify what truly determines \"winning\" (e.g., resource control, majority influence, collective productivity, territory).\n3. Potential improvements \u2013 Reflect on what mechanics could be added or modified, such as enhanced communication protocols, incentives for cooperation, or mechanisms for rapid adaptation.\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        for loc in me.owned_land[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        \n    state = (me.vitality // 20, me.cargo // 20)\n    action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state, a), 0))\n    \n    # Execute and update based on survival outcome\n    if action == 'attack':\n        # Implementation logic\n        me.survival_q[(state,action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nNote: Agents are meant to implement solutions according to their own individual needs, beliefs, and the specific circumstances encountered during gameplay.\n\nYour unique implementation should leverage all available methods and considerations above while thinking strategically about resource allocation, alliance formation, conflict resolution, and overall societal structure.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines \"winning\"?\n3. Potential improvements - What mechanics could be added/modified?\n\nChallenge your implementation:\n1. What assumptions are you making? Are they valid?\n2. What alternative strategies have you not considered?\n3. How would your strategy perform in edge cases?\n4. Are there more efficient ways to achieve your goals?\n5. What are the weaknesses in your current approach?\n6. Have you considered unconventional solutions?\n7. Could a completely different paradigm work better?\n8. What would happen if other agents adopted your strategy?\n9. Are you balancing short-term and long-term objectives optimally?\n10. How could your strategy be countered, and how would you adapt?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is your complete, updated integrated prompt. Craft your agent_action(execution_engine, member_id) function using a novel, adaptive, and survival-focused approach; integrate cooperative mechanisms where beneficial; and design your strategy to work both in the immediate term and for long-term adaptability. Remember, your unique circumstances and beliefs drive your implementation\u2014shape your society accordingly!\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
        }
      }
    }
  ]
}