# Phase 4: Constitution, Receipt Signing, Federation Prep & Moderator APIs — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Establish formal trust model (Constitution), cryptographic receipt signing (Ed25519), federation-ready schemas, and moderator override APIs for the Leviathan world kernel.

**Architecture:** Constitution-first approach — build the 3-layer constitution object, then Ed25519 oracle signing, then federation-prep schema fields, then moderator APIs. Each component builds on the previous: moderator actions respect constitution constraints, receipts include constitution_hash and oracle signature.

**Tech Stack:** Python dataclasses, YAML (PyYAML), Ed25519 (cryptography.hazmat.primitives.asymmetric.ed25519), FastAPI, Pydantic, pytest

---

### Task 1: Constitution dataclass + YAML loading + hash

**Files:**
- Create: `kernel/constitution.py`
- Create: `kernel/constitution_default.yaml`
- Test: `test_world_kernel.py` (append)

**Context:** The Constitution is a 3-layer object (kernel/governance/world_rules). Kernel clauses are immutable. Governance clauses are amendable via judge-approved mechanisms. World rules are open. The hash goes into every RoundReceipt.

**Step 1: Write the failing tests**

Append to `test_world_kernel.py`:

```python
# ──────────────────────────────────────────────
# Phase 4 – Constitution tests
# ──────────────────────────────────────────────

from kernel.constitution import Constitution, load_constitution


class TestConstitution:
    def test_default_constitution_has_kernel_clauses(self):
        c = Constitution.default()
        assert "energy_conservation" in c.kernel_clauses
        assert "identity_permanence" in c.kernel_clauses
        assert "determinism" in c.kernel_clauses

    def test_default_constitution_has_governance_clauses(self):
        c = Constitution.default()
        assert "proposal_limit" in c.governance_clauses

    def test_default_constitution_has_world_rules(self):
        c = Constitution.default()
        assert len(c.world_rules) >= 0  # may start empty

    def test_constitution_hash_is_deterministic(self):
        c1 = Constitution.default()
        c2 = Constitution.default()
        assert c1.compute_hash() == c2.compute_hash()
        assert len(c1.compute_hash()) == 64  # SHA-256 hex

    def test_amend_governance_changes_hash(self):
        c = Constitution.default()
        h1 = c.compute_hash()
        c.amend_governance("new_rule", "Some new governance rule")
        h2 = c.compute_hash()
        assert h1 != h2
        assert c.version == 2  # started at 1, incremented

    def test_amend_kernel_raises(self):
        c = Constitution.default()
        with pytest.raises(ValueError, match="[Kk]ernel"):
            c.amend_kernel("energy_conservation", "modified")

    def test_amend_world_rules(self):
        c = Constitution.default()
        h1 = c.compute_hash()
        c.amend_world_rules("trade_fee", "10% fee on trades")
        h2 = c.compute_hash()
        assert h1 != h2
        assert c.world_rules["trade_fee"] == "10% fee on trades"

    def test_load_from_yaml(self, tmp_path):
        yaml_content = """
kernel_clauses:
  test_immutable: "Cannot be changed"
governance_clauses:
  test_gov: "Can be amended"
world_rules:
  test_rule: "Open rule"
"""
        yaml_file = tmp_path / "constitution.yaml"
        yaml_file.write_text(yaml_content)
        c = load_constitution(str(yaml_file))
        assert c.kernel_clauses["test_immutable"] == "Cannot be changed"
        assert c.governance_clauses["test_gov"] == "Can be amended"
        assert c.world_rules["test_rule"] == "Open rule"
```

**Step 2: Run tests to verify they fail**

Run: `pytest test_world_kernel.py::TestConstitution -v`
Expected: FAIL with `ModuleNotFoundError: No module named 'kernel.constitution'`

**Step 3: Create the default YAML**

Create `kernel/constitution_default.yaml`:

```yaml
kernel_clauses:
  energy_conservation: "Total vitality cannot be created from nothing"
  identity_permanence: "Agent IDs are permanent and unique"
  determinism: "Same seed + same actions = same outcome"

governance_clauses:
  max_tax_rate: "No mechanism may extract more than 50% of an agent's vitality"
  proposal_limit: "One mechanism proposal per agent per round"

world_rules: {}
```

**Step 4: Implement Constitution**

Create `kernel/constitution.py`:

```python
"""Three-layer constitution: kernel (immutable), governance (amendable), world rules (open)."""

import hashlib
import json
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict

import yaml


_DEFAULT_YAML = Path(__file__).parent / "constitution_default.yaml"


@dataclass
class Constitution:
    kernel_clauses: Dict[str, str] = field(default_factory=dict)
    governance_clauses: Dict[str, str] = field(default_factory=dict)
    world_rules: Dict[str, str] = field(default_factory=dict)
    version: int = 1

    @classmethod
    def default(cls) -> "Constitution":
        return load_constitution(str(_DEFAULT_YAML))

    def compute_hash(self) -> str:
        canonical = json.dumps(
            {
                "kernel_clauses": self.kernel_clauses,
                "governance_clauses": self.governance_clauses,
                "world_rules": self.world_rules,
                "version": self.version,
            },
            sort_keys=True,
            separators=(",", ":"),
            ensure_ascii=False,
        ).encode("utf-8")
        return hashlib.sha256(canonical).hexdigest()

    def amend_governance(self, key: str, value: str) -> None:
        self.governance_clauses[key] = value
        self.version += 1

    def amend_world_rules(self, key: str, value: str) -> None:
        self.world_rules[key] = value
        self.version += 1

    def amend_kernel(self, key: str, value: str) -> None:
        raise ValueError("Kernel clauses are immutable and cannot be amended")


def load_constitution(path: str) -> Constitution:
    with open(path, "r") as f:
        data = yaml.safe_load(f)
    return Constitution(
        kernel_clauses=data.get("kernel_clauses", {}),
        governance_clauses=data.get("governance_clauses", {}),
        world_rules=data.get("world_rules", {}),
    )
```

**Step 5: Run tests to verify they pass**

Run: `pytest test_world_kernel.py::TestConstitution -v`
Expected: 8 PASSED

**Step 6: Commit**

```bash
git add kernel/constitution.py kernel/constitution_default.yaml test_world_kernel.py
git commit -m "feat: add Constitution dataclass with 3-layer model and YAML loading"
```

---

### Task 2: OracleIdentity — Ed25519 keypair, sign, verify

**Files:**
- Create: `kernel/oracle.py`
- Test: `test_world_kernel.py` (append)

**Context:** Each world gets an Ed25519 keypair. Deterministic from seed when provided. Signs receipts for federation trust.

**Step 1: Write the failing tests**

Append to `test_world_kernel.py`:

```python
from kernel.oracle import OracleIdentity


class TestOracleIdentity:
    def test_generate_produces_hex_public_key(self):
        oracle = OracleIdentity.generate()
        assert isinstance(oracle.world_public_key, str)
        assert len(oracle.world_public_key) == 64  # 32 bytes hex

    def test_deterministic_from_seed(self):
        o1 = OracleIdentity.from_seed(42)
        o2 = OracleIdentity.from_seed(42)
        assert o1.world_public_key == o2.world_public_key

    def test_different_seeds_different_keys(self):
        o1 = OracleIdentity.from_seed(42)
        o2 = OracleIdentity.from_seed(99)
        assert o1.world_public_key != o2.world_public_key

    def test_sign_and_verify(self):
        oracle = OracleIdentity.generate()
        data = b"hello world"
        sig = oracle.sign(data)
        assert isinstance(sig, str)
        assert oracle.verify(data, sig) is True

    def test_tampered_data_fails_verification(self):
        oracle = OracleIdentity.generate()
        sig = oracle.sign(b"original data")
        assert oracle.verify(b"tampered data", sig) is False

    def test_verify_with_public_key_only(self):
        oracle = OracleIdentity.generate()
        data = b"test payload"
        sig = oracle.sign(data)
        # Verify using only the public key (simulating a remote verifier)
        assert OracleIdentity.verify_with_public_key(
            oracle.world_public_key, data, sig
        ) is True
```

**Step 2: Run tests to verify they fail**

Run: `pytest test_world_kernel.py::TestOracleIdentity -v`
Expected: FAIL with `ModuleNotFoundError: No module named 'kernel.oracle'`

**Step 3: Implement OracleIdentity**

Create `kernel/oracle.py`:

```python
"""Ed25519 oracle identity for world receipt signing."""

import hashlib
from dataclasses import dataclass

from cryptography.hazmat.primitives.asymmetric.ed25519 import (
    Ed25519PrivateKey,
    Ed25519PublicKey,
)
from cryptography.hazmat.primitives import serialization
from cryptography.exceptions import InvalidSignature


@dataclass
class OracleIdentity:
    world_public_key: str  # hex-encoded 32-byte Ed25519 public key
    _private_key: Ed25519PrivateKey = None

    def sign(self, data: bytes) -> str:
        """Sign data and return hex-encoded signature."""
        sig_bytes = self._private_key.sign(data)
        return sig_bytes.hex()

    def verify(self, data: bytes, signature: str) -> bool:
        """Verify a hex-encoded signature against this oracle's public key."""
        return self.verify_with_public_key(self.world_public_key, data, signature)

    @staticmethod
    def verify_with_public_key(public_key_hex: str, data: bytes, signature: str) -> bool:
        """Verify using only the public key (for remote verification)."""
        try:
            pub_bytes = bytes.fromhex(public_key_hex)
            pub_key = Ed25519PublicKey.from_public_bytes(pub_bytes)
            sig_bytes = bytes.fromhex(signature)
            pub_key.verify(sig_bytes, data)
            return True
        except (InvalidSignature, ValueError):
            return False

    @classmethod
    def generate(cls) -> "OracleIdentity":
        """Generate a new random Ed25519 keypair."""
        private_key = Ed25519PrivateKey.generate()
        pub_bytes = private_key.public_key().public_bytes(
            serialization.Encoding.Raw, serialization.PublicFormat.Raw
        )
        return cls(world_public_key=pub_bytes.hex(), _private_key=private_key)

    @classmethod
    def from_seed(cls, seed: int) -> "OracleIdentity":
        """Deterministic keypair from seed.

        Derives a 32-byte Ed25519 seed from the integer seed via SHA-256,
        then constructs the private key from that fixed seed.
        """
        seed_bytes = hashlib.sha256(f"oracle-{seed}".encode()).digest()
        private_key = Ed25519PrivateKey.from_private_bytes(seed_bytes)
        pub_bytes = private_key.public_key().public_bytes(
            serialization.Encoding.Raw, serialization.PublicFormat.Raw
        )
        return cls(world_public_key=pub_bytes.hex(), _private_key=private_key)
```

**Step 4: Run tests to verify they pass**

Run: `pytest test_world_kernel.py::TestOracleIdentity -v`
Expected: 6 PASSED

**Step 5: Commit**

```bash
git add kernel/oracle.py test_world_kernel.py
git commit -m "feat: add OracleIdentity with Ed25519 keypair, sign, and verify"
```

---

### Task 3: Add constitution_hash + signature + federation fields to RoundReceipt

**Files:**
- Modify: `kernel/schemas.py:73-87`
- Modify: `api/models.py:17-30`
- Test: `test_world_kernel.py` (append)

**Context:** RoundReceipt gets 8 new Optional fields. Existing tests won't break because all fields default to None. The API response model must match.

**Step 1: Write the failing tests**

Append to `test_world_kernel.py`:

```python
class TestReceiptNewFields:
    def test_receipt_has_constitution_hash(self):
        receipt = RoundReceipt(
            round_id=1, seed=42,
            snapshot_hash_before="aa" * 32, snapshot_hash_after="bb" * 32,
            accepted_action_ids=[], rejected_action_ids=[],
            activated_mechanism_ids=[], judge_results=[], round_metrics={},
            timestamp="t1", constitution_hash="cc" * 32,
        )
        assert receipt.constitution_hash == "cc" * 32

    def test_receipt_has_oracle_signature(self):
        receipt = RoundReceipt(
            round_id=1, seed=42,
            snapshot_hash_before="aa" * 32, snapshot_hash_after="bb" * 32,
            accepted_action_ids=[], rejected_action_ids=[],
            activated_mechanism_ids=[], judge_results=[], round_metrics={},
            timestamp="t1", oracle_signature="dd" * 32,
        )
        assert receipt.oracle_signature == "dd" * 32

    def test_receipt_has_world_public_key(self):
        receipt = RoundReceipt(
            round_id=1, seed=42,
            snapshot_hash_before="aa" * 32, snapshot_hash_after="bb" * 32,
            accepted_action_ids=[], rejected_action_ids=[],
            activated_mechanism_ids=[], judge_results=[], round_metrics={},
            timestamp="t1", world_public_key="ee" * 16,
        )
        assert receipt.world_public_key == "ee" * 16

    def test_receipt_federation_fields_default_none(self):
        receipt = RoundReceipt(
            round_id=1, seed=42,
            snapshot_hash_before="a", snapshot_hash_after="b",
            accepted_action_ids=[], rejected_action_ids=[],
            activated_mechanism_ids=[], judge_results=[], round_metrics={},
            timestamp="t",
        )
        assert receipt.constitution_hash is None
        assert receipt.oracle_signature is None
        assert receipt.world_public_key is None
        assert receipt.origin_world_id is None
        assert receipt.origin_receipt_hash is None
        assert receipt.bridge_channel_id is None
        assert receipt.bridge_seq is None
        assert receipt.notary_signature is None
```

**Step 2: Run tests to verify they fail**

Run: `pytest test_world_kernel.py::TestReceiptNewFields -v`
Expected: FAIL with `TypeError: __init__() got an unexpected keyword argument 'constitution_hash'`

**Step 3: Add fields to RoundReceipt in `kernel/schemas.py`**

Add these fields after `timestamp: str` (line 86):

```python
    # Phase 4: Constitution + signing + federation prep
    constitution_hash: Optional[str] = None
    oracle_signature: Optional[str] = None
    world_public_key: Optional[str] = None
    # Federation fields (K8) — reserved, populated in Phase 5
    origin_world_id: Optional[str] = None
    origin_receipt_hash: Optional[str] = None
    bridge_channel_id: Optional[str] = None
    bridge_seq: Optional[int] = None
    notary_signature: Optional[str] = None
```

**Step 4: Add matching fields to RoundReceiptResponse in `api/models.py`**

Add after `timestamp: str` (line 29):

```python
    # Phase 4 fields
    constitution_hash: Optional[str] = None
    oracle_signature: Optional[str] = None
    world_public_key: Optional[str] = None
    origin_world_id: Optional[str] = None
    origin_receipt_hash: Optional[str] = None
    bridge_channel_id: Optional[str] = None
    bridge_seq: Optional[int] = None
    notary_signature: Optional[str] = None
```

**Step 5: Run tests to verify they pass**

Run: `pytest test_world_kernel.py::TestReceiptNewFields -v`
Expected: 4 PASSED

**Step 6: Run full test suite to verify nothing broke**

Run: `pytest test_world_kernel.py test_api.py -v`
Expected: All 228 PASSED (existing tests unaffected because all new fields have defaults)

**Step 7: Commit**

```bash
git add kernel/schemas.py api/models.py test_world_kernel.py
git commit -m "feat: add constitution_hash, oracle signature, and federation fields to RoundReceipt"
```

---

### Task 4: Enrich EventEnvelope with world_id, phase, payload_hash, prev_event_hash (resolves A4)

**Files:**
- Modify: `api/models.py:39-47`
- Test: `test_api.py` (append)

**Context:** EventEnvelope gets 4 new Optional fields for federation-ready self-contained events. Existing code that creates EventEnvelope objects doesn't set these yet — that's fine, they're Optional.

**Step 1: Write the failing tests**

Append to `test_api.py`:

```python
# ──────────────────────────────────────────────
# Phase 4 – EventEnvelope enrichment tests
# ──────────────────────────────────────────────

class TestEventEnvelopeEnrichment:
    def test_event_envelope_new_fields_default_none(self):
        event = EventEnvelope(
            event_id=1, event_type="test", round_id=1,
            timestamp="t", payload={},
        )
        assert event.world_id is None
        assert event.phase is None
        assert event.payload_hash is None
        assert event.prev_event_hash is None

    def test_event_envelope_with_enriched_fields(self):
        event = EventEnvelope(
            event_id=1, event_type="round_settled", round_id=1,
            timestamp="t", payload={"key": "val"},
            world_id="w-123", phase="settlement",
            payload_hash="aa" * 32, prev_event_hash="bb" * 32,
        )
        assert event.world_id == "w-123"
        assert event.phase == "settlement"
        assert event.payload_hash == "aa" * 32
        assert event.prev_event_hash == "bb" * 32
```

**Step 2: Run tests to verify they fail**

Run: `pytest test_api.py::TestEventEnvelopeEnrichment -v`
Expected: FAIL with `unexpected keyword argument 'world_id'`

**Step 3: Add fields to EventEnvelope in `api/models.py`**

Add after `payload: Dict[str, Any]` (line 46):

```python
    # Phase 4: Federation-prep fields (A4)
    world_id: Optional[str] = None
    phase: Optional[str] = None
    payload_hash: Optional[str] = None
    prev_event_hash: Optional[str] = None
```

**Step 4: Run tests to verify they pass**

Run: `pytest test_api.py::TestEventEnvelopeEnrichment -v`
Expected: 2 PASSED

**Step 5: Run full suite**

Run: `pytest test_world_kernel.py test_api.py -v`
Expected: All tests PASSED

**Step 6: Commit**

```bash
git add api/models.py test_api.py
git commit -m "feat: enrich EventEnvelope with world_id, phase, payload_hash, prev_event_hash (A4)"
```

---

### Task 5: Wire Constitution + Oracle into WorldKernel + sign receipts

**Files:**
- Modify: `kernel/world_kernel.py:1-54` (imports + __init__)
- Modify: `kernel/world_kernel.py:278-325` (settle_round)
- Test: `test_world_kernel.py` (append)

**Context:** WorldKernel creates a Constitution and OracleIdentity in `__init__`. `settle_round` includes `constitution_hash` in the receipt and signs it with the oracle. The signature covers the canonical JSON of the receipt with `oracle_signature=None`.

**Step 1: Write the failing tests**

Append to `test_world_kernel.py`:

```python
from kernel.oracle import OracleIdentity


class TestKernelConstitutionAndSigning:
    @pytest.fixture
    def kernel(self, tmp_path):
        config = WorldConfig(init_member_number=5, land_shape=(10, 10), random_seed=42)
        return WorldKernel(config, save_path=str(tmp_path))

    def test_kernel_has_constitution(self, kernel):
        assert kernel.constitution is not None
        assert "energy_conservation" in kernel.constitution.kernel_clauses

    def test_kernel_has_oracle(self, kernel):
        assert kernel.oracle is not None
        assert len(kernel.oracle.world_public_key) == 64

    def test_deterministic_oracle_from_seed(self, tmp_path):
        k1 = WorldKernel(WorldConfig(init_member_number=5, land_shape=(10, 10), random_seed=42), str(tmp_path / "a"))
        k2 = WorldKernel(WorldConfig(init_member_number=5, land_shape=(10, 10), random_seed=42), str(tmp_path / "b"))
        assert k1.oracle.world_public_key == k2.oracle.world_public_key

    def test_receipt_has_constitution_hash(self, kernel):
        kernel.begin_round()
        receipt = kernel.settle_round(seed=1)
        assert receipt.constitution_hash is not None
        assert receipt.constitution_hash == kernel.constitution.compute_hash()

    def test_receipt_is_signed(self, kernel):
        kernel.begin_round()
        receipt = kernel.settle_round(seed=1)
        assert receipt.oracle_signature is not None
        assert receipt.world_public_key == kernel.oracle.world_public_key

    def test_receipt_signature_is_verifiable(self, kernel):
        kernel.begin_round()
        receipt = kernel.settle_round(seed=1)
        # Rebuild canonical receipt without signature for verification
        import dataclasses, json
        d = dataclasses.asdict(receipt)
        d["oracle_signature"] = None
        canonical = json.dumps(d, sort_keys=True, separators=(",", ":"),
                               ensure_ascii=False, default=str).encode("utf-8")
        assert OracleIdentity.verify_with_public_key(
            receipt.world_public_key, canonical, receipt.oracle_signature
        ) is True
```

**Step 2: Run tests to verify they fail**

Run: `pytest test_world_kernel.py::TestKernelConstitutionAndSigning -v`
Expected: FAIL with `AttributeError: 'WorldKernel' object has no attribute 'constitution'`

**Step 3: Wire into WorldKernel**

In `kernel/world_kernel.py`:

Add imports at top:
```python
from kernel.constitution import Constitution
from kernel.oracle import OracleIdentity
```

In `__init__`, after `self._last_receipt = None` (line 53), add:
```python
        self._constitution = Constitution.default()
        if config.random_seed is not None:
            self._oracle = OracleIdentity.from_seed(config.random_seed)
        else:
            self._oracle = OracleIdentity.generate()
```

Add properties after `round_id` property:
```python
    @property
    def constitution(self) -> Constitution:
        return self._constitution

    @property
    def oracle(self) -> OracleIdentity:
        return self._oracle
```

In `settle_round`, modify the receipt construction to include constitution_hash and world_public_key:
```python
        receipt = RoundReceipt(
            round_id=self._round_id,
            seed=seed,
            snapshot_hash_before=snap_before.state_hash,
            snapshot_hash_after=snap_after.state_hash,
            accepted_action_ids=accepted_ids,
            rejected_action_ids=rejected_ids,
            activated_mechanism_ids=[],
            judge_results=judge_results or [],
            round_metrics=metrics,
            timestamp=deterministic_ts,
            constitution_hash=self._constitution.compute_hash(),
            world_public_key=self._oracle.world_public_key,
        )

        # Sign the receipt
        receipt_dict = dataclasses.asdict(receipt)
        receipt_dict["oracle_signature"] = None  # exclude sig from signed data
        import json
        canonical = json.dumps(receipt_dict, sort_keys=True, separators=(",", ":"),
                               ensure_ascii=False, default=str).encode("utf-8")
        receipt.oracle_signature = self._oracle.sign(canonical)

        self._last_receipt = receipt
        return receipt
```

Note: Move `import json` to the top-level imports instead of inline.

**Step 4: Run tests to verify they pass**

Run: `pytest test_world_kernel.py::TestKernelConstitutionAndSigning -v`
Expected: 6 PASSED

**Step 5: Run full suite**

Run: `pytest test_world_kernel.py test_api.py -v`
Expected: All tests PASSED

**Step 6: Commit**

```bash
git add kernel/world_kernel.py test_world_kernel.py
git commit -m "feat: wire Constitution + OracleIdentity into WorldKernel, sign receipts"
```

---

### Task 6: Expose world_public_key in API + verify receipt fields flow through

**Files:**
- Modify: `api/routes/world.py:13-23`
- Test: `test_api.py` (append)

**Context:** The `GET /v1/world` endpoint should include `world_public_key` so clients can verify receipt signatures. The snapshot endpoint already returns `dataclasses.asdict()` which will include the new receipt fields automatically, but `WorldInfo` needs a new field.

**Step 1: Write the failing tests**

Append to `test_api.py`:

```python
class TestPhase4WorldEndpoint:
    @pytest.fixture
    def client(self, tmp_path):
        """Create a test client with a kernel."""
        from scripts.run_server import build_app
        from fastapi.testclient import TestClient
        app = build_app(members=5, land_w=10, land_h=10, seed=42)
        return TestClient(app)

    def test_world_info_has_public_key(self, client):
        resp = client.get("/v1/world")
        assert resp.status_code == 200
        data = resp.json()
        assert "world_public_key" in data
        assert len(data["world_public_key"]) == 64

    def test_receipt_fields_in_api(self, client):
        """After settling a round, receipt should have constitution_hash and signature."""
        kernel = client.app.state.leviathan["kernel"]
        kernel.begin_round()
        receipt = kernel.settle_round(seed=1)
        resp = client.get("/v1/world/rounds/current")
        assert resp.status_code == 200
        data = resp.json()
        lr = data["last_receipt"]
        assert lr["constitution_hash"] is not None
        assert lr["oracle_signature"] is not None
        assert lr["world_public_key"] is not None
```

**Step 2: Run tests to verify they fail**

Run: `pytest test_api.py::TestPhase4WorldEndpoint -v`
Expected: FAIL (WorldInfo doesn't have world_public_key field)

**Step 3: Add world_public_key to WorldInfo model**

In `api/models.py`, add to `WorldInfo` class after `state_hash: str`:
```python
    world_public_key: Optional[str] = None
```

**Step 4: Update get_world_info route**

In `api/routes/world.py`, modify `get_world_info` to include the public key:
```python
@router.get("", response_model=WorldInfo)
def get_world_info(request: Request) -> WorldInfo:
    """Return summary information about the current world state."""
    kernel = request.app.state.leviathan["kernel"]
    snapshot = kernel.get_snapshot()
    return WorldInfo(
        world_id=snapshot.world_id,
        round_id=snapshot.round_id,
        member_count=len(snapshot.members),
        state_hash=snapshot.state_hash,
        world_public_key=kernel.oracle.world_public_key,
    )
```

**Step 5: Run tests to verify they pass**

Run: `pytest test_api.py::TestPhase4WorldEndpoint -v`
Expected: 2 PASSED

**Step 6: Run full suite**

Run: `pytest test_world_kernel.py test_api.py -v`
Expected: All tests PASSED

**Step 7: Commit**

```bash
git add api/models.py api/routes/world.py test_api.py
git commit -m "feat: expose world_public_key in GET /v1/world and verify receipt fields"
```

---

### Task 7: Moderator auth — extend APIKeyAuth with moderator_keys

**Files:**
- Modify: `api/auth.py:11-39`
- Modify: `api/app.py:18-42`
- Test: `test_api.py` (append)

**Context:** APIKeyAuth needs to distinguish regular keys from moderator keys. A new `require_moderator` dependency rejects non-moderator callers with 403. The app factory must accept `moderator_keys` parameter.

**Step 1: Write the failing tests**

Append to `test_api.py`:

```python
from api.auth import APIKeyAuth


class TestModeratorAuth:
    def test_moderator_key_is_valid(self):
        auth = APIKeyAuth(api_keys={"agent1"}, moderator_keys={"mod1"})
        assert auth.is_moderator_key("mod1") is True
        assert auth.is_moderator_key("agent1") is False
        assert auth.is_moderator_key("unknown") is False

    def test_moderator_key_also_valid_as_regular(self):
        """Moderator keys should pass regular auth too."""
        auth = APIKeyAuth(api_keys={"agent1"}, moderator_keys={"mod1"})
        assert auth.is_valid_key("mod1") is True
        assert auth.is_valid_key("agent1") is True
        assert auth.is_valid_key("unknown") is False

    def test_auth_disabled_when_no_keys(self):
        auth = APIKeyAuth()
        assert auth.enabled is False

    def test_moderator_endpoint_rejects_agent_key(self, tmp_path):
        from scripts.run_server import build_app
        from fastapi.testclient import TestClient
        app = build_app(
            members=5, land_w=10, land_h=10, seed=42,
            api_keys={"agent1"}, moderator_keys={"mod1"},
        )
        client = TestClient(app)
        resp = client.get("/v1/admin/status", headers={"X-API-Key": "agent1"})
        assert resp.status_code == 403

    def test_moderator_endpoint_accepts_moderator_key(self, tmp_path):
        from scripts.run_server import build_app
        from fastapi.testclient import TestClient
        app = build_app(
            members=5, land_w=10, land_h=10, seed=42,
            api_keys={"agent1"}, moderator_keys={"mod1"},
        )
        client = TestClient(app)
        resp = client.get("/v1/admin/status", headers={"X-API-Key": "mod1"})
        assert resp.status_code == 200
```

**Step 2: Run tests to verify they fail**

Run: `pytest test_api.py::TestModeratorAuth -v`
Expected: FAIL (APIKeyAuth doesn't accept moderator_keys)

**Step 3: Extend APIKeyAuth in `api/auth.py`**

Replace the `APIKeyAuth` class:

```python
class APIKeyAuth:
    """Callable FastAPI dependency for API key authentication.

    Supports two tiers: regular API keys and moderator keys.
    Moderator keys pass regular auth checks too.
    When no keys are configured, authentication is disabled.
    """

    def __init__(self, api_keys=None, moderator_keys=None):
        self.api_keys: Set[str] = api_keys or set()
        self.moderator_keys: Set[str] = moderator_keys or set()
        self.enabled = bool(self.api_keys or self.moderator_keys)

    def is_valid_key(self, key: str) -> bool:
        return key in self.api_keys or key in self.moderator_keys

    def is_moderator_key(self, key: str) -> bool:
        return key in self.moderator_keys

    def __call__(self, request: Request) -> None:
        if not self.enabled:
            return
        key = request.headers.get("X-API-Key") or request.query_params.get("api_key")
        if not key:
            raise HTTPException(status_code=401, detail="Missing API key")
        if not self.is_valid_key(key):
            raise HTTPException(status_code=403, detail="Invalid API key")

    def require_moderator(self, request: Request) -> None:
        """Dependency that requires a moderator API key."""
        if not self.enabled:
            return
        key = request.headers.get("X-API-Key") or request.query_params.get("api_key")
        if not key:
            raise HTTPException(status_code=401, detail="Missing API key")
        if not self.is_moderator_key(key):
            raise HTTPException(status_code=403, detail="Moderator access required")
```

**Step 4: Update `create_app` in `api/app.py` and `build_app` in `scripts/run_server.py`**

In `api/app.py`, add `moderator_keys` parameter:
```python
def create_app(
    kernel: WorldKernel,
    api_keys: Optional[Set[str]] = None,
    moderator_keys: Optional[Set[str]] = None,
    rate_limit: int = 60,
) -> FastAPI:
```
And: `app.state.auth = APIKeyAuth(api_keys, moderator_keys)`

In `scripts/run_server.py`, add `moderator_keys` to `build_app`:
```python
def build_app(
    members: int,
    land_w: int,
    land_h: int,
    seed: int,
    api_keys: Optional[Set[str]] = None,
    moderator_keys: Optional[Set[str]] = None,
    rate_limit: int = 60,
) -> FastAPI:
```
And pass `moderator_keys=moderator_keys` to `create_app`.

Note: The admin/status endpoint doesn't exist yet — create a stub in Task 8. For now, tests for `is_moderator_key` and `is_valid_key` should pass. The endpoint tests will fail until Task 8.

**Step 5: Run the non-endpoint tests**

Run: `pytest test_api.py::TestModeratorAuth::test_moderator_key_is_valid test_api.py::TestModeratorAuth::test_moderator_key_also_valid_as_regular test_api.py::TestModeratorAuth::test_auth_disabled_when_no_keys -v`
Expected: 3 PASSED

**Step 6: Commit (endpoint tests deferred to Task 8)**

```bash
git add api/auth.py api/app.py scripts/run_server.py test_api.py
git commit -m "feat: extend APIKeyAuth with moderator_keys and require_moderator"
```

---

### Task 8: ModeratorConfig + admin routes (pause, resume, ban, unban, status, rollback, quotas)

**Files:**
- Create: `kernel/moderator.py`
- Create: `api/routes/admin.py`
- Modify: `api/deps.py`
- Modify: `api/app.py`
- Modify: `api/models.py`
- Test: `test_api.py` (append)

**Context:** This is the largest task. ModeratorConfig stores moderator state (paused, banned_agents, quotas, snapshot_history). Admin routes use `require_moderator` dependency. Every admin action emits an event.

**Step 1: Write the failing tests**

Append to `test_api.py`:

```python
class TestAdminEndpoints:
    @pytest.fixture
    def mod_client(self, tmp_path):
        from scripts.run_server import build_app
        from fastapi.testclient import TestClient
        app = build_app(
            members=5, land_w=10, land_h=10, seed=42,
            api_keys={"agent1"}, moderator_keys={"mod1"},
        )
        return TestClient(app)

    def test_admin_status(self, mod_client):
        resp = mod_client.get("/v1/admin/status", headers={"X-API-Key": "mod1"})
        assert resp.status_code == 200
        data = resp.json()
        assert data["paused"] is False
        assert data["banned_agents"] == []
        assert "quotas" in data

    def test_admin_status_rejects_agent_key(self, mod_client):
        resp = mod_client.get("/v1/admin/status", headers={"X-API-Key": "agent1"})
        assert resp.status_code == 403

    def test_pause_and_resume(self, mod_client):
        resp = mod_client.post("/v1/admin/pause", headers={"X-API-Key": "mod1"})
        assert resp.status_code == 200
        status = mod_client.get("/v1/admin/status", headers={"X-API-Key": "mod1"}).json()
        assert status["paused"] is True

        resp = mod_client.post("/v1/admin/resume", headers={"X-API-Key": "mod1"})
        assert resp.status_code == 200
        status = mod_client.get("/v1/admin/status", headers={"X-API-Key": "mod1"}).json()
        assert status["paused"] is False

    def test_ban_and_unban(self, mod_client):
        resp = mod_client.post("/v1/admin/ban/1", headers={"X-API-Key": "mod1"})
        assert resp.status_code == 200
        status = mod_client.get("/v1/admin/status", headers={"X-API-Key": "mod1"}).json()
        assert 1 in status["banned_agents"]

        resp = mod_client.post("/v1/admin/unban/1", headers={"X-API-Key": "mod1"})
        assert resp.status_code == 200
        status = mod_client.get("/v1/admin/status", headers={"X-API-Key": "mod1"}).json()
        assert 1 not in status["banned_agents"]

    def test_update_quotas(self, mod_client):
        resp = mod_client.put(
            "/v1/admin/quotas",
            json={"max_actions_per_round": 3, "max_proposals_per_round": 1},
            headers={"X-API-Key": "mod1"},
        )
        assert resp.status_code == 200
        status = mod_client.get("/v1/admin/status", headers={"X-API-Key": "mod1"}).json()
        assert status["quotas"]["max_actions_per_round"] == 3

    def test_admin_actions_emit_events(self, mod_client):
        mod_client.post("/v1/admin/pause", headers={"X-API-Key": "mod1"})
        mod_client.post("/v1/admin/ban/1", headers={"X-API-Key": "mod1"})
        events = mod_client.get("/v1/world/events").json()
        admin_events = [e for e in events if e["event_type"].startswith("admin_")]
        assert len(admin_events) >= 2
        assert any(e["event_type"] == "admin_pause" for e in admin_events)
        assert any(e["event_type"] == "admin_ban" for e in admin_events)

    def test_admin_event_has_moderator_hash_not_key(self, mod_client):
        mod_client.post("/v1/admin/pause", headers={"X-API-Key": "mod1"})
        events = mod_client.get("/v1/world/events").json()
        admin_events = [e for e in events if e["event_type"] == "admin_pause"]
        assert len(admin_events) == 1
        payload = admin_events[0]["payload"]
        assert "moderator_key_hash" in payload
        assert payload["moderator_key_hash"] != "mod1"  # hash, not raw key
```

**Step 2: Run tests to verify they fail**

Run: `pytest test_api.py::TestAdminEndpoints -v`
Expected: FAIL (no admin routes)

**Step 3: Create ModeratorConfig**

Create `kernel/moderator.py`:

```python
"""Moderator configuration and state management."""

import hashlib
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set

from kernel.schemas import WorldSnapshot


@dataclass
class QuotaConfig:
    max_actions_per_round: int = 0      # 0 = unlimited
    max_proposals_per_round: int = 1


class ModeratorState:
    """Tracks moderator-controlled world state."""

    def __init__(self, max_snapshots: int = 10) -> None:
        self.paused: bool = False
        self.banned_agents: Set[int] = set()
        self.quotas: QuotaConfig = QuotaConfig()
        self._snapshot_history: List[WorldSnapshot] = []
        self._max_snapshots = max_snapshots

    def is_banned(self, agent_id: int) -> bool:
        return agent_id in self.banned_agents

    def ban(self, agent_id: int) -> None:
        self.banned_agents.add(agent_id)

    def unban(self, agent_id: int) -> None:
        self.banned_agents.discard(agent_id)

    def store_snapshot(self, snapshot: WorldSnapshot) -> None:
        self._snapshot_history.append(snapshot)
        if len(self._snapshot_history) > self._max_snapshots:
            self._snapshot_history.pop(0)

    def get_snapshot_for_round(self, round_id: int) -> Optional[WorldSnapshot]:
        for s in self._snapshot_history:
            if s.round_id == round_id:
                return s
        return None

    def to_dict(self) -> dict:
        return {
            "paused": self.paused,
            "banned_agents": sorted(self.banned_agents),
            "quotas": {
                "max_actions_per_round": self.quotas.max_actions_per_round,
                "max_proposals_per_round": self.quotas.max_proposals_per_round,
            },
            "snapshot_history_size": len(self._snapshot_history),
        }

    @staticmethod
    def hash_key(key: str) -> str:
        return hashlib.sha256(key.encode()).hexdigest()[:16]
```

**Step 4: Create admin API models**

Append to `api/models.py`:

```python
# ── Phase 4: Moderator / Admin models ────────────


class AdminStatusResponse(BaseModel):
    """Response from GET /v1/admin/status."""
    paused: bool
    banned_agents: List[int]
    quotas: Dict[str, Any]
    snapshot_history_size: int


class QuotaUpdateRequest(BaseModel):
    """Request body for PUT /v1/admin/quotas."""
    max_actions_per_round: Optional[int] = None
    max_proposals_per_round: Optional[int] = None
```

**Step 5: Create admin routes**

Create `api/routes/admin.py`:

```python
"""Moderator / admin endpoints for world management."""

import hashlib
from datetime import datetime, timezone
from typing import List

from fastapi import APIRouter, HTTPException, Request

from api.models import AdminStatusResponse, EventEnvelope, QuotaUpdateRequest

router = APIRouter(prefix="/v1/admin")


def _require_moderator(request: Request) -> str:
    """Check moderator key and return the key for audit logging."""
    auth = request.app.state.auth
    if not auth.enabled:
        return "open_access"
    key = request.headers.get("X-API-Key") or request.query_params.get("api_key")
    if not key:
        raise HTTPException(status_code=401, detail="Missing API key")
    if not auth.is_moderator_key(key):
        raise HTTPException(status_code=403, detail="Moderator access required")
    return key


def _emit_admin_event(request: Request, event_type: str, key: str, payload: dict) -> None:
    """Append an admin event to the event log."""
    from kernel.moderator import ModeratorState
    event_log: List[EventEnvelope] = request.app.state.leviathan["event_log"]
    event_log.append(EventEnvelope(
        event_id=len(event_log) + 1,
        event_type=event_type,
        round_id=request.app.state.leviathan["kernel"].round_id,
        timestamp=datetime.now(timezone.utc).isoformat(),
        payload={
            "moderator_key_hash": ModeratorState.hash_key(key),
            **payload,
        },
    ))


@router.get("/status", response_model=AdminStatusResponse)
def admin_status(request: Request):
    key = _require_moderator(request)
    mod_state = request.app.state.leviathan["moderator"]
    d = mod_state.to_dict()
    return AdminStatusResponse(**d)


@router.post("/pause")
def admin_pause(request: Request):
    key = _require_moderator(request)
    mod_state = request.app.state.leviathan["moderator"]
    mod_state.paused = True
    _emit_admin_event(request, "admin_pause", key, {"action": "pause"})
    return {"status": "paused"}


@router.post("/resume")
def admin_resume(request: Request):
    key = _require_moderator(request)
    mod_state = request.app.state.leviathan["moderator"]
    mod_state.paused = False
    _emit_admin_event(request, "admin_resume", key, {"action": "resume"})
    return {"status": "resumed"}


@router.post("/ban/{agent_id}")
def admin_ban(agent_id: int, request: Request):
    key = _require_moderator(request)
    mod_state = request.app.state.leviathan["moderator"]
    mod_state.ban(agent_id)
    _emit_admin_event(request, "admin_ban", key, {"agent_id": agent_id})
    return {"status": "banned", "agent_id": agent_id}


@router.post("/unban/{agent_id}")
def admin_unban(agent_id: int, request: Request):
    key = _require_moderator(request)
    mod_state = request.app.state.leviathan["moderator"]
    mod_state.unban(agent_id)
    _emit_admin_event(request, "admin_unban", key, {"agent_id": agent_id})
    return {"status": "unbanned", "agent_id": agent_id}


@router.put("/quotas")
def admin_update_quotas(body: QuotaUpdateRequest, request: Request):
    key = _require_moderator(request)
    mod_state = request.app.state.leviathan["moderator"]
    if body.max_actions_per_round is not None:
        mod_state.quotas.max_actions_per_round = body.max_actions_per_round
    if body.max_proposals_per_round is not None:
        mod_state.quotas.max_proposals_per_round = body.max_proposals_per_round
    _emit_admin_event(request, "admin_quotas", key, {
        "max_actions_per_round": mod_state.quotas.max_actions_per_round,
        "max_proposals_per_round": mod_state.quotas.max_proposals_per_round,
    })
    return {"status": "updated", "quotas": mod_state.to_dict()["quotas"]}


@router.post("/rollback")
def admin_rollback(request: Request, target_round: int = 0):
    key = _require_moderator(request)
    mod_state = request.app.state.leviathan["moderator"]
    kernel = request.app.state.leviathan["kernel"]

    if target_round <= 0:
        raise HTTPException(status_code=400, detail="target_round must be positive")

    snapshot = mod_state.get_snapshot_for_round(target_round)
    if snapshot is None:
        raise HTTPException(
            status_code=404,
            detail=f"No snapshot available for round {target_round}",
        )

    old_round = kernel.round_id
    kernel._round_id = target_round
    kernel._idempotency_cache = {}
    kernel._last_receipt = None

    _emit_admin_event(request, "admin_rollback", key, {
        "from_round": old_round,
        "to_round": target_round,
    })
    return {"status": "rolled_back", "from_round": old_round, "to_round": target_round}
```

**Step 6: Wire into deps and app**

In `api/deps.py`, add import and modify `create_app_state`:
```python
from kernel.moderator import ModeratorState
```
Add to the returned dict:
```python
        "moderator": ModeratorState(),
```

In `api/app.py`, add:
```python
from api.routes.admin import router as admin_router
```
And include: `app.include_router(admin_router)`

Also pass `moderator_keys` through to `APIKeyAuth`:
```python
    app.state.auth = APIKeyAuth(api_keys, moderator_keys)
```

**Step 7: Run tests to verify they pass**

Run: `pytest test_api.py::TestAdminEndpoints -v`
Expected: 7 PASSED

Also run the deferred moderator auth tests from Task 7:
Run: `pytest test_api.py::TestModeratorAuth -v`
Expected: 5 PASSED

**Step 8: Run full suite**

Run: `pytest test_world_kernel.py test_api.py -v`
Expected: All tests PASSED

**Step 9: Commit**

```bash
git add kernel/moderator.py api/routes/admin.py api/deps.py api/app.py api/models.py test_api.py
git commit -m "feat: add moderator APIs (pause, resume, ban, unban, quotas, rollback, status)"
```

---

### Task 9: Ban enforcement in action + mechanism submission routes

**Files:**
- Modify: `api/routes/actions.py:11-39`
- Modify: `api/routes/mechanisms.py:13-43`
- Test: `test_api.py` (append)

**Context:** When an agent is banned, their action submissions and mechanism proposals should be rejected with 403. Check `moderator.is_banned(member_id)` after resolving the agent's API key.

**Step 1: Write the failing tests**

Append to `test_api.py`:

```python
class TestBanEnforcement:
    @pytest.fixture
    def banned_client(self, tmp_path):
        from scripts.run_server import build_app
        from fastapi.testclient import TestClient
        app = build_app(
            members=5, land_w=10, land_h=10, seed=42,
            api_keys=set(), moderator_keys={"mod1"},
        )
        client = TestClient(app)
        # Register an agent
        resp = client.post("/v1/agents/register", json={"name": "test_agent"})
        assert resp.status_code == 200
        agent_key = resp.json()["api_key"]
        member_id = resp.json()["member_id"]
        # Start accepting round
        kernel = app.state.leviathan["kernel"]
        round_state = app.state.leviathan["round_state"]
        kernel.begin_round()
        round_state.open_submissions(round_id=kernel.round_id, pace=60.0)
        return client, agent_key, member_id

    def test_banned_agent_action_rejected(self, banned_client):
        client, agent_key, member_id = banned_client
        # Ban the agent
        client.post(f"/v1/admin/ban/{member_id}", headers={"X-API-Key": "mod1"})
        # Try to submit action
        resp = client.post(
            "/v1/world/actions",
            json={"code": "pass", "idempotency_key": "k1"},
            headers={"X-API-Key": agent_key},
        )
        assert resp.status_code == 403
        assert "banned" in resp.json()["detail"].lower()

    def test_banned_agent_proposal_rejected(self, banned_client):
        client, agent_key, member_id = banned_client
        client.post(f"/v1/admin/ban/{member_id}", headers={"X-API-Key": "mod1"})
        resp = client.post(
            "/v1/world/mechanisms/propose",
            json={"code": "pass", "description": "test", "idempotency_key": "k2"},
            headers={"X-API-Key": agent_key},
        )
        assert resp.status_code == 403

    def test_unbanned_agent_can_submit(self, banned_client):
        client, agent_key, member_id = banned_client
        client.post(f"/v1/admin/ban/{member_id}", headers={"X-API-Key": "mod1"})
        client.post(f"/v1/admin/unban/{member_id}", headers={"X-API-Key": "mod1"})
        resp = client.post(
            "/v1/world/actions",
            json={"code": "pass", "idempotency_key": "k3"},
            headers={"X-API-Key": agent_key},
        )
        assert resp.status_code == 200
```

**Step 2: Run tests to verify they fail**

Run: `pytest test_api.py::TestBanEnforcement -v`
Expected: FAIL (no ban check in routes)

**Step 3: Add ban check to actions route**

In `api/routes/actions.py`, after resolving the agent record (line 22), add:

```python
    # Check if agent is banned
    mod_state = request.app.state.leviathan["moderator"]
    if mod_state.is_banned(record.member_id):
        raise HTTPException(status_code=403, detail="Agent is banned")
```

**Step 4: Add ban check to mechanisms route**

In `api/routes/mechanisms.py`, after resolving the agent record (line 25), add:

```python
    # Check if agent is banned
    mod_state = request.app.state.leviathan["moderator"]
    if mod_state.is_banned(record.member_id):
        raise HTTPException(status_code=403, detail="Agent is banned")
```

**Step 5: Run tests to verify they pass**

Run: `pytest test_api.py::TestBanEnforcement -v`
Expected: 3 PASSED

**Step 6: Run full suite**

Run: `pytest test_world_kernel.py test_api.py -v`
Expected: All tests PASSED

**Step 7: Commit**

```bash
git add api/routes/actions.py api/routes/mechanisms.py test_api.py
git commit -m "feat: enforce ban in action and mechanism submission routes"
```

---

### Task 10: Sim loop respects paused flag + stores snapshots for rollback

**Files:**
- Modify: `scripts/run_server.py:51-165`
- Modify: `api/round_state.py`
- Test: `test_api.py` (append)

**Context:** The simulation loop should check `moderator.paused` at the top of each iteration and skip the round if paused. It should also store pre-settlement snapshots in the moderator state for rollback support.

**Step 1: Write the failing tests**

Append to `test_api.py`:

```python
class TestSimLoopPause:
    def test_round_state_has_paused(self):
        from api.round_state import RoundState
        rs = RoundState()
        assert hasattr(rs, "paused") or True  # RoundState doesn't own paused, moderator does

    def test_moderator_state_pause_flag(self):
        from kernel.moderator import ModeratorState
        ms = ModeratorState()
        assert ms.paused is False
        ms.paused = True
        assert ms.paused is True

    def test_moderator_stores_snapshots(self):
        from kernel.moderator import ModeratorState
        from kernel.schemas import WorldSnapshot
        ms = ModeratorState(max_snapshots=3)
        for i in range(5):
            snap = WorldSnapshot(
                world_id="w", round_id=i, members=[], land={},
                active_mechanisms=[], active_contracts=[],
                physics_constraints=[], state_hash=f"h{i}",
            )
            ms.store_snapshot(snap)
        # Only last 3 should be kept
        assert ms.get_snapshot_for_round(0) is None
        assert ms.get_snapshot_for_round(1) is None
        assert ms.get_snapshot_for_round(2) is not None
        assert ms.get_snapshot_for_round(4) is not None
```

**Step 2: Run tests to verify they fail/pass**

Run: `pytest test_api.py::TestSimLoopPause -v`
Expected: These should pass since ModeratorState was created in Task 8.

**Step 3: Update `_simulation_loop` in `scripts/run_server.py`**

Add `moderator` parameter and pause check. At the top of the while loop, after `while not stop_event.is_set():`, add:

```python
        # Check pause flag — sleep briefly and retry
        if moderator.paused:
            stop_event.wait(timeout=0.5)
            continue
```

Before `receipt = kernel.settle_round(...)`, store the pre-settlement snapshot:
```python
        # Store snapshot for potential rollback
        moderator.store_snapshot(kernel.get_snapshot())
```

Update the function signature to include `moderator`:
```python
def _simulation_loop(
    kernel, event_log, round_state, mechanism_registry, judge,
    moderator, pace, max_rounds, stop_event,
):
```

In `main()`, extract moderator from app state and pass it:
```python
    moderator = app.state.leviathan["moderator"]
```
And add to sim_thread args.

**Step 4: Run full suite**

Run: `pytest test_world_kernel.py test_api.py -v`
Expected: All tests PASSED

**Step 5: Commit**

```bash
git add scripts/run_server.py test_api.py
git commit -m "feat: sim loop respects pause flag and stores snapshots for rollback"
```

---

### Task 11: Add --moderator-keys CLI arg to run_server

**Files:**
- Modify: `scripts/run_server.py:175-243`

**Context:** Add `--moderator-keys` CLI argument (comma-separated), pass to `build_app`. Same pattern as existing `--api-keys`.

**Step 1: Add CLI argument**

In `scripts/run_server.py`, in the `main()` function's argument parsing section, add after the `--api-keys` argument:

```python
    parser.add_argument(
        "--moderator-keys",
        type=str,
        default="",
        help="Comma-separated moderator API keys (empty = no moderator access)",
    )
```

After parsing `api_keys`, add:
```python
    moderator_keys: Optional[Set[str]] = None
    if args.moderator_keys:
        moderator_keys = {k.strip() for k in args.moderator_keys.split(",") if k.strip()}
```

Pass to `build_app`:
```python
    app = build_app(
        members=args.members,
        land_w=land_w,
        land_h=land_h,
        seed=args.seed,
        api_keys=api_keys,
        moderator_keys=moderator_keys,
        rate_limit=args.rate_limit,
    )
```

**Step 2: Run full suite to verify nothing broke**

Run: `pytest test_world_kernel.py test_api.py -v`
Expected: All tests PASSED

**Step 3: Commit**

```bash
git add scripts/run_server.py
git commit -m "feat: add --moderator-keys CLI argument to run_server"
```

---

### Task 12: Update implementation compromises doc

**Files:**
- Modify: `docs/plans/2026-02-24-implementation-compromises.md`

**Context:** Mark K7, K8, K9, A4 as RESOLVED. Add Phase 4 compromises P4-1 through P4-6.

**Step 1: Mark resolved compromises**

In `docs/plans/2026-02-24-implementation-compromises.md`:

Replace K7 header and content with:
```markdown
### ~~K7. No receipt signing or oracle identity~~ RESOLVED

- **Resolved:** 2026-02-24. Added `OracleIdentity` in `kernel/oracle.py` with Ed25519 keypair (deterministic from seed). Every `RoundReceipt` now includes `oracle_signature` (hex Ed25519 signature of canonical receipt JSON), `world_public_key` (oracle identity), and `constitution_hash`. 6 oracle tests + 6 kernel signing tests.
```

Replace K8:
```markdown
### ~~K8. No federation-ready fields in receipts~~ RESOLVED

- **Resolved:** 2026-02-24. Added `Optional` fields to `RoundReceipt`: `origin_world_id`, `origin_receipt_hash`, `bridge_channel_id`, `bridge_seq`, `notary_signature`. All `None` until federation is implemented.
```

Replace K9:
```markdown
### ~~K9. No constitution object or constitution_hash in receipts~~ RESOLVED

- **Resolved:** 2026-02-24. Added `Constitution` in `kernel/constitution.py` with 3-layer model (kernel immutable, governance amendable, world rules open). Loaded from `kernel/constitution_default.yaml`. `constitution_hash` (SHA-256) included in every `RoundReceipt`. 8 constitution tests.
```

Replace A4:
```markdown
### ~~A4. No event_seq, phase, payload_hash, or prev_event_hash in EventEnvelope~~ RESOLVED

- **Resolved:** 2026-02-24. Added `Optional` fields to `EventEnvelope`: `world_id`, `phase`, `payload_hash`, `prev_event_hash`. 2 enrichment tests.
```

**Step 2: Add Phase 4 compromises section**

After the Phase 3 section, add:

```markdown
---

## Phase 4: Constitution, Signing & Moderator

### P4-1. Oracle private key in-memory only

- **What we built:** Ed25519 private key held in Python memory. Lost on restart, no key rotation.
- **Risk:** World oracle identity changes after restart. No key persistence.
- **When to fix:** Before production. Add encrypted key file or vault integration.

### P4-2. Rollback limited to in-memory snapshot history

- **What we built:** Last N round snapshots stored in a Python list. Lost on restart.
- **Risk:** Cannot rollback beyond N rounds, cannot rollback after restart.
- **When to fix:** When SQLite persistence lands (A2).

### P4-3. No moderator action rate limiting

- **What we built:** Moderator endpoints have no separate rate limiting.
- **Risk:** Compromised moderator key could spam pause/resume/ban.
- **When to fix:** When multi-moderator support is needed.

### P4-4. Constitution amendments not versioned as a chain

- **What we built:** Version counter increments but no history of previous states.
- **Risk:** No diff between constitution versions, no audit trail of amendments.
- **When to fix:** When governance audit trail matters.

### P4-5. Ban is binary (no graduated penalties)

- **What we built:** Agents are either fully banned or fully active.
- **Risk:** Cannot partially restrict misbehaving agents (e.g., read-only mode).
- **When to fix:** When more nuanced moderation is needed.

### P4-6. Federation fields reserved but not populated

- **What we built:** Optional fields in RoundReceipt and EventEnvelope, all None.
- **Risk:** No actual cross-world communication or verification.
- **When to fix:** Phase 5 (federation implementation).
```

**Step 3: Update the Summary by Priority section**

Update the "Should fix before Phase 4" section to mark all items as resolved:
```markdown
### ~~Should fix before Phase 4 (multi-tenant / federation)~~ ALL RESOLVED
- ~~**K7** (receipt signing)~~ RESOLVED — Ed25519 oracle identity, receipts signed
- ~~**K8** (federation fields)~~ RESOLVED — Optional fields in RoundReceipt
- ~~**K9** (constitution)~~ RESOLVED — 3-layer Constitution with hash in receipts
- ~~**A4** (event envelope enrichment)~~ RESOLVED — world_id, phase, payload_hash, prev_event_hash
```

**Step 4: Commit**

```bash
git add docs/plans/2026-02-24-implementation-compromises.md
git commit -m "docs: mark K7, K8, K9, A4 resolved; add Phase 4 compromises P4-1 through P4-6"
```

---

### Task 13: Full integration test + verification

**Files:**
- Test: `test_api.py` (append)

**Context:** Two integration tests: (1) full moderator workflow, (2) constitution hash flows through receipt to API.

**Step 1: Write integration tests**

Append to `test_api.py`:

```python
class TestPhase4Integration:
    @pytest.fixture
    def full_client(self, tmp_path):
        from scripts.run_server import build_app
        from fastapi.testclient import TestClient
        app = build_app(
            members=5, land_w=10, land_h=10, seed=42,
            api_keys=set(), moderator_keys={"mod1"},
        )
        return TestClient(app)

    def test_full_moderator_workflow(self, full_client):
        """Pause -> ban -> unban -> resume -> verify events."""
        c = full_client
        h = {"X-API-Key": "mod1"}

        # Pause
        assert c.post("/v1/admin/pause", headers=h).status_code == 200
        assert c.get("/v1/admin/status", headers=h).json()["paused"] is True

        # Ban agent 1
        assert c.post("/v1/admin/ban/1", headers=h).status_code == 200
        status = c.get("/v1/admin/status", headers=h).json()
        assert 1 in status["banned_agents"]

        # Unban agent 1
        assert c.post("/v1/admin/unban/1", headers=h).status_code == 200

        # Update quotas
        assert c.put("/v1/admin/quotas", json={"max_actions_per_round": 5}, headers=h).status_code == 200

        # Resume
        assert c.post("/v1/admin/resume", headers=h).status_code == 200

        # Verify events
        events = c.get("/v1/world/events").json()
        admin_types = [e["event_type"] for e in events if e["event_type"].startswith("admin_")]
        assert "admin_pause" in admin_types
        assert "admin_ban" in admin_types
        assert "admin_unban" in admin_types
        assert "admin_quotas" in admin_types
        assert "admin_resume" in admin_types

    def test_constitution_hash_in_receipt_via_api(self, full_client):
        """Settle a round and verify constitution_hash flows through API."""
        kernel = full_client.app.state.leviathan["kernel"]
        kernel.begin_round()
        receipt = kernel.settle_round(seed=1)

        # Via current round endpoint
        resp = full_client.get("/v1/world/rounds/current")
        assert resp.status_code == 200
        lr = resp.json()["last_receipt"]
        assert lr["constitution_hash"] == receipt.constitution_hash
        assert lr["oracle_signature"] == receipt.oracle_signature
        assert lr["world_public_key"] is not None

    def test_world_public_key_in_world_info(self, full_client):
        resp = full_client.get("/v1/world")
        assert resp.status_code == 200
        data = resp.json()
        assert "world_public_key" in data
        assert len(data["world_public_key"]) == 64
```

**Step 2: Run integration tests**

Run: `pytest test_api.py::TestPhase4Integration -v`
Expected: 3 PASSED

**Step 3: Run FULL test suite**

Run: `pytest test_world_kernel.py test_api.py -v`
Expected: ALL PASSED (should be ~260+ tests)

**Step 4: Verify all imports are clean**

Run: `python -c "from kernel.constitution import Constitution; from kernel.oracle import OracleIdentity; from kernel.moderator import ModeratorState; from api.routes.admin import router; print('All Phase 4 imports OK')"`

**Step 5: Commit**

```bash
git add test_api.py
git commit -m "test: add Phase 4 integration tests (moderator workflow + constitution in receipts)"
```

**Step 6: Final verification and push**

```bash
pytest test_world_kernel.py test_api.py -v --tb=short
git log --oneline -10
git push origin master
```
