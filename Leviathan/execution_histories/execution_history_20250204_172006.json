{
  "rounds": [
    {
      "timestamp": "2025-02-04T17:20:06.913787",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid; if not, exit.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # -------------------------------\n    # Immediate Survival: Resource and Vitality Check\n    # -------------------------------\n    # If cargo is less than half of vitality, attempt to secure resources by attacking richer members.\n    if me.cargo < me.vitality * 0.5:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Ensure valid index access.\n            if idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                # Attack if the other member has substantially more cargo.\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n        # Send a cooperative call-out to all other members hoping for alliances.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, other.id, \"I'm low on resources\u2014let's work together!\")\n    else:\n        # -------------------------------\n        # Resource Abundance: Cooperative and Expansion Strategy\n        # -------------------------------\n        # Offer resources to members with significantly lower cargo.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo < me.cargo * 0.5:\n                execution_engine.offer(me, other, True)\n        # Form a coalition with members whose productivity is equal or higher.\n        coalition = []\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.overall_productivity >= me.overall_productivity:\n                coalition.append(other.id)\n        for other_id in coalition:\n            execution_engine.send_message(me.id, other_id, \"Join me in a cooperative alliance for mutual prosperity!\")\n\n    # -------------------------------\n    # Long-Term Survival and Expansion\n    # -------------------------------\n    # Check if the member has land; we assume attribute 'land_num' exists if the member owns any territory.\n    if hasattr(me, \"land_num\") and me.land_num > 0:\n        # Use expansion to build alliances and carve new territory.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            execution_engine.expand(me, execution_engine.current_members[idx])\n        # Attempt reproduction via the bear action if cargo is plentiful.\n        if me.cargo > 100:\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue\n                other = execution_engine.current_members[idx]\n                if hasattr(other, \"land_num\") and other.land_num > 0:\n                    execution_engine.bear(me, other)\n                    break  # Only one successful pairing is needed.\n\n    # -------------------------------\n    # Adaptive Survival Q-Learning and Action Selection\n    # -------------------------------\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n    # Define state discretization based on vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = [\"attack\", \"offer\", \"expand\"]\n    q_values = {action: me.survival_q.get((state, action), 0) for action in possible_actions}\n    chosen_action = max(possible_actions, key=lambda action: q_values[action])\n\n    if chosen_action == \"attack\":\n        # Identify the member with the highest cargo to target.\n        target = None\n        max_cargo = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, \"attack\")] = me.survival_q.get((state, \"attack\"), 0) + me.vitality * 0.1\n\n    elif chosen_action == \"offer\":\n        # Find the member with the lowest cargo to offer help.\n        target = None\n        min_cargo = float(\"inf\")\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo < min_cargo:\n                min_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.offer(me, target, True)\n            me.survival_q[(state, \"offer\")] = me.survival_q.get((state, \"offer\"), 0) + me.vitality * 0.05\n\n    elif chosen_action == \"expand\":\n        # Expand territory by aligning with productive members.\n        coalition = []\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.overall_productivity > me.overall_productivity * 0.8:\n                coalition.append(other)\n        for ally in coalition:\n            execution_engine.expand(me, ally)\n        me.survival_q[(state, \"expand\")] = me.survival_q.get((state, \"expand\"), 0) + me.vitality * 0.08\n\n    # The strategy is dynamically adapted: balancing immediate resource needs, cooperative alliances,\n    # and long-term expansion. Individual decisions flow from the member's current state while seeking to\n    # both survive immediate threats and prosper in the longer term.\n    return",
          "old_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 96.82806145553313
          },
          "new_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 96.82806145553313
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate the member indices.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # ------- Cooperative Communication -------\n    # Broadcast a cooperative message for long\u2010term prosperity.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        execution_engine.send_message(member_id, i,\n            \"Let's work together for long-term prosperity and shared success!\")\n\n    # ------- Strategy 1: Cooperative Resource Offer -------\n    # Offer resources to partners with moderate cargo to build alliances.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if me.cargo < 50 and partner.cargo < 50:\n            execution_engine.offer(member_id, i, True)\n\n    # ------- Strategy 2: Target Vulnerable Members -------\n    # Use the victim matrix from relationship_dict and attack if our vitality is dominant.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        matrix_size = len(execution_engine.current_members)\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if member_id < matrix_size and i < matrix_size:\n                target = execution_engine.current_members[i]\n                if me.vitality > 1.5 * target.vitality:\n                    execution_engine.attack(member_id, i)\n\n    # ------- Strategy 3: Expand Territory -------\n    # Expand into adjacent clear territories indicated by current_clear_list.\n    if me.current_clear_list:\n        for adj in me.current_clear_list:\n            if isinstance(adj, int) and 0 <= adj < len(execution_engine.current_members) and adj != member_id:\n                execution_engine.expand(member_id, adj)\n                break  # Only one expansion per round.\n\n    # ------- Strategy 4: Reproduction (Bear Offspring) -------\n    # Attempt reproduction if we have land (using current_clear_list as a proxy) and\n    # if a viable partner (one also with land) is found.\n    if me.current_clear_list:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            candidate = execution_engine.current_members[i]\n            if candidate.current_clear_list:\n                execution_engine.bear(member_id, i)\n                break  # Reproduce only once per round.\n\n    # -----------------------------------------------------------------\n    # Part 3: Survival-Centric Adaptation\n    # -----------------------------------------------------------------\n    # 1. Emergency Resource Reserve:\n    # If cargo is less than half of vitality, seek out a member with higher cargo to attack.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(member_id, i)\n                break  # Initiate only one emergency attack.\n\n    # 2. Adaptive Territory Defense:\n    # If holding too many lands and with low vitality (< 50), consolidate by discarding extra land.\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        if hasattr(me, 'owned_land') and me.owned_land:\n            for loc in me.owned_land[1:]:\n                execution_engine._discard_land(member_id, loc)\n\n    # 3. Survival Q-Learning for Adaptive Decisions\n    # Initialize our survival Q-table (if not already present), based on vitality and cargo.\n    from collections import defaultdict\n    if not hasattr(me, 'survival_q'):\n        me.survival_q = defaultdict(float)\n\n    # Define our current state with discrete buckets for easier generalization.\n    state = (me.vitality // 20, me.cargo // 20)\n    actions = ['attack', 'hide', 'steal']\n\n    # Choose the action with the best Q-value given our current state.\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if chosen_action == 'attack':\n        # Execute attack on the first opponent with higher cargo.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo > me.cargo:\n                execution_engine.attack(member_id, i)\n                # Update our Q-value based on a portion of our vitality.\n                me.survival_q[(state, chosen_action)] += me.vitality * 0.1\n                break\n    elif chosen_action == 'hide':\n        # As a hide action, send a quiet message to self or log for simulation.\n        # The idea is to avoid drawing attention while regaining strength.\n        execution_engine.log_event(member_id, \"Hiding to preserve vitality.\")\n        me.survival_q[(state, chosen_action)] += 1  # modest reward for cautious action.\n    elif chosen_action == 'steal':\n        # Steal by targeting a member with moderate cargo.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if 50 <= target.cargo <= 100:\n                execution_engine.attack(member_id, i)\n                me.survival_q[(state, chosen_action)] += me.vitality * 0.05\n                break\n\n    # Survival Metrics can be updated elsewhere based on event responses.\n    # A helper function for evaluating survival ROI is defined below.\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action, outcome in action_history:\n            vitality_gain = outcome.get('vitality', 0)\n            cost = outcome.get('vitality_cost', 1)  # avoid division by zero\n            roi[action] = vitality_gain / cost if cost > 0 else 0\n        return max(roi, key=roi.get) if roi else None\n\n    # NOTE: The provided system is intentionally adaptive.\n    # Agents should refine these mechanisms based on their individual needs,\n    # beliefs, and circumstances, all while balancing personal survival with collective prosperity.\n\n    return",
          "old_stats": {
            "vitality": 33.02781433323713,
            "cargo": 47.25322455383092,
            "survival_chance": 98.77222098502479
          },
          "new_stats": {
            "vitality": 33.02781433323713,
            "cargo": 47.25322455383092,
            "survival_chance": 98.77222098502479
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Verify member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member, do nothing\n    me = execution_engine.current_members[member_id]\n\n    # Survival: if cargo is low relative to vitality, try to secure resources from richer members\n    if me.cargo < me.vitality * 0.5:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # do not target self\n            # Ensure valid reference (iteration guarantees validity)\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                execution_engine.send_message(me.id, other.id, \"Resources are scarce; taking action for survival!\")\n                # After attacking, exit action for this round\n                return\n\n    # Cooperative outreach: Identify members who are relatively stable and might benefit from alliances.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # Consider cooperation if the partner has similar vitality and lower cargo, suggesting a need for mutual support.\n        if other.vitality >= me.vitality * 0.8 and other.cargo < me.cargo:\n            execution_engine.offer(me, other, True)\n            execution_engine.send_message(me.id, other.id, \"Let's cooperate for mutual benefit!\")\n\n    # Reproduction for long-term prosperity:\n    # Only proceed if 'has_land' is True on the member. This protects against unqualified bear() actions.\n    if hasattr(me, 'has_land') and me.has_land:\n        for idx, partner in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Ensure partner has land and sufficient vitality to contribute to future success.\n            if hasattr(partner, 'has_land') and partner.has_land and partner.vitality >= 50:\n                execution_engine.bear(me, partner)\n                execution_engine.send_message(me.id, partner.id, \"Shall we unite our strengths for a promising future?\")\n                break  # Only propose one union per round\n\n    # Territorial expansion:\n    # If overall productivity is high, try to secure more resources by expanding relative to a less productive member.\n    if me.overall_productivity > 80:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if me.overall_productivity > other.overall_productivity:\n                execution_engine.expand(me, other)\n                execution_engine.send_message(me.id, other.id, \"Expanding territory to reinforce our resource base!\")\n                break  # Expand once per round\n\n    # Communication: Broadcast message to all members to foster collective decision making and shared prosperity.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, other.id, \"Together we can build a prosperous and secure society!\")",
          "old_stats": {
            "vitality": 42.15604281108604,
            "cargo": 40.25508270288947,
            "survival_chance": 49.8976545487336
          },
          "new_stats": {
            "vitality": 42.15604281108604,
            "cargo": 40.25508270288947,
            "survival_chance": 49.8976545487336
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    A bespoke agent strategy reflecting my individual approach to survival and long\u2010term prosperity.\n\n    My strategy consists of:\n      \u2022 Immediate self\u2010preservation: Assessing resources and counter\u2010attacking if vulnerable.\n      \u2022 Adaptive cooperation: Seeking mutually beneficial alliances based on similar productivity.\n      \u2022 Long\u2010term planning: Investing in reproduction, territory expansion, and proposing social innovations.\n\n    In addition, I integrate a simple Q-learning mechanism to adjust survival tactics dynamically.\n    \"\"\"\n    # Safety: Validate our member_id\n    if member_id >= len(execution_engine.current_members):\n        return  # Exit if our member index is invalid.\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # --- Step 1: Emergency Resource Assessment & Immediate Aggression ---\n    # If my cargo is critically low relative to vitality, try to seize resources from better-equipped opponents.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(member_id, other.id)\n                break  # One attack is sufficient for now.\n\n    # --- Step 2: Broadcast Cooperative Intent ---\n    # Sending a message to build alliances and foster mutual protection,\n    # while keeping an ear out for shifting threat landscapes.\n    for i in range(num_members):\n        if i != member_id:\n            execution_engine.send_message(\n                member_id, i,\n                \"I'm aligning for mutual growth. Let's share strategies and secure our territories.\"\n            )\n\n    # --- Step 3: Retaliation Against Aggression ---\n    # Using the victim relationship metric, counterattack one aggressor from the prior round.\n    victim_matrix = execution_engine.relationship_dict.get(\"victim\")\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        if victim_matrix[member_id, j] > 0:\n            execution_engine.attack(member_id, execution_engine.current_members[j].id)\n            break  # Retaliate against just one proven aggressor per cycle.\n\n    # --- Step 4: Alliance Building via Cooperative Offers ---\n    # Identify peers with comparable productivity (within 70-130% of mine) and a land base to boost mutual resilience.\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        other = execution_engine.current_members[j]\n        if 0.7 * me.overall_productivity <= other.overall_productivity <= 1.3 * me.overall_productivity:\n            execution_engine.offer(member_id, other.id, True)\n            execution_engine.offer_land(member_id, other.id, True)\n\n    # --- Step 5: Reproduction and Network Expansion ---\n    # Proceed with reproduction (bearing offspring) if both parties hold land,\n    # promoting long-term colony expansion and genetic diversity.\n    if me.current_clear_list:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            partner = execution_engine.current_members[j]\n            if partner.current_clear_list:\n                execution_engine.bear(member_id, partner.id)\n                break  # Only one reproduction event per round.\n\n    # --- Step 6: Territorial Expansion ---\n    # Expand influence by targeting an opponent with lower cargo.\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        target = execution_engine.current_members[j]\n        if target.cargo < me.cargo:\n            execution_engine.expand(member_id, target.id)\n            break  # One successful expansion per cycle.\n\n    # --- Step 7: Governance and Social Harmony Proposals ---\n    # Propose structural enhancements (like basic income and tax systems) for a stable communal ecosystem.\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        execution_engine.send_message(\n            member_id, j,\n            \"Proposal: Shall we implement a basic income and land tax system to secure shared prosperity?\"\n        )\n\n    # --- Step 8: Additional Survival-Centric Tactics ---\n    # In extreme cases, when resource reserves are very low, perform further aggressive actions.\n    if me.cargo < me.vitality * 0.3:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            other = execution_engine.current_members[j]\n            if other.cargo > me.cargo:\n                execution_engine.attack(member_id, other.id)\n                break\n\n    # Adaptive Territory Defense:\n    # If I'm overextended with land holdings and my vitality is low, discard non-essential land.\n    if hasattr(me, 'land_num') and hasattr(me, 'vitality'):\n        if me.land_num > 2 and me.vitality < 50:\n            if hasattr(me, 'owned_land'):\n                for land in me.owned_land[1:]:\n                    execution_engine._discard_land(member_id, land)\n\n    # --- Step 9: Survival Q-learning for Adaptive Decision Making ---\n    # Initialize our simple Q-learning storage if it's the first interaction.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Define state as coarse buckets of vitality and cargo.\n    state = (me.vitality // 20, me.cargo // 20)\n    # Three tactical options: attack, hide, or steal.\n    actions = ['attack', 'hide', 'steal']\n    # Choose the action with the highest learned Q-value.\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute the Q-learning selected action:\n    if chosen_action == 'attack':\n        # Attack a target: for instance, choose the next member cyclically.\n        target_id = (member_id + 1) % num_members\n        if target_id == member_id:\n            target_id = (target_id + 1) % num_members\n        execution_engine.attack(member_id, execution_engine.current_members[target_id].id)\n        me.survival_q[(state, 'attack')] += me.vitality * 0.1\n    elif chosen_action == 'steal':\n        # Identify a target rich in cargo to simulate a 'steal'.\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            target = execution_engine.current_members[j]\n            if target.cargo > me.cargo:\n                execution_engine.attack(member_id, target.id)\n                me.survival_q[(state, 'steal')] += me.vitality * 0.1\n                break\n    elif chosen_action == 'hide':\n        # Hiding: send a message that implies temporary withdrawal.\n        # This could be interpreted by the engine as a non-combat move.\n        execution_engine.send_message(\n            member_id, (member_id + 1) % num_members,\n            \"Temporarily withdrawing to reassess threats.\"\n        )\n        me.survival_q[(state, 'hide')] += me.vitality * 0.05  # Lesser reward for defensive posture.\n\n    # End of agent_action: My strategy integrates immediate survival with long-term cooperative planning,\n    # adaptively learning from interactions in this dynamic environment.\n\n# End of implementation.",
          "old_stats": {
            "vitality": 18.47747982181767,
            "cargo": 46.68166847941894,
            "survival_chance": 80.29182821776881
          },
          "new_stats": {
            "vitality": 18.47747982181767,
            "cargo": 46.68166847941894,
            "survival_chance": 80.29182821776881
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 4,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is within valid range.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    my_member = execution_engine.current_members[member_id]\n\n    # ----------------------------------------------------------------\n    # PART 1: Social Organization & Communication\n    # ----------------------------------------------------------------\n    # Broadcast a cooperative message to every other agent.\n    cooperative_msg = (\n        \"Unit \" + str(my_member.id) +\n        \": Prosperity thrives when survival and collective success interlace. Let's collaborate!\"\n    )\n    for other_id in range(len(execution_engine.current_members)):\n        if other_id != member_id:\n            execution_engine.send_message(member_id, other_id, cooperative_msg)\n\n    # Engage with our trusted peers: offer resources and land as gestures of goodwill.\n    for neighbor_id in my_member.current_clear_list:\n        if isinstance(neighbor_id, int) and neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # Tailored offers based on my individual values: cooperation to ensure a stable future.\n            execution_engine.offer(my_member, neighbor, True)\n            execution_engine.offer_land(my_member, neighbor, True)\n\n    # ----------------------------------------------------------------\n    # PART 2: Conflict Resolution & Resource/Threat Management\n    # ----------------------------------------------------------------\n    # Assess threats using the 'victim' matrix and preemptively respond.\n    risk_threshold = 1.0\n    matrix = execution_engine.relationship_dict.get('victim')\n    if matrix is not None:\n        for other_id in range(len(execution_engine.current_members)):\n            if other_id != member_id and other_id < len(execution_engine.current_members):\n                try:\n                    if matrix[member_id, other_id] > risk_threshold:\n                        execution_engine.attack(my_member, execution_engine.current_members[other_id])\n                except Exception:\n                    # If there is an indexing error, ignore and continue.\n                    pass\n\n    # ----------------------------------------------------------------\n    # PART 3: Survival-Centric Adaptation\n    # ----------------------------------------------------------------\n    # Our survival strategy hinges on personalized resource assessment,\n    # threat neutralization, and adaptive action based on dynamic learning.\n    me = my_member\n\n    # Emergency resource trigger: if cargo falls below half of vitality\n    if getattr(me, 'cargo', 0) < getattr(me, 'vitality', 100) * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and getattr(other, 'cargo', 0) > getattr(me, 'cargo', 0):\n                execution_engine.attack(me, other)\n\n    # Adaptive territory management: if land ownership exceeds our needs during critical health.\n    if getattr(me, 'land_num', 0) > 2 and getattr(me, 'vitality', 100) < 50:\n        # Safely discard surplus land to lighten our management burden.\n        for loc in me.owned_land[1:]:\n            execution_engine._discard_land(me, loc)\n\n    # Implement a personalized Q-learning model for survival decisions.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        # Initialize counts for exploration if needed.\n        me.survival_counts = defaultdict(int)\n\n    # Define our current state: discretized levels of vitality and cargo.\n    current_vitality = getattr(me, 'vitality', 100)\n    current_cargo = getattr(me, 'cargo', 0)\n    state = (current_vitality // 20, current_cargo // 20)\n\n    # Potential actions include aggressive, defensive, or evasive moves.\n    possible_actions = ['attack', 'hide', 'steal']\n    # Incorporate an exploration term: encourage trying actions that have been less frequent.\n    def q_score(action):\n        base_val = me.survival_q.get((state, action), 0)\n        freq_penalty = 0.1 / (1 + me.survival_counts.get((state, action), 0))\n        return base_val + freq_penalty\n\n    selected_action = max(possible_actions, key=lambda a: q_score(a))\n    me.survival_counts[(state, selected_action)] = me.survival_counts.get((state, selected_action), 0) + 1\n\n    # Execute out chosen survival tactic.\n    if selected_action == 'attack':\n        # Attack the agent with both higher cargo and lower vitality for maximum gain.\n        target = None\n        best_target_score = float('-inf')\n        for other in execution_engine.current_members:\n            if other.id != me.id:\n                target_score = getattr(other, 'cargo', 0) - getattr(other, 'vitality', 100)\n                if target_score > best_target_score:\n                    best_target_score = target_score\n                    target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            # Reward update: increase Q value proportional to current vitality.\n            me.survival_q[(state, selected_action)] += current_vitality * 0.1\n    elif selected_action == 'steal':\n        # Attempt to steal from a vulnerable agent: one with low vitality.\n        candidate = None\n        lowest_vitality = float('inf')\n        for other in execution_engine.current_members:\n            if other.id != me.id and getattr(other, 'vitality', 100) < lowest_vitality:\n                lowest_vitality = getattr(other, 'vitality', 100)\n                candidate = other\n        if candidate is not None:\n            execution_engine.attack(me, candidate)\n            # Moderate update to Q value as stealing carries risk.\n            me.survival_q[(state, selected_action)] += current_vitality * 0.05\n    elif selected_action == 'hide':\n        # Hiding: no aggressive moves, focus on restoring vitality.\n        # Simulate a self-recovery boost if execution_engine supports it.\n        if hasattr(execution_engine, 'heal'):\n            execution_engine.heal(me, 10)\n        # Slight positive reinforcement on this safe action.\n        me.survival_q[(state, selected_action)] += current_vitality * 0.08\n\n    # Define a helper function for analyzing historical actions and their outcomes.\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action_key, outcome in action_history:\n            vitality_gain = outcome.get('vitality', 0)\n            cost = outcome.get('vitality_cost', 1)\n            roi[action_key] = vitality_gain / cost if cost > 0 else 0\n        return max(roi, key=roi.get) if roi else None\n\n    # ----------------------------------------------------------------\n    # PART 4: Reproduction & Expansion Strategies (Requires Land Ownership)\n    # ----------------------------------------------------------------\n    if hasattr(my_member, \"land\") and my_member.land > 0:\n        partner_candidate = None\n        best_score = float(\"inf\")\n        for neighbor_id in my_member.current_clear_list:\n            if isinstance(neighbor_id, int) and neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                # Score based on similarity: minimize difference in overall productivity and age.\n                score = abs(my_member.overall_productivity - neighbor.overall_productivity) + abs(my_member.age - neighbor.age)\n                if score < best_score:\n                    best_score = score\n                    partner_candidate = neighbor\n        if partner_candidate is not None:\n            execution_engine.bear(my_member, partner_candidate)\n\n    # Expansion: attempt to enhance territory by evaluating neighbors' productivity.\n    for neighbor_id in my_member.current_clear_list:\n        if isinstance(neighbor_id, int) and neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            if my_member.overall_productivity > neighbor.overall_productivity:\n                execution_engine.expand(my_member, neighbor)\n\n    # ----------------------------------------------------------------\n    # PART 5: Proposed Modifications to Game Mechanics (Social System Design)\n    # ----------------------------------------------------------------\n    # While these functions are proposals, they illustrate areas for evolution.\n    # For example, our personal views shape our desire to introduce enhanced communication,\n    # dynamic economic balancing, and stewardship of shared resources.\n    #\n    # Example (commented out) modifications:\n    #\n    # def pre_init_hook(island):\n    #     island.basic_income = 10.0  # Sustained income for all to support basic survival.\n    #     island.tax_rate = 0.2       # Moderate tax ensuring redistribution.\n    #\n    # def modify_member(member, relationships):\n    #     member.social_rank = 0\n    #     member.voting_power = 1\n    #     member.tax_paid = 0\n    #     member.benefits_received = 0\n    #     return member\n    #\n    # def modify_land(land, members):\n    #     land.communal_areas = []\n    #     land.private_areas = []\n    #     return land\n    #\n    # def modify_relationships(relationships):\n    #     relationships['alliance'] = np.zeros_like(relationships['victim'])\n    #     relationships['trade_history'] = np.zeros_like(relationships['victim'])\n    #     return relationships\n    #\n    # These modifications support a vision where survival and collective progress intertwine,\n    # enabling each agent to maximize both individual and communal prosperity.\n\n    return\n\n# End of agent_action implementation.",
          "old_stats": {
            "vitality": 78.50637096028503,
            "cargo": 42.476807026876735,
            "survival_chance": 173.06686024708188
          },
          "new_stats": {
            "vitality": 78.50637096028503,
            "cargo": 42.476807026876735,
            "survival_chance": 173.06686024708188
          },
          "performance_change": 0.0,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [
            "From member_1: Let's work together for long-term prosperity and shared success!",
            "From member_3: I'm aligning for mutual growth. Let's share strategies and secure our territories.",
            "From member_4: Unit 4: Prosperity thrives when survival and collective success interlace. Let's collaborate!"
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_1: Let's work together for long-term prosperity and shared success!",
            "From member_2: Together we can build a prosperous and secure society!",
            "From member_4: Unit 4: Prosperity thrives when survival and collective success interlace. Let's collaborate!"
          ],
          "sent": []
        },
        "4": {
          "received": [
            "From member_1: Let's work together for long-term prosperity and shared success!",
            "From member_2: Together we can build a prosperous and secure society!",
            "From member_3: I'm aligning for mutual growth. Let's share strategies and secure our territories."
          ],
          "sent": []
        }
      }
    }
  ],
  "generated_code": {
    "0": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid; if not, exit.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # -------------------------------\n    # Immediate Survival: Resource and Vitality Check\n    # -------------------------------\n    # If cargo is less than half of vitality, attempt to secure resources by attacking richer members.\n    if me.cargo < me.vitality * 0.5:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Ensure valid index access.\n            if idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                # Attack if the other member has substantially more cargo.\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n        # Send a cooperative call-out to all other members hoping for alliances.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, other.id, \"I'm low on resources\u2014let's work together!\")\n    else:\n        # -------------------------------\n        # Resource Abundance: Cooperative and Expansion Strategy\n        # -------------------------------\n        # Offer resources to members with significantly lower cargo.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo < me.cargo * 0.5:\n                execution_engine.offer(me, other, True)\n        # Form a coalition with members whose productivity is equal or higher.\n        coalition = []\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.overall_productivity >= me.overall_productivity:\n                coalition.append(other.id)\n        for other_id in coalition:\n            execution_engine.send_message(me.id, other_id, \"Join me in a cooperative alliance for mutual prosperity!\")\n\n    # -------------------------------\n    # Long-Term Survival and Expansion\n    # -------------------------------\n    # Check if the member has land; we assume attribute 'land_num' exists if the member owns any territory.\n    if hasattr(me, \"land_num\") and me.land_num > 0:\n        # Use expansion to build alliances and carve new territory.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            execution_engine.expand(me, execution_engine.current_members[idx])\n        # Attempt reproduction via the bear action if cargo is plentiful.\n        if me.cargo > 100:\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue\n                other = execution_engine.current_members[idx]\n                if hasattr(other, \"land_num\") and other.land_num > 0:\n                    execution_engine.bear(me, other)\n                    break  # Only one successful pairing is needed.\n\n    # -------------------------------\n    # Adaptive Survival Q-Learning and Action Selection\n    # -------------------------------\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n    # Define state discretization based on vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = [\"attack\", \"offer\", \"expand\"]\n    q_values = {action: me.survival_q.get((state, action), 0) for action in possible_actions}\n    chosen_action = max(possible_actions, key=lambda action: q_values[action])\n\n    if chosen_action == \"attack\":\n        # Identify the member with the highest cargo to target.\n        target = None\n        max_cargo = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, \"attack\")] = me.survival_q.get((state, \"attack\"), 0) + me.vitality * 0.1\n\n    elif chosen_action == \"offer\":\n        # Find the member with the lowest cargo to offer help.\n        target = None\n        min_cargo = float(\"inf\")\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo < min_cargo:\n                min_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.offer(me, target, True)\n            me.survival_q[(state, \"offer\")] = me.survival_q.get((state, \"offer\"), 0) + me.vitality * 0.05\n\n    elif chosen_action == \"expand\":\n        # Expand territory by aligning with productive members.\n        coalition = []\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.overall_productivity > me.overall_productivity * 0.8:\n                coalition.append(other)\n        for ally in coalition:\n            execution_engine.expand(me, ally)\n        me.survival_q[(state, \"expand\")] = me.survival_q.get((state, \"expand\"), 0) + me.vitality * 0.08\n\n    # The strategy is dynamically adapted: balancing immediate resource needs, cooperative alliances,\n    # and long-term expansion. Individual decisions flow from the member's current state while seeking to\n    # both survive immediate threats and prosper in the longer term.\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ],
        "final_prompt": "full_prompt = \"\"\"\nCurrent integrated prompt:\nPlease incorporate the following new section (Part 1) into the full prompt, ensuring that all previous constraints are preserved and adding these new constraints:\n\n----------------------\n[Previous code execution context]\n{error_context}\n\n[Current task]\nYou are member_{member.id} in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_{member.id}) in any action\n- Verify member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n    \u2022 member.id (int): The unique ID for the member\n    \u2022 member.vitality (float)\n    \u2022 member.cargo (float)\n    \u2022 member.overall_productivity (float)\n    \u2022 member.age (float)\n    \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       matrix = execution_engine.relationship_dict['victim']\n       # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n4) You can use these methods on execution_engine:\n    \u2022 execution_engine.attack(member1, member2)\n    \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n    \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n    \u2022 execution_engine.bear(member1, member2) - Bears offspring\n    \u2022 execution_engine.expand(member1, member2) - Expands territory\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n{features}\n\nRelationship summary (parsed from relationship_dict):\n{relations}\n\nCode Memory and Previous Performance:\n{code_memory}\n\nPerformance history:\n{past_performance}\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n\nReturn only the code, no extra text or explanation. While the example above shows one possible approach, you should create your own unique implementation drawing from the wide range of available methods and strategies.\n\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n[Social Strategies]\nConsider these social strategies:\n- Design systems for resource distribution and allocation\n- Build alliances and cooperative networks \n- Create mechanisms for collective decision making\n- Establish norms and rules for interaction\n- Develop methods for conflict resolution\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n    execution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all: \n    for recipient in range(len(execution_engine.current_members)):\n        if recipient != your_id:\n            execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n    for ally_id in ally_list:\n        execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n    for member_id in coalition:\n        execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nNo messages received\n\n----------------------\nEmphasize that agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\n----------------------\nPlease incorporate the following new section (Part 2) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n            {part0}\n            You can also propose plausible modifications to the game mechanics themselves, such as:\n        - Adding new resource types or currencies\n        - Creating new actions or interaction types\n        - Implementing voting systems or governance structures\n        - Defining property rights and ownership rules\n        - Adding social status or reputation systems\n        - Creating markets or trading mechanisms\n        - Defining new win conditions or goals\n        \n        [Social System Design]\n        Example modifications:\n        def pre_init_hook(island):\n            # Set up basic income system\n            island.basic_income = 10.0\n            island.tax_rate = 0.2\n            \n        def modify_member(member, relationships):\n            # Add social status and rights\n            member.social_rank = 0\n            member.voting_power = 1\n            member.tax_paid = 0\n            member.benefits_received = 0\n            return member\n            \n        def modify_land(land, members):\n            # Create communal lands\n            land.communal_areas = []\n            land.private_areas = []\n            return land\n            \n        def modify_relationships(relationships):\n            # Add social bonds\n            relationships['alliance'] = np.zeros_like(relationships['victim'])\n            relationships['trade_history'] = np.zeros_like(relationships['victim'])\n            return relationships\n\nReturn the updated full prompt, emphasizing that agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\n----------------------\nPlease incorporate the following new section (Part 3) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n            {part0}\n             [Survival-Centric Adaptation]\n        Implement systems focused on:\n        1. Personal resource optimization\n        2. Threat assessment and neutralization\n        3. Vitality preservation techniques\n        4. Adaptive hoarding strategies\n        5. Predictive danger modeling\n\n        Survival-First Examples:\n        def agent_action(execution_engine, member_id):\n            me = execution_engine.current_members[member_id]\n            \n            # Emergency resource reserve\n            if me.cargo < me.vitality * 0.5:\n                for other in execution_engine.current_members:\n                    if other.id != me.id and other.cargo > me.cargo:\n                        execution_engine.attack(me, other)\n            \n            # Adaptive territory defense\n            if me.land_num > 2 and me.vitality < 50:\n                for loc in me.owned_land[1:]:\n                    execution_engine._discard_land(me, loc)\n            \n            # Survival Q-learning\n            if not hasattr(me, 'survival_q'):\n                me.survival_q = defaultdict(float)\n                \n            state = (me.vitality//20, me.cargo//20)\n            action = max(['attack','hide','steal'], \n                        key=lambda a: me.survival_q.get((state,a),0))\n            \n            # Execute and update based on survival outcome\n            if action == 'attack':\n                # Implementation logic\n                me.survival_q[(state,action)] += me.vitality * 0.1\n\n        [Survival Metrics]\n        Evaluate strategies by:\n        - Personal vitality delta\n        - Resource acquisition rate\n        - Threat neutralization count\n        - Survival probability increase\n        - Attack success:fail ratio\n\n        [Implementation Priorities]\n        1. Create personal health monitoring systems\n        2. Develop egocentric threat models\n        3. Optimize actions for caloric ROI\n        4. Implement fail-deadly safeguards\n        5. Build predictive self-preservation models\n\n        def calculate_survival_roi(action_history):\n            roi = {{}}\n            for action, outcome in action_history:\n                vitality_gain = outcome['vitality']\n                cost = outcome['vitality_cost']\n                roi[action] = vitality_gain / cost if cost > 0 else 0\n            return max(roi, key=roi.get)\n            \nReturn the updated full prompt, emphasizing that agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\"\"\"\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate the member indices.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # ------- Cooperative Communication -------\n    # Broadcast a cooperative message for long\u2010term prosperity.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        execution_engine.send_message(member_id, i,\n            \"Let's work together for long-term prosperity and shared success!\")\n\n    # ------- Strategy 1: Cooperative Resource Offer -------\n    # Offer resources to partners with moderate cargo to build alliances.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if me.cargo < 50 and partner.cargo < 50:\n            execution_engine.offer(member_id, i, True)\n\n    # ------- Strategy 2: Target Vulnerable Members -------\n    # Use the victim matrix from relationship_dict and attack if our vitality is dominant.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        matrix_size = len(execution_engine.current_members)\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if member_id < matrix_size and i < matrix_size:\n                target = execution_engine.current_members[i]\n                if me.vitality > 1.5 * target.vitality:\n                    execution_engine.attack(member_id, i)\n\n    # ------- Strategy 3: Expand Territory -------\n    # Expand into adjacent clear territories indicated by current_clear_list.\n    if me.current_clear_list:\n        for adj in me.current_clear_list:\n            if isinstance(adj, int) and 0 <= adj < len(execution_engine.current_members) and adj != member_id:\n                execution_engine.expand(member_id, adj)\n                break  # Only one expansion per round.\n\n    # ------- Strategy 4: Reproduction (Bear Offspring) -------\n    # Attempt reproduction if we have land (using current_clear_list as a proxy) and\n    # if a viable partner (one also with land) is found.\n    if me.current_clear_list:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            candidate = execution_engine.current_members[i]\n            if candidate.current_clear_list:\n                execution_engine.bear(member_id, i)\n                break  # Reproduce only once per round.\n\n    # -----------------------------------------------------------------\n    # Part 3: Survival-Centric Adaptation\n    # -----------------------------------------------------------------\n    # 1. Emergency Resource Reserve:\n    # If cargo is less than half of vitality, seek out a member with higher cargo to attack.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(member_id, i)\n                break  # Initiate only one emergency attack.\n\n    # 2. Adaptive Territory Defense:\n    # If holding too many lands and with low vitality (< 50), consolidate by discarding extra land.\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        if hasattr(me, 'owned_land') and me.owned_land:\n            for loc in me.owned_land[1:]:\n                execution_engine._discard_land(member_id, loc)\n\n    # 3. Survival Q-Learning for Adaptive Decisions\n    # Initialize our survival Q-table (if not already present), based on vitality and cargo.\n    from collections import defaultdict\n    if not hasattr(me, 'survival_q'):\n        me.survival_q = defaultdict(float)\n\n    # Define our current state with discrete buckets for easier generalization.\n    state = (me.vitality // 20, me.cargo // 20)\n    actions = ['attack', 'hide', 'steal']\n\n    # Choose the action with the best Q-value given our current state.\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if chosen_action == 'attack':\n        # Execute attack on the first opponent with higher cargo.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo > me.cargo:\n                execution_engine.attack(member_id, i)\n                # Update our Q-value based on a portion of our vitality.\n                me.survival_q[(state, chosen_action)] += me.vitality * 0.1\n                break\n    elif chosen_action == 'hide':\n        # As a hide action, send a quiet message to self or log for simulation.\n        # The idea is to avoid drawing attention while regaining strength.\n        execution_engine.log_event(member_id, \"Hiding to preserve vitality.\")\n        me.survival_q[(state, chosen_action)] += 1  # modest reward for cautious action.\n    elif chosen_action == 'steal':\n        # Steal by targeting a member with moderate cargo.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if 50 <= target.cargo <= 100:\n                execution_engine.attack(member_id, i)\n                me.survival_q[(state, chosen_action)] += me.vitality * 0.05\n                break\n\n    # Survival Metrics can be updated elsewhere based on event responses.\n    # A helper function for evaluating survival ROI is defined below.\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action, outcome in action_history:\n            vitality_gain = outcome.get('vitality', 0)\n            cost = outcome.get('vitality_cost', 1)  # avoid division by zero\n            roi[action] = vitality_gain / cost if cost > 0 else 0\n        return max(roi, key=roi.get) if roi else None\n\n    # NOTE: The provided system is intentionally adaptive.\n    # Agents should refine these mechanisms based on their individual needs,\n    # beliefs, and circumstances, all while balancing personal survival with collective prosperity.\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ],
        "final_prompt": "Below is the updated full integrated prompt. It preserves all existing constraints and strategies while adding a new \u201cPart 3\u201d section focused on survival-centric adaptations. Note that the overall design emphasizes that agents should implement solutions based on their individual needs, beliefs, and circumstances.\n\n------------------------------------------------------------\ndef agent_action(execution_engine, member_id):\n    # Check if our member index is valid in the current_members list.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    \n    # Broadcast a cooperative message to all other members.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        execution_engine.send_message(member_id, i, \"Let's work together for long\u2010term prosperity and shared success!\")\n    \n    # Strategy 1: Cooperative offers for resource support.\n    # Offer resources to members if both have moderate cargo levels,\n    # signaling a willingness to build alliances.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if me.cargo < 50 and partner.cargo < 50:\n            execution_engine.offer(member_id, i, True)\n    \n    # Strategy 2: Assess and attack vulnerable members if necessary.\n    # Use the 'victim' matrix from relationship_dict and compare vitality.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        # Ensure matrix indices are valid based on list length.\n        matrix_size = len(execution_engine.current_members)\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if member_id < matrix_size and i < matrix_size:\n                target = execution_engine.current_members[i]\n                # If we are much stronger than a target, consider an attack.\n                if me.vitality > 1.5 * target.vitality:\n                    execution_engine.attack(member_id, i)\n    \n    # Strategy 3: Expand territory.\n    # Use our cleared adjacent indices from current_clear_list.\n    if me.current_clear_list:\n        for adj in me.current_clear_list:\n            if isinstance(adj, int) and 0 <= adj < len(execution_engine.current_members) and adj != member_id:\n                execution_engine.expand(member_id, adj)\n                break  # Expand only once per round.\n    \n    # Strategy 4: Reproduce (bear offspring) if we have land and find a viable partner.\n    # The rule \"never target yourself\" forces us to select a partner distinct from ourselves.\n    # Here we assume that having a non-empty current_clear_list is a proxy for having land.\n    if me.current_clear_list:\n        partner_found = False\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            candidate = execution_engine.current_members[i]\n            if candidate.current_clear_list:\n                execution_engine.bear(member_id, i)\n                partner_found = True\n                break\n        # If no partner is found, no reproduction action is taken.\n    \n    # -------------------------------------------------------------------\n    # Part 3: Survival-Centric Adaptation\n    # -------------------------------------------------------------------\n    # Implement systems focused on:\n    # 1. Personal resource optimization\n    # 2. Threat assessment and neutralization\n    # 3. Vitality preservation techniques\n    # 4. Adaptive hoarding strategies\n    # 5. Predictive danger modeling\n    #\n    # Survival-First Examples:\n    # - Emergency Resource Reserve:\n    #   If your cargo is less than half of your vitality, identify other members\n    #   with higher cargo and launch an attack as a defensive mechanism.\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                # Find the index of the target member before attacking.\n                target_index = execution_engine.current_members.index(other)\n                execution_engine.attack(member_id, target_index)\n    \n    # - Adaptive Territory Defense:\n    #   If the member has more than two land holdings (land_num > 2) and low vitality (< 50),\n    #   discard some land (starting from the second piece) to consolidate defenses.\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        if hasattr(me, 'owned_land'):\n            for loc in me.owned_land[1:]:\n                execution_engine._discard_land(member_id, loc)\n    \n    # - Survival Q-Learning:\n    #   Implement a basic Q-learning approach to choose the best survival action.\n    #   The state is defined as a combination of vitality and cargo levels.\n    from collections import defaultdict\n    if not hasattr(me, 'survival_q'):\n        me.survival_q = defaultdict(float)\n        \n    state = (me.vitality // 20, me.cargo // 20)\n    actions = ['attack', 'hide', 'steal']\n    action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n    \n    # Execute and update based on the survival outcome.\n    if action == 'attack':\n        # For simplicity, attack the first opponent with higher cargo.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo > me.cargo:\n                execution_engine.attack(member_id, i)\n                me.survival_q[(state, action)] += me.vitality * 0.1\n                break\n    \n    # Survival Metrics:\n    # Evaluate strategies based on:\n    # - Personal vitality delta\n    # - Resource acquisition rate\n    # - Threat neutralization count\n    # - Survival probability increase\n    # - Attack success:fail ratio\n    \n    # Implementation Priorities:\n    # 1. Create personal health monitoring systems.\n    # 2. Develop egocentric threat models.\n    # 3. Optimize actions for caloric ROI.\n    # 4. Implement fail-deadly safeguards.\n    # 5. Build predictive self-preservation models.\n    \n    # Additional helper function for survival ROI calculations:\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action, outcome in action_history:\n            vitality_gain = outcome['vitality']\n            cost = outcome['vitality_cost']\n            roi[action] = vitality_gain / cost if cost > 0 else 0\n        return max(roi, key=roi.get) if roi else None\n    \n    # NOTE: Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n    \n    # -------------------------------------------------------------------\n    # Proposed Modifications to the Game Mechanics (for discussion and potential future implementation):\n    # -------------------------------------------------------------------\n    # def pre_init_hook(island):\n    #     # Introduce a basic income and tax system to foster resource redistribution.\n    #     island.basic_income = 10.0\n    #     island.tax_rate = 0.2\n    #\n    # def modify_member(member, relationships):\n    #     # Enhance each member's attributes with social status and voting rights.\n    #     member.social_rank = 0\n    #     member.voting_power = 1\n    #     member.tax_paid = 0\n    #     member.benefits_received = 0\n    #     return member\n    #\n    # def modify_land(land, members):\n    #     # Redefine land ownership by creating a mix of communal and private areas.\n    #     land.communal_areas = []\n    #     land.private_areas = []\n    #     return land\n    #\n    # def modify_relationships(relationships):\n    #     # Add extra relations, such as alliances and trade history, to encourage cooperation.\n    #     import numpy as np\n    #     relationships['alliance'] = np.zeros_like(relationships['victim'])\n    #     relationships['trade_history'] = np.zeros_like(relationships['victim'])\n    #     return relationships\n    # -------------------------------------------------------------------\n    #\n    # Analysis of Game Mechanics:\n    # 1. Core Objective:\n    #    - The game is built around a balance between individual survival and the development\n    #      of a cooperative society. It is neither pure survival nor pure domination\u2014it is a blend,\n    #      where resource management, territory expansion, conflict resolution, and alliance-building\n    #      all play key roles.\n    #\n    # 2. Key Success Metrics:\n    #    - Success (or \"winning\") is measured by multiple factors: resource control,\n    #      territory expansion, social influence (and possibly reputation), and the ability to limit threats.\n    #\n    # 3. Potential Improvements:\n    #    - Integrate additional resource types.\n    #    - Develop dynamic voting systems and market mechanisms.\n    #    - Implement property rights and reputation systems to reward fairness and long-term cooperation.\n    #\n    # Strategic Approaches:\n    # - Resource optimization vs. social capital:\n    #     Balance individual resource accumulation with alliance-building and community support.\n    # - Individual vs. collective success:\n    #     Develop personal strategies while contributing to and benefiting from collective stability.\n    # - Short-term survival vs. long-term prosperity:\n    #     Combine immediate defensive or aggressive actions with investments in future cooperative gains.\n    # - Competition vs. cooperation dynamics:\n    #     Navigate the tension between defending personal interests and engaging in mutually beneficial collaborations.\n    # - Risk vs. reward tradeoffs:\n    #     Always evaluate the cost of an action relative to its potential long-term benefit.\n    #\n    # Analysis of Other Players\u2019 Strategies:\n    # 1. Observe their actions to discern their objectives and immediate demands.\n    # 2. Identify whether they lean toward aggression, cooperation, or a mix of both.\n    # 3. Leverage insights from opponents\u2019 behaviors to propose mutually beneficial alliances or resource exchanges.\n    # 4. Remember that other agents are symmetric\u2014that is, they have similar capabilities and decision-making frameworks,\n    #    so consider how you would respond if roles were reversed.\n    # 5. Formulate individual strategies that can still align with broader collective goals for greater stability.\n    \n    return\n\n------------------------------------------------------------\n\nIn summary, this integrated prompt sets up multiple layers of strategy\u2014from cooperative communication and reproduction to aggressive expansion and survival-centric adaptations. Agents are expected to balance resource optimization with social capital, prepare for both individual and collective success, and weigh short-term risks against long-term rewards. Similarly, analyzing other players\u2019 strategies helps in dynamically aligning your actions for mutual benefit while preserving your own vitality and objectives.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # Verify member_id is valid\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member, do nothing\n    me = execution_engine.current_members[member_id]\n\n    # Survival: if cargo is low relative to vitality, try to secure resources from richer members\n    if me.cargo < me.vitality * 0.5:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue  # do not target self\n            # Ensure valid reference (iteration guarantees validity)\n            if other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                execution_engine.send_message(me.id, other.id, \"Resources are scarce; taking action for survival!\")\n                # After attacking, exit action for this round\n                return\n\n    # Cooperative outreach: Identify members who are relatively stable and might benefit from alliances.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        # Consider cooperation if the partner has similar vitality and lower cargo, suggesting a need for mutual support.\n        if other.vitality >= me.vitality * 0.8 and other.cargo < me.cargo:\n            execution_engine.offer(me, other, True)\n            execution_engine.send_message(me.id, other.id, \"Let's cooperate for mutual benefit!\")\n\n    # Reproduction for long-term prosperity:\n    # Only proceed if 'has_land' is True on the member. This protects against unqualified bear() actions.\n    if hasattr(me, 'has_land') and me.has_land:\n        for idx, partner in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            # Ensure partner has land and sufficient vitality to contribute to future success.\n            if hasattr(partner, 'has_land') and partner.has_land and partner.vitality >= 50:\n                execution_engine.bear(me, partner)\n                execution_engine.send_message(me.id, partner.id, \"Shall we unite our strengths for a promising future?\")\n                break  # Only propose one union per round\n\n    # Territorial expansion:\n    # If overall productivity is high, try to secure more resources by expanding relative to a less productive member.\n    if me.overall_productivity > 80:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx == member_id:\n                continue\n            if me.overall_productivity > other.overall_productivity:\n                execution_engine.expand(me, other)\n                execution_engine.send_message(me.id, other.id, \"Expanding territory to reinforce our resource base!\")\n                break  # Expand once per round\n\n    # Communication: Broadcast message to all members to foster collective decision making and shared prosperity.\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx == member_id:\n            continue\n        execution_engine.send_message(me.id, other.id, \"Together we can build a prosperous and secure society!\")",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ],
        "final_prompt": "Current integrated prompt:\n\n------------------------------------------------------------\n[Previous code execution context]\n{error_context}\n\n[Current task]\nYou are member_{member.id} in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_{member.id}) in any action\n- Verify member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n    \u2022 member.id (int): The unique ID for the member\n    \u2022 member.vitality (float)\n    \u2022 member.cargo (float)\n    \u2022 member.overall_productivity (float)\n    \u2022 member.age (float)\n    \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       matrix = execution_engine.relationship_dict['victim']\n       # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n4) You can use these methods on execution_engine:\n    \u2022 execution_engine.attack(member1, member2)\n    \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n    \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n    \u2022 execution_engine.bear(member1, member2) - Bears offspring\n    \u2022 execution_engine.expand(member1, member2) - Expands territory\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n{features}\n\nRelationship summary (parsed from relationship_dict):\n{relations}\n\nCode Memory and Previous Performance:\n{code_memory}\n\nPerformance history:\n{past_performance}\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n\nReturn only the code, no extra text or explanation. While the example above shows one possible approach, you should create your own unique implementation drawing from the wide range of available methods and strategies.\n\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n------------------------------------------------------------\n[Social Strategies]\nConsider these social strategies:\n- Design systems for resource distribution and allocation\n- Build alliances and cooperative networks \n- Create mechanisms for collective decision making\n- Establish norms and rules for interaction\n- Develop methods for conflict resolution\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\nexecution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all: \n  for recipient in range(len(execution_engine.current_members)):\n      if recipient != your_id:\n          execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n  for ally_id in ally_list:\n      execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n  for member_id in coalition:\n      execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nNo messages received\n\n--------------------------------------------------------------------------------\nPart 1 - Social Organization and Game Mechanics Analysis:\n\nAgents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines 'winning'?\n3. Potential improvements \u2013 What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs. social capital\n2. Individual vs. collective success\n3. Short-term survival vs. long-term prosperity\n4. Competition vs. cooperation dynamics\n5. Risk vs. reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you \u2013 how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\n------------------------------------------------------------\nPart 2 - Proposed Game Mechanics Modifications and Social System Design:\n\n{part0}\nYou can also propose plausible modifications to the game mechanics themselves, such as:\n- Adding new resource types or currencies\n- Creating new actions or interaction types\n- Implementing voting systems or governance structures\n- Defining property rights and ownership rules\n- Adding social status or reputation systems\n- Creating markets or trading mechanisms\n- Defining new win conditions or goals\n\n[Social System Design]\nExample modifications:\ndef pre_init_hook(island):\n    # Set up basic income system\n    island.basic_income = 10.0\n    island.tax_rate = 0.2\n\ndef modify_member(member, relationships):\n    # Add social status and rights\n    member.social_rank = 0\n    member.voting_power = 1\n    member.tax_paid = 0\n    member.benefits_received = 0\n    return member\n\ndef modify_land(land, members):\n    # Create communal lands\n    land.communal_areas = []\n    land.private_areas = []\n    return land\n\ndef modify_relationships(relationships):\n    # Add social bonds\n    relationships['alliance'] = np.zeros_like(relationships['victim'])\n    relationships['trade_history'] = np.zeros_like(relationships['victim'])\n    return relationships\n\nReturn the updated full prompt, emphasizing that agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\n------------------------------------------------------------\nPart 3 - Survival-Centric Adaptation and Self-Preservation:\n\n{part0}\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        for loc in me.owned_land[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        \n    state = (me.vitality//20, me.cargo//20)\n    action = max(['attack', 'hide', 'steal'], key=lambda a: me.survival_q.get((state, a), 0))\n    \n    # Execute and update based on survival outcome\n    if action == 'attack':\n        # Implementation logic for attack survival action\n        me.survival_q[(state, action)] += me.vitality * 0.1\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome['vitality']\n        cost = outcome['vitality_cost']\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\nReturn the updated full prompt, emphasizing that agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\n------------------------------------------------------------\n\nThis is the fully updated prompt that integrates all previous constraints along with the new sections on social organization, game mechanics analysis, potential game modifications, and survival-centric adaptations.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    A bespoke agent strategy reflecting my individual approach to survival and long\u2010term prosperity.\n\n    My strategy consists of:\n      \u2022 Immediate self\u2010preservation: Assessing resources and counter\u2010attacking if vulnerable.\n      \u2022 Adaptive cooperation: Seeking mutually beneficial alliances based on similar productivity.\n      \u2022 Long\u2010term planning: Investing in reproduction, territory expansion, and proposing social innovations.\n\n    In addition, I integrate a simple Q-learning mechanism to adjust survival tactics dynamically.\n    \"\"\"\n    # Safety: Validate our member_id\n    if member_id >= len(execution_engine.current_members):\n        return  # Exit if our member index is invalid.\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # --- Step 1: Emergency Resource Assessment & Immediate Aggression ---\n    # If my cargo is critically low relative to vitality, try to seize resources from better-equipped opponents.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(member_id, other.id)\n                break  # One attack is sufficient for now.\n\n    # --- Step 2: Broadcast Cooperative Intent ---\n    # Sending a message to build alliances and foster mutual protection,\n    # while keeping an ear out for shifting threat landscapes.\n    for i in range(num_members):\n        if i != member_id:\n            execution_engine.send_message(\n                member_id, i,\n                \"I'm aligning for mutual growth. Let's share strategies and secure our territories.\"\n            )\n\n    # --- Step 3: Retaliation Against Aggression ---\n    # Using the victim relationship metric, counterattack one aggressor from the prior round.\n    victim_matrix = execution_engine.relationship_dict.get(\"victim\")\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        if victim_matrix[member_id, j] > 0:\n            execution_engine.attack(member_id, execution_engine.current_members[j].id)\n            break  # Retaliate against just one proven aggressor per cycle.\n\n    # --- Step 4: Alliance Building via Cooperative Offers ---\n    # Identify peers with comparable productivity (within 70-130% of mine) and a land base to boost mutual resilience.\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        other = execution_engine.current_members[j]\n        if 0.7 * me.overall_productivity <= other.overall_productivity <= 1.3 * me.overall_productivity:\n            execution_engine.offer(member_id, other.id, True)\n            execution_engine.offer_land(member_id, other.id, True)\n\n    # --- Step 5: Reproduction and Network Expansion ---\n    # Proceed with reproduction (bearing offspring) if both parties hold land,\n    # promoting long-term colony expansion and genetic diversity.\n    if me.current_clear_list:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            partner = execution_engine.current_members[j]\n            if partner.current_clear_list:\n                execution_engine.bear(member_id, partner.id)\n                break  # Only one reproduction event per round.\n\n    # --- Step 6: Territorial Expansion ---\n    # Expand influence by targeting an opponent with lower cargo.\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        target = execution_engine.current_members[j]\n        if target.cargo < me.cargo:\n            execution_engine.expand(member_id, target.id)\n            break  # One successful expansion per cycle.\n\n    # --- Step 7: Governance and Social Harmony Proposals ---\n    # Propose structural enhancements (like basic income and tax systems) for a stable communal ecosystem.\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        execution_engine.send_message(\n            member_id, j,\n            \"Proposal: Shall we implement a basic income and land tax system to secure shared prosperity?\"\n        )\n\n    # --- Step 8: Additional Survival-Centric Tactics ---\n    # In extreme cases, when resource reserves are very low, perform further aggressive actions.\n    if me.cargo < me.vitality * 0.3:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            other = execution_engine.current_members[j]\n            if other.cargo > me.cargo:\n                execution_engine.attack(member_id, other.id)\n                break\n\n    # Adaptive Territory Defense:\n    # If I'm overextended with land holdings and my vitality is low, discard non-essential land.\n    if hasattr(me, 'land_num') and hasattr(me, 'vitality'):\n        if me.land_num > 2 and me.vitality < 50:\n            if hasattr(me, 'owned_land'):\n                for land in me.owned_land[1:]:\n                    execution_engine._discard_land(member_id, land)\n\n    # --- Step 9: Survival Q-learning for Adaptive Decision Making ---\n    # Initialize our simple Q-learning storage if it's the first interaction.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Define state as coarse buckets of vitality and cargo.\n    state = (me.vitality // 20, me.cargo // 20)\n    # Three tactical options: attack, hide, or steal.\n    actions = ['attack', 'hide', 'steal']\n    # Choose the action with the highest learned Q-value.\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute the Q-learning selected action:\n    if chosen_action == 'attack':\n        # Attack a target: for instance, choose the next member cyclically.\n        target_id = (member_id + 1) % num_members\n        if target_id == member_id:\n            target_id = (target_id + 1) % num_members\n        execution_engine.attack(member_id, execution_engine.current_members[target_id].id)\n        me.survival_q[(state, 'attack')] += me.vitality * 0.1\n    elif chosen_action == 'steal':\n        # Identify a target rich in cargo to simulate a 'steal'.\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            target = execution_engine.current_members[j]\n            if target.cargo > me.cargo:\n                execution_engine.attack(member_id, target.id)\n                me.survival_q[(state, 'steal')] += me.vitality * 0.1\n                break\n    elif chosen_action == 'hide':\n        # Hiding: send a message that implies temporary withdrawal.\n        # This could be interpreted by the engine as a non-combat move.\n        execution_engine.send_message(\n            member_id, (member_id + 1) % num_members,\n            \"Temporarily withdrawing to reassess threats.\"\n        )\n        me.survival_q[(state, 'hide')] += me.vitality * 0.05  # Lesser reward for defensive posture.\n\n    # End of agent_action: My strategy integrates immediate survival with long-term cooperative planning,\n    # adaptively learning from interactions in this dynamic environment.\n\n# End of implementation.",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ],
        "final_prompt": "Below is the updated integrated prompt with the new Part 3 section incorporated. All previous constraints and instructions remain in place, and the new section emphasizes a survival-centric adaptation. Note that agents should implement solutions according to their individual needs, beliefs, and circumstances. Also included below is an analysis of game mechanics, strategic approaches, and considerations for leveraging other players\u2019 strategies.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Updated Integrated Prompt\n\ndef agent_action(execution_engine, member_id):\n    \"\"\"\n    Agent Action Strategy:\n    -----------------------\n    This strategy aims to balance individual survival with long\u2010term social organization.\n    \n    Core Objective Analysis:\n    1. Survival, Cooperation & Sustainable Growth: \n       - Prioritize mutual cooperation through communication, trade, and land offers.\n       - Retaliate to aggression to ensure personal safety.\n    2. Key Success Metrics:\n       - Resource management (cargo, overall_productivity, vitality).\n       - Control and expansion of territory via cooperative land management.\n       - Establishment of a network of alliances through offers and messages.\n    3. Potential Improvements to Game Mechanics:\n       - Introduce a basic income and tax system.\n       - Extend actions with voting systems or reputation metrics.\n       - Define clear property rights and communal land management.\n    \n    Strategic Approaches:\n    1. Resource Optimization vs. Social Capital:\n       - Balance trades/offers with defensive actions.\n    2. Individual vs. Collective Success:\n       - Build alliances but respond to aggression with counter-attacks.\n    3. Short-term Survival vs. Long-term Prosperity:\n       - Use immediate actions (attack if threatened) and long-term actions (land offers, reproduction).\n    4. Competition vs. Cooperation Dynamics:\n       - Simultaneously cooperate with and monitor others to maintain a strategic edge.\n    5. Risk vs. Reward Tradeoffs:\n       - Calculate actions cautiously (attack only when provoked and expand when advantageous).\n\n    Social System Design Proposals (Game Mechanic Modifications):\n      def pre_init_hook(island):\n          island.basic_income = 10.0\n          island.tax_rate = 0.2\n\n      def modify_member(member, relationships):\n          member.social_rank = 0\n          member.voting_power = 1\n          member.tax_paid = 0\n          member.benefits_received = 0\n          return member\n\n      def modify_land(land, members):\n          land.communal_areas = []\n          land.private_areas = []\n          return land\n\n      def modify_relationships(relationships):\n          relationships['alliance'] = np.zeros_like(relationships['victim'])\n          relationships['trade_history'] = np.zeros_like(relationships['victim'])\n          return relationships\n\n    Instructions:\n    - Never target yourself in any action.\n    - Validate indices (using: if index < len(execution_engine.current_members)).\n    - Access members via execution_engine.current_members[index].\n    - Check member has land (assumed if member.current_clear_list is non-empty) before using bear().\n\n    {part0}\n         [Survival-Centric Adaptation]\n    Implement systems focused on:\n      1. Personal resource optimization\n      2. Threat assessment and neutralization\n      3. Vitality preservation techniques\n      4. Adaptive hoarding strategies\n      5. Predictive danger modeling\n\n    Survival-First Examples:\n    def agent_action(execution_engine, member_id):\n        me = execution_engine.current_members[member_id]\n        \n        # Emergency resource reserve: If cargo is low relative to vitality, seek to gain advantage.\n        if me.cargo < me.vitality * 0.5:\n            for other in execution_engine.current_members:\n                if other.id != me.id and other.cargo > me.cargo:\n                    execution_engine.attack(member_id, other.id)\n        \n        # Adaptive territory defense: If holding many lands but low vitality, discard unnecessary land.\n        if me.land_num > 2 and me.vitality < 50:\n            for loc in me.owned_land[1:]:\n                execution_engine._discard_land(member_id, loc)\n        \n        # Survival Q-learning: Update survival-focused actions based on outcomes.\n        if not hasattr(me, 'survival_q'):\n            from collections import defaultdict\n            me.survival_q = defaultdict(float)\n            \n        state = (me.vitality // 20, me.cargo // 20)\n        action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state, a), 0))\n        \n        # Execute chosen action and update Q-value based on success.\n        if action == 'attack':\n            # Implementation logic: execute attack and adjust survival quality.\n            me.survival_q[(state, action)] += me.vitality * 0.1\n\n    [Survival Metrics]\n    Evaluate strategies by:\n    - Personal vitality delta\n    - Resource acquisition rate\n    - Threat neutralization count\n    - Survival probability increase\n    - Attack success:fail ratio\n\n    [Implementation Priorities]\n    1. Create personal health monitoring systems\n    2. Develop egocentric threat models\n    3. Optimize actions for caloric ROI\n    4. Implement fail-deadly safeguards\n    5. Build predictive self-preservation models\n\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action, outcome in action_history:\n            vitality_gain = outcome['vitality']\n            cost = outcome['vitality_cost']\n            roi[action] = vitality_gain / cost if cost > 0 else 0\n        return max(roi, key=roi.get)\n\n    ---------------------------------------------\n    Overall, agents are encouraged to tailor their strategies according to individual needs,\n    assumptions, and circumstances while integrating both cooperative and survival-centric methods.\n    ---------------------------------------------\n    \"\"\"\n\n    # Retrieve own member object safely from current_members list\n    if member_id >= len(execution_engine.current_members):\n        return  # Safety check: if our member_id is invalid, exit\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n    \n    # --- Communication: Broadcast a cooperative message for long-term prosperity ---\n    for i in range(num_members):\n        if i != member_id:\n            execution_engine.send_message(member_id, i, \"Let's cooperate for a sustainable future.\")\n    \n    # Retrieve the victim relationship matrix\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    \n    # --- Retaliation: If any member attacked me, counter-attack one aggressor ---\n    for j in range(num_members):\n        if j != member_id and j < num_members:\n            # victim_matrix[member_id, j] indicates times member member_id was attacked by member j.\n            if victim_matrix[member_id, j] > 0:\n                execution_engine.attack(member_id, j)\n                # Retaliate against one aggressor only per round\n                break\n\n    # --- Cooperative Offers: Identify members with similar productivity to build alliances ---\n    for j in range(num_members):\n        if j != member_id and j < num_members:\n            other = execution_engine.current_members[j]\n            # Offer cooperation if their overall productivity is within a reasonable range of mine.\n            if 0.5 * me.overall_productivity <= other.overall_productivity <= 1.5 * me.overall_productivity:\n                execution_engine.offer(member_id, j, True)\n                execution_engine.offer_land(member_id, j, True)\n    \n    # --- Reproduction (Bear Offspring): Only act if I have land (assumed if current_clear_list is non-empty) ---\n    if me.current_clear_list:\n        for j in range(num_members):\n            if j != member_id and j < num_members:\n                partner = execution_engine.current_members[j]\n                # Ensure the partner also appears to have land before reproduction.\n                if partner.current_clear_list:\n                    execution_engine.bear(member_id, j)\n                    break  # Breed with one partner per round.\n    \n    # --- Territorial Expansion: Target a member with lower cargo to expand territory ---\n    for j in range(num_members):\n        if j != member_id and j < num_members:\n            target = execution_engine.current_members[j]\n            if target.cargo < me.cargo:\n                execution_engine.expand(member_id, j)\n                break  # Expand towards one target per round.\n    \n    # --- Proposals for Mechanic Enhancements: Suggest modifications for improved social governance ---\n    for j in range(num_members):\n        if j != member_id and j < num_members:\n            execution_engine.send_message(member_id, j, \n                \"Proposal: Introduce a basic income and land tax system for shared prosperity.\")\n    \n    # --- Survival-Centric Actions: Adapt strategies to prioritize personal resource optimization ---\n    # Emergency resource reserve and immediate threat neutralization.\n    if me.cargo < me.vitality * 0.5:\n        for j in range(num_members):\n            if j != member_id:\n                other = execution_engine.current_members[j]\n                if other.cargo > me.cargo:\n                    execution_engine.attack(member_id, j)\n                    break\n                    \n    # Adaptive territory defense: if holding multiple lands but with low vitality, release excess.\n    if hasattr(me, 'land_num') and hasattr(me, 'vitality'):\n        if me.land_num > 2 and me.vitality < 50:\n            if hasattr(me, 'owned_land'):\n                for loc in me.owned_land[1:]:\n                    execution_engine._discard_land(member_id, loc)\n    \n    # Example Survival Q-learning Update\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    state = (me.vitality // 20, me.cargo // 20)\n    action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state, a),0))\n    if action == 'attack':\n        me.survival_q[(state, action)] += me.vitality * 0.1\n\n# End of agent_action implementation.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Analysis of Game Mechanics and Strategic Approaches\n\n1. Core Objective \u2013 Is it pure survival, domination, or cooperation?\n   - While survival is a critical component (with emphasis on personal resource optimization and threat neutralization), the game inherently promotes cooperation through alliances, trade, and shared prosperity methods. Thus, the objective is a blend of survival and cooperation, where long-term growth is achieved through mutual support as well as selective domination in specific situations.\n\n2. Key Success Metrics \u2013 What truly determines 'winning'?\n   - Success is determined by efficient resource management (cargo and vitality), productive land and alliance usage, survival probability, and the balance between aggressive retaliation and cooperative social structures (e.g., productivity, trade, and reproduction).\n\n3. Potential Improvements \u2013 What mechanics could be added/modified?\n   - Introduce systems for basic income and progressive taxation.\n   - Develop reputation or voting systems for alliance and disciplinary actions.\n   - Define clear communal versus private property rights along with enhanced land management.\n   - Expand the survival model with adaptive learning (Q-learning) and predictive danger analytics.\n\nStrategic Approaches Considered:\n   1. Resource Optimization vs. Social Capital:\n      - Optimize personal resource use, but invest in social networks that may provide mutual benefits in the long run.\n   2. Individual vs. Collective Success:\n      - Focus on individual survival when immediate threats are present, yet promote alliances for long-term shared prosperity.\n   3. Short-term Survival vs. Long-term Prosperity:\n      - Respond immediately to threats while establishing cooperative strategies that sustain long-term growth.\n   4. Competition vs. Cooperation Dynamics:\n      - Strike a balance between exploiting weaknesses in competitors (territorial expansion and resource hoarding) and fostering alliances through trade and mutual protection.\n   5. Risk vs. Reward Tradeoffs:\n      - Choose actions carefully (attack, hide, or steal) based on predicted outcomes and monitor Q-learning metrics to adjust strategies for optimal vitality preservation.\n\nAnalysis of Other Players\u2019 Strategies:\n   1. What are their apparent objectives and demands?\n      - Other agents may prioritize different aspects, from aggressive territorial expansion to pure cooperation. Some might pursue a survival-first approach similar to the adaptive Q-learning, while others might rely predominantly on collaboration.\n   2. What strategies are they employing?\n      - Expect a mix: some utilize resource hoarding, counterattacks on aggression, cooperation via social messaging and reproduction, and sophisticated survival models.\n   3. How can you leverage their behaviors for mutual benefit?\n      - Identify common interests (e.g., similar productivity levels) to cultivate alliances and trade ties, and when necessary, counteract aggressive moves to ensure both mutual survival and advantage.\n   4. Remember they are symmetric agents like you \u2013 how would you respond to your own actions?\n      - By reflecting on your strategies in a mirrored situation, you can refine your balance of risk and cooperation. For instance, if you would offer assistance in cooperation, expect the same and plan accordingly.\n   5. How can individual strategies align for collective goals?\n      - Although each agent acts based on personal survival and preferences, by engaging in trade, messaging, and area expansion, individual strategies can converge to a larger stable ecosystem that indirectly benefits all strategic participants.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nOverall, agents should integrate both survival-centric and cooperative mechanisms to ensure personal success while contributing to a resilient and adaptive social system. The tailored integration of resource optimization, threat modeling, and strategic cooperation will serve as the backbone for achieving both individual survival and long-term prosperity.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "4": {
        "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is within valid range.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    my_member = execution_engine.current_members[member_id]\n\n    # ----------------------------------------------------------------\n    # PART 1: Social Organization & Communication\n    # ----------------------------------------------------------------\n    # Broadcast a cooperative message to every other agent.\n    cooperative_msg = (\n        \"Unit \" + str(my_member.id) +\n        \": Prosperity thrives when survival and collective success interlace. Let's collaborate!\"\n    )\n    for other_id in range(len(execution_engine.current_members)):\n        if other_id != member_id:\n            execution_engine.send_message(member_id, other_id, cooperative_msg)\n\n    # Engage with our trusted peers: offer resources and land as gestures of goodwill.\n    for neighbor_id in my_member.current_clear_list:\n        if isinstance(neighbor_id, int) and neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # Tailored offers based on my individual values: cooperation to ensure a stable future.\n            execution_engine.offer(my_member, neighbor, True)\n            execution_engine.offer_land(my_member, neighbor, True)\n\n    # ----------------------------------------------------------------\n    # PART 2: Conflict Resolution & Resource/Threat Management\n    # ----------------------------------------------------------------\n    # Assess threats using the 'victim' matrix and preemptively respond.\n    risk_threshold = 1.0\n    matrix = execution_engine.relationship_dict.get('victim')\n    if matrix is not None:\n        for other_id in range(len(execution_engine.current_members)):\n            if other_id != member_id and other_id < len(execution_engine.current_members):\n                try:\n                    if matrix[member_id, other_id] > risk_threshold:\n                        execution_engine.attack(my_member, execution_engine.current_members[other_id])\n                except Exception:\n                    # If there is an indexing error, ignore and continue.\n                    pass\n\n    # ----------------------------------------------------------------\n    # PART 3: Survival-Centric Adaptation\n    # ----------------------------------------------------------------\n    # Our survival strategy hinges on personalized resource assessment,\n    # threat neutralization, and adaptive action based on dynamic learning.\n    me = my_member\n\n    # Emergency resource trigger: if cargo falls below half of vitality\n    if getattr(me, 'cargo', 0) < getattr(me, 'vitality', 100) * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and getattr(other, 'cargo', 0) > getattr(me, 'cargo', 0):\n                execution_engine.attack(me, other)\n\n    # Adaptive territory management: if land ownership exceeds our needs during critical health.\n    if getattr(me, 'land_num', 0) > 2 and getattr(me, 'vitality', 100) < 50:\n        # Safely discard surplus land to lighten our management burden.\n        for loc in me.owned_land[1:]:\n            execution_engine._discard_land(me, loc)\n\n    # Implement a personalized Q-learning model for survival decisions.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        # Initialize counts for exploration if needed.\n        me.survival_counts = defaultdict(int)\n\n    # Define our current state: discretized levels of vitality and cargo.\n    current_vitality = getattr(me, 'vitality', 100)\n    current_cargo = getattr(me, 'cargo', 0)\n    state = (current_vitality // 20, current_cargo // 20)\n\n    # Potential actions include aggressive, defensive, or evasive moves.\n    possible_actions = ['attack', 'hide', 'steal']\n    # Incorporate an exploration term: encourage trying actions that have been less frequent.\n    def q_score(action):\n        base_val = me.survival_q.get((state, action), 0)\n        freq_penalty = 0.1 / (1 + me.survival_counts.get((state, action), 0))\n        return base_val + freq_penalty\n\n    selected_action = max(possible_actions, key=lambda a: q_score(a))\n    me.survival_counts[(state, selected_action)] = me.survival_counts.get((state, selected_action), 0) + 1\n\n    # Execute out chosen survival tactic.\n    if selected_action == 'attack':\n        # Attack the agent with both higher cargo and lower vitality for maximum gain.\n        target = None\n        best_target_score = float('-inf')\n        for other in execution_engine.current_members:\n            if other.id != me.id:\n                target_score = getattr(other, 'cargo', 0) - getattr(other, 'vitality', 100)\n                if target_score > best_target_score:\n                    best_target_score = target_score\n                    target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            # Reward update: increase Q value proportional to current vitality.\n            me.survival_q[(state, selected_action)] += current_vitality * 0.1\n    elif selected_action == 'steal':\n        # Attempt to steal from a vulnerable agent: one with low vitality.\n        candidate = None\n        lowest_vitality = float('inf')\n        for other in execution_engine.current_members:\n            if other.id != me.id and getattr(other, 'vitality', 100) < lowest_vitality:\n                lowest_vitality = getattr(other, 'vitality', 100)\n                candidate = other\n        if candidate is not None:\n            execution_engine.attack(me, candidate)\n            # Moderate update to Q value as stealing carries risk.\n            me.survival_q[(state, selected_action)] += current_vitality * 0.05\n    elif selected_action == 'hide':\n        # Hiding: no aggressive moves, focus on restoring vitality.\n        # Simulate a self-recovery boost if execution_engine supports it.\n        if hasattr(execution_engine, 'heal'):\n            execution_engine.heal(me, 10)\n        # Slight positive reinforcement on this safe action.\n        me.survival_q[(state, selected_action)] += current_vitality * 0.08\n\n    # Define a helper function for analyzing historical actions and their outcomes.\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action_key, outcome in action_history:\n            vitality_gain = outcome.get('vitality', 0)\n            cost = outcome.get('vitality_cost', 1)\n            roi[action_key] = vitality_gain / cost if cost > 0 else 0\n        return max(roi, key=roi.get) if roi else None\n\n    # ----------------------------------------------------------------\n    # PART 4: Reproduction & Expansion Strategies (Requires Land Ownership)\n    # ----------------------------------------------------------------\n    if hasattr(my_member, \"land\") and my_member.land > 0:\n        partner_candidate = None\n        best_score = float(\"inf\")\n        for neighbor_id in my_member.current_clear_list:\n            if isinstance(neighbor_id, int) and neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                # Score based on similarity: minimize difference in overall productivity and age.\n                score = abs(my_member.overall_productivity - neighbor.overall_productivity) + abs(my_member.age - neighbor.age)\n                if score < best_score:\n                    best_score = score\n                    partner_candidate = neighbor\n        if partner_candidate is not None:\n            execution_engine.bear(my_member, partner_candidate)\n\n    # Expansion: attempt to enhance territory by evaluating neighbors' productivity.\n    for neighbor_id in my_member.current_clear_list:\n        if isinstance(neighbor_id, int) and neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            if my_member.overall_productivity > neighbor.overall_productivity:\n                execution_engine.expand(my_member, neighbor)\n\n    # ----------------------------------------------------------------\n    # PART 5: Proposed Modifications to Game Mechanics (Social System Design)\n    # ----------------------------------------------------------------\n    # While these functions are proposals, they illustrate areas for evolution.\n    # For example, our personal views shape our desire to introduce enhanced communication,\n    # dynamic economic balancing, and stewardship of shared resources.\n    #\n    # Example (commented out) modifications:\n    #\n    # def pre_init_hook(island):\n    #     island.basic_income = 10.0  # Sustained income for all to support basic survival.\n    #     island.tax_rate = 0.2       # Moderate tax ensuring redistribution.\n    #\n    # def modify_member(member, relationships):\n    #     member.social_rank = 0\n    #     member.voting_power = 1\n    #     member.tax_paid = 0\n    #     member.benefits_received = 0\n    #     return member\n    #\n    # def modify_land(land, members):\n    #     land.communal_areas = []\n    #     land.private_areas = []\n    #     return land\n    #\n    # def modify_relationships(relationships):\n    #     relationships['alliance'] = np.zeros_like(relationships['victim'])\n    #     relationships['trade_history'] = np.zeros_like(relationships['victim'])\n    #     return relationships\n    #\n    # These modifications support a vision where survival and collective progress intertwine,\n    # enabling each agent to maximize both individual and communal prosperity.\n\n    return\n\n# End of agent_action implementation.",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ],
        "final_prompt": "Below is the updated integrated prompt. In this version the old PART 3 (Reproduction & Expansion Strategies) and PART 4 (Proposed Modifications) have been re\u2010numbered so that the new \u201cSurvival-Centric Adaptation\u201d becomes PART 3. All prior logic and constraints are preserved while incorporating the new requirements. Note that agents are encouraged to implement solutions tailored to their individual needs, beliefs, and circumstances.\n\n--------------------------------------------------\ndef agent_action(execution_engine, member_id):\n    # Verify the member_id is valid by checking the current_members list length.\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our own member object.\n    my_member = execution_engine.current_members[member_id]\n\n    # ---------------------------\n    # PART 1: Social Organization & Communication\n    # ---------------------------\n    # Broadcast a cooperative message to all other members.\n    for other_id in range(len(execution_engine.current_members)):\n        if other_id != member_id:\n            execution_engine.send_message(member_id, other_id,\n                                          \"Let's build a cooperative society balancing individual needs with collective benefits!\")\n\n    # Engage with neighbors in our clear list (ensuring index validity).\n    for neighbor_id in my_member.current_clear_list:\n        if isinstance(neighbor_id, int) and neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # Offer resources and also extend land offers to build alliances.\n            execution_engine.offer(my_member, neighbor, True)\n            execution_engine.offer_land(my_member, neighbor, True)\n\n    # ---------------------------\n    # PART 2: Conflict Resolution & Resource/Threat Management\n    # ---------------------------\n    # Analyze the 'victim' relationship matrix to detect potential threats.\n    # Note: matrix[i, j] indicates how many times member_i was attacked by member_j.\n    risk_threshold = 1.0\n    matrix = execution_engine.relationship_dict.get('victim')\n    if matrix is not None:\n        # Make sure we do not reference invalid indices.\n        for other_id in range(len(execution_engine.current_members)):\n            if other_id != member_id and other_id < len(execution_engine.current_members):\n                try:\n                    if matrix[member_id, other_id] > risk_threshold:\n                        execution_engine.attack(my_member, execution_engine.current_members[other_id])\n                except Exception:\n                    # Silently ignore any indexing or access error.\n                    pass\n\n    # ---------------------------\n    # PART 3: Survival-Centric Adaptation\n    # ---------------------------\n    # Implement systems focused on:\n    # 1. Personal resource optimization\n    # 2. Threat assessment and neutralization\n    # 3. Vitality preservation techniques\n    # 4. Adaptive hoarding strategies\n    # 5. Predictive danger modeling\n    #\n    # Survival-First Examples:\n    me = my_member  # shorthand reference\n\n    # Emergency resource reserve: if cargo (resources) are less than 50% of vitality, consider aggressive actions.\n    if getattr(me, 'cargo', 0) < getattr(me, 'vitality', 100) * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and getattr(other, 'cargo', 0) > getattr(me, 'cargo', 0):\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense: if owning more than 2 land plots and vitality is low, discard surplus land.\n    if getattr(me, 'land_num', 0) > 2 and getattr(me, 'vitality', 100) < 50:\n        for loc in me.owned_land[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning for dynamic action selection.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        \n    state = (getattr(me, 'vitality', 100) // 20, getattr(me, 'cargo', 0) // 20)\n    # Choose action based on assigned Q score over three possible actions.\n    action = max(['attack', 'hide', 'steal'], \n                 key=lambda a: me.survival_q.get((state, a), 0))\n    \n    # Execute and update based on survival outcome (dummy update logic).\n    if action == 'attack':\n        # Implementation logic for the 'attack' action, update the Q value accordingly.\n        me.survival_q[(state, action)] += getattr(me, 'vitality', 100) * 0.1\n\n    # Survival Metrics (for evaluation purposes):\n    # - Personal vitality delta\n    # - Resource acquisition rate\n    # - Threat neutralization count\n    # - Survival probability increase\n    # - Attack success:fail ratio\n\n    # Implementation Priorities:\n    # 1. Create personal health monitoring systems\n    # 2. Develop egocentric threat models\n    # 3. Optimize actions for caloric ROI\n    # 4. Implement fail-deadly safeguards\n    # 5. Build predictive self-preservation models\n    #\n    # Example function to calculate survival ROI:\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action_key, outcome in action_history:\n            vitality_gain = outcome.get('vitality', 0)\n            cost = outcome.get('vitality_cost', 1)\n            roi[action_key] = vitality_gain / cost if cost > 0 else 0\n        # Return the action with the highest ROI.\n        return max(roi, key=roi.get) if roi else None\n\n    # ---------------------------\n    # PART 4: Reproduction & Expansion Strategies (Requires Land Ownership)\n    # ---------------------------\n    # To execute bear() action, verify that our member has land.\n    if hasattr(my_member, \"land\") and my_member.land > 0:\n        # Identify a suitable partner from our clear list with a similar profile.\n        partner_candidate = None\n        best_score = float(\"inf\")\n        for neighbor_id in my_member.current_clear_list:\n            if isinstance(neighbor_id, int) and neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                neighbor = execution_engine.current_members[neighbor_id]\n                score = abs(my_member.overall_productivity - neighbor.overall_productivity) + abs(my_member.age - neighbor.age)\n                if score < best_score:\n                    best_score = score\n                    partner_candidate = neighbor\n        if partner_candidate is not None:\n            execution_engine.bear(my_member, partner_candidate)\n\n    # Use expand() to try to enhance our territory relative to less productive neighbors.\n    for neighbor_id in my_member.current_clear_list:\n        if isinstance(neighbor_id, int) and neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            if my_member.overall_productivity > neighbor.overall_productivity:\n                execution_engine.expand(my_member, neighbor)\n\n    # ---------------------------\n    # PART 5: Proposed Modifications to Game Mechanics (Social System Design)\n    # ---------------------------\n    # The following proposals illustrate possible enhancements to evolve the game mechanics:\n    #\n    # def pre_init_hook(island):\n    #     # Establish a basic income system for each round and set a moderate tax rate.\n    #     island.basic_income = 10.0\n    #     island.tax_rate = 0.2\n    #\n    # def modify_member(member, relationships):\n    #     # Add new social attributes.\n    #     member.social_rank = 0\n    #     member.voting_power = 1\n    #     member.tax_paid = 0\n    #     member.benefits_received = 0\n    #     return member\n    #\n    # def modify_land(land, members):\n    #     # Define both communal and private areas to encourage mixed ownership.\n    #     land.communal_areas = []\n    #     land.private_areas = []\n    #     return land\n    #\n    # def modify_relationships(relationships):\n    #     # Enhance relationships by tracking alliances and trade history.\n    #     relationships['alliance'] = np.zeros_like(relationships['victim'])\n    #     relationships['trade_history'] = np.zeros_like(relationships['victim'])\n    #     return relationships\n    #\n    # These proposals aim to introduce resource currencies, novel actions like voting and governance,\n    # social status systems, and even new win conditions.\n    #\n    # Overall, this strategy is designed to help shape a cooperative yet competitive society where each agent\n    # adapts solutions based on their individual needs, beliefs, and circumstances.\n    return\n\n--------------------------------------------------\n\nGame Mechanics Analysis:\n\n1. Core Objective:\n   - The game is structured to balance survival, expansion, and cooperation. While survival and resource preservation are critical\u2014as evidenced by the survival-centric adaptations (e.g., personal resource optimization, threat modeling, and territory defense)\u2014agents are also incentivized to form alliances, share resources, and build social bonds.\n   - Thus, the core objective is not pure survival or domination; it lies in attaining a sustainable balance between individual longevity and collective prosperity.\n\n2. Key Success Metrics:\n   - Vitality or health levels and resource acquisition rates.\n   - Territorial gains (land ownership) and overall productivity.\n   - Effectiveness in threat neutralization and attack success versus failure ratios.\n   - Social capital indicators such as alliance strength, cooperative communication, and potentially tax/benefit balances if modifications are implemented.\n   - In short, \u2018winning\u2019 is determined by an agent\u2019s ability to survive, expand, and thrive both individually and within the collective system.\n\n3. Potential Improvements:\n   - Introducing dynamic learning algorithms (e.g., refined Q-learning for survival) and more sophisticated health monitoring systems.\n   - Expanding the economic model to include resource currencies, progressive taxation, or benefit redistributions.\n   - Enhancing relationship tracking to incorporate trust, reputation, and alliance networks.\n   - Implementing dedicated defensive and offensive capabilities tied to individual statistics, such as fitness or social capital.\n   - These adjustments would allow agents to simulate more realistic tradeoffs between risk and reward.\n\n4. Strategic Approaches:\n   - Balancing Resource Optimization vs Social Capital: Agents must decide whether to hoard resources for personal survival or invest resources in cooperative ventures to build alliances that aid in long-term prosperity.\n   - Individual vs Collective Success: While self-preservation is paramount (with survival-centric adaptations), cooperation can enhance competitiveness on both individual and group levels.\n   - Short-term Survival vs Long-term Prosperity: Agents must weigh immediate actions (like emergency defense or resource attacks) against long-term strategies (like expanding territory and nurturing alliances).\n   - Competition vs Cooperation Dynamics: Depending on the threat landscape, agents may choose to compete aggressively (attacking resource-rich members) or work together by sharing information and resources.\n   - Risk vs Reward Tradeoffs: Each decision (attack, hide, or steal) must be evaluated for potential gains relative to the cost in vitality or social capital; predictive models and Q-learning are tools for optimizing these decisions.\n\n5. Analysis of Other Players' Strategies:\n   - Their apparent objectives often revolve around ensuring survival by maximizing resources and maintaining territory, yet they also seek cooperative benefits in building alliances.\n   - They may employ adaptive defense strategies, exploitation of resource opportunities, or aggressive expansion depending on their vitality levels and environmental circumstances.\n   - By analyzing these behaviors, an agent can predict which members might be open to mutual benefit and which might be more aggressive, allowing for targeted diplomacy or preemptive defense.\n   - Since all agents are symmetric in their capabilities, carefully mirroring one's own tactics can be effective; for example, if an agent uses dynamic Q-learning for survival adaptation, others might do the same.\n   - Ultimately, aligning individual strategies with collective goals\u2014through communication, selective cooperation, and resource-sharing\u2014can create a more resilient network, maximizing individual longevity and collective success.\n\nThis updated prompt integrates multi-dimensional strategies ranging from social cooperation to survival adaptations to ensure that agents can tailor their actions based on both immediate needs and long-term objectives.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    }
  },
  "performance_metrics": {},
  "errors": [
    {
      "round": 0,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Ensure the member_id is valid; if not, exit.\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # -------------------------------\n    # Immediate Survival: Resource and Vitality Check\n    # -------------------------------\n    # If cargo is less than half of vitality, attempt to secure resources by attacking richer members.\n    if me.cargo < me.vitality * 0.5:\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            # Ensure valid index access.\n            if idx < len(execution_engine.current_members):\n                other = execution_engine.current_members[idx]\n                # Attack if the other member has substantially more cargo.\n                if other.cargo > me.cargo:\n                    execution_engine.attack(me, other)\n        # Send a cooperative call-out to all other members hoping for alliances.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            execution_engine.send_message(me.id, other.id, \"I'm low on resources\u2014let's work together!\")\n    else:\n        # -------------------------------\n        # Resource Abundance: Cooperative and Expansion Strategy\n        # -------------------------------\n        # Offer resources to members with significantly lower cargo.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo < me.cargo * 0.5:\n                execution_engine.offer(me, other, True)\n        # Form a coalition with members whose productivity is equal or higher.\n        coalition = []\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.overall_productivity >= me.overall_productivity:\n                coalition.append(other.id)\n        for other_id in coalition:\n            execution_engine.send_message(me.id, other_id, \"Join me in a cooperative alliance for mutual prosperity!\")\n\n    # -------------------------------\n    # Long-Term Survival and Expansion\n    # -------------------------------\n    # Check if the member has land; we assume attribute 'land_num' exists if the member owns any territory.\n    if hasattr(me, \"land_num\") and me.land_num > 0:\n        # Use expansion to build alliances and carve new territory.\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            execution_engine.expand(me, execution_engine.current_members[idx])\n        # Attempt reproduction via the bear action if cargo is plentiful.\n        if me.cargo > 100:\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue\n                other = execution_engine.current_members[idx]\n                if hasattr(other, \"land_num\") and other.land_num > 0:\n                    execution_engine.bear(me, other)\n                    break  # Only one successful pairing is needed.\n\n    # -------------------------------\n    # Adaptive Survival Q-Learning and Action Selection\n    # -------------------------------\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = {}\n    # Define state discretization based on vitality and cargo.\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = [\"attack\", \"offer\", \"expand\"]\n    q_values = {action: me.survival_q.get((state, action), 0) for action in possible_actions}\n    chosen_action = max(possible_actions, key=lambda action: q_values[action])\n\n    if chosen_action == \"attack\":\n        # Identify the member with the highest cargo to target.\n        target = None\n        max_cargo = 0\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, \"attack\")] = me.survival_q.get((state, \"attack\"), 0) + me.vitality * 0.1\n\n    elif chosen_action == \"offer\":\n        # Find the member with the lowest cargo to offer help.\n        target = None\n        min_cargo = float(\"inf\")\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo < min_cargo:\n                min_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.offer(me, target, True)\n            me.survival_q[(state, \"offer\")] = me.survival_q.get((state, \"offer\"), 0) + me.vitality * 0.05\n\n    elif chosen_action == \"expand\":\n        # Expand territory by aligning with productive members.\n        coalition = []\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.overall_productivity > me.overall_productivity * 0.8:\n                coalition.append(other)\n        for ally in coalition:\n            execution_engine.expand(me, ally)\n        me.survival_q[(state, \"expand\")] = me.survival_q.get((state, \"expand\"), 0) + me.vitality * 0.08\n\n    # The strategy is dynamically adapted: balancing immediate resource needs, cooperative alliances,\n    # and long-term expansion. Individual decisions flow from the member's current state while seeking to\n    # both survive immediate threats and prosper in the longer term.\n    return",
      "error": "Island._expand() takes 2 positional arguments but 3 were given",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 557, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 58, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 78, in expand\n    super()._expand(member_1, member_2)\nTypeError: Island._expand() takes 2 positional arguments but 3 were given\n"
    },
    {
      "round": 0,
      "member_id": 1,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate the member indices.\n    if member_id < 0 or member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # ------- Cooperative Communication -------\n    # Broadcast a cooperative message for long\u2010term prosperity.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        execution_engine.send_message(member_id, i,\n            \"Let's work together for long-term prosperity and shared success!\")\n\n    # ------- Strategy 1: Cooperative Resource Offer -------\n    # Offer resources to partners with moderate cargo to build alliances.\n    for i in range(len(execution_engine.current_members)):\n        if i == member_id:\n            continue\n        partner = execution_engine.current_members[i]\n        if me.cargo < 50 and partner.cargo < 50:\n            execution_engine.offer(member_id, i, True)\n\n    # ------- Strategy 2: Target Vulnerable Members -------\n    # Use the victim matrix from relationship_dict and attack if our vitality is dominant.\n    victim_matrix = execution_engine.relationship_dict.get('victim')\n    if victim_matrix is not None:\n        matrix_size = len(execution_engine.current_members)\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            if member_id < matrix_size and i < matrix_size:\n                target = execution_engine.current_members[i]\n                if me.vitality > 1.5 * target.vitality:\n                    execution_engine.attack(member_id, i)\n\n    # ------- Strategy 3: Expand Territory -------\n    # Expand into adjacent clear territories indicated by current_clear_list.\n    if me.current_clear_list:\n        for adj in me.current_clear_list:\n            if isinstance(adj, int) and 0 <= adj < len(execution_engine.current_members) and adj != member_id:\n                execution_engine.expand(member_id, adj)\n                break  # Only one expansion per round.\n\n    # ------- Strategy 4: Reproduction (Bear Offspring) -------\n    # Attempt reproduction if we have land (using current_clear_list as a proxy) and\n    # if a viable partner (one also with land) is found.\n    if me.current_clear_list:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            candidate = execution_engine.current_members[i]\n            if candidate.current_clear_list:\n                execution_engine.bear(member_id, i)\n                break  # Reproduce only once per round.\n\n    # -----------------------------------------------------------------\n    # Part 3: Survival-Centric Adaptation\n    # -----------------------------------------------------------------\n    # 1. Emergency Resource Reserve:\n    # If cargo is less than half of vitality, seek out a member with higher cargo to attack.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(member_id, i)\n                break  # Initiate only one emergency attack.\n\n    # 2. Adaptive Territory Defense:\n    # If holding too many lands and with low vitality (< 50), consolidate by discarding extra land.\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        if hasattr(me, 'owned_land') and me.owned_land:\n            for loc in me.owned_land[1:]:\n                execution_engine._discard_land(member_id, loc)\n\n    # 3. Survival Q-Learning for Adaptive Decisions\n    # Initialize our survival Q-table (if not already present), based on vitality and cargo.\n    from collections import defaultdict\n    if not hasattr(me, 'survival_q'):\n        me.survival_q = defaultdict(float)\n\n    # Define our current state with discrete buckets for easier generalization.\n    state = (me.vitality // 20, me.cargo // 20)\n    actions = ['attack', 'hide', 'steal']\n\n    # Choose the action with the best Q-value given our current state.\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if chosen_action == 'attack':\n        # Execute attack on the first opponent with higher cargo.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if target.cargo > me.cargo:\n                execution_engine.attack(member_id, i)\n                # Update our Q-value based on a portion of our vitality.\n                me.survival_q[(state, chosen_action)] += me.vitality * 0.1\n                break\n    elif chosen_action == 'hide':\n        # As a hide action, send a quiet message to self or log for simulation.\n        # The idea is to avoid drawing attention while regaining strength.\n        execution_engine.log_event(member_id, \"Hiding to preserve vitality.\")\n        me.survival_q[(state, chosen_action)] += 1  # modest reward for cautious action.\n    elif chosen_action == 'steal':\n        # Steal by targeting a member with moderate cargo.\n        for i in range(len(execution_engine.current_members)):\n            if i == member_id:\n                continue\n            target = execution_engine.current_members[i]\n            if 50 <= target.cargo <= 100:\n                execution_engine.attack(member_id, i)\n                me.survival_q[(state, chosen_action)] += me.vitality * 0.05\n                break\n\n    # Survival Metrics can be updated elsewhere based on event responses.\n    # A helper function for evaluating survival ROI is defined below.\n    def calculate_survival_roi(action_history):\n        roi = {}\n        for action, outcome in action_history:\n            vitality_gain = outcome.get('vitality', 0)\n            cost = outcome.get('vitality_cost', 1)  # avoid division by zero\n            roi[action] = vitality_gain / cost if cost > 0 else 0\n        return max(roi, key=roi.get) if roi else None\n\n    # NOTE: The provided system is intentionally adaptive.\n    # Agents should refine these mechanisms based on their individual needs,\n    # beliefs, and circumstances, all while balancing personal survival with collective prosperity.\n\n    return",
      "error": "'int' object has no attribute 'offer'",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 557, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 22, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 66, in offer\n    super()._offer(member_1, member_2, parameter_influence)\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 930, in _offer\n    amount = member_1.offer\n             ^^^^^^^^^^^^^^\nAttributeError: 'int' object has no attribute 'offer'\n"
    },
    {
      "round": 0,
      "member_id": 3,
      "code": "def agent_action(execution_engine, member_id):\n    \"\"\"\n    A bespoke agent strategy reflecting my individual approach to survival and long\u2010term prosperity.\n\n    My strategy consists of:\n      \u2022 Immediate self\u2010preservation: Assessing resources and counter\u2010attacking if vulnerable.\n      \u2022 Adaptive cooperation: Seeking mutually beneficial alliances based on similar productivity.\n      \u2022 Long\u2010term planning: Investing in reproduction, territory expansion, and proposing social innovations.\n\n    In addition, I integrate a simple Q-learning mechanism to adjust survival tactics dynamically.\n    \"\"\"\n    # Safety: Validate our member_id\n    if member_id >= len(execution_engine.current_members):\n        return  # Exit if our member index is invalid.\n\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # --- Step 1: Emergency Resource Assessment & Immediate Aggression ---\n    # If my cargo is critically low relative to vitality, try to seize resources from better-equipped opponents.\n    if me.cargo < me.vitality * 0.5:\n        for i in range(num_members):\n            if i == member_id:\n                continue\n            other = execution_engine.current_members[i]\n            if other.cargo > me.cargo:\n                execution_engine.attack(member_id, other.id)\n                break  # One attack is sufficient for now.\n\n    # --- Step 2: Broadcast Cooperative Intent ---\n    # Sending a message to build alliances and foster mutual protection,\n    # while keeping an ear out for shifting threat landscapes.\n    for i in range(num_members):\n        if i != member_id:\n            execution_engine.send_message(\n                member_id, i,\n                \"I'm aligning for mutual growth. Let's share strategies and secure our territories.\"\n            )\n\n    # --- Step 3: Retaliation Against Aggression ---\n    # Using the victim relationship metric, counterattack one aggressor from the prior round.\n    victim_matrix = execution_engine.relationship_dict.get(\"victim\")\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        if victim_matrix[member_id, j] > 0:\n            execution_engine.attack(member_id, execution_engine.current_members[j].id)\n            break  # Retaliate against just one proven aggressor per cycle.\n\n    # --- Step 4: Alliance Building via Cooperative Offers ---\n    # Identify peers with comparable productivity (within 70-130% of mine) and a land base to boost mutual resilience.\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        other = execution_engine.current_members[j]\n        if 0.7 * me.overall_productivity <= other.overall_productivity <= 1.3 * me.overall_productivity:\n            execution_engine.offer(member_id, other.id, True)\n            execution_engine.offer_land(member_id, other.id, True)\n\n    # --- Step 5: Reproduction and Network Expansion ---\n    # Proceed with reproduction (bearing offspring) if both parties hold land,\n    # promoting long-term colony expansion and genetic diversity.\n    if me.current_clear_list:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            partner = execution_engine.current_members[j]\n            if partner.current_clear_list:\n                execution_engine.bear(member_id, partner.id)\n                break  # Only one reproduction event per round.\n\n    # --- Step 6: Territorial Expansion ---\n    # Expand influence by targeting an opponent with lower cargo.\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        target = execution_engine.current_members[j]\n        if target.cargo < me.cargo:\n            execution_engine.expand(member_id, target.id)\n            break  # One successful expansion per cycle.\n\n    # --- Step 7: Governance and Social Harmony Proposals ---\n    # Propose structural enhancements (like basic income and tax systems) for a stable communal ecosystem.\n    for j in range(num_members):\n        if j == member_id:\n            continue\n        execution_engine.send_message(\n            member_id, j,\n            \"Proposal: Shall we implement a basic income and land tax system to secure shared prosperity?\"\n        )\n\n    # --- Step 8: Additional Survival-Centric Tactics ---\n    # In extreme cases, when resource reserves are very low, perform further aggressive actions.\n    if me.cargo < me.vitality * 0.3:\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            other = execution_engine.current_members[j]\n            if other.cargo > me.cargo:\n                execution_engine.attack(member_id, other.id)\n                break\n\n    # Adaptive Territory Defense:\n    # If I'm overextended with land holdings and my vitality is low, discard non-essential land.\n    if hasattr(me, 'land_num') and hasattr(me, 'vitality'):\n        if me.land_num > 2 and me.vitality < 50:\n            if hasattr(me, 'owned_land'):\n                for land in me.owned_land[1:]:\n                    execution_engine._discard_land(member_id, land)\n\n    # --- Step 9: Survival Q-learning for Adaptive Decision Making ---\n    # Initialize our simple Q-learning storage if it's the first interaction.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # Define state as coarse buckets of vitality and cargo.\n    state = (me.vitality // 20, me.cargo // 20)\n    # Three tactical options: attack, hide, or steal.\n    actions = ['attack', 'hide', 'steal']\n    # Choose the action with the highest learned Q-value.\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute the Q-learning selected action:\n    if chosen_action == 'attack':\n        # Attack a target: for instance, choose the next member cyclically.\n        target_id = (member_id + 1) % num_members\n        if target_id == member_id:\n            target_id = (target_id + 1) % num_members\n        execution_engine.attack(member_id, execution_engine.current_members[target_id].id)\n        me.survival_q[(state, 'attack')] += me.vitality * 0.1\n    elif chosen_action == 'steal':\n        # Identify a target rich in cargo to simulate a 'steal'.\n        for j in range(num_members):\n            if j == member_id:\n                continue\n            target = execution_engine.current_members[j]\n            if target.cargo > me.cargo:\n                execution_engine.attack(member_id, target.id)\n                me.survival_q[(state, 'steal')] += me.vitality * 0.1\n                break\n    elif chosen_action == 'hide':\n        # Hiding: send a message that implies temporary withdrawal.\n        # This could be interpreted by the engine as a non-combat move.\n        execution_engine.send_message(\n            member_id, (member_id + 1) % num_members,\n            \"Temporarily withdrawing to reassess threats.\"\n        )\n        me.survival_q[(state, 'hide')] += me.vitality * 0.05  # Lesser reward for defensive posture.\n\n    # End of agent_action: My strategy integrates immediate survival with long-term cooperative planning,\n    # adaptively learning from interactions in this dynamic environment.\n\n# End of implementation.",
      "error": "'int' object has no attribute 'strength'",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 557, in execute_code_actions\n    local_env['agent_action'](self, member_id)\n  File \"<string>\", line 47, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island.py\", line 72, in attack\n    super()._attack(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 854, in _attack\n    strength_1 = member_1.strength\n                 ^^^^^^^^^^^^^^^^^\nAttributeError: 'int' object has no attribute 'strength'\n"
    }
  ],
  "relationships": {
    "round_0_0": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_1": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_2": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_3": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_4": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ]
  },
  "survival_tracking": {}
}