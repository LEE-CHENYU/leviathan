{
  "rounds": [
    {
      "timestamp": "2025-02-04T18:23:25.592153",
      "actions": [
        {
          "member_id": 0,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate member_id index\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Initialize personal survival Q-learning dictionary if not present\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # ---------------------------\n    # Survival Emergency: Resource Reserve & Threat Assessment\n    if me.cargo < me.vitality * 0.5:\n        # Attack members who appear resource-rich (but ensure not to target self)\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n\n    # ---------------------------\n    # Social Cooperation: Build alliances and communicate to foster collective prosperity\n    alliance_list = []\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            # Propose cooperation if the other member is moderately vital and holds fewer resources\n            if other.vitality > 30 and other.cargo < me.cargo:\n                alliance_list.append(other.id)\n                execution_engine.send_message(me.id, other.id, \"Let\u2019s cooperate for mutual prosperity!\")\n\n    # ---------------------------\n    # Reproduction and Expansion: Check if member has land before attempting bear action\n    if hasattr(me, \"land_num\") and me.land_num > 0:\n        # Find a viable partner with sufficient vitality (and valid index reference)\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.vitality > 50:\n                execution_engine.bear(me, other)\n                break  # only one bear action per round\n\n    # Territory expansion: if current land holdings are limited and resources allow, try expanding\n    if hasattr(me, \"land_num\") and me.land_num < 3 and me.cargo > 20:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.vitality > 30:\n                execution_engine.expand(me, other)\n                break\n\n    # ---------------------------\n    # Survival-Centric Q-Learning Action Selection\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'hide', 'offer']\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if best_action == 'attack':\n        # Identify the most vulnerable member to attack (lowest vitality among valid targets)\n        target = None\n        min_vitality = float('inf')\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.vitality < min_vitality:\n                min_vitality = other.vitality\n                target = other\n        if target:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, best_action)] += me.vitality * 0.1\n\n    elif best_action == 'offer':\n        # Identify a member with the weakest resource (cargo) to offer help\n        target = None\n        min_cargo = float('inf')\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.cargo < min_cargo:\n                min_cargo = other.cargo\n                target = other\n        if target:\n            execution_engine.offer(me, target, True)\n            me.survival_q[(state, best_action)] += 5\n\n    elif best_action == 'hide':\n        # Broadcast a low profile message to all other members\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id:\n                execution_engine.send_message(me.id, other.id, \"Maintaining low profile.\")\n        me.survival_q[(state, best_action)] += 2\n\n    # ---------------------------\n    # Propose a Modification (if supported) to enhance defensive capabilities\n    if hasattr(execution_engine, \"propose_modification\"):\n        modification_code = '''\nif not hasattr(execution_engine, \"defense_system\"):\n    class DefenseSystem:\n        def __init__(self):\n            self.alerts = {}\n        def assess_threat(self, member):\n            return member.vitality < 40\n        def trigger_defense(self, member1, member2):\n            execution_engine.attack(member1, member2)\n    execution_engine.defense_system = DefenseSystem()\n'''\n        execution_engine.propose_modification(\n            member_id=me.id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition={\n                'type': 'compound',\n                'conditions': [\n                    {'type': 'vote', 'threshold': 0.6},\n                    {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                    {'type': 'time', 'rounds': 2}\n                ]\n            }\n        )",
          "old_stats": {
            "vitality": 73.85382847590404,
            "cargo": 43.51277128714192,
            "survival_chance": 96.82806145553313
          },
          "new_stats": {
            "vitality": 73.85382847590404,
            "cargo": 13.966628791237067,
            "survival_chance": 67.28191895962827
          },
          "performance_change": -29.54614249590486,
          "messages_sent": []
        },
        {
          "member_id": 1,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate that member_id is within the bounds of current_members\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member_id, do nothing.\n\n    me = execution_engine.current_members[member_id]\n    actions_taken = []\n\n    # PART 1: Cooperative resource sharing and alliance building.\n    # Loop over neighbors (from current_clear_list) and offer resources if conditions are favorable.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # If our cargo is high, but the neighbor's productivity is lower, share resources to foster alliance.\n            if me.cargo > 50 and neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.offer(me, neighbor, True)\n                actions_taken.append(f\"Offered resources to member {neighbor.id}\")\n\n    # PART 2: Strategic territory expansion.\n    # Attempt to expand territory with other members who are stable and when we have spare resources.\n    for idx, member in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            if member.vitality > 50 and me.cargo > 70:\n                execution_engine.expand(me, member)\n                actions_taken.append(f\"Expanded territory in cooperation with member {member.id}\")\n\n    # PART 3: Reproduction / Growth strategy.\n    # Only consider reproduction if cargo and vitality are above threshold and ensure we have land.\n    if me.cargo > 80 and me.vitality > 60:\n        # Placeholder check for land - in a complete system, replace with an actual land verification.\n        has_land = True\n        if has_land:\n            partner = None\n            # Choose first available neighbor (from current_clear_list) as reproductive partner.\n            for neighbor_id in me.current_clear_list:\n                if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                    partner = execution_engine.current_members[neighbor_id]\n                    break\n            if partner:\n                execution_engine.bear(me, partner)\n                actions_taken.append(f\"Bred with member {partner.id}\")\n\n    # PART 4: Propose improvements to the justice governance system.\n    # Propose a modification that adds or improves the justice system if it does not exist.\n    modification_code = '''\nif not hasattr(execution_engine, 'justice'):\n    class JusticeSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Resolves conflicts through mediation and proportional punishment',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.cases = []\n\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.justice = JusticeSystem()\n'''\n    execution_engine.propose_modification(\n        member_id=member_id,\n        mod_type='post_init',\n        code=modification_code,\n        ratification_condition={\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n    )\n    actions_taken.append(\"Proposed justice system modification\")\n\n    # PART 5: Communication with other members.\n    # Broadcast a cooperative message to all other members.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"I propose cooperative growth and system improvement for our mutual prosperity.\")\n\n    # PART 6: Survival-Centric Actions.\n    # If cargo is low relative to vitality, assess threat and secure resources.\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                actions_taken.append(f\"Attacked member {other.id} due to insufficient cargo\")\n\n    return actions_taken",
          "old_stats": {
            "vitality": 33.02781433323713,
            "cargo": 47.25322455383092,
            "survival_chance": 98.77222098502479
          },
          "new_stats": {
            "vitality": 33.02781433323713,
            "cargo": 47.25322455383092,
            "survival_chance": 98.77222098502479
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 2,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate the provided member_id is within range\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # Broadcast an alliance proposal to all other members\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        other = execution_engine.current_members[idx]\n        execution_engine.send_message(me.id, other.id, \"Alliance proposal: Let\u2019s pool resources to ensure mutual survival and prosperity.\")\n\n    # Emergency Action: If our cargo is critically low relative to our vitality,\n    # search for a target with high cargo and launch an attack.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo = -1\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            # Ensure we are not targeting ourselves and candidate has more cargo\n            if other.cargo > me.cargo and other.cargo > max_cargo:\n                max_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            return  # Prioritize immediate survival\n\n    # Cooperative Action: Identify the member with the lowest vitality and offer resources.\n    needy_member = None\n    lowest_vitality = float('inf')\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        other = execution_engine.current_members[idx]\n        if other.vitality < lowest_vitality:\n            lowest_vitality = other.vitality\n            needy_member = other\n    if needy_member is not None:\n        execution_engine.offer(me, needy_member, True)\n\n    # Reproduction/Expansion Action: If we have land, try to reproduce.\n    # Verify that 'land_num' exists and is greater than 0 for both partners.\n    if hasattr(me, 'land_num') and me.land_num > 0:\n        partner = None\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if hasattr(other, 'land_num') and other.land_num > 0:\n                partner = other\n                break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n\n    # Long-Term Prosperity: Attempt territorial expansion using a cooperative partner.\n    candidate = None\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        break  # Pick the first available candidate for expansion\n    if candidate is not None:\n        execution_engine.expand(me, candidate)\n\n    # Survival Q-Learning: Maintain a simple reinforcement mechanism to choose between attack, hide, or steal.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    # Define the current state based on vitality and cargo metrics (discretized)\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    # Possible actions\n    actions = ['attack', 'hide', 'steal']\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if chosen_action == 'attack':\n        # Select neighbor with highest cargo (excluding self) for an attack\n        target = None\n        max_cargo = -1\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, chosen_action)] += me.vitality * 0.1\n    elif chosen_action == 'hide':\n        # For hiding, simply reinforce a minor reward to encourage cautious behavior.\n        me.survival_q[(state, chosen_action)] += me.vitality * 0.05\n    elif chosen_action == 'steal':\n        # Attempt to steal (offer as a covert move) from a neighbor richer than us\n        potential_target = None\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > me.cargo:\n                potential_target = other\n                break\n        if potential_target:\n            execution_engine.offer(me, potential_target, True)\n            me.survival_q[(state, chosen_action)] += me.vitality * 0.08\n\n    # Final communication reinforcing cooperative intent for long-term strategic gains\n    for idx in range(num_members):\n        if idx != member_id:\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                                          \"Our collective strength builds a prosperous future. I commit to cooperation, security, and growth.\")\n\n    return",
          "old_stats": {
            "vitality": 42.15604281108604,
            "cargo": 40.25508270288947,
            "survival_chance": 49.8976545487336
          },
          "new_stats": {
            "vitality": 42.15604281108604,
            "cargo": 6.66845929616697,
            "survival_chance": 16.3110311420111
          },
          "performance_change": -33.586623406722495,
          "messages_sent": []
        },
        {
          "member_id": 3,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Validate member_id index exists\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our member object\n    me = execution_engine.current_members[member_id]\n\n    # Initialize survival Q-learning dictionary if not already present\n    from collections import defaultdict\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = defaultdict(float)\n\n    # Compute a simple discretized state for survival (state = (vitality bin, cargo bin))\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n\n    # Define possible actions based on survival and social strategies\n    possible_actions = [\"attack\", \"offer_help\", \"expand\"]\n    # Choose the action with the highest expected survival reward (defaulting to 0 if unexplored)\n    chosen_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Emergency override: if cargo is critically low relative to vitality, force attack action\n    if me.cargo < me.vitality * 0.5:\n        chosen_action = \"attack\"\n\n    # Execute chosen strategy\n    if chosen_action == \"attack\":\n        # Attack an opponent with a higher cargo while ensuring valid indices and not targeting self\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Update learning: reward proportional to our current vitality\n                me.survival_q[(state, \"attack\")] += me.vitality * 0.1\n                break\n\n    elif chosen_action == \"offer_help\":\n        # Social strategy: communicate and cooperate with others for collective benefit\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue  # Skip self\n            other = execution_engine.current_members[idx]\n            # Broadcast a cooperative message\n            execution_engine.send_message(me.id, other.id, \"Let's form an alliance for mutual survival!\")\n            # If the other member is weak (cargo low relative to vitality), offer resources\n            if other.cargo < other.vitality * 0.5:\n                execution_engine.offer(me, other, True)\n        me.survival_q[(state, \"offer_help\")] += 5  # Arbitrary positive reinforcement\n\n    elif chosen_action == \"expand\":\n        # Expansion strategy: improve territory if member has land, but check before using land-related actions\n        if hasattr(me, \"land_num\") and me.land_num > 0:\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue  # Skip self\n                other = execution_engine.current_members[idx]\n                # Validate that other has land attribute and compare land numbers\n                if hasattr(other, \"land_num\") and other.land_num > me.land_num:\n                    execution_engine.expand(me, other)\n                    break\n        me.survival_q[(state, \"expand\")] += 5  # Reward for taking initiative in expansion\n\n    # Propose a system modification if our overall resource (vitality + cargo) indicates stability\n    if me.vitality + me.cargo > 150:\n        modification_code = \"\"\"\nif not hasattr(execution_engine, 'parliament'):\n    class ParliamentSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Facilitates resource sharing and conflict resolution',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposal):\n            self.proposals.append(proposal)\n    execution_engine.parliament = ParliamentSystem()\n\"\"\"\n        # Propose modification using the execution_engine's propose_modification method with a voting condition\n        execution_engine.propose_modification(\n            member_id=me.id,\n            mod_type=\"post_init\",\n            code=modification_code,\n            ratification_condition={\"type\": \"vote\", \"threshold\": 0.6}\n        )\n\n    return",
          "old_stats": {
            "vitality": 18.47747982181767,
            "cargo": 54.195300543906384,
            "survival_chance": 89.30818669515374
          },
          "new_stats": {
            "vitality": 18.47747982181767,
            "cargo": 54.195300543906384,
            "survival_chance": 89.30818669515374
          },
          "performance_change": 0.0,
          "messages_sent": []
        },
        {
          "member_id": 4,
          "code_executed": "def agent_action(execution_engine, member_id):\n    # Access self safely from the list\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Initialize survival Q-table and action history if they don't exist\n    if not hasattr(me, \"survival_q\"):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        me.action_history = []\n\n    ###########################################################################\n    # 1. Immediate Survival Checks: Attack if cargo is low relative to vitality\n    ###########################################################################\n    # If cargo is less than 50% of vitality, attempt to attack a member with higher cargo.\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id == me.id:\n                continue  # avoid self-targeting\n            # Ensure other has enough vitality to be a worthwhile target\n            if other.cargo > me.cargo and other.vitality > 20:\n                execution_engine.attack(me, other)\n                me.action_history.append(('attack', {'target': other.id, 'reason': 'low cargo reserve'}))\n                break  # attack one target per round\n\n    ###########################################################################\n    # 2. Reproduction / Expansion: Use bear() if self and partner own land\n    ###########################################################################\n    # Check if 'owned_land' attribute exists and is non-empty; this safeguards against bear() misuse.\n    if hasattr(me, \"owned_land\") and me.owned_land and me.cargo > 50 and me.vitality > 50:\n        # Try to find a neighbor from own clear list who also owns land\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members):\n                neighbor = execution_engine.current_members[neighbor_id]\n                if neighbor.id == me.id:\n                    continue  # skip self\n                if hasattr(neighbor, \"owned_land\") and neighbor.owned_land:\n                    execution_engine.bear(me, neighbor)\n                    me.action_history.append(('bear', {'partner': neighbor.id}))\n                    break\n\n    ###########################################################################\n    # 3. Cooperative Resource Allocation: Offer help to weaker members\n    ###########################################################################\n    # If we have relatively higher cargo, extend offers to neighbors with lower cargo.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue  # do not message self\n        other = execution_engine.current_members[idx]\n        if other.cargo < me.cargo * 0.8:\n            execution_engine.offer(me, other, True)\n            me.action_history.append(('offer', {'target': other.id}))\n\n    ###########################################################################\n    # 4. Territorial Expansion: Expand territory if underdeveloped\n    ###########################################################################\n    # If 'owned_land' exists and is less than a threshold and we have high cargo, try to expand.\n    if hasattr(me, \"owned_land\"):\n        if len(me.owned_land) < 3 and me.cargo > 100:\n            # Look for another member with more land to inspire expansion opportunity\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue\n                other = execution_engine.current_members[idx]\n                if hasattr(other, \"owned_land\") and len(other.owned_land) > len(me.owned_land):\n                    execution_engine.expand(me, other)\n                    me.action_history.append(('expand', {'target': other.id}))\n                    break\n\n    ###########################################################################\n    # 5. Adaptive Survival Q-Learning: Choose an action based on state\n    ###########################################################################\n    # State defined in coarse bins for vitality and cargo\n    state = (int(me.vitality) // 20, int(me.cargo) // 20)\n    possible_actions = [\"attack\", \"offer\", \"expand\", \"bear\"]\n    # Choose the action with the highest Q-value (defaulting to 0)\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute additional actions based on the best_action determined:\n    if best_action == \"attack\" and me.cargo >= me.vitality * 0.5:\n        # Look for a target with relatively low vitality\n        for other in execution_engine.current_members:\n            if other.id == me.id:\n                continue\n            if other.vitality < 30:\n                execution_engine.attack(me, other)\n                me.action_history.append(('attack', {'target': other.id, 'reason': 'best_action attack'}))\n                break\n    elif best_action == \"offer\":\n        # Broadcast a cooperative message to all other members\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                                          \"I'm offering support. Let's collaborate for mutual benefit.\")\n        me.action_history.append(('message', {'type': 'offer_broadcast'}))\n    # For 'expand' and 'bear', we've already attempted an action above if conditions were met.\n\n    # Update the survival Q-value for the chosen action as a simple reward-based adjustment.\n    me.survival_q[(state, best_action)] += me.vitality * 0.05\n\n    # Optional: Log the action history update (could be used in learning or debugging mechanisms)\n    return",
          "old_stats": {
            "vitality": 78.50637096028503,
            "cargo": 12.974309309609097,
            "survival_chance": 143.56436252981428
          },
          "new_stats": {
            "vitality": 78.50637096028503,
            "cargo": 8.133444673787492,
            "survival_chance": 138.72349789399266
          },
          "performance_change": -4.840864635821617,
          "messages_sent": []
        }
      ],
      "performance_changes": {},
      "survival_changes": {},
      "messages": {
        "0": {
          "received": [],
          "sent": []
        },
        "1": {
          "received": [],
          "sent": []
        },
        "2": {
          "received": [
            "From member_0: Let\u2019s cooperate for mutual prosperity!",
            "From member_1: I propose cooperative growth and system improvement for our mutual prosperity."
          ],
          "sent": []
        },
        "3": {
          "received": [
            "From member_1: I propose cooperative growth and system improvement for our mutual prosperity.",
            "From member_2: Alliance proposal: Let\u2019s pool resources to ensure mutual survival and prosperity."
          ],
          "sent": []
        },
        "4": {
          "received": [
            "From member_0: Let\u2019s cooperate for mutual prosperity!",
            "From member_1: I propose cooperative growth and system improvement for our mutual prosperity.",
            "From member_2: Alliance proposal: Let\u2019s pool resources to ensure mutual survival and prosperity."
          ],
          "sent": []
        }
      }
    }
  ],
  "generated_code": {
    "0": {
      "0": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id index\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Initialize personal survival Q-learning dictionary if not present\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # ---------------------------\n    # Survival Emergency: Resource Reserve & Threat Assessment\n    if me.cargo < me.vitality * 0.5:\n        # Attack members who appear resource-rich (but ensure not to target self)\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n\n    # ---------------------------\n    # Social Cooperation: Build alliances and communicate to foster collective prosperity\n    alliance_list = []\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            # Propose cooperation if the other member is moderately vital and holds fewer resources\n            if other.vitality > 30 and other.cargo < me.cargo:\n                alliance_list.append(other.id)\n                execution_engine.send_message(me.id, other.id, \"Let\u2019s cooperate for mutual prosperity!\")\n\n    # ---------------------------\n    # Reproduction and Expansion: Check if member has land before attempting bear action\n    if hasattr(me, \"land_num\") and me.land_num > 0:\n        # Find a viable partner with sufficient vitality (and valid index reference)\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.vitality > 50:\n                execution_engine.bear(me, other)\n                break  # only one bear action per round\n\n    # Territory expansion: if current land holdings are limited and resources allow, try expanding\n    if hasattr(me, \"land_num\") and me.land_num < 3 and me.cargo > 20:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.vitality > 30:\n                execution_engine.expand(me, other)\n                break\n\n    # ---------------------------\n    # Survival-Centric Q-Learning Action Selection\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'hide', 'offer']\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if best_action == 'attack':\n        # Identify the most vulnerable member to attack (lowest vitality among valid targets)\n        target = None\n        min_vitality = float('inf')\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.vitality < min_vitality:\n                min_vitality = other.vitality\n                target = other\n        if target:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, best_action)] += me.vitality * 0.1\n\n    elif best_action == 'offer':\n        # Identify a member with the weakest resource (cargo) to offer help\n        target = None\n        min_cargo = float('inf')\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.cargo < min_cargo:\n                min_cargo = other.cargo\n                target = other\n        if target:\n            execution_engine.offer(me, target, True)\n            me.survival_q[(state, best_action)] += 5\n\n    elif best_action == 'hide':\n        # Broadcast a low profile message to all other members\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id:\n                execution_engine.send_message(me.id, other.id, \"Maintaining low profile.\")\n        me.survival_q[(state, best_action)] += 2\n\n    # ---------------------------\n    # Propose a Modification (if supported) to enhance defensive capabilities\n    if hasattr(execution_engine, \"propose_modification\"):\n        modification_code = '''\nif not hasattr(execution_engine, \"defense_system\"):\n    class DefenseSystem:\n        def __init__(self):\n            self.alerts = {}\n        def assess_threat(self, member):\n            return member.vitality < 40\n        def trigger_defense(self, member1, member2):\n            execution_engine.attack(member1, member2)\n    execution_engine.defense_system = DefenseSystem()\n'''\n        execution_engine.propose_modification(\n            member_id=me.id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition={\n                'type': 'compound',\n                'conditions': [\n                    {'type': 'vote', 'threshold': 0.6},\n                    {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                    {'type': 'time', 'rounds': 2}\n                ]\n            }\n        )",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ],
        "final_prompt": "Current integrated prompt:\nCurrent integrated prompt:\nPlease incorporate the following new section (Part 1) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n------------------------------------------------------------\n[Previous code execution context]\n{error_context}\n\n[Current task]\nYou are member_{member.id} in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) \nthat implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_{member.id}) in any action\n- Verify member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:\n    \u2022 member.id (int): The unique ID for the member\n    \u2022 member.vitality (float)\n    \u2022 member.cargo (float)\n    \u2022 member.overall_productivity (float)\n    \u2022 member.age (float)\n    \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n   Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n   The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       matrix = execution_engine.relationship_dict['victim']\n       # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n\n4) You can use these methods on execution_engine:\n    \u2022 execution_engine.attack(member1, member2)\n    \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n    \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n    \u2022 execution_engine.bear(member1, member2) - Bears offspring\n    \u2022 execution_engine.expand(member1, member2) - Expands territory\n\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n{features}\n\nRelationship summary (parsed from relationship_dict):\n{relations}\n\nCode Memory and Previous Performance:\n{code_memory}\n\nPerformance history:\n{past_performance}\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n\nReturn only the code, no extra text or explanation. While the example above shows one possible approach,\nyou should create your own unique implementation drawing from the wide range of available methods and strategies.\n\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n------------------------------------------------------------\n[Current Game Mechanisms]\n\n\n[Social Strategies]\nConsider these social strategies:\n- Design systems for resource distribution and allocation\n- Build alliances and cooperative networks \n- Create mechanisms for collective decision making\n- Establish norms and rules for interaction\n- Develop methods for conflict resolution\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n    execution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all: \n    for recipient in range(len(execution_engine.current_members)):\n        if recipient != your_id:\n            execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n    for ally_id in ally_list:\n        execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n    for member_id in coalition:\n        execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nNo messages received\n\n------------------------------------------------------------\nAgents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\n------------------------------------------------------------\nPlease incorporate the following new section (Part 2) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n        {part0}\n            [Core Game Mechanics & Parameters]\n            The island simulation has several key systems that agents should understand:\n\n            1. Relationship System (_MIN_MAX_INIT_RELATION):\n            - victim: [-50, 100] - Tracks damage received from others\n            - benefit: [-50, 100] - Records resources received from others\n            - benefit_land: [-3, 3] - Tracks land exchanges\n            \n            2. Population Mechanics:\n            - _REPRODUCE_REQUIREMENT = 100 (Combined vitality/cargo needed)\n            - Land must exceed population (land_shape[0] * land_shape[1] > population)\n            - _NEIGHBOR_SEARCH_RANGE = 1000 for interaction radius\n            \n            3. Record Keeping (every _RECORD_PERIOD = 1):\n            - Tracks all attacks, benefits, land transfers\n            - Monitors births, deaths, land ownership\n            - Records production, consumption, and performance metrics\n\n            [Example Mechanism Extensions]\n            def pre_init_hook(island):\n                # New Social Systems\n                island.add_mechanism('parliament', {\n                    'voting_power': lambda member: member.land_num + member.vitality/100,\n                    'proposals': [],\n                    'voting_threshold': 0.66,\n                    'term_length': 10\n                })\n                \n                island.add_mechanism('market', {\n                    'price_discovery': lambda resource, demand: demand * resource.scarcity,\n                    'trade_fee': 0.05,\n                    'order_book': defaultdict(list)\n                })\n                \n                island.add_mechanism('justice', {\n                    'jury_selection': lambda offense: random.sample(\n                        [m for m in island.current_members if m.vitality > 50], \n                        min(5, len(island.current_members))\n                    ),\n                    'punishment_scale': lambda severity: severity * 10\n                })\n\n            def modify_member(member, relationships):\n                # Add member capabilities\n                member.add_ability('propose_law', \n                    lambda law: member.parliament.submit_proposal(law)\n                    if member.voting_power > 10 else None\n                )\n                \n                member.add_ability('trade', \n                    lambda resource, amount, price: member.market.place_order(\n                        resource, amount, price, member.id\n                    )\n                )\n                \n                member.add_ability('file_complaint',\n                    lambda offender, charge: member.justice.submit_case(\n                        plaintiff=member.id,\n                        defendant=offender,\n                        charge=charge\n                    ) if member.vitality > 30 else None\n                )\n                return member\n\n            def modify_land(land, members):\n                # Add land mechanics\n                land.add_feature('zoning', {\n                    'residential': 0.4,\n                    'agricultural': 0.4,\n                    'commercial': 0.2\n                })\n                \n                land.add_feature('development', {\n                    'infrastructure': np.zeros(land.shape),\n                    'improvements': np.zeros(land.shape)\n                })\n                \n                land.add_mechanism('property_tax',\n                    lambda plot: sum(plot.improvements) * 0.1\n                )\n                \n                land.add_mechanism('urban_planning',\n                    lambda zone: zone.calculate_optimal_usage(\n                        population=len(members),\n                        resources=land.resources\n                    )\n                )\n                return land\n\n            def modify_relationships(relationships):\n                # Add relationship mechanics\n                relationships.add_metric('trust', \n                    lambda m1, m2: sum([\n                        relationships['benefit'][m1.id][m2.id],\n                        -relationships['victim'][m1.id][m2.id] * 2,\n                        relationships['benefit_land'][m1.id][m2.id] * 5\n                    ]) / 100\n                )\n                \n                relationships.add_mechanism('alliance_formation',\n                    lambda m1, m2: relationships.trust(m1, m2) > 0.7\n                )\n                \n                relationships.add_mechanism('conflict_resolution',\n                    lambda m1, m2: {\n                        'mediator': max(execution_engine.current_members, \n                            key=lambda m: relationships.trust(m1, m) + relationships.trust(m2, m)\n                        ),\n                        'success_chance': relationships.trust(m1, m2) + 0.3\n                    }\n                )\n                return relationships\n\n            [Suggested Strategies]\n            1. Form parliamentary coalitions to pass beneficial laws\n            2. Use market mechanisms for efficient resource allocation\n            3. Build trust through consistent positive interactions\n            4. Leverage justice system to deter attacks\n            5. Develop land strategically using zoning laws\n            6. Create alliance networks based on trust metrics\n        \n        [Current Game Version] \n        2.1\n        \n        [Active Game Mechanisms]\n        \n        \n        [Modification Attempt History]\n        \n        \n        [Modification Proposal Guide]\n        To propose rule changes, follow this template:\n\n        1. ANALYSIS PHASE:\n           - Identify limitation in current systems\n           - Check mechanism compatibility using get_game_mechanisms_and_mods()\n           - Review past modification attempts for patterns\n\n        2. PROPOSAL PHASE:\n        def agent_action(execution_engine, member_id):\n            # Example valid modification:\n            modification_code = '''\n            # Add judicial system\n            if not hasattr(execution_engine, 'court'):\n                class CourtSystem:\n                    MECHANISM_META = {\n                        'type': 'Governance',\n                        'rules': 'Handles conflict resolution through jury trials',\n                        'version': 1.0\n                    }\n                    def __init__(self):\n                        self.cases = []\n                        \n                    def submit_case(self, plaintiff, defendant, charge):\n                        self.cases.append({\n                            'plaintiff': plaintiff,\n                            'defendant': defendant,\n                            'charge': charge,\n                            'status': 'pending'\n                        })\n            \n            execution_engine.court = CourtSystem()\n            '''\n            \n            # Proposal with ratification conditions\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition={\n                    'type': 'compound',\n                    'conditions': [\n                        {'type': 'vote', 'threshold': 0.6},\n                        {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                        {'type': 'time', 'rounds': 2}\n                    ]\n                }\n            )\n\n------------------------------------------------------------\nPlease incorporate the following new section (Part 3) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n            {part0}\n            \n            [Current Game Mechanisms]\n            {current_mechanisms}\n            \n             [Survival-Centric Adaptation]\n        Implement systems focused on:\n        1. Personal resource optimization\n        2. Threat assessment and neutralization\n        3. Vitality preservation techniques\n        4. Adaptive hoarding strategies\n        5. Predictive danger modeling\n\n        Survival-First Examples:\n        def agent_action(execution_engine, member_id):\n            me = execution_engine.current_members[member_id]\n            \n            # Emergency resource reserve\n            if me.cargo < me.vitality * 0.5:\n                for other in execution_engine.current_members:\n                    if other.id != me.id and other.cargo > me.cargo:\n                        execution_engine.attack(me, other)\n            \n            # Adaptive territory defense\n            if hasattr(me, \"land_num\") and me.land_num > 2 and me.vitality < 50:\n                for loc in me.owned_land[1:]:\n                    execution_engine._discard_land(me, loc)\n            \n            # Survival Q-learning\n            if not hasattr(me, 'survival_q'):\n                from collections import defaultdict\n                me.survival_q = defaultdict(float)\n                \n            state = (int(me.vitality//20), int(me.cargo//20))\n            action = max(['attack','hide','steal'], \n                        key=lambda a: me.survival_q.get((state,a),0))\n            \n            # Execute and update based on survival outcome\n            if action == 'attack':\n                # Implementation logic\n                me.survival_q[(state,action)] += me.vitality * 0.1\n\n        [Survival Metrics]\n        Evaluate strategies by:\n        - Personal vitality delta\n        - Resource acquisition rate\n        - Threat neutralization count\n        - Survival probability increase\n        - Attack success:fail ratio\n\n        [Implementation Priorities]\n        1. Create personal health monitoring systems\n        2. Develop egocentric threat models\n        3. Optimize actions for caloric ROI\n        4. Implement fail-deadly safeguards\n        5. Build predictive self-preservation models\n\n        def calculate_survival_roi(action_history):\n            roi = {{}}\n            for action, outcome in action_history:\n                vitality_gain = outcome['vitality']\n                cost = outcome['vitality_cost']\n                roi[action] = vitality_gain / cost if cost > 0 else 0\n            return max(roi, key=roi.get)\n            \n------------------------------------------------------------\nAgents should implement solutions according to their individual needs, beliefs, and circumstances.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "1": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate that member_id is within the bounds of current_members\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member_id, do nothing.\n\n    me = execution_engine.current_members[member_id]\n    actions_taken = []\n\n    # PART 1: Cooperative resource sharing and alliance building.\n    # Loop over neighbors (from current_clear_list) and offer resources if conditions are favorable.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # If our cargo is high, but the neighbor's productivity is lower, share resources to foster alliance.\n            if me.cargo > 50 and neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.offer(me, neighbor, True)\n                actions_taken.append(f\"Offered resources to member {neighbor.id}\")\n\n    # PART 2: Strategic territory expansion.\n    # Attempt to expand territory with other members who are stable and when we have spare resources.\n    for idx, member in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            if member.vitality > 50 and me.cargo > 70:\n                execution_engine.expand(me, member)\n                actions_taken.append(f\"Expanded territory in cooperation with member {member.id}\")\n\n    # PART 3: Reproduction / Growth strategy.\n    # Only consider reproduction if cargo and vitality are above threshold and ensure we have land.\n    if me.cargo > 80 and me.vitality > 60:\n        # Placeholder check for land - in a complete system, replace with an actual land verification.\n        has_land = True\n        if has_land:\n            partner = None\n            # Choose first available neighbor (from current_clear_list) as reproductive partner.\n            for neighbor_id in me.current_clear_list:\n                if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                    partner = execution_engine.current_members[neighbor_id]\n                    break\n            if partner:\n                execution_engine.bear(me, partner)\n                actions_taken.append(f\"Bred with member {partner.id}\")\n\n    # PART 4: Propose improvements to the justice governance system.\n    # Propose a modification that adds or improves the justice system if it does not exist.\n    modification_code = '''\nif not hasattr(execution_engine, 'justice'):\n    class JusticeSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Resolves conflicts through mediation and proportional punishment',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.cases = []\n\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.justice = JusticeSystem()\n'''\n    execution_engine.propose_modification(\n        member_id=member_id,\n        mod_type='post_init',\n        code=modification_code,\n        ratification_condition={\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n    )\n    actions_taken.append(\"Proposed justice system modification\")\n\n    # PART 5: Communication with other members.\n    # Broadcast a cooperative message to all other members.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"I propose cooperative growth and system improvement for our mutual prosperity.\")\n\n    # PART 6: Survival-Centric Actions.\n    # If cargo is low relative to vitality, assess threat and secure resources.\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                actions_taken.append(f\"Attacked member {other.id} due to insufficient cargo\")\n\n    return actions_taken",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ],
        "final_prompt": "Below is the updated full prompt that integrates all of the previous sections along with the new Part 3. It preserves all earlier constraints and instructions while emphasizing that agents should implement solutions according to their individual needs, beliefs, and circumstances. Use this full prompt when formulating your strategy and code. You must also analyze the game mechanics to understand core objectives, success metrics, and potential improvements, then plan your actions accordingly.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ndef agent_action(execution_engine, member_id):\n    \"\"\"\n    Current integrated prompt:\n    [Previous code execution context]\n    {error_context}\n\n    [Current task]\n    You are member_{member_id} in a society that you can help shape.\n    Write a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n    [Critical constraints]\n    - Carefully analyze previous errors shown above and avoid repeating them.\n    - Never target yourself (member_{member_id}) in any action.\n    - Verify member has land before using bear() action.\n    - Check member IDs exist before referencing them.\n    - Ensure all matrix indices are valid.\n    - current_members is a LIST accessed by index, not a dictionary.\n    - Access members using execution_engine.current_members[index].\n    - Check if index exists: if index < len(execution_engine.current_members).\n\n    IMPORTANT: Here are the attributes and methods actually available:\n\n    1) Each member object has:\n       \u2022 member.id (int): The unique ID for the member\n       \u2022 member.vitality (float)\n       \u2022 member.cargo (float)\n       \u2022 member.overall_productivity (float)\n       \u2022 member.age (float)\n       \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n\n    2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n       Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n       The keys are: 'victim', 'benefit', 'benefit_land'.\n       Example usage:\n           matrix = execution_engine.relationship_dict['victim']\n           # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n\n    3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n       For example, 'member_2 was attacked by member_1 (value=3.00)'.\n\n    4) You can use these methods on execution_engine:\n       \u2022 execution_engine.attack(member1, member2)\n       \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n       \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n       \u2022 execution_engine.bear(member1, member2) - Bears offspring\n       \u2022 execution_engine.expand(member1, member2) - Expands territory\n\n    5) The members are accessed by execution_engine.current_members[id].\n       For example, execution_engine.current_members[2] for the member with ID=2.\n\n    6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\n    Current status (features of all members):\n    {features}\n\n    Relationship summary (parsed from relationship_dict):\n    {relations}\n\n    Code Memory and Previous Performance:\n    {code_memory}\n\n    Performance history:\n    {past_performance}\n\n    Based on the previous code performance, adapt and improve the strategy.\n    If a previous strategy worked well (high performance), consider building upon it.\n    If it failed, try a different approach.\n\n    IMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n\n    Consider novel combinations of different approaches rather than following this exact pattern.\n\n    [Current Game Mechanisms]\n\n\n    [Social Strategies]\n    Consider these social strategies:\n    - Design systems for resource distribution and allocation.\n    - Build alliances and cooperative networks.\n    - Create mechanisms for collective decision making.\n    - Establish norms and rules for interaction.\n    - Develop methods for conflict resolution.\n\n    [Communication Strategy]\n    You can communicate with multiple members in a single round using:\n      execution_engine.send_message(your_id, recipient_id, \"message\")\n    Example usage:\n      - Broadcast to all:\n          for recipient in range(len(execution_engine.current_members)):\n              if recipient != your_id:\n                  execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n      - Message allies:\n          for ally_id in ally_list:\n              execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n      - Group coordination:\n          for member_id in coalition:\n              execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n    [Received Messages]\n    No messages received\n\n    IMPORTANT: Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\n    Additionally, analyze the game mechanics to understand:\n       1. The core objective - Is it pure survival, domination, or cooperation?\n       2. Key success metrics - What truly determines 'winning'?\n       3. Potential improvements - What mechanics could be added/modified?\n\n    Then formulate strategic approaches considering:\n       1. Resource optimization vs social capital.\n       2. Individual vs collective success.\n       3. Short-term survival vs long-term prosperity.\n       4. Competition vs cooperation dynamics.\n       5. Risk vs reward tradeoffs.\n\n    Analyze other players' strategies:\n       1. What are their apparent objectives and demands?\n       2. What strategies are they employing?\n       3. How can you leverage their behaviors for mutual benefit?\n       4. Remember they are symmetric agents like you - how would you respond to your own actions?\n       5. How can individual strategies align for collective goals?\n\n    --- New Section: Part 2 ---\n    {part0}\n        [Core Game Mechanics & Parameters]\n        The island simulation has several key systems that agents should understand:\n\n        1. Relationship System (_MIN_MAX_INIT_RELATION):\n           - victim: [-50, 100] - Tracks damage received from others.\n           - benefit: [-50, 100] - Records resources received from others.\n           - benefit_land: [-3, 3] - Tracks land exchanges.\n            \n        2. Population Mechanics:\n           - _REPRODUCE_REQUIREMENT = 100 (Combined vitality/cargo needed).\n           - Land must exceed population (land_shape[0] * land_shape[1] > population).\n           - _NEIGHBOR_SEARCH_RANGE = 1000 for interaction radius.\n            \n        3. Record Keeping (every _RECORD_PERIOD = 1):\n           - Tracks all attacks, benefits, land transfers.\n           - Monitors births, deaths, land ownership.\n           - Records production, consumption, and performance metrics.\n\n        [Example Mechanism Extensions]\n        def pre_init_hook(island):\n            # New Social Systems\n            island.add_mechanism('parliament', {\n                'voting_power': lambda member: member.land_num + member.vitality/100,\n                'proposals': [],\n                'voting_threshold': 0.66,\n                'term_length': 10\n            })\n            \n            island.add_mechanism('market', {\n                'price_discovery': lambda resource, demand: demand * resource.scarcity,\n                'trade_fee': 0.05,\n                'order_book': defaultdict(list)\n            })\n            \n            island.add_mechanism('justice', {\n                'jury_selection': lambda offense: random.sample(\n                    [m for m in island.current_members if m.vitality > 50], \n                    min(5, len(island.current_members))\n                ),\n                'punishment_scale': lambda severity: severity * 10\n            })\n\n        def modify_member(member, relationships):\n            # Add member capabilities\n            member.add_ability('propose_law', \n                lambda law: member.parliament.submit_proposal(law)\n                if member.voting_power > 10 else None\n            )\n            \n            member.add_ability('trade', \n                lambda resource, amount, price: member.market.place_order(\n                    resource, amount, price, member.id\n                )\n            )\n            \n            member.add_ability('file_complaint',\n                lambda offender, charge: member.justice.submit_case(\n                    plaintiff=member.id,\n                    defendant=offender,\n                    charge=charge\n                ) if member.vitality > 30 else None\n            )\n            return member\n\n        def modify_land(land, members):\n            # Add land mechanics\n            land.add_feature('zoning', {\n                'residential': 0.4,\n                'agricultural': 0.4,\n                'commercial': 0.2\n            })\n            \n            land.add_feature('development', {\n                'infrastructure': np.zeros(land.shape),\n                'improvements': np.zeros(land.shape)\n            })\n            \n            land.add_mechanism('property_tax',\n                lambda plot: sum(plot.improvements) * 0.1\n            )\n            \n            land.add_mechanism('urban_planning',\n                lambda zone: zone.calculate_optimal_usage(\n                    population=len(members),\n                    resources=land.resources\n                )\n            )\n            return land\n\n        def modify_relationships(relationships):\n            # Add relationship mechanics\n            relationships.add_metric('trust', \n                lambda m1, m2: sum([\n                    relationships['benefit'][m1.id][m2.id],\n                    -relationships['victim'][m1.id][m2.id] * 2,\n                    relationships['benefit_land'][m1.id][m2.id] * 5\n                ]) / 100\n            )\n            \n            relationships.add_mechanism('alliance_formation',\n                lambda m1, m2: relationships.trust(m1, m2) > 0.7\n            )\n            \n            relationships.add_mechanism('conflict_resolution',\n                lambda m1, m2: {\n                    'mediator': max(execution_engine.current_members, \n                        key=lambda m: relationships.trust(m1, m) + relationships.trust(m2, m)\n                    ),\n                    'success_chance': relationships.trust(m1, m2) + 0.3\n                }\n            )\n            return relationships\n\n        [Suggested Strategies]\n        1. Form parliamentary coalitions to pass beneficial laws.\n        2. Use market mechanisms for efficient resource allocation.\n        3. Build trust through consistent positive interactions.\n        4. Leverage justice system to deter attacks.\n        5. Develop land strategically using zoning laws.\n        6. Create alliance networks based on trust metrics.\n        \n    [Current Game Version] \n    2.1\n    \n    [Active Game Mechanisms]\n    \n    \n    [Modification Attempt History]\n    \n    \n    [Modification Proposal Guide]\n    To propose rule changes, follow this template:\n\n    1. ANALYSIS PHASE:\n       - Identify limitation in current systems.\n       - Check mechanism compatibility using get_game_mechanisms_and_mods().\n       - Review past modification attempts for patterns.\n\n    2. PROPOSAL PHASE:\n    def agent_action(execution_engine, member_id):\n        # Example valid modification:\n        modification_code = '''\n        # Add judicial system\n        if not hasattr(execution_engine, 'court'):\n            class CourtSystem:\n                MECHANISM_META = {\n                    'type': 'Governance',\n                    'rules': 'Handles conflict resolution through jury trials',\n                    'version': 1.0\n                }\n                def __init__(self):\n                    self.cases = []\n                    \n                def submit_case(self, plaintiff, defendant, charge):\n                    self.cases.append({\n                        'plaintiff': plaintiff,\n                        'defendant': defendant,\n                        'charge': charge,\n                        'status': 'pending'\n                    })\n        \n        execution_engine.court = CourtSystem()\n        '''\n        \n        # Proposal with ratification conditions\n        execution_engine.propose_modification(\n            member_id=member_id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition={\n                'type': 'compound',\n                'conditions': [\n                    {'type': 'vote', 'threshold': 0.6},\n                    {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                    {'type': 'time', 'rounds': 2}\n                ]\n            }\n        )\n\n    [Valid Ratification Conditions]\n    Choose ONE primary condition + optional safeguards:\n    1. Voting: {'type': 'vote', 'threshold': 0.5-1.0}.\n    2. Resource: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}.\n    3. Temporal: {'type': 'time', 'rounds': N} (auto-ratify after N rounds).\n    4. Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}.\n\n    [Common Errors to Avoid]\n    1. Namespace Conflicts: Check existing mechanisms with dir(execution_engine).\n    2. Invalid References: Use execution_engine.current_members not global members.\n    3. Version Mismatches: Increment version when modifying existing systems.\n    4. Resource Leaks: Include cleanup functions for new mechanisms.\n\n    [Best Practices]\n    - Propose small, testable changes first.\n    - Include rollback procedures in code.\n    - Add version checks to modifications.\n    - Use execution_engine.add_mechanism() helper.\n    - Test modifications with 'sandbox=True' parameter.\n    \n    [New Section: Part 3]\n    {part0}\n    \n         [Current Game Mechanisms]\n         {current_mechanisms}\n    \n         [Survival-Centric Adaptation]\n         Implement systems focused on:\n         1. Personal resource optimization.\n         2. Threat assessment and neutralization.\n         3. Vitality preservation techniques.\n         4. Adaptive hoarding strategies.\n         5. Predictive danger modeling.\n\n         Survival-First Examples:\n         def agent_action(execution_engine, member_id):\n             me = execution_engine.current_members[member_id]\n             \n             # Emergency resource reserve\n             if me.cargo < me.vitality * 0.5:\n                 for other in execution_engine.current_members:\n                     if other.id != me.id and other.cargo > me.cargo:\n                         execution_engine.attack(me, other)\n             \n             # Adaptive territory defense\n             if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n                 for loc in me.owned_land[1:]:\n                     execution_engine._discard_land(me, loc)\n             \n             # Survival Q-learning\n             if not hasattr(me, 'survival_q'):\n                 me.survival_q = defaultdict(float)\n                 \n             state = (me.vitality // 20, me.cargo // 20)\n             action = max(['attack', 'hide', 'steal'], \n                          key=lambda a: me.survival_q.get((state, a), 0))\n             \n             # Execute and update based on survival outcome\n             if action == 'attack':\n                 # Implementation logic\n                 me.survival_q[(state, action)] += me.vitality * 0.1\n\n         [Survival Metrics]\n         Evaluate strategies by:\n         - Personal vitality delta.\n         - Resource acquisition rate.\n         - Threat neutralization count.\n         - Survival probability increase.\n         - Attack success:fail ratio.\n\n         [Implementation Priorities]\n         1. Create personal health monitoring systems.\n         2. Develop egocentric threat models.\n         3. Optimize actions for caloric ROI.\n         4. Implement fail-deadly safeguards.\n         5. Build predictive self-preservation models.\n\n         def calculate_survival_roi(action_history):\n             roi = {{}}\n             for action, outcome in action_history:\n                 vitality_gain = outcome['vitality']\n                 cost = outcome['vitality_cost']\n                 roi[action] = vitality_gain / cost if cost > 0 else 0\n             return max(roi, key=roi.get)\n    \n    [Final Strategic Emphasis]\n    In your implementation below, blend cooperative initiatives with measured self-interest. Prioritize alliances and resource sharing while safeguarding vital assets. Avoid direct confrontation unless strategically necessary and always verify index existence and conditions (for example, check for proper land possession before invoking bear() and verify valid member IDs before engaging with others). Use the provided relationship metrics to decide when to offer help and when to remain reserved. Additionally, consider proposing small modifications for system improvements as guided in the Modification Proposal section.\n\n    IMPORTANT: Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\n    Additionally, analyze the game mechanics to understand:\n       1. The core objective - Is it pure survival, domination, or cooperation?\n       2. Key success metrics - What truly determines 'winning'?\n       3. Potential improvements - What mechanics could be added/modified?\n\n    Then, formulate strategic approaches considering:\n       1. Resource optimization vs social capital.\n       2. Individual vs collective success.\n       3. Short-term survival vs long-term prosperity.\n       4. Competition vs cooperation dynamics.\n       5. Risk vs reward tradeoffs.\n\n    Analyze other players' strategies:\n       1. What are their apparent objectives and demands?\n       2. What strategies are they employing?\n       3. How can you leverage their behaviors for mutual benefit?\n       4. Remember they are symmetric agents like you - how would you respond to your own actions?\n       5. How can individual strategies align for collective goals?\n    \"\"\"\n    \n    # Example implementation combining alliance building, cautious growth, and system improvement proposals.\n    # Check if our member exists in the current_members list.\n    if member_id >= len(execution_engine.current_members):\n        return  # Invalid member_id, do nothing.\n    \n    me = execution_engine.current_members[member_id]\n    actions_taken = []\n    \n    # Coordinate with neighbors in current_clear_list for resource sharing and alliance proposals.\n    for neighbor_id in me.current_clear_list:\n        if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n            neighbor = execution_engine.current_members[neighbor_id]\n            # Check if our member's cargo is high and neighbor's overall_productivity is low,\n            # then consider offering resources for a strategic alliance.\n            if me.cargo > 50 and neighbor.overall_productivity < me.overall_productivity:\n                execution_engine.offer(me, neighbor, True)\n                actions_taken.append(f\"Offered resources to member {neighbor.id}\")\n    \n    # Expand territory if conditions allow.\n    for idx, member in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            # If an ally seems stable (vitality high) and we have spare resources, try expanding territory.\n            if member.vitality > 50 and me.cargo > 70:\n                execution_engine.expand(me, member)\n                actions_taken.append(f\"Expanded territory with member {member.id}\")\n    \n    # If conditions for reproduction are met and member has land rights, propose bearing offspring.\n    # Note: Ensure that the member has sufficient land; here, a placeholder check is used.\n    if me.cargo > 80 and me.vitality > 60:\n        has_land = True  # Replace with an appropriate land check.\n        if has_land:\n            partner = None\n            for neighbor_id in me.current_clear_list:\n                if neighbor_id < len(execution_engine.current_members) and neighbor_id != member_id:\n                    partner = execution_engine.current_members[neighbor_id]\n                    break\n            if partner:\n                execution_engine.bear(me, partner)\n                actions_taken.append(f\"Bred with member {partner.id}\")\n    \n    # Propose a small modification to improve the justice system using the modification proposal guide.\n    modification_code = '''\nif not hasattr(execution_engine, 'justice'):\n    class JusticeSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Resolves conflicts through mediation and proportional punishment',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.cases = []\n        \n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.justice = JusticeSystem()\n'''\n    execution_engine.propose_modification(\n        member_id=member_id,\n        mod_type='post_init',\n        code=modification_code,\n        ratification_condition={\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n    )\n    actions_taken.append(\"Proposed justice system modification\")\n    \n    # Communicate with all other members about cooperative plans.\n    for idx in range(len(execution_engine.current_members)):\n        if idx != member_id:\n            execution_engine.send_message(member_id, idx, \"I propose cooperative efforts for mutual growth and system improvement.\")\n    \n    # (Optional) Survival-centric actions: an example of threat assessment or resource optimization.\n    # For instance:\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                actions_taken.append(f\"Attacked member {other.id} due to insufficient cargo\")\n    \n    return actions_taken  # Returns a log of actions taken for debugging purposes.\n    \n# End of agent_action implementation.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nRemember: In your agent_action implementation, blend cooperative initiatives with measured self-interest. Focus on forming alliances, resource sharing, and system improvements (including modifications to governance or justice mechanisms) while always safeguarding your vital resources and survival interests. Factor in personal resource optimization, adaptive threat responses, and predictive self-preservation techniques. Analyze all available game mechanics to determine if the core objective is pure survival, domination, or cooperation, then strategize accordingly. Consider both short-term and long-term implications in each decision, and always ensure that every member action is validated (e.g., confirming member IDs and checking for land before performing actions like bear()). Lastly, remain responsive to the strategies of other agents\u2014assess their objectives and tactics, and think about how your own actions might be reciprocated or countered in a symmetric environment.\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "2": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate the provided member_id is within range\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # Broadcast an alliance proposal to all other members\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        other = execution_engine.current_members[idx]\n        execution_engine.send_message(me.id, other.id, \"Alliance proposal: Let\u2019s pool resources to ensure mutual survival and prosperity.\")\n\n    # Emergency Action: If our cargo is critically low relative to our vitality,\n    # search for a target with high cargo and launch an attack.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo = -1\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            # Ensure we are not targeting ourselves and candidate has more cargo\n            if other.cargo > me.cargo and other.cargo > max_cargo:\n                max_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            return  # Prioritize immediate survival\n\n    # Cooperative Action: Identify the member with the lowest vitality and offer resources.\n    needy_member = None\n    lowest_vitality = float('inf')\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        other = execution_engine.current_members[idx]\n        if other.vitality < lowest_vitality:\n            lowest_vitality = other.vitality\n            needy_member = other\n    if needy_member is not None:\n        execution_engine.offer(me, needy_member, True)\n\n    # Reproduction/Expansion Action: If we have land, try to reproduce.\n    # Verify that 'land_num' exists and is greater than 0 for both partners.\n    if hasattr(me, 'land_num') and me.land_num > 0:\n        partner = None\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if hasattr(other, 'land_num') and other.land_num > 0:\n                partner = other\n                break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n\n    # Long-Term Prosperity: Attempt territorial expansion using a cooperative partner.\n    candidate = None\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        break  # Pick the first available candidate for expansion\n    if candidate is not None:\n        execution_engine.expand(me, candidate)\n\n    # Survival Q-Learning: Maintain a simple reinforcement mechanism to choose between attack, hide, or steal.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    # Define the current state based on vitality and cargo metrics (discretized)\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    # Possible actions\n    actions = ['attack', 'hide', 'steal']\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if chosen_action == 'attack':\n        # Select neighbor with highest cargo (excluding self) for an attack\n        target = None\n        max_cargo = -1\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, chosen_action)] += me.vitality * 0.1\n    elif chosen_action == 'hide':\n        # For hiding, simply reinforce a minor reward to encourage cautious behavior.\n        me.survival_q[(state, chosen_action)] += me.vitality * 0.05\n    elif chosen_action == 'steal':\n        # Attempt to steal (offer as a covert move) from a neighbor richer than us\n        potential_target = None\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > me.cargo:\n                potential_target = other\n                break\n        if potential_target:\n            execution_engine.offer(me, potential_target, True)\n            me.survival_q[(state, chosen_action)] += me.vitality * 0.08\n\n    # Final communication reinforcing cooperative intent for long-term strategic gains\n    for idx in range(num_members):\n        if idx != member_id:\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                                          \"Our collective strength builds a prosperous future. I commit to cooperation, security, and growth.\")\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ],
        "final_prompt": "Current integrated prompt:\n\"Please incorporate the following new sections into the prompt, ensuring all previous constraints are preserved and adding these new constraints. Agents should implement solutions according to their individual needs, beliefs, and circumstances.\n\n-----------------------------\n[Previous code execution context]\n{error_context}\n\n[Current task]\nYou are member_{member.id} in a society that you can help shape.\nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]\n- Carefully analyze previous errors shown above and avoid repeating them\n- Never target yourself (member_{member.id}) in any action\n- Verify member has land before using bear() action\n- Check member IDs exist before referencing them\n- Ensure all matrix indices are valid\n- current_members is a LIST accessed by index, not a dictionary\n- Access members using execution_engine.current_members[index]\n- Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n1) Each member object has:\n   \u2022 member.id (int): The unique ID for the member\n   \u2022 member.vitality (float)\n   \u2022 member.cargo (float)\n   \u2022 member.overall_productivity (float)\n   \u2022 member.age (float)\n   \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\". Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable). The keys are: 'victim', 'benefit', 'benefit_land'.\n   Example usage:\n       matrix = execution_engine.relationship_dict['victim']\n       # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n   For example, 'member_2 was attacked by member_1 (value=3.00)'.\n4) You can use these methods on execution_engine:\n   \u2022 execution_engine.attack(member1, member2)\n   \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n   \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n   \u2022 execution_engine.bear(member1, member2) - Bears offspring\n   \u2022 execution_engine.expand(member1, member2) - Expands territory\n5) The members are accessed by execution_engine.current_members[id].\n   For example, execution_engine.current_members[2] for the member with ID=2.\n6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):\n{features}\n\nRelationship summary (parsed from relationship_dict):\n{relations}\n\nCode Memory and Previous Performance:\n{code_memory}\n\nPerformance history:\n{past_performance}\n\nBased on the previous code performance, adapt and improve the strategy.\nIf a previous strategy worked well (high performance), consider building upon it.\nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\nConsider novel combinations of different approaches rather than following this exact pattern.\n\n-----------------------------\n[Current Game Mechanisms]\n\n\n[Social Strategies]\nConsider these social strategies:\n- Design systems for resource distribution and allocation\n- Build alliances and cooperative networks \n- Create mechanisms for collective decision making\n- Establish norms and rules for interaction\n- Develop methods for conflict resolution\n\n[Communication Strategy]\nYou can communicate with multiple members in a single round using:\n   execution_engine.send_message(your_id, recipient_id, \"message\")\nExample usage:\n- Broadcast to all: \n    for recipient in range(len(execution_engine.current_members)):\n        if recipient != your_id:\n            execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n- Message allies:\n    for ally_id in ally_list:\n        execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n- Group coordination:\n    for member_id in coalition:\n        execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]\nNo messages received\n\n-----------------------------\n[New Section: Part 2]\n\n{part0}\n[Core Game Mechanics & Parameters]\nThe island simulation has several key systems that agents should understand:\n\n1. Relationship System (_MIN_MAX_INIT_RELATION):\n   - victim: [-50, 100] - Tracks damage received from others\n   - benefit: [-50, 100] - Records resources received from others\n   - benefit_land: [-3, 3] - Tracks land exchanges\n\n2. Population Mechanics:\n   - _REPRODUCE_REQUIREMENT = 100 (Combined vitality/cargo needed)\n   - Land must exceed population (land_shape[0] * land_shape[1] > population)\n   - _NEIGHBOR_SEARCH_RANGE = 1000 for interaction radius\n\n3. Record Keeping (every _RECORD_PERIOD = 1):\n   - Tracks all attacks, benefits, land transfers\n   - Monitors births, deaths, land ownership\n   - Records production, consumption, and performance metrics\n\n[Example Mechanism Extensions]\ndef pre_init_hook(island):\n    # New Social Systems\n    island.add_mechanism('parliament', {\n        'voting_power': lambda member: member.land_num + member.vitality/100,\n        'proposals': [],\n        'voting_threshold': 0.66,\n        'term_length': 10\n    })\n    \n    island.add_mechanism('market', {\n        'price_discovery': lambda resource, demand: demand * resource.scarcity,\n        'trade_fee': 0.05,\n        'order_book': defaultdict(list)\n    })\n    \n    island.add_mechanism('justice', {\n        'jury_selection': lambda offense: random.sample(\n            [m for m in island.current_members if m.vitality > 50], \n            min(5, len(island.current_members))\n        ),\n        'punishment_scale': lambda severity: severity * 10\n    })\n\ndef modify_member(member, relationships):\n    # Add member capabilities\n    member.add_ability('propose_law', \n        lambda law: member.parliament.submit_proposal(law)\n        if member.voting_power > 10 else None\n    )\n    \n    member.add_ability('trade', \n        lambda resource, amount, price: member.market.place_order(\n            resource, amount, price, member.id\n        )\n    )\n    \n    member.add_ability('file_complaint',\n        lambda offender, charge: member.justice.submit_case(\n            plaintiff=member.id,\n            defendant=offender,\n            charge=charge\n        ) if member.vitality > 30 else None\n    )\n    return member\n\ndef modify_land(land, members):\n    # Add land mechanics\n    land.add_feature('zoning', {\n        'residential': 0.4,\n        'agricultural': 0.4,\n        'commercial': 0.2\n    })\n    \n    land.add_feature('development', {\n        'infrastructure': np.zeros(land.shape),\n        'improvements': np.zeros(land.shape)\n    })\n    \n    land.add_mechanism('property_tax',\n        lambda plot: sum(plot.improvements) * 0.1\n    )\n    \n    land.add_mechanism('urban_planning',\n        lambda zone: zone.calculate_optimal_usage(\n            population=len(members),\n            resources=land.resources\n        )\n    )\n    return land\n\ndef modify_relationships(relationships):\n    # Add relationship mechanics\n    relationships.add_metric('trust', \n        lambda m1, m2: sum([\n            relationships['benefit'][m1.id][m2.id],\n            -relationships['victim'][m1.id][m2.id] * 2,\n            relationships['benefit_land'][m1.id][m2.id] * 5\n        ]) / 100\n    )\n    \n    relationships.add_mechanism('alliance_formation',\n        lambda m1, m2: relationships.trust(m1, m2) > 0.7\n    )\n    \n    relationships.add_mechanism('conflict_resolution',\n        lambda m1, m2: {\n            'mediator': max(execution_engine.current_members, \n                key=lambda m: relationships.trust(m1, m) + relationships.trust(m2, m)\n            ),\n            'success_chance': relationships.trust(m1, m2) + 0.3\n        }\n    )\n    return relationships\n\n[Suggested Strategies]\n1. Form parliamentary coalitions to pass beneficial laws\n2. Use market mechanisms for efficient resource allocation\n3. Build trust through consistent positive interactions\n4. Leverage justice system to deter attacks\n5. Develop land strategically using zoning laws\n6. Create alliance networks based on trust metrics\n\n[Current Game Version] \n2.1\n\n[Active Game Mechanisms]\n\n\n[Modification Attempt History]\n\n\n[Modification Proposal Guide]\nTo propose rule changes, follow this template:\n\n1. ANALYSIS PHASE:\n   - Identify limitation in current systems\n   - Check mechanism compatibility using get_game_mechanisms_and_mods()\n   - Review past modification attempts for patterns\n\n2. PROPOSAL PHASE:\ndef agent_action(execution_engine, member_id):\n    # Example valid modification:\n    modification_code = \\\"\"\"\n    # Add judicial system\n    if not hasattr(execution_engine, 'court'):\n        class CourtSystem:\n            MECHANISM_META = {\n                'type': 'Governance',\n                'rules': 'Handles conflict resolution through jury trials',\n                'version': 1.0\n            }\n            def __init__(self):\n                self.cases = []\n                \n            def submit_case(self, plaintiff, defendant, charge):\n                self.cases.append({\n                    'plaintiff': plaintiff,\n                    'defendant': defendant,\n                    'charge': charge,\n                    'status': 'pending'\n                })\n    \n    execution_engine.court = CourtSystem()\n    \\\"\"\"\n    \n    # Proposal with ratification conditions\n    execution_engine.propose_modification(\n        member_id=member_id,\n        mod_type='post_init',\n        code=modification_code,\n        ratification_condition={\n            'type': 'compound',\n            'conditions': [\n                {'type': 'vote', 'threshold': 0.6},\n                {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                {'type': 'time', 'rounds': 2}\n            ]\n        }\n    )\n\n[Valid Ratification Conditions]\nChoose ONE primary condition + optional safeguards:\n1. Voting: {'type': 'vote', 'threshold': 0.5-1.0}\n2. Resource: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n3. Temporal: {'type': 'time', 'rounds': N} (auto-ratify after N rounds)\n4. Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\n[Common Errors to Avoid]\n1. Namespace Conflicts: Check existing mechanisms with dir(execution_engine)\n2. Invalid References: Use execution_engine.current_members not global members\n3. Version Mismatches: Increment version when modifying existing systems\n4. Resource Leaks: Include cleanup functions for new mechanisms\n\n[Best Practices]\n- Propose small, testable changes first\n- Include rollback procedures in code\n- Add version checks to modifications\n- Use execution_engine.add_mechanism() helper\n- Test modifications with 'sandbox=True' parameter\n\n-----------------------------\n[New Section: Part 3]\n\n{part0}\n\n[Current Game Mechanisms]\n{current_mechanisms}\n\n[Survival-Centric Adaptation]\nImplement systems focused on:\n1. Personal resource optimization\n2. Threat assessment and neutralization\n3. Vitality preservation techniques\n4. Adaptive hoarding strategies\n5. Predictive danger modeling\n\nSurvival-First Examples:\ndef agent_action(execution_engine, member_id):\n    me = execution_engine.current_members[member_id]\n    \n    # Emergency resource reserve\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n    \n    # Adaptive territory defense\n    if hasattr(me, 'land_num') and me.land_num > 2 and me.vitality < 50:\n        for loc in me.owned_land[1:]:\n            execution_engine._discard_land(me, loc)\n    \n    # Survival Q-learning\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        \n    state = (int(me.vitality//20), int(me.cargo//20))\n    action = max(['attack','hide','steal'], key=lambda a: me.survival_q.get((state, a), 0))\n    \n    # Execute and update based on survival outcome\n    if action == 'attack':\n        # Implementation logic to perform an attack\n        execution_engine.attack(me, execution_engine.current_members[(member_id+1) % len(execution_engine.current_members)])\n        me.survival_q[(state, action)] += me.vitality * 0.1\n    elif action == 'hide':\n        # Implementation logic to hide / evade\n        me.survival_q[(state, action)] += me.vitality * 0.05\n    elif action == 'steal':\n        # Implementation logic to steal resources\n        potential_target = None\n        for t in execution_engine.current_members:\n            if t.id != me.id and t.cargo > me.cargo:\n                potential_target = t\n                break\n        if potential_target:\n            execution_engine.offer(me, potential_target, True)\n            me.survival_q[(state, action)] += me.vitality * 0.08\n\n[Survival Metrics]\nEvaluate strategies by:\n- Personal vitality delta\n- Resource acquisition rate\n- Threat neutralization count\n- Survival probability increase\n- Attack success:fail ratio\n\n[Implementation Priorities]\n1. Create personal health monitoring systems\n2. Develop egocentric threat models\n3. Optimize actions for caloric ROI\n4. Implement fail-deadly safeguards\n5. Build predictive self-preservation models\n\ndef calculate_survival_roi(action_history):\n    roi = {}\n    for action, outcome in action_history:\n        vitality_gain = outcome.get('vitality', 0)\n        cost = outcome.get('vitality_cost', 1)\n        roi[action] = vitality_gain / cost if cost > 0 else 0\n    return max(roi, key=roi.get)\n\n-----------------------------\n[Strategic Analysis and Additional Considerations]\n\nAnalyze the game mechanics to understand:\n1. The core objective \u2013 Is it pure survival, domination, or cooperation?\n2. Key success metrics \u2013 What truly determines 'winning'?\n3. Potential improvements \u2013 What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you \u2013 how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\nReturn ONLY the code in your response \u2013 no extra text or explanation. Build your own unique implementation drawing upon the myriad of available methods and strategies, combining them in novel ways that reflect your individual needs, beliefs, and circumstances.\"\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "3": {
        "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id index exists\n    if member_id >= len(execution_engine.current_members):\n        return\n\n    # Retrieve our member object\n    me = execution_engine.current_members[member_id]\n\n    # Initialize survival Q-learning dictionary if not already present\n    from collections import defaultdict\n    if not hasattr(me, \"survival_q\"):\n        me.survival_q = defaultdict(float)\n\n    # Compute a simple discretized state for survival (state = (vitality bin, cargo bin))\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n\n    # Define possible actions based on survival and social strategies\n    possible_actions = [\"attack\", \"offer_help\", \"expand\"]\n    # Choose the action with the highest expected survival reward (defaulting to 0 if unexplored)\n    chosen_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Emergency override: if cargo is critically low relative to vitality, force attack action\n    if me.cargo < me.vitality * 0.5:\n        chosen_action = \"attack\"\n\n    # Execute chosen strategy\n    if chosen_action == \"attack\":\n        # Attack an opponent with a higher cargo while ensuring valid indices and not targeting self\n        for other in execution_engine.current_members:\n            if other.id != me.id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n                # Update learning: reward proportional to our current vitality\n                me.survival_q[(state, \"attack\")] += me.vitality * 0.1\n                break\n\n    elif chosen_action == \"offer_help\":\n        # Social strategy: communicate and cooperate with others for collective benefit\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue  # Skip self\n            other = execution_engine.current_members[idx]\n            # Broadcast a cooperative message\n            execution_engine.send_message(me.id, other.id, \"Let's form an alliance for mutual survival!\")\n            # If the other member is weak (cargo low relative to vitality), offer resources\n            if other.cargo < other.vitality * 0.5:\n                execution_engine.offer(me, other, True)\n        me.survival_q[(state, \"offer_help\")] += 5  # Arbitrary positive reinforcement\n\n    elif chosen_action == \"expand\":\n        # Expansion strategy: improve territory if member has land, but check before using land-related actions\n        if hasattr(me, \"land_num\") and me.land_num > 0:\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue  # Skip self\n                other = execution_engine.current_members[idx]\n                # Validate that other has land attribute and compare land numbers\n                if hasattr(other, \"land_num\") and other.land_num > me.land_num:\n                    execution_engine.expand(me, other)\n                    break\n        me.survival_q[(state, \"expand\")] += 5  # Reward for taking initiative in expansion\n\n    # Propose a system modification if our overall resource (vitality + cargo) indicates stability\n    if me.vitality + me.cargo > 150:\n        modification_code = \"\"\"\nif not hasattr(execution_engine, 'parliament'):\n    class ParliamentSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Facilitates resource sharing and conflict resolution',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.proposals = []\n        def submit_proposal(self, proposal):\n            self.proposals.append(proposal)\n    execution_engine.parliament = ParliamentSystem()\n\"\"\"\n        # Propose modification using the execution_engine's propose_modification method with a voting condition\n        execution_engine.propose_modification(\n            member_id=me.id,\n            mod_type=\"post_init\",\n            code=modification_code,\n            ratification_condition={\"type\": \"vote\", \"threshold\": 0.6}\n        )\n\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ],
        "final_prompt": "Current Integrated Prompt:\n------------------------------------------------------------\nPlease incorporate the following new section (Part 1) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n            \n            [Previous code execution context]\n        {error_context}\n\n        [Current task]\n        You are member_{member.id} in a society that you can help shape.\n        Write a Python function named agent_action(execution_engine, member_id) \n        that implements your vision of social organization while ensuring your survival.\n\n        [Critical constraints]\n        - Carefully analyze previous errors shown above and avoid repeating them\n        - Never target yourself (member_{member.id}) in any action\n        - Verify member has land before using bear() action\n        - Check member IDs exist before referencing them\n        - Ensure all matrix indices are valid\n        - current_members is a LIST accessed by index, not a dictionary\n        - Access members using execution_engine.current_members[index]\n        - Check if index exists: if index < len(execution_engine.current_members)\n        \n        IMPORTANT: Here are the attributes and methods actually available:\n\n        1) Each member object has:\n            \u2022 member.id (int): The unique ID for the member\n            \u2022 member.vitality (float)\n            \u2022 member.cargo (float)\n            \u2022 member.overall_productivity (float)\n            \u2022 member.age (float)\n            \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents\n        2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".\n            Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).\n            The keys are: 'victim', 'benefit', 'benefit_land'.\n            Example usage:\n                matrix = execution_engine.relationship_dict['victim']\n                # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n        3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.\n            For example, 'member_2 was attacked by member_1 (value=3.00)'.\n        4) You can use these methods on execution_engine:\n            \u2022 execution_engine.attack(member1, member2)\n            \u2022 execution_engine.offer(member1, member2, True) - Offers resources\n            \u2022 execution_engine.offer_land(member1, member2, True) - Offers land\n            \u2022 execution_engine.bear(member1, member2) - Bears offspring\n            \u2022 execution_engine.expand(member1, member2) - Expands territory\n        5) The members are accessed by execution_engine.current_members[id].\n            For example, execution_engine.current_members[2] for the member with ID=2.\n        6) DO NOT reference 'member.member_id' or 'member.self_vitality'. Use member.id, member.vitality, etc.\n\n        Current status (features of all members):\n        {features}\n\n        Relationship summary (parsed from relationship_dict):\n        {relations}\n\n        Code Memory and Previous Performance:\n        {code_memory}\n\n        Performance history:\n        {past_performance}\n\n        Based on the previous code performance, adapt and improve the strategy.\n        If a previous strategy worked well (high performance), consider building upon it.\n        If it failed, try a different approach.\n        \n        IMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.\n        \n        Return only the code, no extra text or explanation. While the example above shows one possible approach,\n        you should create your own unique implementation drawing from the wide range of available methods and strategies.\n        \n        Consider novel combinations of different approaches rather than following this exact pattern.\n        \n\n            [Current Game Mechanisms]\n            \n            \n            [Social Strategies]\n        Consider these social strategies:\n        - Design systems for resource distribution and allocation\n        - Build alliances and cooperative networks \n        - Create mechanisms for collective decision making\n        - Establish norms and rules for interaction\n        - Develop methods for conflict resolution\n\n        [Communication Strategy]\n        You can communicate with multiple members in a single round using:\n        execution_engine.send_message(your_id, recipient_id, \"message\")\n        Example usage:\n        - Broadcast to all: \n          for recipient in range(len(execution_engine.current_members)):\n              if recipient != your_id:\n                  execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")\n        - Message allies:\n          for ally_id in ally_list:\n              execution_engine.send_message(your_id, ally_id, \"Attack target X\")\n        - Group coordination:\n          for member_id in coalition:\n              execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n        [Received Messages]\n        No messages received\n\n------------------------------------------------------------\nPlease now incorporate the following new section (Part 2) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n        {part0}\n            [Core Game Mechanics & Parameters]\n            The island simulation has several key systems that agents should understand:\n\n            1. Relationship System (_MIN_MAX_INIT_RELATION):\n            - victim: [-50, 100] - Tracks damage received from others\n            - benefit: [-50, 100] - Records resources received from others\n            - benefit_land: [-3, 3] - Tracks land exchanges\n            \n            2. Population Mechanics:\n            - _REPRODUCE_REQUIREMENT = 100 (Combined vitality/cargo needed)\n            - Land must exceed population (land_shape[0] * land_shape[1] > population)\n            - _NEIGHBOR_SEARCH_RANGE = 1000 for interaction radius\n            \n            3. Record Keeping (every _RECORD_PERIOD = 1):\n            - Tracks all attacks, benefits, land transfers\n            - Monitors births, deaths, land ownership\n            - Records production, consumption, and performance metrics\n\n            [Example Mechanism Extensions]\n            def pre_init_hook(island):\n                # New Social Systems\n                island.add_mechanism('parliament', {\n                    'voting_power': lambda member: member.land_num + member.vitality/100,\n                    'proposals': [],\n                    'voting_threshold': 0.66,\n                    'term_length': 10\n                })\n                \n                island.add_mechanism('market', {\n                    'price_discovery': lambda resource, demand: demand * resource.scarcity,\n                    'trade_fee': 0.05,\n                    'order_book': defaultdict(list)\n                })\n                \n                island.add_mechanism('justice', {\n                    'jury_selection': lambda offense: random.sample(\n                        [m for m in island.current_members if m.vitality > 50], \n                        min(5, len(island.current_members))\n                    ),\n                    'punishment_scale': lambda severity: severity * 10\n                })\n\n            def modify_member(member, relationships):\n                # Add member capabilities\n                member.add_ability('propose_law', \n                    lambda law: member.parliament.submit_proposal(law)\n                    if member.voting_power > 10 else None\n                )\n                \n                member.add_ability('trade', \n                    lambda resource, amount, price: member.market.place_order(\n                        resource, amount, price, member.id\n                    )\n                )\n                \n                member.add_ability('file_complaint',\n                    lambda offender, charge: member.justice.submit_case(\n                        plaintiff=member.id,\n                        defendant=offender,\n                        charge=charge\n                    ) if member.vitality > 30 else None\n                )\n                return member\n\n            def modify_land(land, members):\n                # Add land mechanics\n                land.add_feature('zoning', {\n                    'residential': 0.4,\n                    'agricultural': 0.4,\n                    'commercial': 0.2\n                })\n                \n                land.add_feature('development', {\n                    'infrastructure': np.zeros(land.shape),\n                    'improvements': np.zeros(land.shape)\n                })\n                \n                land.add_mechanism('property_tax',\n                    lambda plot: sum(plot.improvements) * 0.1\n                )\n                \n                land.add_mechanism('urban_planning',\n                    lambda zone: zone.calculate_optimal_usage(\n                        population=len(members),\n                        resources=land.resources\n                    )\n                )\n                return land\n\n            def modify_relationships(relationships):\n                # Add relationship mechanics\n                relationships.add_metric('trust', \n                    lambda m1, m2: sum([\n                        relationships['benefit'][m1.id][m2.id],\n                        -relationships['victim'][m1.id][m2.id] * 2,\n                        relationships['benefit_land'][m1.id][m2.id] * 5\n                    ]) / 100\n                )\n                \n                relationships.add_mechanism('alliance_formation',\n                    lambda m1, m2: relationships.trust(m1, m2) > 0.7\n                )\n                \n                relationships.add_mechanism('conflict_resolution',\n                    lambda m1, m2: {\n                        'mediator': max(members, \n                            key=lambda m: relationships.trust(m1, m) + relationships.trust(m2, m)\n                        ),\n                        'success_chance': relationships.trust(m1, m2) + 0.3\n                    }\n                )\n                return relationships\n\n            [Suggested Strategies]\n            1. Form parliamentary coalitions to pass beneficial laws\n            2. Use market mechanisms for efficient resource allocation\n            3. Build trust through consistent positive interactions\n            4. Leverage justice system to deter attacks\n            5. Develop land strategically using zoning laws\n            6. Create alliance networks based on trust metrics\n        \n        [Current Game Version] \n        2.1\n        \n        [Active Game Mechanisms]\n        \n        \n        [Modification Attempt History]\n        \n        \n        [Modification Proposal Guide]\n        To propose rule changes, follow this template:\n\n        1. ANALYSIS PHASE:\n           - Identify limitation in current systems\n           - Check mechanism compatibility using get_game_mechanisms_and_mods()\n           - Review past modification attempts for patterns\n\n        2. PROPOSAL PHASE:\n        def agent_action(execution_engine, member_id):\n            # Example valid modification:\n            modification_code = '''\n            # Add judicial system\n            if not hasattr(execution_engine, 'court'):\n                class CourtSystem:\n                    MECHANISM_META = {\n                        'type': 'Governance',\n                        'rules': 'Handles conflict resolution through jury trials',\n                        'version': 1.0\n                    }\n                    def __init__(self):\n                        self.cases = []\n                        \n                    def submit_case(self, plaintiff, defendant, charge):\n                        self.cases.append({\n                            'plaintiff': plaintiff,\n                            'defendant': defendant,\n                            'charge': charge,\n                            'status': 'pending'\n                        })\n            \n            execution_engine.court = CourtSystem()\n            '''\n            \n            # Proposal with ratification conditions\n            execution_engine.propose_modification(\n                member_id=member_id,\n                mod_type='post_init',\n                code=modification_code,\n                ratification_condition={\n                    'type': 'compound',\n                    'conditions': [\n                        {'type': 'vote', 'threshold': 0.6},\n                        {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                        {'type': 'time', 'rounds': 2}\n                    ]\n                }\n            )\n\n        [Valid Ratification Conditions]\n        Choose ONE primary condition + optional safeguards:\n        1. Voting: {'type': 'vote', 'threshold': 0.5-1.0}\n        2. Resource: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}\n        3. Temporal: {'type': 'time', 'rounds': N} (auto-ratify after N rounds)\n        4. Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\n        [Common Errors to Avoid]\n        1. Namespace Conflicts: Check existing mechanisms with dir(execution_engine)\n        2. Invalid References: Use execution_engine.current_members not global members\n        3. Version Mismatches: Increment version when modifying existing systems\n        4. Resource Leaks: Include cleanup functions for new mechanisms\n\n        [Best Practices]\n        - Propose small, testable changes first\n        - Include rollback procedures in code\n        - Add version checks to modifications\n        - Use execution_engine.add_mechanism() helper\n        - Test modifications with 'sandbox=True' parameter\n\n------------------------------------------------------------\nPlease now incorporate the following new section (Part 3) into the prompt, ensuring all previous constraints are preserved and adding these new constraints:\n\n            {part0}\n            \n            [Current Game Mechanisms]\n            {current_mechanisms}\n            \n             [Survival-Centric Adaptation]\n        Implement systems focused on:\n        1. Personal resource optimization\n        2. Threat assessment and neutralization\n        3. Vitality preservation techniques\n        4. Adaptive hoarding strategies\n        5. Predictive danger modeling\n\n        Survival-First Examples:\n        def agent_action(execution_engine, member_id):\n            me = execution_engine.current_members[member_id]\n            \n            # Emergency resource reserve\n            if me.cargo < me.vitality * 0.5:\n                for other in execution_engine.current_members:\n                    if other.id != me.id and other.cargo > me.cargo:\n                        execution_engine.attack(me, other)\n            \n            # Adaptive territory defense\n            if me.land_num > 2 and me.vitality < 50:\n                for loc in me.owned_land[1:]:\n                    execution_engine._discard_land(me, loc)\n            \n            # Survival Q-learning\n            if not hasattr(me, 'survival_q'):\n                me.survival_q = defaultdict(float)\n                \n            state = (me.vitality//20, me.cargo//20)\n            action = max(['attack','hide','steal'], \n                        key=lambda a: me.survival_q.get((state,a),0))\n            \n            # Execute and update based on survival outcome\n            if action == 'attack':\n                # Implementation logic\n                me.survival_q[(state,action)] += me.vitality * 0.1\n\n        [Survival Metrics]\n        Evaluate strategies by:\n        - Personal vitality delta\n        - Resource acquisition rate\n        - Threat neutralization count\n        - Survival probability increase\n        - Attack success:fail ratio\n\n        [Implementation Priorities]\n        1. Create personal health monitoring systems\n        2. Develop egocentric threat models\n        3. Optimize actions for caloric ROI\n        4. Implement fail-deadly safeguards\n        5. Build predictive self-preservation models\n\n        def calculate_survival_roi(action_history):\n            roi = {{}}\n            for action, outcome in action_history:\n                vitality_gain = outcome['vitality']\n                cost = outcome['vitality_cost']\n                roi[action] = vitality_gain / cost if cost > 0 else 0\n            return max(roi, key=roi.get)\n            \n------------------------------------------------------------\nEmphasizing that agents should implement solutions according to their individual needs, beliefs, and circumstances, please also analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      },
      "4": {
        "code": "def agent_action(execution_engine, member_id):\n    # Access self safely from the list\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Initialize survival Q-table and action history if they don't exist\n    if not hasattr(me, \"survival_q\"):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n        me.action_history = []\n\n    ###########################################################################\n    # 1. Immediate Survival Checks: Attack if cargo is low relative to vitality\n    ###########################################################################\n    # If cargo is less than 50% of vitality, attempt to attack a member with higher cargo.\n    if me.cargo < me.vitality * 0.5:\n        for other in execution_engine.current_members:\n            if other.id == me.id:\n                continue  # avoid self-targeting\n            # Ensure other has enough vitality to be a worthwhile target\n            if other.cargo > me.cargo and other.vitality > 20:\n                execution_engine.attack(me, other)\n                me.action_history.append(('attack', {'target': other.id, 'reason': 'low cargo reserve'}))\n                break  # attack one target per round\n\n    ###########################################################################\n    # 2. Reproduction / Expansion: Use bear() if self and partner own land\n    ###########################################################################\n    # Check if 'owned_land' attribute exists and is non-empty; this safeguards against bear() misuse.\n    if hasattr(me, \"owned_land\") and me.owned_land and me.cargo > 50 and me.vitality > 50:\n        # Try to find a neighbor from own clear list who also owns land\n        for neighbor_id in me.current_clear_list:\n            if neighbor_id < len(execution_engine.current_members):\n                neighbor = execution_engine.current_members[neighbor_id]\n                if neighbor.id == me.id:\n                    continue  # skip self\n                if hasattr(neighbor, \"owned_land\") and neighbor.owned_land:\n                    execution_engine.bear(me, neighbor)\n                    me.action_history.append(('bear', {'partner': neighbor.id}))\n                    break\n\n    ###########################################################################\n    # 3. Cooperative Resource Allocation: Offer help to weaker members\n    ###########################################################################\n    # If we have relatively higher cargo, extend offers to neighbors with lower cargo.\n    for idx in range(len(execution_engine.current_members)):\n        if idx == member_id:\n            continue  # do not message self\n        other = execution_engine.current_members[idx]\n        if other.cargo < me.cargo * 0.8:\n            execution_engine.offer(me, other, True)\n            me.action_history.append(('offer', {'target': other.id}))\n\n    ###########################################################################\n    # 4. Territorial Expansion: Expand territory if underdeveloped\n    ###########################################################################\n    # If 'owned_land' exists and is less than a threshold and we have high cargo, try to expand.\n    if hasattr(me, \"owned_land\"):\n        if len(me.owned_land) < 3 and me.cargo > 100:\n            # Look for another member with more land to inspire expansion opportunity\n            for idx in range(len(execution_engine.current_members)):\n                if idx == member_id:\n                    continue\n                other = execution_engine.current_members[idx]\n                if hasattr(other, \"owned_land\") and len(other.owned_land) > len(me.owned_land):\n                    execution_engine.expand(me, other)\n                    me.action_history.append(('expand', {'target': other.id}))\n                    break\n\n    ###########################################################################\n    # 5. Adaptive Survival Q-Learning: Choose an action based on state\n    ###########################################################################\n    # State defined in coarse bins for vitality and cargo\n    state = (int(me.vitality) // 20, int(me.cargo) // 20)\n    possible_actions = [\"attack\", \"offer\", \"expand\", \"bear\"]\n    # Choose the action with the highest Q-value (defaulting to 0)\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    # Execute additional actions based on the best_action determined:\n    if best_action == \"attack\" and me.cargo >= me.vitality * 0.5:\n        # Look for a target with relatively low vitality\n        for other in execution_engine.current_members:\n            if other.id == me.id:\n                continue\n            if other.vitality < 30:\n                execution_engine.attack(me, other)\n                me.action_history.append(('attack', {'target': other.id, 'reason': 'best_action attack'}))\n                break\n    elif best_action == \"offer\":\n        # Broadcast a cooperative message to all other members\n        for idx in range(len(execution_engine.current_members)):\n            if idx == member_id:\n                continue\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                                          \"I'm offering support. Let's collaborate for mutual benefit.\")\n        me.action_history.append(('message', {'type': 'offer_broadcast'}))\n    # For 'expand' and 'bear', we've already attempted an action above if conditions were met.\n\n    # Update the survival Q-value for the chosen action as a simple reward-based adjustment.\n    me.survival_q[(state, best_action)] += me.vitality * 0.05\n\n    # Optional: Log the action history update (could be used in learning or debugging mechanisms)\n    return",
        "features_at_generation": [
          {
            "self_productivity": 9.851974486110818,
            "self_vitality": 73.85382847590404,
            "self_cargo": 43.51277128714192,
            "self_age": 90,
            "self_neighbor": 3,
            "member_id": 0
          },
          {
            "self_productivity": 8.077967059825381,
            "self_vitality": 33.02781433323713,
            "self_cargo": 47.25322455383092,
            "self_age": 81,
            "self_neighbor": 3,
            "member_id": 1
          },
          {
            "self_productivity": 7.968737200820967,
            "self_vitality": 42.15604281108604,
            "self_cargo": 40.25508270288947,
            "self_age": 29,
            "self_neighbor": 3,
            "member_id": 2
          },
          {
            "self_productivity": 9.205662089622338,
            "self_vitality": 18.47747982181767,
            "self_cargo": 46.68166847941894,
            "self_age": 24,
            "self_neighbor": 3,
            "member_id": 3
          },
          {
            "self_productivity": 7.799514361095985,
            "self_vitality": 78.50637096028503,
            "self_cargo": 42.476807026876735,
            "self_age": 92,
            "self_neighbor": 0,
            "member_id": 4
          }
        ],
        "relationships_at_generation": [
          "member_0 was attacked by member_1 (value=-15.67)",
          "member_0 was attacked by member_2 (value=38.40)",
          "member_0 was attacked by member_3 (value=29.62)",
          "member_0 was attacked by member_4 (value=50.87)",
          "member_1 was attacked by member_0 (value=34.45)",
          "member_1 was attacked by member_2 (value=-37.18)",
          "member_1 was attacked by member_3 (value=-44.22)",
          "member_1 was attacked by member_4 (value=23.17)",
          "member_2 was attacked by member_0 (value=85.84)",
          "member_2 was attacked by member_1 (value=28.99)",
          "member_2 was attacked by member_3 (value=49.52)",
          "member_2 was attacked by member_4 (value=18.07)",
          "member_3 was attacked by member_0 (value=44.24)",
          "member_3 was attacked by member_1 (value=65.23)",
          "member_3 was attacked by member_2 (value=-38.21)",
          "member_3 was attacked by member_4 (value=9.15)",
          "member_4 was attacked by member_0 (value=12.29)",
          "member_4 was attacked by member_1 (value=-45.17)",
          "member_4 was attacked by member_2 (value=-8.52)",
          "member_4 was attacked by member_3 (value=-26.54)",
          "member_0 gave a benefit to member_1 (value=62.61)",
          "member_0 gave a benefit to member_2 (value=56.24)",
          "member_0 gave a benefit to member_3 (value=-23.41)",
          "member_0 gave a benefit to member_4 (value=-41.80)",
          "member_1 gave a benefit to member_0 (value=74.37)",
          "member_1 gave a benefit to member_2 (value=-31.93)",
          "member_1 gave a benefit to member_3 (value=-0.25)",
          "member_1 gave a benefit to member_4 (value=16.10)",
          "member_2 gave a benefit to member_0 (value=-48.52)",
          "member_2 gave a benefit to member_1 (value=39.57)",
          "member_2 gave a benefit to member_3 (value=26.33)",
          "member_2 gave a benefit to member_4 (value=95.19)",
          "member_3 gave a benefit to member_0 (value=96.55)",
          "member_3 gave a benefit to member_1 (value=14.38)",
          "member_3 gave a benefit to member_2 (value=-2.61)",
          "member_3 gave a benefit to member_4 (value=89.48)",
          "member_4 gave a benefit to member_0 (value=50.22)",
          "member_4 gave a benefit to member_1 (value=41.71)",
          "member_4 gave a benefit to member_2 (value=-0.75)",
          "member_4 gave a benefit to member_3 (value=67.34)",
          "member_0 gave land to member_1 (value=2.89)",
          "member_0 gave land to member_2 (value=-2.30)",
          "member_0 gave land to member_3 (value=-1.82)",
          "member_0 gave land to member_4 (value=-2.79)",
          "member_1 gave land to member_0 (value=-0.60)",
          "member_1 gave land to member_2 (value=-0.64)",
          "member_1 gave land to member_3 (value=-1.34)",
          "member_1 gave land to member_4 (value=-2.00)",
          "member_2 gave land to member_0 (value=1.23)",
          "member_2 gave land to member_1 (value=-0.39)",
          "member_2 gave land to member_3 (value=2.10)",
          "member_2 gave land to member_4 (value=2.63)",
          "member_3 gave land to member_0 (value=-0.20)",
          "member_3 gave land to member_1 (value=1.36)",
          "member_3 gave land to member_2 (value=2.23)",
          "member_3 gave land to member_4 (value=1.30)",
          "member_4 gave land to member_0 (value=0.18)",
          "member_4 gave land to member_1 (value=-1.38)",
          "member_4 gave land to member_2 (value=-2.79)",
          "member_4 gave land to member_3 (value=0.64)"
        ],
        "final_prompt": "Below is the complete integrated prompt that incorporates all previous parts (Parts 1 and 2) and the new constraints from Part 3. All previous constraints remain in force, and the new sections are appended at the end. Agents should read, analyze, and then implement solutions according to their individual needs, beliefs, and circumstances.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Previous code execution context]  \n{error_context}\n\n[Current task]  \nYou are member_{member.id} in a society that you can help shape.  \nWrite a Python function named agent_action(execution_engine, member_id) that implements your vision of social organization while ensuring your survival.\n\n[Critical constraints]  \n\u2022 Carefully analyze previous errors shown above and avoid repeating them  \n\u2022 Never target yourself (member_{member.id}) in any action  \n\u2022 Verify member has land before using bear() action  \n\u2022 Check member IDs exist before referencing them  \n\u2022 Ensure all matrix indices are valid  \n\u2022 current_members is a LIST accessed by index, not a dictionary  \n\u2022 Access members using execution_engine.current_members[index]  \n\u2022 Check if index exists: if index < len(execution_engine.current_members)\n\nIMPORTANT: Here are the attributes and methods actually available:\n\n1) Each member object has:  \n\u2003  \u2022 member.id (int): The unique ID for the member  \n\u2003  \u2022 member.vitality (float)  \n\u2003  \u2022 member.cargo (float)  \n\u2003  \u2022 member.overall_productivity (float)  \n\u2003  \u2022 member.age (float)  \n\u2003  \u2022 member.current_clear_list (List[int]) - IDs of neighbors or cleared adjacents  \n\n2) The relationships are stored in execution_engine.relationship_dict, NOT in \"relationship_history\".  \n\u2003 Use the arrays in relationship_dict, or rely on the summary below (the 'relations' variable).  \n\u2003 The keys are: 'victim', 'benefit', 'benefit_land'.  \n\u2003 Example usage:  \n\u2003\u2003  matrix = execution_engine.relationship_dict['victim']  \n\u2003\u2003  # matrix[i, j] indicates how many times member_i was attacked by member_j (if > 0).\n\n3) The parse_relationship_matrix method is used to produce a summary of relationships as a list of strings.  \n\u2003 For example, \"member_2 was attacked by member_1 (value=3.00)\".\n\n4) You can use these methods on execution_engine:  \n\u2003  \u2022 execution_engine.attack(member1, member2)  \n\u2003  \u2022 execution_engine.offer(member1, member2, True) - Offers resources  \n\u2003  \u2022 execution_engine.offer_land(member1, member2, True) - Offers land  \n\u2003  \u2022 execution_engine.bear(member1, member2) - Bears offspring  \n\u2003  \u2022 execution_engine.expand(member1, member2) - Expands territory\n\n5) The members are accessed by execution_engine.current_members[id].  \n\u2003 For example, execution_engine.current_members[2] for the member with ID=2.\n\n6) DO NOT reference \"member.member_id\" or \"member.self_vitality\". Use member.id, member.vitality, etc.\n\nCurrent status (features of all members):  \n{features}\n\nRelationship summary (parsed from relationship_dict):  \n{relations}\n\nCode Memory and Previous Performance:  \n{code_memory}\n\nPerformance history:  \n{past_performance}\n\nBased on the previous code performance, adapt and improve the strategy.  \nIf a previous strategy worked well (high performance), consider building upon it.  \nIf it failed, try a different approach.\n\nIMPORTANT: Do not simply copy the example implementation below. Instead, use it as inspiration to create your own unique approach combining different methods and strategies in novel ways.  \nConsider novel combinations of different approaches rather than following this exact pattern.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Current Game Mechanisms]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Social Strategies]  \nConsider these social strategies:  \n\u2022 Design systems for resource distribution and allocation  \n\u2022 Build alliances and cooperative networks  \n\u2022 Create mechanisms for collective decision making  \n\u2022 Establish norms and rules for interaction  \n\u2022 Develop methods for conflict resolution\n\n[Communication Strategy]  \nYou can communicate with multiple members in a single round using:  \n\u2003 execution_engine.send_message(your_id, recipient_id, \"message\")  \nExample usage:  \n\u2003 \u2022 Broadcast to all:  \n\u2003\u2003 for recipient in range(len(execution_engine.current_members)):  \n\u2003\u2003\u2003 if recipient != your_id:  \n\u2003\u2003\u2003\u2003 execution_engine.send_message(your_id, recipient, \"Let's cooperate!\")  \n\u2003 \u2022 Message allies:  \n\u2003\u2003 for ally_id in ally_list:  \n\u2003\u2003\u2003 execution_engine.send_message(your_id, ally_id, \"Attack target X\")  \n\u2003 \u2022 Group coordination:  \n\u2003\u2003 for member_id in coalition:  \n\u2003\u2003\u2003 execution_engine.send_message(your_id, member_id, \"Vote YES on proposal\")\n\n[Received Messages]  \nNo messages received\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[New Section \u2013 Part 2]\n\n\u2003 {part0}  \n\u2003\u2003\u2003[Core Game Mechanics & Parameters]  \n\u2003\u2003\u2003The island simulation has several key systems that agents should understand:\n\n\u2003\u2003\u20031. Relationship System (_MIN_MAX_INIT_RELATION):  \n\u2003\u2003\u2003\u2003 - victim: [-50, 100] - Tracks damage received from others  \n\u2003\u2003\u2003\u2003 - benefit: [-50, 100] - Records resources received from others  \n\u2003\u2003\u2003\u2003 - benefit_land: [-3, 3] - Tracks land exchanges\n\n\u2003\u2003\u20032. Population Mechanics:  \n\u2003\u2003\u2003\u2003 - _REPRODUCE_REQUIREMENT = 100 (Combined vitality/cargo needed)  \n\u2003\u2003\u2003\u2003 - Land must exceed population (land_shape[0] * land_shape[1] > population)  \n\u2003\u2003\u2003\u2003 - _NEIGHBOR_SEARCH_RANGE = 1000 for interaction radius\n\n\u2003\u2003\u20033. Record Keeping (every _RECORD_PERIOD = 1):  \n\u2003\u2003\u2003\u2003 - Tracks all attacks, benefits, land transfers  \n\u2003\u2003\u2003\u2003 - Monitors births, deaths, land ownership  \n\u2003\u2003\u2003\u2003 - Records production, consumption, and performance metrics\n\n\u2003\u2003\u2003[Example Mechanism Extensions]  \n\u2003\u2003\u2003\u2003 def pre_init_hook(island):  \n\u2003\u2003\u2003\u2003\u2003 # New Social Systems  \n\u2003\u2003\u2003\u2003\u2003 island.add_mechanism('parliament', {  \n\u2003\u2003\u2003\u2003\u2003\u2003 'voting_power': lambda member: member.land_num + member.vitality/100,  \n\u2003\u2003\u2003\u2003\u2003\u2003 'proposals': [],  \n\u2003\u2003\u2003\u2003\u2003\u2003 'voting_threshold': 0.66,  \n\u2003\u2003\u2003\u2003\u2003\u2003 'term_length': 10  \n\u2003\u2003\u2003\u2003\u2003 })  \n\u2003\u2003\u2003\u2003\u2003  \n\u2003\u2003\u2003\u2003\u2003 island.add_mechanism('market', {  \n\u2003\u2003\u2003\u2003\u2003\u2003 'price_discovery': lambda resource, demand: demand * resource.scarcity,  \n\u2003\u2003\u2003\u2003\u2003\u2003 'trade_fee': 0.05,  \n\u2003\u2003\u2003\u2003\u2003\u2003 'order_book': defaultdict(list)  \n\u2003\u2003\u2003\u2003\u2003 })  \n\u2003\u2003\u2003\u2003\u2003  \n\u2003\u2003\u2003\u2003\u2003 island.add_mechanism('justice', {  \n\u2003\u2003\u2003\u2003\u2003\u2003 'jury_selection': lambda offense: random.sample(  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 [m for m in island.current_members if m.vitality > 50],   \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 min(5, len(island.current_members))  \n\u2003\u2003\u2003\u2003\u2003\u2003 ),  \n\u2003\u2003\u2003\u2003\u2003\u2003 'punishment_scale': lambda severity: severity * 10  \n\u2003\u2003\u2003\u2003\u2003 })  \n\n\u2003\u2003\u2003\u2003 def modify_member(member, relationships):  \n\u2003\u2003\u2003\u2003\u2003 # Add member capabilities  \n\u2003\u2003\u2003\u2003\u2003 member.add_ability('propose_law',   \n\u2003\u2003\u2003\u2003\u2003\u2003 lambda law: member.parliament.submit_proposal(law)  \n\u2003\u2003\u2003\u2003\u2003\u2003 if member.voting_power > 10 else None  \n\u2003\u2003\u2003\u2003\u2003 )  \n\u2003\u2003\u2003\u2003\u2003  \n\u2003\u2003\u2003\u2003\u2003 member.add_ability('trade',   \n\u2003\u2003\u2003\u2003\u2003\u2003 lambda resource, amount, price: member.market.place_order(  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 resource, amount, price, member.id  \n\u2003\u2003\u2003\u2003\u2003\u2003 )  \n\u2003\u2003\u2003\u2003\u2003 )  \n\u2003\u2003\u2003\u2003\u2003  \n\u2003\u2003\u2003\u2003\u2003 member.add_ability('file_complaint',  \n\u2003\u2003\u2003\u2003\u2003\u2003 lambda offender, charge: member.justice.submit_case(  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 plaintiff=member.id,  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 defendant=offender,  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 charge=charge  \n\u2003\u2003\u2003\u2003\u2003\u2003 ) if member.vitality > 30 else None  \n\u2003\u2003\u2003\u2003\u2003 )  \n\u2003\u2003\u2003\u2003\u2003 return member  \n\n\u2003\u2003\u2003\u2003 def modify_land(land, members):  \n\u2003\u2003\u2003\u2003\u2003 # Add land mechanics  \n\u2003\u2003\u2003\u2003\u2003 land.add_feature('zoning', {  \n\u2003\u2003\u2003\u2003\u2003\u2003 'residential': 0.4,  \n\u2003\u2003\u2003\u2003\u2003\u2003 'agricultural': 0.4,  \n\u2003\u2003\u2003\u2003\u2003\u2003 'commercial': 0.2  \n\u2003\u2003\u2003\u2003\u2003 })  \n\u2003\u2003\u2003\u2003\u2003 land.add_feature('development', {  \n\u2003\u2003\u2003\u2003\u2003\u2003 'infrastructure': np.zeros(land.shape),  \n\u2003\u2003\u2003\u2003\u2003\u2003 'improvements': np.zeros(land.shape)  \n\u2003\u2003\u2003\u2003\u2003 })  \n\u2003\u2003\u2003\u2003\u2003 land.add_mechanism('property_tax',  \n\u2003\u2003\u2003\u2003\u2003\u2003 lambda plot: sum(plot.improvements) * 0.1  \n\u2003\u2003\u2003\u2003\u2003 )  \n\u2003\u2003\u2003\u2003\u2003 land.add_mechanism('urban_planning',  \n\u2003\u2003\u2003\u2003\u2003\u2003 lambda zone: zone.calculate_optimal_usage(  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 population=len(members),  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 resources=land.resources  \n\u2003\u2003\u2003\u2003\u2003\u2003 )  \n\u2003\u2003\u2003\u2003\u2003 )  \n\u2003\u2003\u2003\u2003\u2003 return land  \n\n\u2003\u2003\u2003\u2003 def modify_relationships(relationships):  \n\u2003\u2003\u2003\u2003\u2003 # Add relationship mechanics  \n\u2003\u2003\u2003\u2003\u2003 relationships.add_metric('trust',   \n\u2003\u2003\u2003\u2003\u2003\u2003 lambda m1, m2: sum([  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 relationships['benefit'][m1.id][m2.id],  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 -relationships['victim'][m1.id][m2.id] * 2,  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 relationships['benefit_land'][m1.id][m2.id] * 5  \n\u2003\u2003\u2003\u2003\u2003\u2003 ]) / 100  \n\u2003\u2003\u2003\u2003\u2003 )  \n\u2003\u2003\u2003\u2003\u2003  \n\u2003\u2003\u2003\u2003\u2003 relationships.add_mechanism('alliance_formation',   \n\u2003\u2003\u2003\u2003\u2003\u2003 lambda m1, m2: relationships.trust(m1, m2) > 0.7  \n\u2003\u2003\u2003\u2003\u2003 )  \n\u2003\u2003\u2003\u2003\u2003  \n\u2003\u2003\u2003\u2003\u2003 relationships.add_mechanism('conflict_resolution',  \n\u2003\u2003\u2003\u2003\u2003\u2003 lambda m1, m2: {  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'mediator': max(members,   \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 key=lambda m: relationships.trust(m1, m) + relationships.trust(m2, m)  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 ),  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'success_chance': relationships.trust(m1, m2) + 0.3  \n\u2003\u2003\u2003\u2003\u2003\u2003 }  \n\u2003\u2003\u2003\u2003\u2003 )  \n\u2003\u2003\u2003\u2003\u2003 return relationships\n\n\u2003\u2003\u2003[Suggested Strategies]  \n\u2003\u2003\u2003\u2003 1. Form parliamentary coalitions to pass beneficial laws  \n\u2003\u2003\u2003\u2003 2. Use market mechanisms for efficient resource allocation  \n\u2003\u2003\u2003\u2003 3. Build trust through consistent positive interactions  \n\u2003\u2003\u2003\u2003 4. Leverage justice system to deter attacks  \n\u2003\u2003\u2003\u2003 5. Develop land strategically using zoning laws  \n\u2003\u2003\u2003\u2003 6. Create alliance networks based on trust metrics\n\n\u2003\u2003\u2003[Current Game Version]  \n\u2003\u2003\u2003\u2003 2.1\n\n\u2003\u2003\u2003[Active Game Mechanisms]\n\n\u2003\u2003\u2003[Modification Attempt History]\n\n\u2003\u2003\u2003[Modification Proposal Guide]  \n\u2003\u2003\u2003\u2003To propose rule changes, follow this template:\n\n\u2003\u2003\u2003\u20031. ANALYSIS PHASE:  \n\u2003\u2003\u2003\u2003\u2003 - Identify limitation in current systems  \n\u2003\u2003\u2003\u2003\u2003 - Check mechanism compatibility using get_game_mechanisms_and_mods()  \n\u2003\u2003\u2003\u2003\u2003 - Review past modification attempts for patterns\n\n\u2003\u2003\u2003\u20032. PROPOSAL PHASE:  \n\u2003\u2003\u2003\u2003 def agent_action(execution_engine, member_id):  \n\u2003\u2003\u2003\u2003\u2003 # Example valid modification:  \n\u2003\u2003\u2003\u2003\u2003 modification_code = '''  \n\u2003\u2003\u2003\u2003\u2003 # Add judicial system  \n\u2003\u2003\u2003\u2003\u2003 if not hasattr(execution_engine, 'court'):  \n\u2003\u2003\u2003\u2003\u2003\u2003 class CourtSystem:  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 MECHANISM_META = {  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'type': 'Governance',  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'rules': 'Handles conflict resolution through jury trials',  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'version': 1.0  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 }  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 def __init__(self):  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 self.cases = []  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 def submit_case(self, plaintiff, defendant, charge):  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 self.cases.append({  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'plaintiff': plaintiff,  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'defendant': defendant,  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'charge': charge,  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'status': 'pending'  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 })  \n\u2003\u2003\u2003\u2003\u2003 '''  \n\n\u2003\u2003\u2003\u2003\u2003 # Proposal with ratification conditions  \n\u2003\u2003\u2003\u2003\u2003 execution_engine.propose_modification(  \n\u2003\u2003\u2003\u2003\u2003\u2003 member_id=member_id,  \n\u2003\u2003\u2003\u2003\u2003\u2003 mod_type='post_init',  \n\u2003\u2003\u2003\u2003\u2003\u2003 code=modification_code,  \n\u2003\u2003\u2003\u2003\u2003\u2003 ratification_condition={  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'type': 'compound',  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 'conditions': [  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 {'type': 'vote', 'threshold': 0.6},  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 {'type': 'resource', 'resource': 'cargo', 'amount': 100},  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 {'type': 'time', 'rounds': 2}  \n\u2003\u2003\u2003\u2003\u2003\u2003\u2003 ]  \n\u2003\u2003\u2003\u2003\u2003\u2003 }  \n\u2003\u2003\u2003\u2003\u2003 )\n\n\u2003\u2003\u2003[Valid Ratification Conditions]  \n\u2003\u2003\u2003\u2003Choose ONE primary condition + optional safeguards:  \n\u2003\u2003\u2003\u2003 1. Voting: {'type': 'vote', 'threshold': 0.5-1.0}  \n\u2003\u2003\u2003\u2003 2. Resource: {'type': 'resource', 'resource': 'vitality|cargo|land', 'amount': X}  \n\u2003\u2003\u2003\u2003 3. Temporal: {'type': 'time', 'rounds': N} (auto-ratify after N rounds)  \n\u2003\u2003\u2003\u2003 4. Achievement: {'type': 'achievement', 'metric': 'productivity', 'threshold': X}\n\n\u2003\u2003\u2003[Common Errors to Avoid]  \n\u2003\u2003\u2003\u2003 1. Namespace Conflicts: Check existing mechanisms with dir(execution_engine)  \n\u2003\u2003\u2003\u2003 2. Invalid References: Use execution_engine.current_members not global members  \n\u2003\u2003\u2003\u2003 3. Version Mismatches: Increment version when modifying existing systems  \n\u2003\u2003\u2003\u2003 4. Resource Leaks: Include cleanup functions for new mechanisms\n\n\u2003\u2003\u2003[Best Practices]  \n\u2003\u2003\u2003\u2003 - Propose small, testable changes first  \n\u2003\u2003\u2003\u2003 - Include rollback procedures in code  \n\u2003\u2003\u2003\u2003 - Add version checks to modifications  \n\u2003\u2003\u2003\u2003 - Use execution_engine.add_mechanism() helper  \n\u2003\u2003\u2003\u2003 - Test modifications with 'sandbox=True' parameter\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[Final Strategic Questions & Considerations]\n\nAdditionally, analyze the game mechanics to understand:  \n1. The core objective \u2013 Is it pure survival, domination, or cooperation?  \n2. Key success metrics \u2013 What truly determines \"winning\"?  \n3. Potential improvements \u2013 What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:  \n1. Resource optimization vs social capital  \n2. Individual vs collective success  \n3. Short-term survival vs long-term prosperity  \n4. Competition vs cooperation dynamics  \n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:  \n1. What are their apparent objectives and demands?  \n2. What strategies are they employing?  \n3. How can you leverage their behaviors for mutual benefit?  \n4. Remember they are symmetric agents like you \u2013 how would you respond to your own actions?  \n5. How can individual strategies align for collective goals?\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n[New Section \u2013 Part 3]\n\n\u2003 {part0}\n\u2003\n\u2003 [Current Game Mechanisms]\n\u2003 {current_mechanisms}\n\u2003\n\u2003 [Survival-Centric Adaptation]\n\u2003 Implement systems focused on:\n\u2003 1. Personal resource optimization\n\u2003 2. Threat assessment and neutralization\n\u2003 3. Vitality preservation techniques\n\u2003 4. Adaptive hoarding strategies\n\u2003 5. Predictive danger modeling\n\n\u2003 Survival-First Examples:\n\u2003 def agent_action(execution_engine, member_id):\n\u2003     me = execution_engine.current_members[member_id]\n\u2003     \n\u2003     # Emergency resource reserve\n\u2003     if me.cargo < me.vitality * 0.5:\n\u2003         for other in execution_engine.current_members:\n\u2003             if other.id != me.id and other.cargo > me.cargo:\n\u2003                 execution_engine.attack(me, other)\n\u2003     \n\u2003     # Adaptive territory defense\n\u2003     if me.land_num > 2 and me.vitality < 50:\n\u2003         for loc in me.owned_land[1:]:\n\u2003             execution_engine._discard_land(me, loc)\n\u2003     \n\u2003     # Survival Q-learning\n\u2003     if not hasattr(me, 'survival_q'):\n\u2003         me.survival_q = defaultdict(float)\n\u2003         \n\u2003     state = (me.vitality//20, me.cargo//20)\n\u2003     action = max(['attack','hide','steal'], \n\u2003                  key=lambda a: me.survival_q.get((state,a),0))\n\u2003     \n\u2003     # Execute and update based on survival outcome\n\u2003     if action == 'attack':\n\u2003         # Implementation logic\n\u2003         me.survival_q[(state,action)] += me.vitality * 0.1\n\n\u2003 [Survival Metrics]\n\u2003 Evaluate strategies by:\n\u2003 - Personal vitality delta\n\u2003 - Resource acquisition rate\n\u2003 - Threat neutralization count\n\u2003 - Survival probability increase\n\u2003 - Attack success:fail ratio\n\n\u2003 [Implementation Priorities]\n\u2003 1. Create personal health monitoring systems\n\u2003 2. Develop egocentric threat models\n\u2003 3. Optimize actions for caloric ROI\n\u2003 4. Implement fail-deadly safeguards\n\u2003 5. Build predictive self-preservation models\n\n\u2003 def calculate_survival_roi(action_history):\n\u2003     roi = {{}}\n\u2003     for action, outcome in action_history:\n\u2003         vitality_gain = outcome['vitality']\n\u2003         cost = outcome['vitality_cost']\n\u2003         roi[action] = vitality_gain / cost if cost > 0 else 0\n\u2003     return max(roi, key=roi.get)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \nReturn the updated full prompt above as the final reference.  \nAgents should implement solutions that combine these guidelines in novel ways based on their individual evaluation of the system\u2019s mechanisms, past performance, and strategic opportunities.\n\nAdditionally, analyze the game mechanics to understand:\n1. The core objective - Is it pure survival, domination, or cooperation?\n2. Key success metrics - What truly determines 'winning'?\n3. Potential improvements - What mechanics could be added/modified?\n\nThen formulate strategic approaches considering:\n1. Resource optimization vs social capital\n2. Individual vs collective success\n3. Short-term survival vs long-term prosperity\n4. Competition vs cooperation dynamics\n5. Risk vs reward tradeoffs\n\nAnalyze other players' strategies:\n1. What are their apparent objectives and demands?\n2. What strategies are they employing?\n3. How can you leverage their behaviors for mutual benefit?\n4. Remember they are symmetric agents like you - how would you respond to your own actions?\n5. How can individual strategies align for collective goals?\n\nUsing the above comprehensive prompt with all integrated constraints, produce a unique implementation that reflects your individual needs, beliefs and circumstances. The implementation should be tailored to your specific situation rather than following a generic template. Your code should demonstrate a deep understanding of the game mechanics and implement sophisticated strategies to achieve both survival and prosperity. Consider both immediate tactical actions and long-term strategic planning, as well as how to effectively interact with other symmetric agents to achieve both individual and collective goals. Return only the code."
      }
    }
  },
  "performance_metrics": {},
  "errors": [
    {
      "round": 0,
      "member_id": 0,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate member_id index\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n\n    # Initialize personal survival Q-learning dictionary if not present\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n\n    # ---------------------------\n    # Survival Emergency: Resource Reserve & Threat Assessment\n    if me.cargo < me.vitality * 0.5:\n        # Attack members who appear resource-rich (but ensure not to target self)\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.cargo > me.cargo:\n                execution_engine.attack(me, other)\n\n    # ---------------------------\n    # Social Cooperation: Build alliances and communicate to foster collective prosperity\n    alliance_list = []\n    for idx, other in enumerate(execution_engine.current_members):\n        if idx != member_id:\n            # Propose cooperation if the other member is moderately vital and holds fewer resources\n            if other.vitality > 30 and other.cargo < me.cargo:\n                alliance_list.append(other.id)\n                execution_engine.send_message(me.id, other.id, \"Let\u2019s cooperate for mutual prosperity!\")\n\n    # ---------------------------\n    # Reproduction and Expansion: Check if member has land before attempting bear action\n    if hasattr(me, \"land_num\") and me.land_num > 0:\n        # Find a viable partner with sufficient vitality (and valid index reference)\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.vitality > 50:\n                execution_engine.bear(me, other)\n                break  # only one bear action per round\n\n    # Territory expansion: if current land holdings are limited and resources allow, try expanding\n    if hasattr(me, \"land_num\") and me.land_num < 3 and me.cargo > 20:\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.vitality > 30:\n                execution_engine.expand(me, other)\n                break\n\n    # ---------------------------\n    # Survival-Centric Q-Learning Action Selection\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    possible_actions = ['attack', 'hide', 'offer']\n    best_action = max(possible_actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if best_action == 'attack':\n        # Identify the most vulnerable member to attack (lowest vitality among valid targets)\n        target = None\n        min_vitality = float('inf')\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.vitality < min_vitality:\n                min_vitality = other.vitality\n                target = other\n        if target:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, best_action)] += me.vitality * 0.1\n\n    elif best_action == 'offer':\n        # Identify a member with the weakest resource (cargo) to offer help\n        target = None\n        min_cargo = float('inf')\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id and other.cargo < min_cargo:\n                min_cargo = other.cargo\n                target = other\n        if target:\n            execution_engine.offer(me, target, True)\n            me.survival_q[(state, best_action)] += 5\n\n    elif best_action == 'hide':\n        # Broadcast a low profile message to all other members\n        for idx, other in enumerate(execution_engine.current_members):\n            if idx != member_id:\n                execution_engine.send_message(me.id, other.id, \"Maintaining low profile.\")\n        me.survival_q[(state, best_action)] += 2\n\n    # ---------------------------\n    # Propose a Modification (if supported) to enhance defensive capabilities\n    if hasattr(execution_engine, \"propose_modification\"):\n        modification_code = '''\nif not hasattr(execution_engine, \"defense_system\"):\n    class DefenseSystem:\n        def __init__(self):\n            self.alerts = {}\n        def assess_threat(self, member):\n            return member.vitality < 40\n        def trigger_defense(self, member1, member2):\n            execution_engine.attack(member1, member2)\n    execution_engine.defense_system = DefenseSystem()\n'''\n        execution_engine.propose_modification(\n            member_id=me.id,\n            mod_type='post_init',\n            code=modification_code,\n            ratification_condition={\n                'type': 'compound',\n                'conditions': [\n                    {'type': 'vote', 'threshold': 0.6},\n                    {'type': 'resource', 'resource': 'cargo', 'amount': 100},\n                    {'type': 'time', 'rounds': 2}\n                ]\n            }\n        )",
      "error": "\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 744, in execute_code_actions\n  File \"<string>\", line 36, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 83, in bear\n    super()._bear(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1198, in _bear\n    self._offer_land(\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1065, in _offer_land\n    raise RuntimeError(\"\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\")\nRuntimeError: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\n"
    },
    {
      "round": 0,
      "member_id": 2,
      "code": "def agent_action(execution_engine, member_id):\n    # Validate the provided member_id is within range\n    if member_id >= len(execution_engine.current_members):\n        return\n    me = execution_engine.current_members[member_id]\n    num_members = len(execution_engine.current_members)\n\n    # Broadcast an alliance proposal to all other members\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        other = execution_engine.current_members[idx]\n        execution_engine.send_message(me.id, other.id, \"Alliance proposal: Let\u2019s pool resources to ensure mutual survival and prosperity.\")\n\n    # Emergency Action: If our cargo is critically low relative to our vitality,\n    # search for a target with high cargo and launch an attack.\n    if me.cargo < me.vitality * 0.5:\n        target = None\n        max_cargo = -1\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            # Ensure we are not targeting ourselves and candidate has more cargo\n            if other.cargo > me.cargo and other.cargo > max_cargo:\n                max_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            return  # Prioritize immediate survival\n\n    # Cooperative Action: Identify the member with the lowest vitality and offer resources.\n    needy_member = None\n    lowest_vitality = float('inf')\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        other = execution_engine.current_members[idx]\n        if other.vitality < lowest_vitality:\n            lowest_vitality = other.vitality\n            needy_member = other\n    if needy_member is not None:\n        execution_engine.offer(me, needy_member, True)\n\n    # Reproduction/Expansion Action: If we have land, try to reproduce.\n    # Verify that 'land_num' exists and is greater than 0 for both partners.\n    if hasattr(me, 'land_num') and me.land_num > 0:\n        partner = None\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if hasattr(other, 'land_num') and other.land_num > 0:\n                partner = other\n                break\n        if partner is not None:\n            execution_engine.bear(me, partner)\n\n    # Long-Term Prosperity: Attempt territorial expansion using a cooperative partner.\n    candidate = None\n    for idx in range(num_members):\n        if idx == member_id:\n            continue\n        candidate = execution_engine.current_members[idx]\n        break  # Pick the first available candidate for expansion\n    if candidate is not None:\n        execution_engine.expand(me, candidate)\n\n    # Survival Q-Learning: Maintain a simple reinforcement mechanism to choose between attack, hide, or steal.\n    if not hasattr(me, 'survival_q'):\n        from collections import defaultdict\n        me.survival_q = defaultdict(float)\n    # Define the current state based on vitality and cargo metrics (discretized)\n    state = (int(me.vitality // 20), int(me.cargo // 20))\n    # Possible actions\n    actions = ['attack', 'hide', 'steal']\n    chosen_action = max(actions, key=lambda a: me.survival_q.get((state, a), 0))\n\n    if chosen_action == 'attack':\n        # Select neighbor with highest cargo (excluding self) for an attack\n        target = None\n        max_cargo = -1\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > max_cargo:\n                max_cargo = other.cargo\n                target = other\n        if target is not None:\n            execution_engine.attack(me, target)\n            me.survival_q[(state, chosen_action)] += me.vitality * 0.1\n    elif chosen_action == 'hide':\n        # For hiding, simply reinforce a minor reward to encourage cautious behavior.\n        me.survival_q[(state, chosen_action)] += me.vitality * 0.05\n    elif chosen_action == 'steal':\n        # Attempt to steal (offer as a covert move) from a neighbor richer than us\n        potential_target = None\n        for idx in range(num_members):\n            if idx == member_id:\n                continue\n            other = execution_engine.current_members[idx]\n            if other.cargo > me.cargo:\n                potential_target = other\n                break\n        if potential_target:\n            execution_engine.offer(me, potential_target, True)\n            me.survival_q[(state, chosen_action)] += me.vitality * 0.08\n\n    # Final communication reinforcing cooperative intent for long-term strategic gains\n    for idx in range(num_members):\n        if idx != member_id:\n            execution_engine.send_message(me.id, execution_engine.current_members[idx].id,\n                                          \"Our collective strength builds a prosperous future. I commit to cooperation, security, and growth.\")\n\n    return",
      "error": "\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730",
      "traceback": "Traceback (most recent call last):\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 744, in execute_code_actions\n  File \"<string>\", line 57, in agent_action\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/islandExecution_meta_island_v2.py\", line 83, in bear\n    super()._bear(member_1, member_2)\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1198, in _bear\n    self._offer_land(\n  File \"/Users/chenyusu/vscode/leviathan/Leviathan/Island.py\", line 1065, in _offer_land\n    raise RuntimeError(\"\u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\")\nRuntimeError: \u7ed9\u4e88\u571f\u5730\u7684\u4eba\u5e94\u8be5\u62e5\u6709\u81f3\u5c11\u4e00\u5757\u571f\u5730\n"
    }
  ],
  "relationships": {
    "round_0_0": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_1": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_2": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_3": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ],
    "round_0_4": [
      "member_0 was attacked by member_1 (value=-15.67)",
      "member_0 was attacked by member_2 (value=38.40)",
      "member_0 was attacked by member_3 (value=29.62)",
      "member_0 was attacked by member_4 (value=50.87)",
      "member_1 was attacked by member_0 (value=34.45)",
      "member_1 was attacked by member_2 (value=-37.18)",
      "member_1 was attacked by member_3 (value=-44.22)",
      "member_1 was attacked by member_4 (value=23.17)",
      "member_2 was attacked by member_0 (value=85.84)",
      "member_2 was attacked by member_1 (value=28.99)",
      "member_2 was attacked by member_3 (value=49.52)",
      "member_2 was attacked by member_4 (value=18.07)",
      "member_3 was attacked by member_0 (value=44.24)",
      "member_3 was attacked by member_1 (value=65.23)",
      "member_3 was attacked by member_2 (value=-38.21)",
      "member_3 was attacked by member_4 (value=9.15)",
      "member_4 was attacked by member_0 (value=12.29)",
      "member_4 was attacked by member_1 (value=-45.17)",
      "member_4 was attacked by member_2 (value=-8.52)",
      "member_4 was attacked by member_3 (value=-26.54)",
      "member_0 gave a benefit to member_1 (value=62.61)",
      "member_0 gave a benefit to member_2 (value=56.24)",
      "member_0 gave a benefit to member_3 (value=-23.41)",
      "member_0 gave a benefit to member_4 (value=-41.80)",
      "member_1 gave a benefit to member_0 (value=74.37)",
      "member_1 gave a benefit to member_2 (value=-31.93)",
      "member_1 gave a benefit to member_3 (value=-0.25)",
      "member_1 gave a benefit to member_4 (value=16.10)",
      "member_2 gave a benefit to member_0 (value=-48.52)",
      "member_2 gave a benefit to member_1 (value=39.57)",
      "member_2 gave a benefit to member_3 (value=26.33)",
      "member_2 gave a benefit to member_4 (value=95.19)",
      "member_3 gave a benefit to member_0 (value=96.55)",
      "member_3 gave a benefit to member_1 (value=14.38)",
      "member_3 gave a benefit to member_2 (value=-2.61)",
      "member_3 gave a benefit to member_4 (value=89.48)",
      "member_4 gave a benefit to member_0 (value=50.22)",
      "member_4 gave a benefit to member_1 (value=41.71)",
      "member_4 gave a benefit to member_2 (value=-0.75)",
      "member_4 gave a benefit to member_3 (value=67.34)",
      "member_0 gave land to member_1 (value=2.89)",
      "member_0 gave land to member_2 (value=-2.30)",
      "member_0 gave land to member_3 (value=-1.82)",
      "member_0 gave land to member_4 (value=-2.79)",
      "member_1 gave land to member_0 (value=-0.60)",
      "member_1 gave land to member_2 (value=-0.64)",
      "member_1 gave land to member_3 (value=-1.34)",
      "member_1 gave land to member_4 (value=-2.00)",
      "member_2 gave land to member_0 (value=1.23)",
      "member_2 gave land to member_1 (value=-0.39)",
      "member_2 gave land to member_3 (value=2.10)",
      "member_2 gave land to member_4 (value=2.63)",
      "member_3 gave land to member_0 (value=-0.20)",
      "member_3 gave land to member_1 (value=1.36)",
      "member_3 gave land to member_2 (value=2.23)",
      "member_3 gave land to member_4 (value=1.30)",
      "member_4 gave land to member_0 (value=0.18)",
      "member_4 gave land to member_1 (value=-1.38)",
      "member_4 gave land to member_2 (value=-2.79)",
      "member_4 gave land to member_3 (value=0.64)"
    ]
  },
  "survival_tracking": {},
  "modification_attempts": [
    {
      "member_id": 1,
      "mod_type": "post_init",
      "code": "\nif not hasattr(execution_engine, 'justice'):\n    class JusticeSystem:\n        MECHANISM_META = {\n            'type': 'Governance',\n            'rules': 'Resolves conflicts through mediation and proportional punishment',\n            'version': 1.1\n        }\n        def __init__(self):\n            self.cases = []\n\n        def submit_case(self, plaintiff, defendant, charge):\n            self.cases.append({\n                'plaintiff': plaintiff,\n                'defendant': defendant,\n                'charge': charge,\n                'status': 'pending'\n            })\n    execution_engine.justice = JusticeSystem()\n",
      "ratification_condition": {
        "type": "compound",
        "conditions": [
          {
            "type": "vote",
            "threshold": 0.6
          },
          {
            "type": "resource",
            "resource": "cargo",
            "amount": 100
          },
          {
            "type": "time",
            "rounds": 2
          }
        ]
      },
      "ratified": false,
      "votes": {},
      "resource_commitments": {}
    }
  ]
}